(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

// Mark output/export as enabled for the client API scripts.
window['canvas-sketch-cli'] = window['canvas-sketch-cli'] || {};
window['canvas-sketch-cli'].output = true;

},{}],2:[function(require,module,exports){
"use strict";

const NAMESPACE = 'canvas-sketch-cli'; // Grab the CLI namespace

window[NAMESPACE] = window[NAMESPACE] || {};

if (!window[NAMESPACE].initialized) {
  initialize();
}

function initialize() {
  // Awaiting enable/disable event
  window[NAMESPACE].liveReloadEnabled = undefined;
  window[NAMESPACE].initialized = true;
  const defaultPostOptions = {
    method: 'POST',
    cache: 'no-cache',
    credentials: 'same-origin'
  }; // File saving utility

  window[NAMESPACE].saveBlob = (blob, opts) => {
    opts = opts || {};
    const form = new window.FormData();
    form.append('file', blob, opts.filename);
    return window.fetch('/canvas-sketch-cli/saveBlob', Object.assign({}, defaultPostOptions, {
      body: form
    })).then(res => {
      if (res.status === 200) {
        return res.json();
      } else {
        return res.text().then(text => {
          throw new Error(text);
        });
      }
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn(`There was a problem exporting ${opts.filename}`);
      console.error(err);
      return undefined;
    });
  };

  const stream = (url, opts) => {
    opts = opts || {};
    return window.fetch(url, Object.assign({}, defaultPostOptions, {
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        save: opts.save,
        encoding: opts.encoding,
        timeStamp: opts.timeStamp,
        fps: opts.fps,
        filename: opts.filename
      })
    })).then(res => {
      if (res.status === 200) {
        return res.json();
      } else {
        return res.text().then(text => {
          throw new Error(text);
        });
      }
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn(`There was a problem starting the stream export`);
      console.error(err);
      return undefined;
    });
  }; // File streaming utility


  window[NAMESPACE].streamStart = opts => {
    return stream('/canvas-sketch-cli/stream-start', opts);
  };

  window[NAMESPACE].streamEnd = opts => {
    return stream('/canvas-sketch-cli/stream-end', opts);
  }; // git commit utility


  window[NAMESPACE].commit = () => {
    return window.fetch('/canvas-sketch-cli/commit', defaultPostOptions).then(resp => resp.json()).then(result => {
      if (result.error) {
        if (result.error.toLowerCase().includes('not a git repository')) {
          console.warn(`Warning: ${result.error}`);
          return null;
        } else {
          throw new Error(result.error);
        }
      } // Notify user of changes


      console.log(result.changed ? `[git] ${result.hash} Committed changes` : `[git] ${result.hash} Nothing changed`);
      return result.hash;
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn('Could not commit changes and fetch hash');
      console.error(err);
      return undefined;
    });
  };

  if ('budo-livereload' in window) {
    const client = window['budo-livereload'];
    client.listen(data => {
      if (data.event === 'hot-reload') {
        setupLiveReload(data.enabled);
      }
    }); // On first load, check to see if we should setup live reload or not

    if (window[NAMESPACE].hot) {
      setupLiveReload(true);
    } else {
      setupLiveReload(false);
    }
  }
}

function setupLiveReload(isEnabled) {
  const previousState = window[NAMESPACE].liveReloadEnabled;

  if (typeof previousState !== 'undefined' && isEnabled !== previousState) {
    // We need to reload the page to ensure the new sketch function is
    // named for hot reloading, and/or cleaned up after hot reloading is disabled
    window.location.reload(true);
    return;
  }

  if (isEnabled === window[NAMESPACE].liveReloadEnabled) {
    // No change in state
    return;
  } // Mark new state


  window[NAMESPACE].liveReloadEnabled = isEnabled;

  if (isEnabled) {
    if ('budo-livereload' in window) {
      console.log(`%c[canvas-sketch-cli]%c âœ¨ Hot Reload Enabled`, 'color: #8e8e8e;', 'color: initial;');
      const client = window['budo-livereload'];
      client.listen(onClientData);
    }
  }
}

function onClientData(data) {
  const client = window['budo-livereload'];
  if (!client) return;

  if (data.event === 'eval') {
    if (!data.error) {
      client.clearError();
    }

    try {
      eval(data.code);
      if (!data.error) console.log(`%c[canvas-sketch-cli]%c âœ¨ Hot Reloaded`, 'color: #8e8e8e;', 'color: initial;');
    } catch (err) {
      console.error(`%c[canvas-sketch-cli]%c ðŸš¨ Hot Reload error`, 'color: #8e8e8e;', 'color: initial;');
      client.showError(err.toString()); // This will also load up the problematic script so that stack traces with
      // source maps is visible

      const scriptElement = document.createElement('script');

      scriptElement.onload = () => {
        document.body.removeChild(scriptElement);
      };

      scriptElement.src = data.src;
      document.body.appendChild(scriptElement);
    }
  }
}

},{}],3:[function(require,module,exports){
const canvasSketch = require('canvas-sketch');

// Import Two.js - make sure to have greater than v0.7.0-alpha.1
// because previous versions don't support module loading or headless environments
const Two = require('two.js');

const settings = {
  dimensions: [ 2048, 2048 ],
  // Make the loop animated
  animate: true
};

const sketch = ({ canvas, width, height, pixelRatio }) => {
  // Create the instance of Two.js
  const two = new Two({
    width,
    height,
    ratio: pixelRatio,
    domElement: canvas,
    overdraw: true
  });

  // Create the subject of the visual output
  const star = new Two.Star(0, 0, two.width / 10, two.width / 5, 5);
  star.stroke = 'white';
  star.linewidth = 8;
  star.fill = '#000';
  two.add(star);

  return {
    resize ({ pixelRatio, width, height }) {
      // Update width and height of Two.js scene based on
      // canvas-sketch auto changing viewport parameters
      two.width = width;
      two.height = height;
      two.ratio = pixelRatio;

      // This needs to be passed down to the renderer's width and height as well
      two.renderer.width = two.width;
      two.renderer.height = two.height;
    },
    render ({ time }) {
      const x = Math.random() * two.width;
      const y = Math.random() * two.height;

      // Place the star randomly on the canvas
      star.translation.set(x, y);
      // Change how many sides it has
      star.sides = Math.floor(Math.random() * 8) + 4;
      // Change the rotation
      star.rotation = Math.random() * Math.PI * 2;

      // Swap the stroke / fill every frame randomly
      if (Math.random() > 0.5) {
        star.stroke = '#000';
        star.fill = 'white';
      } else {
        star.stroke = 'white';
        star.fill = '#000';
      }

      // Update two.js via the `render` method - *not* the `update` method.
      two.render();
    }
  };
};

canvasSketch(sketch, settings);

},{"canvas-sketch":4,"two.js":5}],4:[function(require,module,exports){
(function (global){(function (){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.canvasSketch = factory());
}(this, (function () {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var browser =
	  commonjsGlobal.performance &&
	  commonjsGlobal.performance.now ? function now() {
	    return performance.now()
	  } : Date.now || function now() {
	    return +new Date
	  };

	var isPromise_1 = isPromise;

	function isPromise(obj) {
	  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
	}

	var isDom = isNode;

	function isNode (val) {
	  return (!val || typeof val !== 'object')
	    ? false
	    : (typeof window === 'object' && typeof window.Node === 'object')
	      ? (val instanceof window.Node)
	      : (typeof val.nodeType === 'number') &&
	        (typeof val.nodeName === 'string')
	}

	function getClientAPI() {
	    return typeof window !== 'undefined' && window['canvas-sketch-cli'];
	}

	function defined() {
	    var arguments$1 = arguments;

	    for (var i = 0;i < arguments.length; i++) {
	        if (arguments$1[i] != null) {
	            return arguments$1[i];
	        }
	    }
	    return undefined;
	}

	function isBrowser() {
	    return typeof document !== 'undefined';
	}

	function isWebGLContext(ctx) {
	    return typeof ctx.clear === 'function' && typeof ctx.clearColor === 'function' && typeof ctx.bufferData === 'function';
	}

	function isCanvas(element) {
	    return isDom(element) && /canvas/i.test(element.nodeName) && typeof element.getContext === 'function';
	}

	var keys = createCommonjsModule(function (module, exports) {
	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	});
	var keys_1 = keys.shim;

	var is_arguments = createCommonjsModule(function (module, exports) {
	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	}});
	var is_arguments_1 = is_arguments.supported;
	var is_arguments_2 = is_arguments.unsupported;

	var deepEqual_1 = createCommonjsModule(function (module) {
	var pSlice = Array.prototype.slice;



	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (is_arguments(a)) {
	    if (!is_arguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = keys(a),
	        kb = keys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}
	});

	var dateformat = createCommonjsModule(function (module, exports) {
	/*
	 * Date Format 1.2.3
	 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
	 * MIT license
	 *
	 * Includes enhancements by Scott Trenda <scott.trenda.net>
	 * and Kris Kowal <cixar.com/~kris.kowal/>
	 *
	 * Accepts a date, a mask, or a date and a mask.
	 * Returns a formatted version of the given date.
	 * The date defaults to the current date/time.
	 * The mask defaults to dateFormat.masks.default.
	 */

	(function(global) {

	  var dateFormat = (function() {
	      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
	      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
	      var timezoneClip = /[^-+\dA-Z]/g;
	  
	      // Regexes and supporting functions are cached through closure
	      return function (date, mask, utc, gmt) {
	  
	        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
	        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
	          mask = date;
	          date = undefined;
	        }
	  
	        date = date || new Date;
	  
	        if(!(date instanceof Date)) {
	          date = new Date(date);
	        }
	  
	        if (isNaN(date)) {
	          throw TypeError('Invalid date');
	        }
	  
	        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
	  
	        // Allow setting the utc/gmt argument via the mask
	        var maskSlice = mask.slice(0, 4);
	        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
	          mask = mask.slice(4);
	          utc = true;
	          if (maskSlice === 'GMT:') {
	            gmt = true;
	          }
	        }
	  
	        var _ = utc ? 'getUTC' : 'get';
	        var d = date[_ + 'Date']();
	        var D = date[_ + 'Day']();
	        var m = date[_ + 'Month']();
	        var y = date[_ + 'FullYear']();
	        var H = date[_ + 'Hours']();
	        var M = date[_ + 'Minutes']();
	        var s = date[_ + 'Seconds']();
	        var L = date[_ + 'Milliseconds']();
	        var o = utc ? 0 : date.getTimezoneOffset();
	        var W = getWeek(date);
	        var N = getDayOfWeek(date);
	        var flags = {
	          d:    d,
	          dd:   pad(d),
	          ddd:  dateFormat.i18n.dayNames[D],
	          dddd: dateFormat.i18n.dayNames[D + 7],
	          m:    m + 1,
	          mm:   pad(m + 1),
	          mmm:  dateFormat.i18n.monthNames[m],
	          mmmm: dateFormat.i18n.monthNames[m + 12],
	          yy:   String(y).slice(2),
	          yyyy: y,
	          h:    H % 12 || 12,
	          hh:   pad(H % 12 || 12),
	          H:    H,
	          HH:   pad(H),
	          M:    M,
	          MM:   pad(M),
	          s:    s,
	          ss:   pad(s),
	          l:    pad(L, 3),
	          L:    pad(Math.round(L / 10)),
	          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
	          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
	          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
	          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
	          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
	          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
	          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
	          W:    W,
	          N:    N
	        };
	  
	        return mask.replace(token, function (match) {
	          if (match in flags) {
	            return flags[match];
	          }
	          return match.slice(1, match.length - 1);
	        });
	      };
	    })();

	  dateFormat.masks = {
	    'default':               'ddd mmm dd yyyy HH:MM:ss',
	    'shortDate':             'm/d/yy',
	    'mediumDate':            'mmm d, yyyy',
	    'longDate':              'mmmm d, yyyy',
	    'fullDate':              'dddd, mmmm d, yyyy',
	    'shortTime':             'h:MM TT',
	    'mediumTime':            'h:MM:ss TT',
	    'longTime':              'h:MM:ss TT Z',
	    'isoDate':               'yyyy-mm-dd',
	    'isoTime':               'HH:MM:ss',
	    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
	    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
	    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
	  };

	  // Internationalization strings
	  dateFormat.i18n = {
	    dayNames: [
	      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
	      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
	    ],
	    monthNames: [
	      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
	      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
	    ],
	    timeNames: [
	      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'
	    ]
	  };

	function pad(val, len) {
	  val = String(val);
	  len = len || 2;
	  while (val.length < len) {
	    val = '0' + val;
	  }
	  return val;
	}

	/**
	 * Get the ISO 8601 week number
	 * Based on comments from
	 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
	 *
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getWeek(date) {
	  // Remove time components of date
	  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

	  // Change date to Thursday same week
	  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

	  // Take January 4th as it is always in week 1 (see ISO 8601)
	  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

	  // Change date to Thursday same week
	  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

	  // Check if daylight-saving-time-switch occurred and correct for it
	  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
	  targetThursday.setHours(targetThursday.getHours() - ds);

	  // Number of weeks between target Thursday and first Thursday
	  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
	  return 1 + Math.floor(weekDiff);
	}

	/**
	 * Get ISO-8601 numeric representation of the day of the week
	 * 1 (for Monday) through 7 (for Sunday)
	 * 
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getDayOfWeek(date) {
	  var dow = date.getDay();
	  if(dow === 0) {
	    dow = 7;
	  }
	  return dow;
	}

	/**
	 * kind-of shortcut
	 * @param  {*} val
	 * @return {String}
	 */
	function kindOf(val) {
	  if (val === null) {
	    return 'null';
	  }

	  if (val === undefined) {
	    return 'undefined';
	  }

	  if (typeof val !== 'object') {
	    return typeof val;
	  }

	  if (Array.isArray(val)) {
	    return 'array';
	  }

	  return {}.toString.call(val)
	    .slice(8, -1).toLowerCase();
	}


	  if (typeof undefined === 'function' && undefined.amd) {
	    undefined(function () {
	      return dateFormat;
	    });
	  } else {
	    module.exports = dateFormat;
	  }
	})(commonjsGlobal);
	});

	/*!
	 * repeat-string <https://github.com/jonschlinkert/repeat-string>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	/**
	 * Results cache
	 */

	var res = '';
	var cache;

	/**
	 * Expose `repeat`
	 */

	var repeatString = repeat;

	/**
	 * Repeat the given `string` the specified `number`
	 * of times.
	 *
	 * **Example:**
	 *
	 * ```js
	 * var repeat = require('repeat-string');
	 * repeat('A', 5);
	 * //=> AAAAA
	 * ```
	 *
	 * @param {String} `string` The string to repeat
	 * @param {Number} `number` The number of times to repeat the string
	 * @return {String} Repeated string
	 * @api public
	 */

	function repeat(str, num) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expected a string');
	  }

	  // cover common, quick use cases
	  if (num === 1) return str;
	  if (num === 2) return str + str;

	  var max = str.length * num;
	  if (cache !== str || typeof cache === 'undefined') {
	    cache = str;
	    res = '';
	  } else if (res.length >= max) {
	    return res.substr(0, max);
	  }

	  while (max > res.length && num > 1) {
	    if (num & 1) {
	      res += str;
	    }

	    num >>= 1;
	    str += str;
	  }

	  res += str;
	  res = res.substr(0, max);
	  return res;
	}

	var padLeft = function padLeft(str, num, ch) {
	  str = str.toString();

	  if (typeof num === 'undefined') {
	    return str;
	  }

	  if (ch === 0) {
	    ch = '0';
	  } else if (ch) {
	    ch = ch.toString();
	  } else {
	    ch = ' ';
	  }

	  return repeatString(ch, num - str.length) + str;
	};

	var noop = function () {};
	var link;
	var defaultExts = {
	    extension: '',
	    prefix: '',
	    suffix: ''
	};
	var supportedEncodings = ['image/png','image/jpeg','image/webp'];
	function stream(isStart, opts) {
	    if ( opts === void 0 ) opts = {};

	    return new Promise(function (resolve, reject) {
	        opts = objectAssign({}, defaultExts, opts);
	        var filename = resolveFilename(Object.assign({}, opts, {
	            extension: '',
	            frame: undefined
	        }));
	        var func = isStart ? 'streamStart' : 'streamEnd';
	        var client = getClientAPI();
	        if (client && client.output && typeof client[func] === 'function') {
	            return client[func](objectAssign({}, opts, {
	                filename: filename
	            })).then(function (ev) { return resolve(ev); });
	        } else {
	            return resolve({
	                filename: filename,
	                client: false
	            });
	        }
	    });
	}

	function streamStart(opts) {
	    if ( opts === void 0 ) opts = {};

	    return stream(true, opts);
	}

	function streamEnd(opts) {
	    if ( opts === void 0 ) opts = {};

	    return stream(false, opts);
	}

	function exportCanvas(canvas, opt) {
	    if ( opt === void 0 ) opt = {};

	    var encoding = opt.encoding || 'image/png';
	    if (!supportedEncodings.includes(encoding)) 
	        { throw new Error(("Invalid canvas encoding " + encoding)); }
	    var extension = (encoding.split('/')[1] || '').replace(/jpeg/i, 'jpg');
	    if (extension) 
	        { extension = ("." + extension).toLowerCase(); }
	    return {
	        extension: extension,
	        type: encoding,
	        dataURL: canvas.toDataURL(encoding, opt.encodingQuality)
	    };
	}

	function createBlobFromDataURL(dataURL) {
	    return new Promise(function (resolve) {
	        var splitIndex = dataURL.indexOf(',');
	        if (splitIndex === -1) {
	            resolve(new window.Blob());
	            return;
	        }
	        var base64 = dataURL.slice(splitIndex + 1);
	        var byteString = window.atob(base64);
	        var type = dataURL.slice(0, splitIndex);
	        var mimeMatch = /data:([^;]+)/.exec(type);
	        var mime = (mimeMatch ? mimeMatch[1] : '') || undefined;
	        var ab = new ArrayBuffer(byteString.length);
	        var ia = new Uint8Array(ab);
	        for (var i = 0;i < byteString.length; i++) {
	            ia[i] = byteString.charCodeAt(i);
	        }
	        resolve(new window.Blob([ab], {
	            type: mime
	        }));
	    });
	}

	function saveDataURL(dataURL, opts) {
	    if ( opts === void 0 ) opts = {};

	    return createBlobFromDataURL(dataURL).then(function (blob) { return saveBlob(blob, opts); });
	}

	function saveBlob(blob, opts) {
	    if ( opts === void 0 ) opts = {};

	    return new Promise(function (resolve) {
	        opts = objectAssign({}, defaultExts, opts);
	        var filename = opts.filename;
	        var client = getClientAPI();
	        if (client && typeof client.saveBlob === 'function' && client.output) {
	            return client.saveBlob(blob, objectAssign({}, opts, {
	                filename: filename
	            })).then(function (ev) { return resolve(ev); });
	        } else {
	            if (!link) {
	                link = document.createElement('a');
	                link.style.visibility = 'hidden';
	                link.target = '_blank';
	            }
	            link.download = filename;
	            link.href = window.URL.createObjectURL(blob);
	            document.body.appendChild(link);
	            link.onclick = (function () {
	                link.onclick = noop;
	                setTimeout(function () {
	                    window.URL.revokeObjectURL(blob);
	                    if (link.parentElement) 
	                        { link.parentElement.removeChild(link); }
	                    link.removeAttribute('href');
	                    resolve({
	                        filename: filename,
	                        client: false
	                    });
	                });
	            });
	            link.click();
	        }
	    });
	}

	function saveFile(data, opts) {
	    if ( opts === void 0 ) opts = {};

	    var parts = Array.isArray(data) ? data : [data];
	    var blob = new window.Blob(parts, {
	        type: opts.type || ''
	    });
	    return saveBlob(blob, opts);
	}

	function getTimeStamp() {
	    var dateFormatStr = "yyyy.mm.dd-HH.MM.ss";
	    return dateformat(new Date(), dateFormatStr);
	}

	function resolveFilename(opt) {
	    if ( opt === void 0 ) opt = {};

	    opt = objectAssign({}, opt);
	    if (typeof opt.file === 'function') {
	        return opt.file(opt);
	    } else if (opt.file) {
	        return opt.file;
	    }
	    var frame = null;
	    var extension = '';
	    if (typeof opt.extension === 'string') 
	        { extension = opt.extension; }
	    if (typeof opt.frame === 'number') {
	        var totalFrames;
	        if (typeof opt.totalFrames === 'number') {
	            totalFrames = opt.totalFrames;
	        } else {
	            totalFrames = Math.max(10000, opt.frame);
	        }
	        frame = padLeft(String(opt.frame), String(totalFrames).length, '0');
	    }
	    var layerStr = isFinite(opt.totalLayers) && isFinite(opt.layer) && opt.totalLayers > 1 ? ("" + (opt.layer)) : '';
	    if (frame != null) {
	        return [layerStr,frame].filter(Boolean).join('-') + extension;
	    } else {
	        var defaultFileName = opt.timeStamp;
	        return [opt.prefix,opt.name || defaultFileName,layerStr,opt.hash,opt.suffix].filter(Boolean).join('-') + extension;
	    }
	}

	var commonTypos = {
	    dimension: 'dimensions',
	    animated: 'animate',
	    animating: 'animate',
	    unit: 'units',
	    P5: 'p5',
	    pixellated: 'pixelated',
	    looping: 'loop',
	    pixelPerInch: 'pixels'
	};
	var allKeys = ['dimensions','units','pixelsPerInch','orientation','scaleToFit',
	    'scaleToView','bleed','pixelRatio','exportPixelRatio','maxPixelRatio','scaleContext',
	    'resizeCanvas','styleCanvas','canvas','context','attributes','parent','file',
	    'name','prefix','suffix','animate','playing','loop','duration','totalFrames',
	    'fps','playbackRate','timeScale','frame','time','flush','pixelated','hotkeys',
	    'p5','id','scaleToFitPadding','data','params','encoding','encodingQuality'];
	var checkSettings = function (settings) {
	    var keys = Object.keys(settings);
	    keys.forEach(function (key) {
	        if (key in commonTypos) {
	            var actual = commonTypos[key];
	            console.warn(("[canvas-sketch] Could not recognize the setting \"" + key + "\", did you mean \"" + actual + "\"?"));
	        } else if (!allKeys.includes(key)) {
	            console.warn(("[canvas-sketch] Could not recognize the setting \"" + key + "\""));
	        }
	    });
	};

	function keyboardShortcuts (opt) {
	    if ( opt === void 0 ) opt = {};

	    var handler = function (ev) {
	        if (!opt.enabled()) 
	            { return; }
	        var client = getClientAPI();
	        if (ev.keyCode === 83 && !ev.altKey && (ev.metaKey || ev.ctrlKey)) {
	            ev.preventDefault();
	            opt.save(ev);
	        } else if (ev.keyCode === 32) {
	            opt.togglePlay(ev);
	        } else if (client && !ev.altKey && ev.keyCode === 75 && (ev.metaKey || ev.ctrlKey)) {
	            ev.preventDefault();
	            opt.commit(ev);
	        }
	    };
	    var attach = function () {
	        window.addEventListener('keydown', handler);
	    };
	    var detach = function () {
	        window.removeEventListener('keydown', handler);
	    };
	    return {
	        attach: attach,
	        detach: detach
	    };
	}

	var defaultUnits = 'mm';
	var data = [['postcard',101.6,152.4],['poster-small',280,430],['poster',460,610],
	    ['poster-large',610,910],['business-card',50.8,88.9],['2r',64,89],['3r',89,127],
	    ['4r',102,152],['5r',127,178],['6r',152,203],['8r',203,254],['10r',254,305],['11r',
	    279,356],['12r',305,381],['a0',841,1189],['a1',594,841],['a2',420,594],['a3',
	    297,420],['a4',210,297],['a5',148,210],['a6',105,148],['a7',74,105],['a8',52,
	    74],['a9',37,52],['a10',26,37],['2a0',1189,1682],['4a0',1682,2378],['b0',1000,
	    1414],['b1',707,1000],['b1+',720,1020],['b2',500,707],['b2+',520,720],['b3',353,
	    500],['b4',250,353],['b5',176,250],['b6',125,176],['b7',88,125],['b8',62,88],
	    ['b9',44,62],['b10',31,44],['b11',22,32],['b12',16,22],['c0',917,1297],['c1',
	    648,917],['c2',458,648],['c3',324,458],['c4',229,324],['c5',162,229],['c6',114,
	    162],['c7',81,114],['c8',57,81],['c9',40,57],['c10',28,40],['c11',22,32],['c12',
	    16,22],['half-letter',5.5,8.5,'in'],['letter',8.5,11,'in'],['legal',8.5,14,'in'],
	    ['junior-legal',5,8,'in'],['ledger',11,17,'in'],['tabloid',11,17,'in'],['ansi-a',
	    8.5,11.0,'in'],['ansi-b',11.0,17.0,'in'],['ansi-c',17.0,22.0,'in'],['ansi-d',
	    22.0,34.0,'in'],['ansi-e',34.0,44.0,'in'],['arch-a',9,12,'in'],['arch-b',12,18,
	    'in'],['arch-c',18,24,'in'],['arch-d',24,36,'in'],['arch-e',36,48,'in'],['arch-e1',
	    30,42,'in'],['arch-e2',26,38,'in'],['arch-e3',27,39,'in']];
	var paperSizes = data.reduce(function (dict, preset) {
	    var item = {
	        units: preset[3] || defaultUnits,
	        dimensions: [preset[1],preset[2]]
	    };
	    dict[preset[0]] = item;
	    dict[preset[0].replace(/-/g, ' ')] = item;
	    return dict;
	}, {})

	var defined$1 = function () {
	    for (var i = 0; i < arguments.length; i++) {
	        if (arguments[i] !== undefined) return arguments[i];
	    }
	};

	var units = [ 'mm', 'cm', 'm', 'pc', 'pt', 'in', 'ft', 'px' ];

	var conversions = {
	  // metric
	  m: {
	    system: 'metric',
	    factor: 1
	  },
	  cm: {
	    system: 'metric',
	    factor: 1 / 100
	  },
	  mm: {
	    system: 'metric',
	    factor: 1 / 1000
	  },
	  // imperial
	  pt: {
	    system: 'imperial',
	    factor: 1 / 72
	  },
	  pc: {
	    system: 'imperial',
	    factor: 1 / 6
	  },
	  in: {
	    system: 'imperial',
	    factor: 1
	  },
	  ft: {
	    system: 'imperial',
	    factor: 12
	  }
	};

	const anchors = {
	  metric: {
	    unit: 'm',
	    ratio: 1 / 0.0254
	  },
	  imperial: {
	    unit: 'in',
	    ratio: 0.0254
	  }
	};

	function round (value, decimals) {
	  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
	}

	function convertDistance (value, fromUnit, toUnit, opts) {
	  if (typeof value !== 'number' || !isFinite(value)) throw new Error('Value must be a finite number');
	  if (!fromUnit || !toUnit) throw new Error('Must specify from and to units');

	  opts = opts || {};
	  var pixelsPerInch = defined$1(opts.pixelsPerInch, 96);
	  var precision = opts.precision;
	  var roundPixel = opts.roundPixel !== false;

	  fromUnit = fromUnit.toLowerCase();
	  toUnit = toUnit.toLowerCase();

	  if (units.indexOf(fromUnit) === -1) throw new Error('Invalid from unit "' + fromUnit + '", must be one of: ' + units.join(', '));
	  if (units.indexOf(toUnit) === -1) throw new Error('Invalid from unit "' + toUnit + '", must be one of: ' + units.join(', '));

	  if (fromUnit === toUnit) {
	    // We don't need to convert from A to B since they are the same already
	    return value;
	  }

	  var toFactor = 1;
	  var fromFactor = 1;
	  var isToPixel = false;

	  if (fromUnit === 'px') {
	    fromFactor = 1 / pixelsPerInch;
	    fromUnit = 'in';
	  }
	  if (toUnit === 'px') {
	    isToPixel = true;
	    toFactor = pixelsPerInch;
	    toUnit = 'in';
	  }

	  var fromUnitData = conversions[fromUnit];
	  var toUnitData = conversions[toUnit];

	  // source to anchor inside source's system
	  var anchor = value * fromUnitData.factor * fromFactor;

	  // if systems differ, convert one to another
	  if (fromUnitData.system !== toUnitData.system) {
	    // regular 'm' to 'in' and so forth
	    anchor *= anchors[fromUnitData.system].ratio;
	  }

	  var result = anchor / toUnitData.factor * toFactor;
	  if (isToPixel && roundPixel) {
	    result = Math.round(result);
	  } else if (typeof precision === 'number' && isFinite(precision)) {
	    result = round(result, precision);
	  }
	  return result;
	}

	var convertLength = convertDistance;
	var units_1 = units;
	convertLength.units = units_1;

	function getDimensionsFromPreset(dimensions, unitsTo, pixelsPerInch) {
	    if ( unitsTo === void 0 ) unitsTo = 'px';
	    if ( pixelsPerInch === void 0 ) pixelsPerInch = 72;

	    if (typeof dimensions === 'string') {
	        var key = dimensions.toLowerCase();
	        if (!(key in paperSizes)) {
	            throw new Error(("The dimension preset \"" + dimensions + "\" is not supported or could not be found; try using a4, a3, postcard, letter, etc."));
	        }
	        var preset = paperSizes[key];
	        return preset.dimensions.map(function (d) { return convertDistance$1(d, preset.units, unitsTo, pixelsPerInch); });
	    } else {
	        return dimensions;
	    }
	}

	function convertDistance$1(dimension, unitsFrom, unitsTo, pixelsPerInch) {
	    if ( unitsFrom === void 0 ) unitsFrom = 'px';
	    if ( unitsTo === void 0 ) unitsTo = 'px';
	    if ( pixelsPerInch === void 0 ) pixelsPerInch = 72;

	    return convertLength(dimension, unitsFrom, unitsTo, {
	        pixelsPerInch: pixelsPerInch,
	        precision: 4,
	        roundPixel: true
	    });
	}

	function checkIfHasDimensions(settings) {
	    if (!settings.dimensions) 
	        { return false; }
	    if (typeof settings.dimensions === 'string') 
	        { return true; }
	    if (Array.isArray(settings.dimensions) && settings.dimensions.length >= 2) 
	        { return true; }
	    return false;
	}

	function getParentSize(props, settings) {
	    if (!isBrowser()) {
	        return [300,150];
	    }
	    var element = settings.parent || window;
	    if (element === window || element === document || element === document.body) {
	        return [window.innerWidth,window.innerHeight];
	    } else {
	        var ref = element.getBoundingClientRect();
	        var width = ref.width;
	        var height = ref.height;
	        return [width,height];
	    }
	}

	function resizeCanvas(props, settings) {
	    var width, height;
	    var styleWidth, styleHeight;
	    var canvasWidth, canvasHeight;
	    var browser = isBrowser();
	    var dimensions = settings.dimensions;
	    var hasDimensions = checkIfHasDimensions(settings);
	    var exporting = props.exporting;
	    var scaleToFit = hasDimensions ? settings.scaleToFit !== false : false;
	    var scaleToView = !exporting && hasDimensions ? settings.scaleToView : true;
	    if (!browser) 
	        { scaleToFit = (scaleToView = false); }
	    var units = settings.units;
	    var pixelsPerInch = typeof settings.pixelsPerInch === 'number' && isFinite(settings.pixelsPerInch) ? settings.pixelsPerInch : 72;
	    var bleed = defined(settings.bleed, 0);
	    var devicePixelRatio = browser ? window.devicePixelRatio : 1;
	    var basePixelRatio = scaleToView ? devicePixelRatio : 1;
	    var pixelRatio, exportPixelRatio;
	    if (typeof settings.pixelRatio === 'number' && isFinite(settings.pixelRatio)) {
	        pixelRatio = settings.pixelRatio;
	        exportPixelRatio = defined(settings.exportPixelRatio, pixelRatio);
	    } else {
	        if (hasDimensions) {
	            pixelRatio = basePixelRatio;
	            exportPixelRatio = defined(settings.exportPixelRatio, 1);
	        } else {
	            pixelRatio = devicePixelRatio;
	            exportPixelRatio = defined(settings.exportPixelRatio, pixelRatio);
	        }
	    }
	    if (typeof settings.maxPixelRatio === 'number' && isFinite(settings.maxPixelRatio)) {
	        pixelRatio = Math.min(settings.maxPixelRatio, pixelRatio);
	    }
	    if (exporting) {
	        pixelRatio = exportPixelRatio;
	    }
	    var ref = getParentSize(props, settings);
	    var parentWidth = ref[0];
	    var parentHeight = ref[1];
	    var trimWidth, trimHeight;
	    if (hasDimensions) {
	        var result = getDimensionsFromPreset(dimensions, units, pixelsPerInch);
	        var highest = Math.max(result[0], result[1]);
	        var lowest = Math.min(result[0], result[1]);
	        if (settings.orientation) {
	            var landscape = settings.orientation === 'landscape';
	            width = landscape ? highest : lowest;
	            height = landscape ? lowest : highest;
	        } else {
	            width = result[0];
	            height = result[1];
	        }
	        trimWidth = width;
	        trimHeight = height;
	        width += bleed * 2;
	        height += bleed * 2;
	    } else {
	        width = parentWidth;
	        height = parentHeight;
	        trimWidth = width;
	        trimHeight = height;
	    }
	    var realWidth = width;
	    var realHeight = height;
	    if (hasDimensions && units) {
	        realWidth = convertDistance$1(width, units, 'px', pixelsPerInch);
	        realHeight = convertDistance$1(height, units, 'px', pixelsPerInch);
	    }
	    styleWidth = Math.round(realWidth);
	    styleHeight = Math.round(realHeight);
	    if (scaleToFit && !exporting && hasDimensions) {
	        var aspect = width / height;
	        var windowAspect = parentWidth / parentHeight;
	        var scaleToFitPadding = defined(settings.scaleToFitPadding, 40);
	        var maxWidth = Math.round(parentWidth - scaleToFitPadding * 2);
	        var maxHeight = Math.round(parentHeight - scaleToFitPadding * 2);
	        if (styleWidth > maxWidth || styleHeight > maxHeight) {
	            if (windowAspect > aspect) {
	                styleHeight = maxHeight;
	                styleWidth = Math.round(styleHeight * aspect);
	            } else {
	                styleWidth = maxWidth;
	                styleHeight = Math.round(styleWidth / aspect);
	            }
	        }
	    }
	    canvasWidth = scaleToView ? Math.round(pixelRatio * styleWidth) : Math.round(pixelRatio * realWidth);
	    canvasHeight = scaleToView ? Math.round(pixelRatio * styleHeight) : Math.round(pixelRatio * realHeight);
	    var viewportWidth = scaleToView ? Math.round(styleWidth) : Math.round(realWidth);
	    var viewportHeight = scaleToView ? Math.round(styleHeight) : Math.round(realHeight);
	    var scaleX = canvasWidth / width;
	    var scaleY = canvasHeight / height;
	    return {
	        bleed: bleed,
	        pixelRatio: pixelRatio,
	        width: width,
	        height: height,
	        dimensions: [width,height],
	        units: units || 'px',
	        scaleX: scaleX,
	        scaleY: scaleY,
	        pixelsPerInch: pixelsPerInch,
	        viewportWidth: viewportWidth,
	        viewportHeight: viewportHeight,
	        canvasWidth: canvasWidth,
	        canvasHeight: canvasHeight,
	        trimWidth: trimWidth,
	        trimHeight: trimHeight,
	        styleWidth: styleWidth,
	        styleHeight: styleHeight
	    };
	}

	var getCanvasContext_1 = getCanvasContext;
	function getCanvasContext (type, opts) {
	  if (typeof type !== 'string') {
	    throw new TypeError('must specify type string')
	  }

	  opts = opts || {};

	  if (typeof document === 'undefined' && !opts.canvas) {
	    return null // check for Node
	  }

	  var canvas = opts.canvas || document.createElement('canvas');
	  if (typeof opts.width === 'number') {
	    canvas.width = opts.width;
	  }
	  if (typeof opts.height === 'number') {
	    canvas.height = opts.height;
	  }

	  var attribs = opts;
	  var gl;
	  try {
	    var names = [ type ];
	    // prefix GL contexts
	    if (type.indexOf('webgl') === 0) {
	      names.push('experimental-' + type);
	    }

	    for (var i = 0; i < names.length; i++) {
	      gl = canvas.getContext(names[i], attribs);
	      if (gl) return gl
	    }
	  } catch (e) {
	    gl = null;
	  }
	  return (gl || null) // ensure null on fail
	}

	function createCanvasElement() {
	    if (!isBrowser()) {
	        throw new Error('It appears you are runing from Node.js or a non-browser environment. Try passing in an existing { canvas } interface instead.');
	    }
	    return document.createElement('canvas');
	}

	function createCanvas(settings) {
	    if ( settings === void 0 ) settings = {};

	    var context, canvas;
	    var ownsCanvas = false;
	    if (settings.canvas !== false) {
	        context = settings.context;
	        if (!context || typeof context === 'string') {
	            var newCanvas = settings.canvas;
	            if (!newCanvas) {
	                newCanvas = createCanvasElement();
	                ownsCanvas = true;
	            }
	            var type = context || '2d';
	            if (typeof newCanvas.getContext !== 'function') {
	                throw new Error("The specified { canvas } element does not have a getContext() function, maybe it is not a <canvas> tag?");
	            }
	            context = getCanvasContext_1(type, objectAssign({}, settings.attributes, {
	                canvas: newCanvas
	            }));
	            if (!context) {
	                throw new Error(("Failed at canvas.getContext('" + type + "') - the browser may not support this context, or a different context may already be in use with this canvas."));
	            }
	        }
	        canvas = context.canvas;
	        if (settings.canvas && canvas !== settings.canvas) {
	            throw new Error('The { canvas } and { context } settings must point to the same underlying canvas element');
	        }
	        if (settings.pixelated) {
	            context.imageSmoothingEnabled = false;
	            context.mozImageSmoothingEnabled = false;
	            context.oImageSmoothingEnabled = false;
	            context.webkitImageSmoothingEnabled = false;
	            context.msImageSmoothingEnabled = false;
	            canvas.style['image-rendering'] = 'pixelated';
	        }
	    }
	    return {
	        canvas: canvas,
	        context: context,
	        ownsCanvas: ownsCanvas
	    };
	}

	var SketchManager = function SketchManager() {
	    var this$1 = this;

	    this._settings = {};
	    this._props = {};
	    this._sketch = undefined;
	    this._raf = null;
	    this._recordTimeout = null;
	    this._lastRedrawResult = undefined;
	    this._isP5Resizing = false;
	    this._keyboardShortcuts = keyboardShortcuts({
	        enabled: function () { return this$1.settings.hotkeys !== false; },
	        save: function (ev) {
	            if (ev.shiftKey) {
	                if (this$1.props.recording) {
	                    this$1.endRecord();
	                    this$1.run();
	                } else 
	                    { this$1.record(); }
	            } else if (!this$1.props.recording) {
	                this$1.exportFrame();
	            }
	        },
	        togglePlay: function () {
	            if (this$1.props.playing) 
	                { this$1.pause(); }
	             else 
	                { this$1.play(); }
	        },
	        commit: function (ev) {
	            this$1.exportFrame({
	                commit: true
	            });
	        }
	    });
	    this._animateHandler = (function () { return this$1.animate(); });
	    this._resizeHandler = (function () {
	        var changed = this$1.resize();
	        if (changed) {
	            this$1.render();
	        }
	    });
	};

	var prototypeAccessors = { sketch: { configurable: true },settings: { configurable: true },props: { configurable: true } };
	prototypeAccessors.sketch.get = function () {
	    return this._sketch;
	};
	prototypeAccessors.settings.get = function () {
	    return this._settings;
	};
	prototypeAccessors.props.get = function () {
	    return this._props;
	};
	SketchManager.prototype._computePlayhead = function _computePlayhead (currentTime, duration) {
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    return hasDuration ? currentTime / duration : 0;
	};
	SketchManager.prototype._computeFrame = function _computeFrame (playhead, time, totalFrames, fps) {
	    return isFinite(totalFrames) && totalFrames > 1 ? Math.floor(playhead * (totalFrames - 1)) : Math.floor(fps * time);
	};
	SketchManager.prototype._computeCurrentFrame = function _computeCurrentFrame () {
	    return this._computeFrame(this.props.playhead, this.props.time, this.props.totalFrames, this.props.fps);
	};
	SketchManager.prototype._getSizeProps = function _getSizeProps () {
	    var props = this.props;
	    return {
	        width: props.width,
	        height: props.height,
	        pixelRatio: props.pixelRatio,
	        canvasWidth: props.canvasWidth,
	        canvasHeight: props.canvasHeight,
	        viewportWidth: props.viewportWidth,
	        viewportHeight: props.viewportHeight
	    };
	};
	SketchManager.prototype.run = function run () {
	    if (!this.sketch) 
	        { throw new Error('should wait until sketch is loaded before trying to play()'); }
	    if (this.settings.playing !== false) {
	        this.play();
	    }
	    if (typeof this.sketch.dispose === 'function') {
	        console.warn('In canvas-sketch@0.0.23 the dispose() event has been renamed to unload()');
	    }
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    this.tick();
	    this.render();
	    return this;
	};
	SketchManager.prototype._cancelTimeouts = function _cancelTimeouts () {
	    if (this._raf != null && typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function') {
	        window.cancelAnimationFrame(this._raf);
	        this._raf = null;
	    }
	    if (this._recordTimeout != null) {
	        clearTimeout(this._recordTimeout);
	        this._recordTimeout = null;
	    }
	};
	SketchManager.prototype.play = function play () {
	    var animate = this.settings.animate;
	    if ('animation' in this.settings) {
	        animate = true;
	        console.warn('[canvas-sketch] { animation } has been renamed to { animate }');
	    }
	    if (!animate) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Using { animate } in Node.js is not yet supported');
	        return;
	    }
	    if (this.props.playing) 
	        { return; }
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    this.props.playing = true;
	    this._cancelTimeouts();
	    this._lastTime = browser();
	    this._raf = window.requestAnimationFrame(this._animateHandler);
	};
	SketchManager.prototype.pause = function pause () {
	    if (this.props.recording) 
	        { this.endRecord(); }
	    this.props.playing = false;
	    this._cancelTimeouts();
	};
	SketchManager.prototype.togglePlay = function togglePlay () {
	    if (this.props.playing) 
	        { this.pause(); }
	     else 
	        { this.play(); }
	};
	SketchManager.prototype.stop = function stop () {
	    this.pause();
	    this.props.frame = 0;
	    this.props.playhead = 0;
	    this.props.time = 0;
	    this.props.deltaTime = 0;
	    this.props.started = false;
	    this.render();
	};
	SketchManager.prototype.record = function record () {
	        var this$1 = this;

	    if (this.props.recording) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Recording from Node.js is not yet supported');
	        return;
	    }
	    this.stop();
	    this.props.playing = true;
	    this.props.recording = true;
	    var exportOpts = this._createExportOptions({
	        sequence: true
	    });
	    var frameInterval = 1 / this.props.fps;
	    this._cancelTimeouts();
	    var tick = function () {
	        if (!this$1.props.recording) 
	            { return Promise.resolve(); }
	        this$1.props.deltaTime = frameInterval;
	        this$1.tick();
	        return this$1.exportFrame(exportOpts).then(function () {
	            if (!this$1.props.recording) 
	                { return; }
	            this$1.props.deltaTime = 0;
	            this$1.props.frame++;
	            if (this$1.props.frame < this$1.props.totalFrames) {
	                this$1.props.time += frameInterval;
	                this$1.props.playhead = this$1._computePlayhead(this$1.props.time, this$1.props.duration);
	                this$1._recordTimeout = setTimeout(tick, 0);
	            } else {
	                console.log('Finished recording');
	                this$1._signalEnd();
	                this$1.endRecord();
	                this$1.stop();
	                this$1.run();
	            }
	        });
	    };
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    if (this.sketch && typeof this.sketch.beginRecord === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.beginRecord(props); });
	    }
	    streamStart(exportOpts).catch(function (err) {
	        console.error(err);
	    }).then(function (response) {
	        this$1._raf = window.requestAnimationFrame(tick);
	    });
	};
	SketchManager.prototype._signalBegin = function _signalBegin () {
	        var this$1 = this;

	    if (this.sketch && typeof this.sketch.begin === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.begin(props); });
	    }
	};
	SketchManager.prototype._signalEnd = function _signalEnd () {
	        var this$1 = this;

	    if (this.sketch && typeof this.sketch.end === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.end(props); });
	    }
	};
	SketchManager.prototype.endRecord = function endRecord () {
	        var this$1 = this;

	    var wasRecording = this.props.recording;
	    this._cancelTimeouts();
	    this.props.recording = false;
	    this.props.deltaTime = 0;
	    this.props.playing = false;
	    return streamEnd().catch(function (err) {
	        console.error(err);
	    }).then(function () {
	        if (wasRecording && this$1.sketch && typeof this$1.sketch.endRecord === 'function') {
	            this$1._wrapContextScale(function (props) { return this$1.sketch.endRecord(props); });
	        }
	    });
	};
	SketchManager.prototype._createExportOptions = function _createExportOptions (opt) {
	        if ( opt === void 0 ) opt = {};

	    return {
	        sequence: opt.sequence,
	        save: opt.save,
	        fps: this.props.fps,
	        frame: opt.sequence ? this.props.frame : undefined,
	        file: this.settings.file,
	        name: this.settings.name,
	        prefix: this.settings.prefix,
	        suffix: this.settings.suffix,
	        encoding: this.settings.encoding,
	        encodingQuality: this.settings.encodingQuality,
	        timeStamp: opt.timeStamp || getTimeStamp(),
	        totalFrames: isFinite(this.props.totalFrames) ? Math.max(0, this.props.totalFrames) : 1000
	    };
	};
	SketchManager.prototype.exportFrame = function exportFrame (opt) {
	        var this$1 = this;
	        if ( opt === void 0 ) opt = {};

	    if (!this.sketch) 
	        { return Promise.all([]); }
	    if (typeof this.sketch.preExport === 'function') {
	        this.sketch.preExport();
	    }
	    var exportOpts = this._createExportOptions(opt);
	    var client = getClientAPI();
	    var p = Promise.resolve();
	    if (client && opt.commit && typeof client.commit === 'function') {
	        var commitOpts = objectAssign({}, exportOpts);
	        var hash = client.commit(commitOpts);
	        if (isPromise_1(hash)) 
	            { p = hash; }
	         else 
	            { p = Promise.resolve(hash); }
	    }
	    return p.then(function (hash) { return this$1._doExportFrame(objectAssign({}, exportOpts, {
	        hash: hash || ''
	    })); }).then(function (result) {
	        if (result.length === 1) 
	            { return result[0]; }
	         else 
	            { return result; }
	    });
	};
	SketchManager.prototype._doExportFrame = function _doExportFrame (exportOpts) {
	        var this$1 = this;
	        if ( exportOpts === void 0 ) exportOpts = {};

	    this._props.exporting = true;
	    this.resize();
	    var drawResult = this.render();
	    var canvas = this.props.canvas;
	    if (typeof drawResult === 'undefined') {
	        drawResult = [canvas];
	    }
	    drawResult = [].concat(drawResult).filter(Boolean);
	    drawResult = drawResult.map(function (result) {
	        var hasDataObject = typeof result === 'object' && result && ('data' in result || 'dataURL' in result);
	        var data = hasDataObject ? result.data : result;
	        var opts = hasDataObject ? objectAssign({}, result, {
	            data: data
	        }) : {
	            data: data
	        };
	        if (isCanvas(data)) {
	            var encoding = opts.encoding || exportOpts.encoding;
	            var encodingQuality = defined(opts.encodingQuality, exportOpts.encodingQuality, 0.95);
	            var ref = exportCanvas(data, {
	                encoding: encoding,
	                encodingQuality: encodingQuality
	            });
	                var dataURL = ref.dataURL;
	                var extension = ref.extension;
	                var type = ref.type;
	            return Object.assign(opts, {
	                dataURL: dataURL,
	                extension: extension,
	                type: type
	            });
	        } else {
	            return opts;
	        }
	    });
	    this._props.exporting = false;
	    this.resize();
	    this.render();
	    return Promise.all(drawResult.map(function (result, i, layerList) {
	        var curOpt = objectAssign({
	            extension: '',
	            prefix: '',
	            suffix: ''
	        }, exportOpts, result, {
	            layer: i,
	            totalLayers: layerList.length
	        });
	        var saveParam = exportOpts.save === false ? false : result.save;
	        curOpt.save = saveParam !== false;
	        curOpt.filename = resolveFilename(curOpt);
	        delete curOpt.encoding;
	        delete curOpt.encodingQuality;
	        for (var k in curOpt) {
	            if (typeof curOpt[k] === 'undefined') 
	                { delete curOpt[k]; }
	        }
	        var savePromise = Promise.resolve({});
	        if (curOpt.save) {
	            var data = curOpt.data;
	            if (curOpt.dataURL) {
	                var dataURL = curOpt.dataURL;
	                savePromise = saveDataURL(dataURL, curOpt);
	            } else {
	                savePromise = saveFile(data, curOpt);
	            }
	        }
	        return savePromise.then(function (saveResult) { return Object.assign({}, curOpt, saveResult); });
	    })).then(function (ev) {
	        var savedEvents = ev.filter(function (e) { return e.save; });
	        if (savedEvents.length > 0) {
	            var eventWithOutput = savedEvents.find(function (e) { return e.outputName; });
	            var isClient = savedEvents.some(function (e) { return e.client; });
	            var isStreaming = savedEvents.some(function (e) { return e.stream; });
	            var item;
	            if (savedEvents.length > 1) 
	                { item = savedEvents.length; }
	             else if (eventWithOutput) 
	                { item = (eventWithOutput.outputName) + "/" + (savedEvents[0].filename); }
	             else 
	                { item = "" + (savedEvents[0].filename); }
	            var ofSeq = '';
	            if (exportOpts.sequence) {
	                var hasTotalFrames = isFinite(this$1.props.totalFrames);
	                ofSeq = hasTotalFrames ? (" (frame " + (exportOpts.frame + 1) + " / " + (this$1.props.totalFrames) + ")") : (" (frame " + (exportOpts.frame) + ")");
	            } else if (savedEvents.length > 1) {
	                ofSeq = " files";
	            }
	            var client = isClient ? 'canvas-sketch-cli' : 'canvas-sketch';
	            var action = isStreaming ? 'Streaming into' : 'Exported';
	            console.log(("%c[" + client + "]%c " + action + " %c" + item + "%c" + ofSeq), 'color: #8e8e8e;', 'color: initial;', 'font-weight: bold;', 'font-weight: initial;');
	        }
	        if (typeof this$1.sketch.postExport === 'function') {
	            this$1.sketch.postExport();
	        }
	        return ev;
	    });
	};
	SketchManager.prototype._wrapContextScale = function _wrapContextScale (cb) {
	    this._preRender();
	    cb(this.props);
	    this._postRender();
	};
	SketchManager.prototype._preRender = function _preRender () {
	    var props = this.props;
	    if (!this.props.gl && props.context && !props.p5) {
	        props.context.save();
	        if (this.settings.scaleContext !== false) {
	            props.context.scale(props.scaleX, props.scaleY);
	        }
	    } else if (props.p5) {
	        props.p5.scale(props.scaleX / props.pixelRatio, props.scaleY / props.pixelRatio);
	    }
	};
	SketchManager.prototype._postRender = function _postRender () {
	    var props = this.props;
	    if (!this.props.gl && props.context && !props.p5) {
	        props.context.restore();
	    }
	    if (props.gl && this.settings.flush !== false && !props.p5) {
	        props.gl.flush();
	    }
	};
	SketchManager.prototype.tick = function tick () {
	    if (this.sketch && typeof this.sketch.tick === 'function') {
	        this._preRender();
	        this.sketch.tick(this.props);
	        this._postRender();
	    }
	};
	SketchManager.prototype.render = function render () {
	    if (this.props.p5) {
	        this._lastRedrawResult = undefined;
	        this.props.p5.redraw();
	        return this._lastRedrawResult;
	    } else {
	        return this.submitDrawCall();
	    }
	};
	SketchManager.prototype.submitDrawCall = function submitDrawCall () {
	    if (!this.sketch) 
	        { return; }
	    var props = this.props;
	    this._preRender();
	    var drawResult;
	    if (typeof this.sketch === 'function') {
	        drawResult = this.sketch(props);
	    } else if (typeof this.sketch.render === 'function') {
	        drawResult = this.sketch.render(props);
	    }
	    this._postRender();
	    return drawResult;
	};
	SketchManager.prototype.update = function update (opt) {
	        var this$1 = this;
	        if ( opt === void 0 ) opt = {};

	    var notYetSupported = ['animate'];
	    Object.keys(opt).forEach(function (key) {
	        if (notYetSupported.indexOf(key) >= 0) {
	            throw new Error(("Sorry, the { " + key + " } option is not yet supported with update()."));
	        }
	    });
	    var oldCanvas = this._settings.canvas;
	    var oldContext = this._settings.context;
	    for (var key in opt) {
	        var value = opt[key];
	        if (typeof value !== 'undefined') {
	            this$1._settings[key] = value;
	        }
	    }
	    var timeOpts = Object.assign({}, this._settings, opt);
	    if ('time' in opt && 'frame' in opt) 
	        { throw new Error('You should specify { time } or { frame } but not both'); }
	     else if ('time' in opt) 
	        { delete timeOpts.frame; }
	     else if ('frame' in opt) 
	        { delete timeOpts.time; }
	    if ('duration' in opt && 'totalFrames' in opt) 
	        { throw new Error('You should specify { duration } or { totalFrames } but not both'); }
	     else if ('duration' in opt) 
	        { delete timeOpts.totalFrames; }
	     else if ('totalFrames' in opt) 
	        { delete timeOpts.duration; }
	    if ('data' in opt) 
	        { this._props.data = opt.data; }
	    var timeProps = this.getTimeProps(timeOpts);
	    Object.assign(this._props, timeProps);
	    if (oldCanvas !== this._settings.canvas || oldContext !== this._settings.context) {
	        var ref = createCanvas(this._settings);
	            var canvas = ref.canvas;
	            var context = ref.context;
	        this.props.canvas = canvas;
	        this.props.context = context;
	        this._setupGLKey();
	        this._appendCanvasIfNeeded();
	    }
	    if (opt.p5 && typeof opt.p5 !== 'function') {
	        this.props.p5 = opt.p5;
	        this.props.p5.draw = (function () {
	            if (this$1._isP5Resizing) 
	                { return; }
	            this$1._lastRedrawResult = this$1.submitDrawCall();
	        });
	    }
	    if ('playing' in opt) {
	        if (opt.playing) 
	            { this.play(); }
	         else 
	            { this.pause(); }
	    }
	    checkSettings(this._settings);
	    this.resize();
	    this.render();
	    return this.props;
	};
	SketchManager.prototype.resize = function resize () {
	    var oldSizes = this._getSizeProps();
	    var settings = this.settings;
	    var props = this.props;
	    var newProps = resizeCanvas(props, settings);
	    Object.assign(this._props, newProps);
	    var ref = this.props;
	        var pixelRatio = ref.pixelRatio;
	        var canvasWidth = ref.canvasWidth;
	        var canvasHeight = ref.canvasHeight;
	        var styleWidth = ref.styleWidth;
	        var styleHeight = ref.styleHeight;
	    var canvas = this.props.canvas;
	    if (canvas && settings.resizeCanvas !== false) {
	        if (props.p5) {
	            if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
	                this._isP5Resizing = true;
	                props.p5.pixelDensity(pixelRatio);
	                props.p5.resizeCanvas(canvasWidth / pixelRatio, canvasHeight / pixelRatio, false);
	                this._isP5Resizing = false;
	            }
	        } else {
	            if (canvas.width !== canvasWidth) 
	                { canvas.width = canvasWidth; }
	            if (canvas.height !== canvasHeight) 
	                { canvas.height = canvasHeight; }
	        }
	        if (isBrowser() && settings.styleCanvas !== false) {
	            canvas.style.width = styleWidth + "px";
	            canvas.style.height = styleHeight + "px";
	        }
	    }
	    var newSizes = this._getSizeProps();
	    var changed = !deepEqual_1(oldSizes, newSizes);
	    if (changed) {
	        this._sizeChanged();
	    }
	    return changed;
	};
	SketchManager.prototype._sizeChanged = function _sizeChanged () {
	    if (this.sketch && typeof this.sketch.resize === 'function') {
	        this.sketch.resize(this.props);
	    }
	};
	SketchManager.prototype.animate = function animate () {
	    if (!this.props.playing) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Animation in Node.js is not yet supported');
	        return;
	    }
	    this._raf = window.requestAnimationFrame(this._animateHandler);
	    var now = browser();
	    var fps = this.props.fps;
	    var frameIntervalMS = 1000 / fps;
	    var deltaTimeMS = now - this._lastTime;
	    var duration = this.props.duration;
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    var isNewFrame = true;
	    var playbackRate = this.settings.playbackRate;
	    if (playbackRate === 'fixed') {
	        deltaTimeMS = frameIntervalMS;
	    } else if (playbackRate === 'throttle') {
	        if (deltaTimeMS > frameIntervalMS) {
	            now = now - deltaTimeMS % frameIntervalMS;
	            this._lastTime = now;
	        } else {
	            isNewFrame = false;
	        }
	    } else {
	        this._lastTime = now;
	    }
	    var deltaTime = deltaTimeMS / 1000;
	    var newTime = this.props.time + deltaTime * this.props.timeScale;
	    if (newTime < 0 && hasDuration) {
	        newTime = duration + newTime;
	    }
	    var isFinished = false;
	    var isLoopStart = false;
	    var looping = this.settings.loop !== false;
	    if (hasDuration && newTime >= duration) {
	        if (looping) {
	            isNewFrame = true;
	            newTime = newTime % duration;
	            isLoopStart = true;
	        } else {
	            isNewFrame = false;
	            newTime = duration;
	            isFinished = true;
	        }
	        this._signalEnd();
	    }
	    if (isNewFrame) {
	        this.props.deltaTime = deltaTime;
	        this.props.time = newTime;
	        this.props.playhead = this._computePlayhead(newTime, duration);
	        var lastFrame = this.props.frame;
	        this.props.frame = this._computeCurrentFrame();
	        if (isLoopStart) 
	            { this._signalBegin(); }
	        if (lastFrame !== this.props.frame) 
	            { this.tick(); }
	        this.render();
	        this.props.deltaTime = 0;
	    }
	    if (isFinished) {
	        this.pause();
	    }
	};
	SketchManager.prototype.dispatch = function dispatch (cb) {
	    if (typeof cb !== 'function') 
	        { throw new Error('must pass function into dispatch()'); }
	    cb(this.props);
	    this.render();
	};
	SketchManager.prototype.mount = function mount () {
	    this._appendCanvasIfNeeded();
	};
	SketchManager.prototype.unmount = function unmount () {
	    if (isBrowser()) {
	        window.removeEventListener('resize', this._resizeHandler);
	        this._keyboardShortcuts.detach();
	    }
	    if (this.props.canvas.parentElement) {
	        this.props.canvas.parentElement.removeChild(this.props.canvas);
	    }
	};
	SketchManager.prototype._appendCanvasIfNeeded = function _appendCanvasIfNeeded () {
	    if (!isBrowser()) 
	        { return; }
	    if (this.settings.parent !== false && (this.props.canvas && !this.props.canvas.parentElement)) {
	        var defaultParent = this.settings.parent || document.body;
	        defaultParent.appendChild(this.props.canvas);
	    }
	};
	SketchManager.prototype._setupGLKey = function _setupGLKey () {
	    if (this.props.context) {
	        if (isWebGLContext(this.props.context)) {
	            this._props.gl = this.props.context;
	        } else {
	            delete this._props.gl;
	        }
	    }
	};
	SketchManager.prototype.getTimeProps = function getTimeProps (settings) {
	        if ( settings === void 0 ) settings = {};

	    var duration = settings.duration;
	    var totalFrames = settings.totalFrames;
	    var timeScale = defined(settings.timeScale, 1);
	    var fps = defined(settings.fps, 24);
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    var hasTotalFrames = typeof totalFrames === 'number' && isFinite(totalFrames);
	    var totalFramesFromDuration = hasDuration ? Math.floor(fps * duration) : undefined;
	    var durationFromTotalFrames = hasTotalFrames ? totalFrames / fps : undefined;
	    if (hasDuration && hasTotalFrames && totalFramesFromDuration !== totalFrames) {
	        throw new Error('You should specify either duration or totalFrames, but not both. Or, they must match exactly.');
	    }
	    if (typeof settings.dimensions === 'undefined' && typeof settings.units !== 'undefined') {
	        console.warn("You've specified a { units } setting but no { dimension }, so the units will be ignored.");
	    }
	    totalFrames = defined(totalFrames, totalFramesFromDuration, Infinity);
	    duration = defined(duration, durationFromTotalFrames, Infinity);
	    var startTime = settings.time;
	    var startFrame = settings.frame;
	    var hasStartTime = typeof startTime === 'number' && isFinite(startTime);
	    var hasStartFrame = typeof startFrame === 'number' && isFinite(startFrame);
	    var time = 0;
	    var frame = 0;
	    var playhead = 0;
	    if (hasStartTime && hasStartFrame) {
	        throw new Error('You should specify either start frame or time, but not both.');
	    } else if (hasStartTime) {
	        time = startTime;
	        playhead = this._computePlayhead(time, duration);
	        frame = this._computeFrame(playhead, time, totalFrames, fps);
	    } else if (hasStartFrame) {
	        frame = startFrame;
	        time = frame / fps;
	        playhead = this._computePlayhead(time, duration);
	    }
	    return {
	        playhead: playhead,
	        time: time,
	        frame: frame,
	        duration: duration,
	        totalFrames: totalFrames,
	        fps: fps,
	        timeScale: timeScale
	    };
	};
	SketchManager.prototype.setup = function setup (settings) {
	        var this$1 = this;
	        if ( settings === void 0 ) settings = {};

	    if (this.sketch) 
	        { throw new Error('Multiple setup() calls not yet supported.'); }
	    this._settings = Object.assign({}, settings, this._settings);
	    checkSettings(this._settings);
	    var ref = createCanvas(this._settings);
	        var context = ref.context;
	        var canvas = ref.canvas;
	    var timeProps = this.getTimeProps(this._settings);
	    this._props = Object.assign({}, timeProps,
	        {canvas: canvas,
	        context: context,
	        deltaTime: 0,
	        started: false,
	        exporting: false,
	        playing: false,
	        recording: false,
	        settings: this.settings,
	        data: this.settings.data,
	        render: function () { return this$1.render(); },
	        togglePlay: function () { return this$1.togglePlay(); },
	        dispatch: function (cb) { return this$1.dispatch(cb); },
	        tick: function () { return this$1.tick(); },
	        resize: function () { return this$1.resize(); },
	        update: function (opt) { return this$1.update(opt); },
	        exportFrame: function (opt) { return this$1.exportFrame(opt); },
	        record: function () { return this$1.record(); },
	        play: function () { return this$1.play(); },
	        pause: function () { return this$1.pause(); },
	        stop: function () { return this$1.stop(); }});
	    this._setupGLKey();
	    this.resize();
	};
	SketchManager.prototype.loadAndRun = function loadAndRun (canvasSketch, newSettings) {
	        var this$1 = this;

	    return this.load(canvasSketch, newSettings).then(function () {
	        this$1.run();
	        return this$1;
	    });
	};
	SketchManager.prototype.unload = function unload () {
	        var this$1 = this;

	    this.pause();
	    if (!this.sketch) 
	        { return; }
	    if (typeof this.sketch.unload === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.unload(props); });
	    }
	    this._sketch = null;
	};
	SketchManager.prototype.destroy = function destroy () {
	    this.unload();
	    this.unmount();
	};
	SketchManager.prototype.load = function load (createSketch, newSettings) {
	        var this$1 = this;

	    if (typeof createSketch !== 'function') {
	        throw new Error('The function must take in a function as the first parameter. Example:\n  canvasSketcher(() => { ... }, settings)');
	    }
	    if (this.sketch) {
	        this.unload();
	    }
	    if (typeof newSettings !== 'undefined') {
	        this.update(newSettings);
	    }
	    this._preRender();
	    var preload = Promise.resolve();
	    if (this.settings.p5) {
	        if (!isBrowser()) {
	            throw new Error('[canvas-sketch] ERROR: Using p5.js in Node.js is not supported');
	        }
	        preload = new Promise(function (resolve) {
	            var P5Constructor = this$1.settings.p5;
	            var preload;
	            if (P5Constructor.p5) {
	                preload = P5Constructor.preload;
	                P5Constructor = P5Constructor.p5;
	            }
	            var p5Sketch = function (p5) {
	                if (preload) 
	                    { p5.preload = (function () { return preload(p5); }); }
	                p5.setup = (function () {
	                    var props = this$1.props;
	                    var isGL = this$1.settings.context === 'webgl';
	                    var renderer = isGL ? p5.WEBGL : p5.P2D;
	                    p5.noLoop();
	                    p5.pixelDensity(props.pixelRatio);
	                    p5.createCanvas(props.viewportWidth, props.viewportHeight, renderer);
	                    if (isGL && this$1.settings.attributes) {
	                        p5.setAttributes(this$1.settings.attributes);
	                    }
	                    this$1.update({
	                        p5: p5,
	                        canvas: p5.canvas,
	                        context: p5._renderer.drawingContext
	                    });
	                    resolve();
	                });
	            };
	            if (typeof P5Constructor === 'function') {
	                new P5Constructor(p5Sketch);
	            } else {
	                if (typeof window.createCanvas !== 'function') {
	                    throw new Error("{ p5 } setting is passed but can't find p5.js in global (window) scope. Maybe you did not create it globally?\nnew p5(); // <-- attaches to global scope");
	                }
	                p5Sketch(window);
	            }
	        });
	    }
	    return preload.then(function () {
	        var loader = createSketch(this$1.props);
	        if (!isPromise_1(loader)) {
	            loader = Promise.resolve(loader);
	        }
	        return loader;
	    }).then(function (sketch) {
	        if (!sketch) 
	            { sketch = {}; }
	        this$1._sketch = sketch;
	        if (isBrowser()) {
	            this$1._keyboardShortcuts.attach();
	            window.addEventListener('resize', this$1._resizeHandler);
	        }
	        this$1._postRender();
	        this$1._sizeChanged();
	        return this$1;
	    }).catch(function (err) {
	        console.warn('Could not start sketch, the async loading function rejected with an error:\n    Error: ' + err.message);
	        throw err;
	    });
	};

	Object.defineProperties( SketchManager.prototype, prototypeAccessors );

	var CACHE = 'hot-id-cache';
	var runtimeCollisions = [];
	function isHotReload() {
	    var client = getClientAPI();
	    return client && client.hot;
	}

	function cacheGet(id) {
	    var client = getClientAPI();
	    if (!client) 
	        { return undefined; }
	    client[CACHE] = client[CACHE] || {};
	    return client[CACHE][id];
	}

	function cachePut(id, data) {
	    var client = getClientAPI();
	    if (!client) 
	        { return undefined; }
	    client[CACHE] = client[CACHE] || {};
	    client[CACHE][id] = data;
	}

	function getTimeProp(oldManager, newSettings) {
	    return newSettings.animate ? {
	        time: oldManager.props.time
	    } : undefined;
	}

	function canvasSketch(sketch, settings) {
	    if ( settings === void 0 ) settings = {};

	    if (settings.p5) {
	        if (settings.canvas || settings.context && typeof settings.context !== 'string') {
	            throw new Error("In { p5 } mode, you can't pass your own canvas or context, unless the context is a \"webgl\" or \"2d\" string");
	        }
	        var context = typeof settings.context === 'string' ? settings.context : false;
	        settings = Object.assign({}, settings, {
	            canvas: false,
	            context: context
	        });
	    }
	    var isHot = isHotReload();
	    var hotID;
	    if (isHot) {
	        hotID = defined(settings.id, '$__DEFAULT_CANVAS_SKETCH_ID__$');
	    }
	    var isInjecting = isHot && typeof hotID === 'string';
	    if (isInjecting && runtimeCollisions.includes(hotID)) {
	        console.warn("Warning: You have multiple calls to canvasSketch() in --hot mode. You must pass unique { id } strings in settings to enable hot reload across multiple sketches. ", hotID);
	        isInjecting = false;
	    }
	    var preload = Promise.resolve();
	    if (isInjecting) {
	        runtimeCollisions.push(hotID);
	        var previousData = cacheGet(hotID);
	        if (previousData) {
	            var next = function () {
	                var newProps = getTimeProp(previousData.manager, settings);
	                previousData.manager.destroy();
	                return newProps;
	            };
	            preload = previousData.load.then(next).catch(next);
	        }
	    }
	    return preload.then(function (newProps) {
	        var manager = new SketchManager();
	        var result;
	        if (sketch) {
	            settings = Object.assign({}, settings, newProps);
	            manager.setup(settings);
	            manager.mount();
	            result = manager.loadAndRun(sketch);
	        } else {
	            result = Promise.resolve(manager);
	        }
	        if (isInjecting) {
	            cachePut(hotID, {
	                load: result,
	                manager: manager
	            });
	        }
	        return result;
	    });
	}

	canvasSketch.canvasSketch = canvasSketch;
	canvasSketch.PaperSizes = paperSizes;

	return canvasSketch;

})));


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],5:[function(require,module,exports){
(function (global){(function (){
/*
MIT License

Copyright (c) 2012 - 2021 jonobr1 / http://jonobr1.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Two = factory());
}(this, (function () { 'use strict';

  /**
   * @name Two.Commands
   * @property {Object} - Map of possible path commands. Taken from the SVG specification.
   */
  var Commands = {
    move: 'M',
    line: 'L',
    curve: 'C',
    arc: 'A',
    close: 'Z'
  };

  var root;
  if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof self !== 'undefined') {
    root = self;
  }

  var root$1 = root;

  var Matrix$1;

  /**
   * @name Two.Utils.decomposeMatrix
   * @function
   * @param {Two.Matrix} matrix - The matrix to decompose.
   * @returns {Object} An object containing relevant skew values.
   * @description Decompose a 2D 3x3 Matrix to find the skew.
   */
  var decomposeMatrix = function(matrix) {

    // TODO: Include skewX, skewY
    // https://math.stackexchange.com/questions/237369/given-this-transformation-matrix-how-do-i-decompose-it-into-translation-rotati/417813
    // https://stackoverflow.com/questions/45159314/decompose-2d-transformation-matrix

    return {
        translateX: matrix.e,
        translateY: matrix.f,
        scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
        scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
        rotation: 180 * Math.atan2(matrix.b, matrix.a) / Math.PI
    };

  };

  var setMatrix = function(M) {
    Matrix$1 = M;
  };

  /**
   * @name Two.Utils.getComputedMatrix
   * @function
   * @param {Two.Shape} object - The Two.js object that has a matrix property to calculate from.
   * @param {Two.Matrix} [matrix] - The matrix to apply calculated transformations to if available.
   * @returns {Two.Matrix} The computed matrix of a nested object. If no `matrix` was passed in arguments then a `new Two.Matrix` is returned.
   * @description Method to get the world space transformation of a given object in a Two.js scene.
   */
  var getComputedMatrix = function(object, matrix) {

    matrix = (matrix && matrix.identity()) || new Matrix$1();
    var parent = object, matrices = [];

    while (parent && parent._matrix) {
      matrices.push(parent._matrix);
      parent = parent.parent;
    }

    matrices.reverse();

    for (var i = 0; i < matrices.length; i++) {

      var m = matrices[i];
      var e = m.elements;
      matrix.multiply(
        e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9]);

    }

    return matrix;

  };

  /**
   * @name Two.Utils.lerp
   * @function
   * @param {Number} a - Start value.
   * @param {Number} b - End value.
   * @param {Number} t - Zero-to-one value describing percentage between a and b.
   * @returns {Number}
   * @description Linear interpolation between two values `a` and `b` by an amount `t`.
   */
  var lerp = function(a, b, t) {
    return t * (b - a) + a;
  };

  /**
   * @name Two.Utils.mod
   * @function
   * @param {Number} v - The value to modulo
   * @param {Number} l - The value to modulo by
   * @returns {Number}
   * @description Modulo with added functionality to handle negative values in a positive manner.
   */
  var mod = function(v, l) {

    while (v < 0) {
      v += l;
    }

    return v % l;

  };

  var NumArray = root$1.Float32Array || Array;

  /**
  * @name Two.Utils.toFixed
  * @function
  * @param {Number} v - Any float
  * @returns {Number} That float trimmed to the third decimal place.
  * @description A pretty fast toFixed(3) alternative.
  * @see {@link http://jsperf.com/parsefloat-tofixed-vs-math-round/18}
  */
  var toFixed = function(v) {
    return Math.floor(v * 1000000) / 1000000;
  };

  var math = /*#__PURE__*/Object.freeze({
    __proto__: null,
    decomposeMatrix: decomposeMatrix,
    getComputedMatrix: getComputedMatrix,
    setMatrix: setMatrix,
    lerp: lerp,
    mod: mod,
    NumArray: NumArray,
    toFixed: toFixed
  });

  var slice = Array.prototype.slice;

  var isArrayLike = function(collection) {
    if (collection === null || collection === undefined) return false;
    var length = collection.length;
    // Arrays cannot hold more than 2^32 - 1 items
    return (typeof length == 'number' && length >= 0 && length < 4294967296);
  };

  var _ = {
    isNaN: function(obj) {
      return typeof obj === 'number' && obj !== +obj;
    },
    isElement: function(obj) {
      return !!(obj && obj.nodeType === 1);
    },
    isObject: function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    },
    extend: function(base) {
      var sources = slice.call(arguments, 1);
      for (var i = 0; i < sources.length; i++) {
        var obj = sources[i];
        for (var k in obj) {
          base[k] = obj[k];
        }
      }
      return base;
    },
    defaults: function(base) {
      var sources = slice.call(arguments, 1);
      for (var i = 0; i < sources.length; i++) {
        var obj = sources[i];
        for (var k in obj) {
          if (base[k] === void 0) {
          base[k] = obj[k];
          }
        }
      }
      return base;
    },
    each: function(obj, iteratee, context) {
      var ctx = context || this;
      var keys = !isArrayLike(obj) && Object.keys(obj);
      var length = (keys || obj).length;
      for (var i = 0; i < length; i++) {
        var k = keys ? keys[i] : i;
        iteratee.call(ctx, obj[k], k, obj);
      }
      return obj;
    },
    /**
     * @name Two.Utils.performance
     * @property {Date} - A special `Date` like object to get the current millis of the session. Used internally to calculate time between frames.
     * e.g: `Utils.performance.now() // milliseconds since epoch`
     */
    performance: ((root$1.performance && root$1.performance.now) ? root$1.performance : Date),
  };

  /**
   * @name Two.Events
   * @class
   * @description Object inherited by many Two.js objects in order to facilitate custom events.
   */
  var Events = {

    /**
     * @name Two.Events#on
     * @function
     * @param {String} [name] - The name of the event to bind a function to.
     * @param {Function} [handler] - The function to be invoked when the event is dispatched.
     * @description Call to add a listener to a specific event name.
     */
    on: addEventListener,

    /**
     * @name Two.Events#off
     * @function
     * @param {String} [name] - The name of the event intended to be removed.
     * @param {Function} [handler] - The handler intended to be reomved.
     * @description Call to remove listeners from a specific event. If only `name` is passed then all the handlers attached to that `name` will be removed. If no arguments are passed then all handlers for every event on the obejct are removed.
     */
    off: removeEventListener,

    /**
     * @name Two.Events#trigger
     * @function
     * @param {String} name - The name of the event to dispatch.
     * @param arguments - Anything can be passed after the name and those will be passed on to handlers attached to the event in the order they are passed.
     * @description Call to trigger a custom event. Any additional arguments passed after the name will be passed along to the attached handlers.
     */
    trigger: function(name) {
      var scope = this;
      if (!scope._events) return scope;
      var args = Array.prototype.slice.call(arguments, 1);
      var events = scope._events[name];
      if (events) dispatch(scope, events, args);
      return scope;
    },

    listen: function(obj, name, handler) {

      var bound = this;

      if (obj) {

        var event = function () {
          handler.apply(bound, arguments);
        };

        // Add references about the object that assigned this listener
        event.obj = obj;
        event.name = name;
        event.handler = handler;

        obj.on(name, event);

      }

      return bound;

    },

    ignore: function(obj, name, handler) {

      var scope = this;
      obj.off(name, handler);
      return scope;

    },

    /**
     * @name Two.Events.Types
     * @property {Object} - Object of different types of Two.js specific events.
     */
    Types: {
      play: 'play',
      pause: 'pause',
      update: 'update',
      render: 'render',
      resize: 'resize',
      change: 'change',
      remove: 'remove',
      insert: 'insert',
      order: 'order',
      load: 'load'
    }

  };


  /**
   * @name Two.Events.bind
   * @function
   * @description Alias for {@link Two.Events.on}.
   */
  Events.bind = addEventListener;

  /**
   * @name Two.Events.unbind
   * @function
   * @description Alias for {@link Two.Events.off}.
   */
  Events.unbind = removeEventListener;

  /**
   * @private
   * @returns {Two.Events} - Returns an instance of self for the purpose of chaining.
   */
  function addEventListener(name, handler) {

    var scope = this;

    scope._events || (scope._events = {});
    var list = scope._events[name] || (scope._events[name] = []);

    list.push(handler);

    return scope;

  }

  /**
   * @private
   * @returns {Two.Events} - Returns an instance of self for the purpose of chaining.
   */
  function removeEventListener(name, handler) {

    var scope = this;

    if (!scope._events) {
      return scope;
    }
    if (!name && !handler) {
      scope._events = {};
      return scope;
    }

    var names = name ? [name] : Object.keys(scope._events);
    for (var i = 0, l = names.length; i < l; i++) {

      name = names[i];
      var list = scope._events[name];

      if (list) {
        var events = [];
        if (handler) {
          for (var j = 0, k = list.length; j < k; j++) {
            var ev = list[j];
            ev = ev.handler ? ev.handler : ev;
            if (handler && handler !== ev) {
              events.push(ev);
            }
          }
        }
        scope._events[name] = events;
      }
    }

    return scope;
  }

  function dispatch(obj, events, args) {
    var method;
    switch (args.length) {
    case 0:
      method = function(i) {
        events[i].call(obj, args[0]);
      };
      break;
    case 1:
      method = function(i) {
        events[i].call(obj, args[0], args[1]);
      };
      break;
    case 2:
      method = function(i) {
        events[i].call(obj, args[0], args[1], args[2]);
      };
      break;
    case 3:
      method = function(i) {
        events[i].call(obj, args[0], args[1], args[2], args[3]);
      };
      break;
    default:
      method = function(i) {
        events[i].apply(obj, args);
      };
    }
    for (var i = 0; i < events.length; i++) {
      method(i);
    }
  }

  /**
   * @name Two.Vector
   * @class
   * @param {Number} [x=0] - Any number to represent the horizontal x-component of the vector.
   * @param {Number} [y=0] - Any number to represent the vertical y-component of the vector.
   * @description A class to store x / y component vector data. In addition to storing data `Two.Vector` has suped up methods for commonplace mathematical operations.
   */
  function Vector(x, y) {

    /**
     * @name Two.Vector#x
     * @property {Number} - The horizontal x-component of the vector.
     */
    this.x = x || 0;

    /**
     * @name Two.Vector#y
     * @property {Number} - The vertical y-component of the vector.
     */
    this.y = y || 0;

  }

  _.extend(Vector, {

    /**
     * @name Two.Vector.zero
     * @readonly
     * @property {Two.Vector} - Handy reference to a vector with component values 0, 0 at all times.
     */
    zero: new Vector(),

    /**
     * @name Two.Vector.add
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Two.Vector}
     * @description Add two vectors together.
     */
    add: function(v1, v2) {
      return new Vector(v1.x + v2.x, v1.y + v2.y);
    },

    /**
     * @name Two.Vector.sub
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Two.Vector}
     * @description Subtract two vectors: `v2` from `v1`.
     */
    sub: function(v1, v2) {
      return new Vector(v1.x - v2.x, v1.y - v2.y);
    },

    /**
     * @name Two.Vector.subtract
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subtract: function(v1, v2) {
      return Vector.sub(v1, v2);
    },

    /**
     * @name Two.Vector.ratioBetween
     * @function
     * @param {Two.Vector} A
     * @param {Two.Vector} B
     * @returns {Number} The ratio betwen two points `v1` and `v2`.
     */
    ratioBetween: function(v1, v2) {

      return (v1.x * v2.x + v1.y * v2.y) / (v1.length() * v2.length());

    },

    /**
     * @name Two.Vector.angleBetween
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The angle between points `v1` and `v2`.
     */
    angleBetween: function(v1, v2) {

      var dx, dy;

      if (arguments.length >= 4) {

        dx = arguments[0] - arguments[2];
        dy = arguments[1] - arguments[3];

        return Math.atan2(dy, dx);

      }

      dx = v1.x - v2.x;
      dy = v1.y - v2.y;

      return Math.atan2(dy, dx);

    },

    /**
     * @name Two.Vector.distanceBetween
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The distance between points `v1` and `v2`. Distance is always positive.
     */
    distanceBetween: function(v1, v2) {

      return Math.sqrt(Vector.distanceBetweenSquared(v1, v2));

    },

    /**
     * @name Two.Vector.distanceBetweenSquared
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The squared distance between points `v1` and `v2`.
     */
    distanceBetweenSquared: function(v1, v2) {

      var dx = v1.x - v2.x;
      var dy = v1.y - v2.y;

      return dx * dx + dy * dy;

    },

    /**
     * @name Two.Vector.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Vector} to any object. Handy if you'd like to extend the {@link Two.Vector} class on a custom class.
     */
    MakeObservable: function(object) {

      // /**
      //  * Override Backbone bind / on in order to add properly broadcasting.
      //  * This allows Two.Vector to not broadcast events unless event listeners
      //  * are explicity bound to it.
      //  */

      object.bind = object.on = function() {

        if (!this._bound) {
          this._x = this.x;
          this._y = this.y;
          Object.defineProperty(this, 'x', xgs);
          Object.defineProperty(this, 'y', ygs);
          _.extend(this, BoundProto);
          this._bound = true; // Reserved for event initialization check
        }

        Events.bind.apply(this, arguments);

        return this;

      };

    }

  });

  _.extend(Vector.prototype, Events, {

    constructor: Vector,

    /**
     * @name Two.Vector#set
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Set the x / y components of a vector to specific number values.
     */
    set: function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * @name Two.Vector#copy
     * @function
     * @param {Two.Vector} v
     * @description Copy the x / y components of another object `v`.
     */
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    },

    /**
     * @name Two.Vector#clear
     * @function
     * @description Set the x / y component values of the vector to zero.
     */
    clear: function() {
      this.x = 0;
      this.y = 0;
      return this;
    },

    /**
     * @name Two.Vector#clone
     * @function
     * @description Create a new vector and copy the existing values onto the newly created instance.
     */
    clone: function() {
      return new Vector(this.x, this.y);
    },

    /**
     * @name Two.Vector#add
     * @function
     * @param {Two.Vector} v
     * @description Add an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#add
     * @function
     * @param {Number} v
     * @description Add the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#add
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Add `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    add: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x += x;
          this.y += x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x += x.x;
          this.y += x.y;
        }
      } else {
        this.x += x;
        this.y += y;
      }
      return this;
    },

    /**
     * @name Two.Vector#addSelf
     * @function
     * @description Alias for {@link Two.Vector.add}.
     */
    addSelf: function(v) {
      return this.add.apply(this, arguments);
    },

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Two.Vector} v
     * @description Subtract an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Number} v
     * @description Subtract the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Subtract `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    sub: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x -= x;
          this.y -= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x -= x.x;
          this.y -= x.y;
        }
      } else {
        this.x -= x;
        this.y -= y;
      }
      return this;
    },

    /**
     * @name Two.Vector#subtract
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subtract: function() {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#subSelf
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subSelf: function(v) {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#subtractSelf
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subtractSelf: function(v) {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Two.Vector} v
     * @description Multiply an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Number} v
     * @description Multiply the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Multiply `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    multiply: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x *= x;
          this.y *= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x *= x.x;
          this.y *= x.y;
        }
      } else {
        this.x *= x;
        this.y *= y;
      }
      return this;
    },

    /**
     * @name Two.Vector#multiplySelf
     * @function
     * @description Alias for {@link Two.Vector.multiply}.
     */
    multiplySelf: function(v) {
      return this.multiply.apply(this, arguments);
    },

    /**
     * @name Two.Vector#multiplyScalar
     * @function
     * @param {Number} s - The scalar to multiply by.
     * @description Mulitiply the vector by a single number. Shorthand to call {@link Two.Vector#multiply} directly.
     */
    multiplyScalar: function(s) {
      return this.multiply(s);
    },

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Two.Vector} v
     * @description Divide an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Number} v
     * @description Divide the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Divide `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    divide: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x /= x;
          this.y /= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x /= x.x;
          this.y /= x.y;
        }
      } else {
        this.x /= x;
        this.y /= y;
      }
      if (_.isNaN(this.x)) {
        this.x = 0;
      }
      if (_.isNaN(this.y)) {
        this.y = 0;
      }
      return this;
    },

    /**
     * @name Two.Vector#divideSelf
     * @function
     * @description Alias for {@link Two.Vector.divide}.
     */
    divideSelf: function(v) {
      return this.divide.apply(this, arguments);
    },

    /**
     * @name Two.Vector#divideScalar
     * @function
     * @param {Number} s - The scalar to divide by.
     * @description Divide the vector by a single number. Shorthand to call {@link Two.Vector#divide} directly.
     */
    divideScalar: function(s) {
      return this.divide(s);
    },

    /**
     * @name Two.Vector#negate
     * @function
     * @description Invert each component's sign value.
     */
    negate: function() {
      return this.multiply(-1);
    },

    /**
     * @name Two.Vector#negate
     * @function
     * @returns {Number}
     * @description Get the [dot product](https://en.wikipedia.org/wiki/Dot_product) of the vector.
     */
    dot: function(v) {
      return this.x * v.x + this.y * v.y;
    },

    /**
     * @name Two.Vector#length
     * @function
     * @returns {Number}
     * @description Get the length of a vector.
     */
    length: function() {
      return Math.sqrt(this.lengthSquared());
    },

    /**
     * @name Two.Vector#lengthSquared
     * @function
     * @returns {Number}
     * @description Get the length of the vector to the power of two. Widely used as less expensive than {@link Two.Vector#length}, because it isn't square-rooting any numbers.
     */
    lengthSquared: function() {
      return this.x * this.x + this.y * this.y;
    },

    /**
     * @name Two.Vector#normalize
     * @function
     * @description Normalize the vector from negative one to one.
     */
    normalize: function() {
      return this.divideScalar(this.length());
    },

    /**
     * @name Two.Vector#distanceTo
     * @function
     * @returns {Number}
     * @description Get the distance between two vectors.
     */
    distanceTo: function(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },

    /**
     * @name Two.Vector#distanceToSquared
     * @function
     * @returns {Number}
     * @description Get the distance between two vectors to the power of two. Widely used as less expensive than {@link Two.Vector#distanceTo}, because it isn't square-rooting any numbers.
     */
    distanceToSquared: function(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y;
      return dx * dx + dy * dy;
    },

    /**
     * @name Two.Vector#setLength
     * @function
     * @param {Number} l - length to set vector to.
     * @description Set the length of a vector.
     */
    setLength: function(l) {
      return this.normalize().multiplyScalar(l);
    },

    /**
     * @name Two.Vector#equals
     * @function
     * @param {Two.Vector} v - The vector to compare against.
     * @param {Number} [eps=0.0001] - An options epsilon for precision.
     * @returns {Boolean}
     * @description Qualify if one vector roughly equal another. With a margin of error defined by epsilon.
     */
    equals: function(v, eps) {
      eps = (typeof eps === 'undefined') ?  0.0001 : eps;
      return (this.distanceTo(v) < eps);
    },

    /**
     * @name Two.Vector#lerp
     * @function
     * @param {Two.Vector} v - The destination vector to step towards.
     * @param {Number} t - The zero to one value of how close the current vector gets to the destination vector.
     * @description Linear interpolate one vector to another by an amount `t` defined as a zero to one number.
     * @see [Matt DesLauriers](https://twitter.com/mattdesl/status/1031305279227478016) has a good thread about this.
     */
    lerp: function(v, t) {
      var x = (v.x - this.x) * t + this.x;
      var y = (v.y - this.y) * t + this.y;
      return this.set(x, y);
    },

    /**
     * @name Two.Vector#isZero
     * @function
     * @param {Number} [eps=0.0001] - Optional precision amount to check against.
     * @returns {Boolean}
     * @description Check to see if vector is roughly zero, based on the `epsilon` precision value.
     */
    isZero: function(eps) {
      eps = (typeof eps === 'undefined') ?  0.0001 : eps;
      return (this.length() < eps);
    },

    /**
     * @name Two.Vector#toString
     * @function
     * @returns {String}
     * @description Return a comma-separated string of x, y value. Great for storing in a database.
     */
    toString: function() {
      return this.x + ', ' + this.y;
    },

    /**
     * @name Two.Vector#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the vector.
     */
    toObject: function() {
      return { x: this.x, y: this.y };
    },

    /**
     * @name Two.Vector#rotate
     * @function
     * @param {Number} Number - The amoun to rotate the vector by.
     * @description Rotate a vector.
     */
    rotate: function(Number) {
      var cos = Math.cos(Number);
      var sin = Math.sin(Number);
      this.x = this.x * cos - this.y * sin;
      this.y = this.x * sin + this.y * cos;
      return this;
    }

  });

  // The same set of prototypical functions, but using the underlying
  // getter or setter for `x` and `y` values. This set of functions
  // is used instead of the previously documented ones above when
  // Two.Vector#bind is invoked and there is event dispatching processed
  // on x / y property changes.
  var BoundProto = {

    constructor: Vector,

    set: function(x, y) {
      this._x = x;
      this._y = y;
      return this.trigger(Events.Types.change);
    },

    copy: function(v) {
      this._x = v.x;
      this._y = v.y;
      return this.trigger(Events.Types.change);
    },

    clear: function() {
      this._x = 0;
      this._y = 0;
      return this.trigger(Events.Types.change);
    },

    clone: function() {
      return new Vector(this._x, this._y);
    },

    add: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x += x;
          this._y += x;
        }  else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x += x.x;
          this._y += x.y;
        }
      } else {
        this._x += x;
        this._y += y;
      }
      return this.trigger(Events.Types.change);
    },

    sub: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x -= x;
          this._y -= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x -= x.x;
          this._y -= x.y;
        }
      } else {
        this._x -= x;
        this._y -= y;
      }
      return this.trigger(Events.Types.change);
    },

    multiply: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x *= x;
          this._y *= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x *= x.x;
          this._y *= x.y;
        }
      } else {
        this._x *= x;
        this._y *= y;
      }
      return this.trigger(Events.Types.change);
    },

    divide: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x /= x;
          this._y /= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x /= x.x;
          this._y /= x.y;
        }
      } else {
        this._x /= x;
        this._y /= y;
      }
      if (_.isNaN(this._x)) {
        this._x = 0;
      }
      if (_.isNaN(this._y)) {
        this._y = 0;
      }
      return this.trigger(Events.Types.change);
    },

    dot: function(v) {
      return this._x * v.x + this._y * v.y;
    },

    lengthSquared: function() {
      return this._x * this._x + this._y * this._y;
    },

    distanceToSquared: function(v) {
      var dx = this._x - v.x,
          dy = this._y - v.y;
      return dx * dx + dy * dy;
    },

    lerp: function(v, t) {
      var x = (v.x - this._x) * t + this._x;
      var y = (v.y - this._y) * t + this._y;
      return this.set(x, y);
    },

    toString: function() {
      return this._x + ', ' + this._y;
    },

    toObject: function() {
      return { x: this._x, y: this._y };
    },

    rotate: function (Number) {
      var cos = Math.cos(Number);
      var sin = Math.sin(Number);
      this._x = this._x * cos - this._y * sin;
      this._y = this._x * sin + this._y * cos;
      return this;
    }

  };

  var xgs = {
    enumerable: true,
    get: function() {
      return this._x;
    },
    set: function(v) {
      this._x = v;
      this.trigger(Events.Types.change, 'x');
    }
  };

  var ygs = {
    enumerable: true,
    get: function() {
      return this._y;
    },
    set: function(v) {
      this._y = v;
      this.trigger(Events.Types.change, 'y');
    }
  };

  Vector.MakeObservable(Vector.prototype);

  /**
   * @class
   * @name Two.Anchor
   * @param {Number} [x=0] - The x position of the root anchor point.
   * @param {Number} [y=0] - The y position of the root anchor point.
   * @param {Number} [lx=0] - The x position of the left handle point.
   * @param {Number} [ly=0] - The y position of the left handle point.
   * @param {Number} [rx=0] - The x position of the right handle point.
   * @param {Number} [ry=0] - The y position of the right handle point.
   * @param {String} [command=Two.Commands.move] - The command to describe how to render. Applicable commands are {@link Two.Commands}
   * @extends Two.Vector
   * @description An object that holds 3 {@link Two.Vector}s, the anchor point and its corresponding handles: `left` and `right`. In order to properly describe the bezier curve about the point there is also a command property to describe what type of drawing should occur when Two.js renders the anchors.
   */
  function Anchor(x, y, lx, ly, rx, ry, command) {

    Vector.call(this, x, y);

    this._broadcast = (function() {
      this.trigger(Events.Types.change);
    }).bind(this);

    this._command = command || Commands.move;
    this._relative = true;

    var ilx = typeof lx === 'number';
    var ily = typeof ly === 'number';
    var irx = typeof rx === 'number';
    var iry = typeof ry === 'number';

    // Append the `controls` object only if control points are specified,
    // keeping the Two.Anchor inline with a Two.Vector until it needs to
    // evolve beyond those functions - e.g: a simple 2 component vector.
    if (ilx || ily || irx || iry) {
      Anchor.AppendCurveProperties(this);
    }

    if (ilx) {
      this.controls.left.x = lx;
    }
    if (ily) {
      this.controls.left.y = ly;
    }
    if (irx) {
      this.controls.right.x = rx;
    }
    if (iry) {
      this.controls.right.y = ry;
    }

  }

  _.extend(Anchor, {

    /**
     * @name Two.Anchor.AppendCurveProperties
     * @function
     * @param {Two.Anchor} anchor - The instance to append the `control`object to.
     * @description Adds the `controls` property as an object with `left` and `right` properties to access the bezier control handles that define how the curve is drawn. It also sets the `relative` property to `true` making vectors in the `controls` object relative to their corresponding root anchor point.
     */
    AppendCurveProperties: function(anchor) {

      anchor.relative = true;

      /**
       * @name Two.Anchor#controls
       * @property {Object} controls
       * @description An plain object that holds the controls handles for a {@link Two.Anchor}.
       */
      anchor.controls = {};

      /**
       * @name Two.Anchor#controls#left
       * @property {Two.Vector} left
       * @description The "left" control point to define handles on a bezier curve.
       */
      anchor.controls.left = new Vector(0, 0);

      /**
       * @name Two.Anchor#controls#right
       * @property {Two.Vector} right
       * @description The "left" control point to define handles on a bezier curve.
       */
      anchor.controls.right = new Vector(0, 0);

    },

    /**
     * @name Two.Anchor.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Anchor} to any object. Handy if you'd like to extend the {@link Two.Anchor} class on a custom class.
     */
    MakeObservable: function(object) {

      /**
       * @name Two.Anchor#command
       * @property {Two.Commands}
       * @description A draw command associated with the anchor point.
       */
      Object.defineProperty(object, 'command', {

        enumerable: true,

        get: function() {
          return this._command;
        },

        set: function(c) {
          this._command = c;
          if (this._command === Commands.curve && !_.isObject(this.controls)) {
            Anchor.AppendCurveProperties(this);
          }
          this.trigger(Events.Types.change);
        }

      });

      /**
       * @name Two.Anchor#relative
       * @property {Boolean}
       * @description A boolean to render control points relative to the root anchor point or in global coordinate-space to the rest of the scene.
       */
      Object.defineProperty(object, 'relative', {

        enumerable: true,

        get: function() {
          return this._relative;
        },

        set: function(b) {
          if (this._relative != b) {
            this._relative = !!b;
            this.trigger(Events.Types.change);
          }
        }

      });

      _.extend(object, Vector.prototype, AnchorProto);

      // Make it possible to bind and still have the Anchor specific
      // inheritance from Two.Vector. In this case relying on `Two.Vector`
      // to do much of the heavy event-listener binding / unbinding.
      object.bind = object.on = function() {
        var bound = this._bound;
        Vector.prototype.bind.apply(this, arguments);
        if (!bound) {
          _.extend(this, AnchorProto);
        }
      };

    }

  });

  var AnchorProto = {

    constructor: Anchor,

    /**
     * @name Two.Anchor#listen
     * @function
     * @description Convenience method used mainly by {@link Two.Path#vertices} to listen and propagate changes from control points up to their respective anchors and further if necessary.
     */
    listen: function() {

      if (!_.isObject(this.controls)) {
        Anchor.AppendCurveProperties(this);
      }

      this.controls.left.bind(Events.Types.change, this._broadcast);
      this.controls.right.bind(Events.Types.change, this._broadcast);

      return this;

    },

    /**
     * @name Two.Anchor#ignore
     * @function
     * @description Convenience method used mainly by {@link Two.Path#vertices} to ignore changes from a specific anchor's control points.
     */
    ignore: function() {

      this.controls.left.unbind(Events.Types.change, this._broadcast);
      this.controls.right.unbind(Events.Types.change, this._broadcast);

      return this;

    },

    /**
     * @name Two.Anchor#copy
     * @function
     * @param {Two.Anchor} v - The anchor to apply values to.
     * @description Copy the properties of one {@link Two.Anchor} onto another.
     */
    copy: function(v) {

      this.x = v.x;
      this.y = v.y;

      if (typeof v.command === 'string') {
        this.command = v.command;
      }
      if (_.isObject(v.controls)) {
        if (!_.isObject(this.controls)) {
          Anchor.AppendCurveProperties(this);
        }
        // TODO: Do we need to listen here?
        this.controls.left.copy(v.controls.left);
        this.controls.right.copy(v.controls.right);
      }
      if (typeof v.relative === 'boolean') {
        this.relative = v.relative;
      }

      // TODO: Hack for `Two.Commands.arc`
      if (this.command === Commands.arc) {
        this.rx = v.rx;
        this.ry = v.ry;
        this.xAxisRotation = v.xAxisRotation;
        this.largeArcFlag = v.largeArcFlag;
        this.sweepFlag = v.sweepFlag;
      }

      return this;

    },

    /**
     * @name Two.Anchor#clone
     * @function
     * @returns {Two.Anchor}
     * @description Create a new {@link Two.Anchor}, set all its values to the current instance and return it for use.
     */
    clone: function() {

      var controls = this.controls;

      var clone = new Anchor(
        this.x,
        this.y,
        controls && controls.left.x,
        controls && controls.left.y,
        controls && controls.right.x,
        controls && controls.right.y,
        this.command
      );
      clone.relative = this._relative;
      return clone;

    },

    /**
     * @name Two.Anchor#toObject
     * @function
     * @returns {Object} - An object with properties filled out to mirror {@link Two.Anchor}.
     * @description Create a JSON compatible plain object of the current instance. Intended for use with storing values in a database.
     */
    toObject: function() {
      var o = {
        x: this.x,
        y: this.y
      };
      if (this._command) {
        o.command = this._command;
      }
      if (this._relative) {
        o.relative = this._relative;
      }
      if (this.controls) {
        o.controls = {
          left: this.controls.left.toObject(),
          right: this.controls.right.toObject()
        };
      }
      return o;
    },

    /**
     * @name Two.Anchor#toString
     * @function
     * @returns {String} - A String with comma-separated values reflecting the various values on the current instance.
     * @description Create a string form of the current instance. Intended for use with storing values in a database. This is lighter to store than the JSON compatible {@link Two.Anchor#toObject}.
     */
    toString: function() {
      if (!this.controls) {
        return [this._x, this._y].join(', ');
      }
      return [this._x, this._y, this.controls.left.x, this.controls.left.y,
        this.controls.right.x, this.controls.right.y, this._command,
        this._relative ? 1 : 0].join(', ');
    }

  };

  Anchor.MakeObservable(Anchor.prototype);

  var count = 0;

  var Constants = {

    /**
     * @name Two.nextFrameID
     * @property {Number}
     * @description The id of the next requestAnimationFrame function.
     */
    nextFrameID: null,

    // Primitive

    /**
     * @name Two.Types
     * @property {Object} - The different rendering types available in the library.
     */
    Types: {
      webgl: 'WebGLRenderer',
      svg: 'SVGRenderer',
      canvas: 'CanvasRenderer'
    },

    /**
     * @name Two.Version
     * @property {String} - The current working version of the library.
     */
    Version: 'v0.7.8',

    /**
     * @name Two.PublishDate
     * @property {String} - The automatically generated publish date in the build process to verify version release candidates.
     */
    PublishDate: '2021-07-14T02:15:23.697Z',

    /**
     * @name Two.Identifier
     * @property {String} - String prefix for all Two.js object's ids. This trickles down to SVG ids.
     */
    Identifier: 'two-',

    /**
     * @name Two.Resolution
     * @property {Number} - Default amount of vertices to be used for interpreting Arcs and ArcSegments.
     */
    Resolution: 12,

    /**
     * @name Two.AutoCalculateImportedMatrices
     * @property {Boolean} - When importing SVGs through the {@link two#interpret} and {@link two#load}, this boolean determines whether Two.js infers and then overrides the exact transformation matrix of the reference SVG.
     * @nota-bene `false` copies the exact transformation matrix values, but also sets the path's `matrix.manual = true`.
     */
    AutoCalculateImportedMatrices: true,

    /**
     * @name Two.Instances
     * @property {Two[]} - Registered list of all Two.js instances in the current session.
     */
    Instances: [],

    /**
     * @function Two.uniqueId
     * @description Simple method to access an incrementing value. Used for `id` allocation on all Two.js objects.
     * @returns {Number} Ever increasing Number.
     */
    uniqueId: function() {
      return count++;
    }

  };

  var HALF_PI$3 = Math.PI / 2;

  /**
   * @name Two.Utils.Curve
   * @property {Object} - Additional utility constant variables related to curve math and calculations.
   */
  var Curve = {

    CollinearityEpsilon: Math.pow(10, -30),

    RecursionLimit: 16,

    CuspLimit: 0,

    Tolerance: {
      distance: 0.25,
      angle: 0,
      epsilon: Number.EPSILON
    },

    // Lookup tables for abscissas and weights with values for n = 2 .. 16.
    // As values are symmetric, only store half of them and adapt algorithm
    // to factor in symmetry.
    abscissas: [
      [  0.5773502691896257645091488],
      [0,0.7745966692414833770358531],
      [  0.3399810435848562648026658,0.8611363115940525752239465],
      [0,0.5384693101056830910363144,0.9061798459386639927976269],
      [  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
      [0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
      [  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
      [0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
      [  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
      [0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
      [  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
      [0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
      [  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
      [0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
      [  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
    ],

    weights: [
      [1],
      [0.8888888888888888888888889,0.5555555555555555555555556],
      [0.6521451548625461426269361,0.3478548451374538573730639],
      [0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
      [0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
      [0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
      [0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
      [0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
      [0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
      [0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
      [0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
      [0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
      [0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
      [0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
      [0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
    ]

  };

  /**
   * @name Two.Utils.getComponentOnCubicBezier
   * @function
   * @param {Number} t - Zero-to-one value describing what percentage to calculate.
   * @param {Number} a - The firt point's component value.
   * @param {Number} b - The first point's bezier component value.
   * @param {Number} c - The second point's bezier component value.
   * @param {Number} d - The second point's component value.
   * @returns {Number} The coordinate value for a specific component along a cubic bezier curve by `t`.
   */
  var getComponentOnCubicBezier = function(t, a, b, c, d) {
    var k = 1 - t;
    return (k * k * k * a) + (3 * k * k * t * b) + (3 * k * t * t * c) +
        (t * t * t * d);
  };

  /**
   * @name Two.Utils.subdivide
   * @function
   * @param {Number} x1 - x position of first anchor point.
   * @param {Number} y1 - y position of first anchor point.
   * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
   * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
   * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
   * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
   * @param {Number} x4 - x position of second anchor point.
   * @param {Number} y4 - y position of second anchor point.
   * @param {Number} [limit=Two.Utils.Curve.RecursionLimit] - The amount of vertices to create by subdividing.
   * @returns {Anchor[]} A list of anchor points ordered in between `x1`, `y1` and `x4`, `y4`
   * @description Given 2 points (a, b) and corresponding control point for each return an array of points that represent points plotted along the curve. The number of returned points is determined by `limit`.
   */
  var subdivide = function(x1, y1, x2, y2, x3, y3, x4, y4, limit) {

    limit = limit || Curve.RecursionLimit;
    var amount = limit + 1;

    // TODO: Abstract 0.001 to a limiting variable
    // Don't recurse if the end points are identical
    if (Math.abs(x1 - x4) < 0.001 && Math.abs(y1 - y4) < 0.001) {
      return [new Anchor(x4, y4)];
    }

    var result = [];

    for (var i = 0; i < amount; i++) {
      var t = i / amount;
      var x = getComponentOnCubicBezier(t, x1, x2, x3, x4);
      var y = getComponentOnCubicBezier(t, y1, y2, y3, y4);
      result.push(new Anchor(x, y));
    }

    return result;

  };

  /**
   * @name Two.Utils.getCurveLength
   * @function
   * @param {Number} x1 - x position of first anchor point.
   * @param {Number} y1 - y position of first anchor point.
   * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
   * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
   * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
   * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
   * @param {Number} x4 - x position of second anchor point.
   * @param {Number} y4 - y position of second anchor point.
   * @param {Number} [limit=Two.Utils.Curve.RecursionLimit] - The amount of vertices to create by subdividing.
   * @returns {Number} The length of a curve.
   * @description Given 2 points (a, b) and corresponding control point for each, return a float that represents the length of the curve using Gauss-Legendre algorithm. Limit iterations of calculation by `limit`.
   */
  var getCurveLength$1 = function(x1, y1, x2, y2, x3, y3, x4, y4, limit) {

    // TODO: Better / fuzzier equality check
    // Linear calculation
    if (x1 === x2 && y1 === y2 && x3 === x4 && y3 === y4) {
      var dx = x4 - x1;
      var dy = y4 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Calculate the coefficients of a Bezier derivative.
    var ax = 9 * (x2 - x3) + 3 * (x4 - x1),
      bx = 6 * (x1 + x3) - 12 * x2,
      cx = 3 * (x2 - x1),

      ay = 9 * (y2 - y3) + 3 * (y4 - y1),
      by = 6 * (y1 + y3) - 12 * y2,
      cy = 3 * (y2 - y1);

    var integrand = function(t) {
      // Calculate quadratic equations of derivatives for x and y
      var dx = (ax * t + bx) * t + cx,
        dy = (ay * t + by) * t + cy;
      return Math.sqrt(dx * dx + dy * dy);
    };

    return integrate(
      integrand, 0, 1, limit || Curve.RecursionLimit
    );

  };

  /**
   * @name Two.Utils.getCurveBoundingBox
   * @function
   * @param {Number} x1 - x position of first anchor point.
   * @param {Number} y1 - y position of first anchor point.
   * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
   * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
   * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
   * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
   * @param {Number} x4 - x position of second anchor point.
   * @param {Number} y4 - y position of second anchor point.
   * @returns {Object} Object contains min and max `x` / `y` bounds.
   * @see {@link https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js#L856}
   */
  var getCurveBoundingBox = function(x1, y1, x2, y2, x3, y3, x4, y4) {

    var tvalues = [];
    var bounds = [[], []];
    var a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    for (var i = 0; i < 2; ++i) {
        if (i == 0) {
          b = 6 * x1 - 12 * x2 + 6 * x3;
          a = -3 * x1 + 9 * x2 - 9 * x3 + 3 * x4;
          c = 3 * x2 - 3 * x1;
        } else {
          b = 6 * y1 - 12 * y2 + 6 * y3;
          a = -3 * y1 + 9 * y2 - 9 * y3 + 3 * y4;
          c = 3 * y2 - 3 * y1;
        }
        if (Math.abs(a) < 1e-12) {
          if (Math.abs(b) < 1e-12) {
            continue;
          }
          t = -c / b;
          if (0 < t && t < 1) {
            tvalues.push(t);
          }
          continue;
        }
        b2ac = b * b - 4 * c * a;
        sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) {
          continue;
        }
        t1 = (-b + sqrtb2ac) / (2 * a);
        if (0 < t1 && t1 < 1) {
          tvalues.push(t1);
        }
        t2 = (-b - sqrtb2ac) / (2 * a);
        if (0 < t2 && t2 < 1) {
          tvalues.push(t2);
        }
    }

    var j = tvalues.length;
    var jlen = j;
    var mt;

    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x1 + 3 * mt * mt * t * x2 + 3 * mt * t * t * x3 + t * t * t * x4;
      bounds[1][j] = mt * mt * mt * y1 + 3 * mt * mt * t * y2 + 3 * mt * t * t * y3 + t * t * t * y4;
    }

    bounds[0][jlen] = x1;
    bounds[1][jlen] = y1;
    bounds[0][jlen + 1] = x4;
    bounds[1][jlen + 1] = y4;
    bounds[0].length = bounds[1].length = jlen + 2;

    return {
      min: { x: Math.min.apply(0, bounds[0]), y: Math.min.apply(0, bounds[1]) },
      max: { x: Math.max.apply(0, bounds[0]), y: Math.max.apply(0, bounds[1]) }
    };

  };

  /**
   * @name Two.Utils.integrate
   * @function
   * @param {Function} f
   * @param {Number} a
   * @param {Number} b
   * @param {Number} n
   * @description Integration for `getCurveLength` calculations.
   * @see [Paper.js](@link https://github.com/paperjs/paper.js/blob/master/src/util/Numerical.js#L101)
   */
  var integrate = function(f, a, b, n) {
    var x = Curve.abscissas[n - 2],
      w = Curve.weights[n - 2],
      A = 0.5 * (b - a),
      B = A + a,
      i = 0,
      m = (n + 1) >> 1,
      sum = n & 1 ? w[i++] * f(B) : 0; // Handle odd n
    while (i < m) {
      var Ax = A * x[i];
      sum += w[i++] * (f(B + Ax) + f(B - Ax));
    }
    return A * sum;
  };

  /**
   * @name Two.Utils.getCurveFromPoints
   * @function
   * @param {Anchor[]} points
   * @param {Boolean} closed
   * @description Sets the bezier handles on {@link Anchor}s in the `points` list with estimated values to create a catmull-rom like curve. Used by {@link Two.Path#plot}.
   */
  var getCurveFromPoints = function(points, closed) {

    var l = points.length, last = l - 1;

    for (var i = 0; i < l; i++) {

      var point = points[i];

      if (!_.isObject(point.controls)) {
        Anchor.AppendCurveProperties(point);
      }

      var prev = closed ? mod(i - 1, l) : Math.max(i - 1, 0);
      var next = closed ? mod(i + 1, l) : Math.min(i + 1, last);

      var a = points[prev];
      var b = point;
      var c = points[next];
      getControlPoints(a, b, c);

      b.command = i === 0 ? Commands.move : Commands.curve;

    }

  };

  /**
   * @name Two.Utils.getControlPoints
   * @function
   * @param {Anchor} a
   * @param {Anchor} b
   * @param {Anchor} c
   * @returns {Anchor} Returns the passed middle point `b`.
   * @description Given three coordinates set the control points for the middle, b, vertex based on its position with the adjacent points.
   */
  var getControlPoints = function(a, b, c) {

    var a1 = Vector.angleBetween(a, b);
    var a2 = Vector.angleBetween(c, b);

    var d1 = Vector.distanceBetween(a, b);
    var d2 = Vector.distanceBetween(c, b);

    var mid = (a1 + a2) / 2;

    // TODO: Issue 73
    if (d1 < 0.0001 || d2 < 0.0001) {
      if (typeof b.relative === 'boolean' && !b.relative) {
        b.controls.left.copy(b);
        b.controls.right.copy(b);
      }
      return b;
    }

    d1 *= 0.33; // Why 0.33?
    d2 *= 0.33;

    if (a2 < a1) {
      mid += HALF_PI$3;
    } else {
      mid -= HALF_PI$3;
    }

    b.controls.left.x = Math.cos(mid) * d1;
    b.controls.left.y = Math.sin(mid) * d1;

    mid -= Math.PI;

    b.controls.right.x = Math.cos(mid) * d2;
    b.controls.right.y = Math.sin(mid) * d2;

    if (typeof b.relative === 'boolean' && !b.relative) {
      b.controls.left.x += b.x;
      b.controls.left.y += b.y;
      b.controls.right.x += b.x;
      b.controls.right.y += b.y;
    }

    return b;

  };

  /**
   * @name Two.Utils.getReflection
   * @function
   * @param {Vector} a
   * @param {Vector} b
   * @param {Boolean} [relative=false]
   * @returns {Vector} New {@link Vector} that represents the reflection point.
   * @description Get the reflection of a point `b` about point `a`. Where `a` is in absolute space and `b` is relative to `a`.
   * @see {@link http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes}
   */
  var getReflection = function(a, b, relative) {

    return new Vector(
      2 * a.x - (b.x + a.x) - (relative ? a.x : 0),
      2 * a.y - (b.y + a.y) - (relative ? a.y : 0)
    );

  };

  /**
   * @name Two.Utils.getAnchorsFromArcData
   * @function
   * @param {Vector} center
   * @param {Number} xAxisRotation
   * @param {Number} rx - x radius
   * @param {Number} ry - y radius
   * @param {Number} ts
   * @param {Number} td
   * @param {Boolean} [ccw=false] - Set path traversal to counter-clockwise
   */
  var getAnchorsFromArcData = function(center, xAxisRotation, rx, ry, ts, td, ccw) {

    var resolution = Constants.Resolution;

    for (var i = 0; i < resolution; i++) {
      var pct = (i + 1) / resolution;
      if (ccw) {
        pct = 1 - pct;
      }

      var theta = pct * td + ts;
      var x = rx * Math.cos(theta);
      var y = ry * Math.sin(theta);

      // x += center.x;
      // y += center.y;

      var anchor = new Anchor(x, y);
      Anchor.AppendCurveProperties(anchor);
      anchor.command = Commands.line;
    }

  };

  var Curves = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Curve: Curve,
    getComponentOnCubicBezier: getComponentOnCubicBezier,
    subdivide: subdivide,
    getCurveLength: getCurveLength$1,
    getCurveBoundingBox: getCurveBoundingBox,
    integrate: integrate,
    getCurveFromPoints: getCurveFromPoints,
    getControlPoints: getControlPoints,
    getReflection: getReflection,
    getAnchorsFromArcData: getAnchorsFromArcData
  });

  var devicePixelRatio = root$1.devicePixelRatio || 1;

  var getBackingStoreRatio = function(ctx) {
    return ctx.webkitBackingStorePixelRatio ||
    ctx.mozBackingStorePixelRatio ||
    ctx.msBackingStorePixelRatio ||
    ctx.oBackingStorePixelRatio ||
    ctx.backingStorePixelRatio || 1;
  };

  /**
   * @name Two.Utils.getRatio
   * @function
   * @param {CanvasRenderingContext2D} ctx
   * @returns {Number} The ratio of a unit in Two.js to the pixel density of a session's screen.
   * @see [High DPI Rendering](http://www.html5rocks.com/en/tutorials/canvas/hidpi/)
   */
  var getRatio = function(ctx) {
    return devicePixelRatio / getBackingStoreRatio(ctx);
  };

  // Constants

  var cos$5 = Math.cos, sin$5 = Math.sin, tan = Math.tan;
  var array = [];

  /**
   * @name Two.Matrix
   * @class
   * @param {Number} [a=1] - The value for element at the first column and first row.
   * @param {Number} [b=0] - The value for element at the second column and first row.
   * @param {Number} [c=0] - The value for element at the third column and first row.
   * @param {Number} [d=0] - The value for element at the first column and second row.
   * @param {Number} [e=1] - The value for element at the second column and second row.
   * @param {Number} [f=0] - The value for element at the third column and second row.
   * @param {Number} [g=0] - The value for element at the first column and third row.
   * @param {Number} [h=0] - The value for element at the second column and third row.
   * @param {Number} [i=1] - The value for element at the third column and third row.
   * @description A class to store 3 x 3 transformation matrix information. In addition to storing data `Two.Matrix` has suped up methods for commonplace mathematical operations.
   * @nota-bene Order is based on how to construct transformation strings for the browser.
   */
  function Matrix(a, b, c, d, e, f) {

    /**
     * @name Two.Matrix#elements
     * @property {Number[]} - The underlying data stored as an array.
     */
    this.elements = new NumArray(9);

    var elements = a;
    if (!Array.isArray(elements)) {
      elements = Array.prototype.slice.call(arguments);
    }

    // initialize the elements with default values.
    this.identity();

    if (elements.length > 0) {
      this.set(elements);
    }

  }

  setMatrix(Matrix);

  _.extend(Matrix, {

    /**
     * @name Two.Matrix.Identity
     * @property {Number[]} - A stored reference to the default value of a 3 x 3 matrix.
     */
    Identity: [
      1, 0, 0,
      0, 1, 0,
      0, 0, 1
    ],

    /**
     * @name Two.Matrix.Multiply
     * @function
     * @param {Two.Matrix} A
     * @param {Two.Matrix} B
     * @param {Two.Matrix} [C] - An optional matrix to apply the multiplication to.
     * @returns {Two.Matrix} - If an optional `C` matrix isn't passed then a new one is created and returned.
     * @description Multiply two matrices together and return the result.
     */
    Multiply: function(A, B, C) {

      if (B.length <= 3) { // Multiply Vector

        var x, y, z, e = A;

        var a = B[0] || 0,
            b = B[1] || 0,
            c = B[2] || 0;

        // Go down rows first
        // a, d, g, b, e, h, c, f, i

        x = e[0] * a + e[1] * b + e[2] * c;
        y = e[3] * a + e[4] * b + e[5] * c;
        z = e[6] * a + e[7] * b + e[8] * c;

        return { x: x, y: y, z: z };

      }

      var A0 = A[0], A1 = A[1], A2 = A[2];
      var A3 = A[3], A4 = A[4], A5 = A[5];
      var A6 = A[6], A7 = A[7], A8 = A[8];

      var B0 = B[0], B1 = B[1], B2 = B[2];
      var B3 = B[3], B4 = B[4], B5 = B[5];
      var B6 = B[6], B7 = B[7], B8 = B[8];

      C = C || new NumArray(9);

      C[0] = A0 * B0 + A1 * B3 + A2 * B6;
      C[1] = A0 * B1 + A1 * B4 + A2 * B7;
      C[2] = A0 * B2 + A1 * B5 + A2 * B8;
      C[3] = A3 * B0 + A4 * B3 + A5 * B6;
      C[4] = A3 * B1 + A4 * B4 + A5 * B7;
      C[5] = A3 * B2 + A4 * B5 + A5 * B8;
      C[6] = A6 * B0 + A7 * B3 + A8 * B6;
      C[7] = A6 * B1 + A7 * B4 + A8 * B7;
      C[8] = A6 * B2 + A7 * B5 + A8 * B8;

      return C;

    }

  });

  _.extend(Matrix.prototype, Events, {

    constructor: Matrix,

    /**
     * @name Two.Matrix#manual
     * @property {Boolean} - Determines whether Two.js automatically calculates the values for the matrix or if the developer intends to manage the matrix.
     * @nota-bene - Setting to `true` nullifies {@link Two.Shape#translation}, {@link Two.Shape#rotation}, and {@link Two.Shape#scale}.
     */
    manual: false,

    /**
     * @name Two.Matrix#set
     * @function
     * @param {Number} a - The value for element at the first column and first row.
     * @param {Number} b - The value for element at the second column and first row.
     * @param {Number} c - The value for element at the third column and first row.
     * @param {Number} d - The value for element at the first column and second row.
     * @param {Number} e - The value for element at the second column and second row.
     * @param {Number} f - The value for element at the third column and second row.
     * @param {Number} g - The value for element at the first column and third row.
     * @param {Number} h - The value for element at the second column and third row.
     * @param {Number} i - The value for element at the third column and third row.
     * @description Set an array of values onto the matrix. Order described in {@link Two.Matrix}.
     */

      /**
      * @name Two.Matrix#set
      * @function
      * @param {Number[]} a - The array of elements to apply.
      * @description Set an array of values onto the matrix. Order described in {@link Two.Matrix}.
      */
    set: function(a, b, c, d, e, f, g, h, i) {

      var elements;

      if (typeof b === 'undefined') {
        elements = a;
        a = elements[0];
        b = elements[1];
        c = elements[2];
        d = elements[3];
        e = elements[4];
        f = elements[5];
        g = elements[6];
        h = elements[7];
        i = elements[8];
      }

      this.elements[0] = a;
      this.elements[1] = b;
      this.elements[2] = c;
      this.elements[3] = d;
      this.elements[4] = e;
      this.elements[5] = f;
      this.elements[6] = g;
      this.elements[7] = h;
      this.elements[8] = i;

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#copy
     * @function
     * @description Copy the matrix of one to the current instance.
     */
    copy: function(m) {

      this.elements[0] = m.elements[0];
      this.elements[1] = m.elements[1];
      this.elements[2] = m.elements[2];
      this.elements[3] = m.elements[3];
      this.elements[4] = m.elements[4];
      this.elements[5] = m.elements[5];
      this.elements[6] = m.elements[6];
      this.elements[7] = m.elements[7];
      this.elements[8] = m.elements[8];

      this.manual = m.manual;

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#identity
     * @function
     * @description Turn matrix to the identity, like resetting.
     */
    identity: function() {

      this.elements[0] = Matrix.Identity[0];
      this.elements[1] = Matrix.Identity[1];
      this.elements[2] = Matrix.Identity[2];
      this.elements[3] = Matrix.Identity[3];
      this.elements[4] = Matrix.Identity[4];
      this.elements[5] = Matrix.Identity[5];
      this.elements[6] = Matrix.Identity[6];
      this.elements[7] = Matrix.Identity[7];
      this.elements[8] = Matrix.Identity[8];

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#multiply
     * @function
     * @param {Number} a - The scalar to be multiplied.
     * @description Multiply all components of the matrix against a single scalar value.
     * @overloaded
     */

    /**
     * @name Two.Matrix#multiply
     * @function
     * @param {Number} a - The x component to be multiplied.
     * @param {Number} b - The y component to be multiplied.
     * @param {Number} c - The z component to be multiplied.
     * @description Multiply all components of a matrix against a 3 component vector.
     * @overloaded
     */

    /**
     * @name Two.Matrix#multiply
     * @function
     * @param {Number} a - The value at the first column and first row of the matrix to be multiplied.
     * @param {Number} b - The value at the second column and first row of the matrix to be multiplied.
     * @param {Number} c - The value at the third column and first row of the matrix to be multiplied.
     * @param {Number} d - The value at the first column and second row of the matrix to be multiplied.
     * @param {Number} e - The value at the second column and second row of the matrix to be multiplied.
     * @param {Number} f - The value at the third column and second row of the matrix to be multiplied.
     * @param {Number} g - The value at the first column and third row of the matrix to be multiplied.
     * @param {Number} h - The value at the second column and third row of the matrix to be multiplied.
     * @param {Number} i - The value at the third column and third row of the matrix to be multiplied.
     * @description Multiply all components of a matrix against another matrix.
     * @overloaded
     */
    multiply: function(a, b, c, d, e, f, g, h, i) {

      // Multiply scalar

      if (typeof b === 'undefined') {

        this.elements[0] *= a;
        this.elements[1] *= a;
        this.elements[2] *= a;
        this.elements[3] *= a;
        this.elements[4] *= a;
        this.elements[5] *= a;
        this.elements[6] *= a;
        this.elements[7] *= a;
        this.elements[8] *= a;

        return this.trigger(Events.Types.change);

      }

      if (typeof d === 'undefined') { // Multiply Vector

        var x, y, z;
        a = a || 0;
        b = b || 0;
        c = c || 0;
        e = this.elements;

        // Go down rows first
        // a, d, g, b, e, h, c, f, i

        x = e[0] * a + e[1] * b + e[2] * c;
        y = e[3] * a + e[4] * b + e[5] * c;
        z = e[6] * a + e[7] * b + e[8] * c;

        return { x: x, y: y, z: z };

      }

      // Multiple matrix

      var A = this.elements;
      var B = [a, b, c, d, e, f, g, h, i];

      var A0 = A[0], A1 = A[1], A2 = A[2];
      var A3 = A[3], A4 = A[4], A5 = A[5];
      var A6 = A[6], A7 = A[7], A8 = A[8];

      var B0 = B[0], B1 = B[1], B2 = B[2];
      var B3 = B[3], B4 = B[4], B5 = B[5];
      var B6 = B[6], B7 = B[7], B8 = B[8];

      this.elements[0] = A0 * B0 + A1 * B3 + A2 * B6;
      this.elements[1] = A0 * B1 + A1 * B4 + A2 * B7;
      this.elements[2] = A0 * B2 + A1 * B5 + A2 * B8;

      this.elements[3] = A3 * B0 + A4 * B3 + A5 * B6;
      this.elements[4] = A3 * B1 + A4 * B4 + A5 * B7;
      this.elements[5] = A3 * B2 + A4 * B5 + A5 * B8;

      this.elements[6] = A6 * B0 + A7 * B3 + A8 * B6;
      this.elements[7] = A6 * B1 + A7 * B4 + A8 * B7;
      this.elements[8] = A6 * B2 + A7 * B5 + A8 * B8;

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#inverse
     * @function
     * @param {Two.Matrix} [out] - The optional matrix to apply the inversion to.
     * @description Return an inverted version of the matrix. If no optional one is passed a new matrix is created and returned.
     */
    inverse: function(out) {

      var a = this.elements;
      out = out || new Matrix();

      var a00 = a[0], a01 = a[1], a02 = a[2];
      var a10 = a[3], a11 = a[4], a12 = a[5];
      var a20 = a[6], a21 = a[7], a22 = a[8];

      var b01 = a22 * a11 - a12 * a21;
      var b11 = -a22 * a10 + a12 * a20;
      var b21 = a21 * a10 - a11 * a20;

      // Calculate the determinant
      var det = a00 * b01 + a01 * b11 + a02 * b21;

      if (!det) {
        return null;
      }

      det = 1.0 / det;

      out.elements[0] = b01 * det;
      out.elements[1] = (-a22 * a01 + a02 * a21) * det;
      out.elements[2] = (a12 * a01 - a02 * a11) * det;
      out.elements[3] = b11 * det;
      out.elements[4] = (a22 * a00 - a02 * a20) * det;
      out.elements[5] = (-a12 * a00 + a02 * a10) * det;
      out.elements[6] = b21 * det;
      out.elements[7] = (-a21 * a00 + a01 * a20) * det;
      out.elements[8] = (a11 * a00 - a01 * a10) * det;

      return out;

    },

    /**
     * @name Two.Matrix#scale
     * @function
     * @param {Number} scale - The one dimensional scale to apply to the matrix.
     * @description Uniformly scale the transformation matrix.
     */

    /**
     * @name Two.Matrix#scale
     * @function
     * @param {Number} sx - The horizontal scale factor.
     * @param {Number} sy - The vertical scale factor
     * @description Scale the transformation matrix in two dimensions.
     */
    scale: function(sx, sy) {

      var l = arguments.length;
      if (l <= 1) {
        sy = sx;
      }

      return this.multiply(sx, 0, 0, 0, sy, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#rotate
     * @function
     * @param {Number} Number - The amount to rotate in Number.
     * @description Rotate the matrix.
     */
    rotate: function(Number) {

      var c = cos$5(Number);
      var s = sin$5(Number);

      return this.multiply(c, -s, 0, s, c, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#translate
     * @function
     * @param {Number} x - The horizontal translation value to apply.
     * @param {Number} y - The vertical translation value to apply.
     * @description Translate the matrix.
     */
    translate: function(x, y) {

      return this.multiply(1, 0, x, 0, 1, y, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#skewX
     * @function
     * @param {Number} Number - The amount to skew in Number.
     * @description Skew the matrix by an angle in the x axis direction.
     */
    skewX: function(Number) {

      var a = tan(Number);

      return this.multiply(1, a, 0, 0, 1, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#skewY
     * @function
     * @param {Number} Number - The amount to skew in Number.
     * @description Skew the matrix by an angle in the y axis direction.
     */
    skewY: function(Number) {

      var a = tan(Number);

      return this.multiply(1, 0, 0, a, 1, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#toString
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 for 2D transformations.
     * @returns {String} - The transformation matrix as a 6 component string separated by spaces.
     * @description Create a transform string. Used for the Two.js rendering APIs.
     */
    toString: function(fullMatrix) {

      array.length = 0;
      this.toTransformArray(fullMatrix, array);

      return array.map(toFixed).join(' ');

    },

    /**
     * @name Two.Matrix#toTransformArray
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 in the format for 2D transformations.
     * @param {Number[]} [output] - An array empty or otherwise to apply the values to.
     * @description Create a transform array. Used for the Two.js rendering APIs.
     */
    toTransformArray: function(fullMatrix, output) {

      var elements = this.elements;
      var hasOutput = !!output;

      var a = elements[0];
      var b = elements[1];
      var c = elements[2];
      var d = elements[3];
      var e = elements[4];
      var f = elements[5];

      if (fullMatrix) {

        var g = elements[6];
        var h = elements[7];
        var i = elements[8];

        if (hasOutput) {
          output[0] = a;
          output[1] = d;
          output[2] = g;
          output[3] = b;
          output[4] = e;
          output[5] = h;
          output[6] = c;
          output[7] = f;
          output[8] = i;
          return;
        }

        return [
          a, d, g, b, e, h, c, f, i
        ];
      }

      if (hasOutput) {
        output[0] = a;
        output[1] = d;
        output[2] = b;
        output[3] = e;
        output[4] = c;
        output[5] = f;
        return;
      }

      return [
        a, d, b, e, c, f  // Specific format see LN:19
      ];

    },

    /**
     * @name Two.Matrix#toArray
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 for 2D transformations.
     * @param {Number[]} [output] - An array empty or otherwise to apply the values to.
     * @description Create a transform array. Used for the Two.js rendering APIs.
     */
    toArray: function(fullMatrix, output) {

      var elements = this.elements;
      var hasOutput = !!output;

      var a = elements[0];
      var b = elements[1];
      var c = elements[2];
      var d = elements[3];
      var e = elements[4];
      var f = elements[5];

      if (fullMatrix) {

        var g = elements[6];
        var h = elements[7];
        var i = elements[8];

        if (hasOutput) {
          output[0] = a;
          output[1] = b;
          output[2] = c;
          output[3] = d;
          output[4] = e;
          output[5] = f;
          output[6] = g;
          output[7] = h;
          output[8] = i;
          return;
        }

        return [
          a, b, c, d, e, f, g, h, i
        ];
      }

      if (hasOutput) {
        output[0] = a;
        output[1] = b;
        output[2] = c;
        output[3] = d;
        output[4] = e;
        output[5] = f;
        return;
      }

      return [
        a, b, c, d, e, f
      ];

    },

    /**
     * @name Two.Matrix#toObject
     * @function
     * @description Create a JSON compatible object that represents information of the matrix.
     */
    toObject: function() {
      return {
        elements: this.toArray(true),
        manual: !!this.manual
      };
    },

    /**
     * @name Two.Matrix#clone
     * @function
     * @description Clone the current matrix.
     */
    clone: function() {

      return new Matrix().copy(this);

    }

  });

  /**
   * @name Two.Shape
   * @class
   * @extends Two.Events
   * @description The foundational transformation object for the Two.js scenegraph.
   */
  function Shape() {

    /**
     * @name Two.Shape#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.flagMatrix = Shape.FlagMatrix.bind(this);
    this.isShape = true;

    /**
     * @name Two.Shape#id
     * @property {String} - Session specific unique identifier.
     * @nota-bene In the {@link Two.SvgRenderer} change this to change the underlying SVG element's id too.
     */
    this.id = Constants.Identifier + Constants.uniqueId();

    /**
     * @name Two.Shape#classList
     * @property {String[]}
     * @description A list of class strings stored if imported / interpreted  from an SVG element.
     */
    this.classList = [];

    /**
     * @name Two.Shape#matrix
     * @property {Two.Matrix}
     * @description The transformation matrix of the shape.
     * @nota-bene {@link Two.Shape#translation}, {@link Two.Shape#rotation}, {@link Two.Shape#scale}, {@link Two.Shape#skewX}, and {@link Two.Shape#skewY} apply their values to the matrix when changed. The matrix is what is sent to the renderer to be drawn.
     */
    this.matrix = new Matrix();

    /**
     * @name Two.Shape#translation
     * @property {Two.Vector} - The x and y value for where the shape is placed relative to its parent.
     */
    this.translation = new Vector();

    /**
     * @name Two.Shape#rotation
     * @property {Number} - The value in Number for how much the shape is rotated relative to its parent.
     */
    this.rotation = 0;

    /**
     * @name Two.Shape#scale
     * @property {Number} - The value for how much the shape is scaled relative to its parent.
     * @nota-bene This value can be replaced with a {@link Two.Vector} to do non-uniform scaling. e.g: `shape.scale = new Two.Vector(2, 1);`
     */
    this.scale = 1;

    /**
     * @name Two.Shape#skewX
     * @property {Number} - The value in Number for how much the shape is skewed relative to its parent.
     * @description Skew the shape by an angle in the x axis direction.
     */
    this.skewX = 0;

    /**
     * @name Two.Shape#skewY
     * @property {Number} - The value in Number for how much the shape is skewed relative to its parent.
     * @description Skew the shape by an angle in the y axis direction.
     */
    this.skewY = 0;

  }

  _.extend(Shape, {

    /**
     * @name Two.Shape.FlagMatrix
     * @function
     * @description Utility function used in conjunction with event handlers to update the flagMatrix of a shape.
     */
    FlagMatrix: function() {
      this._flagMatrix = true;
    },

    /**
     * @name Two.Shape.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Shape} to any object. Handy if you'd like to extend the {@link Two.Shape} class on a custom class.
     */
    MakeObservable: function(object) {

      var translation = {
        enumerable: false,
        get: function() {
          return this._translation;
        },
        set: function(v) {
          if (this._translation) {
            this._translation.unbind(Events.Types.change, this._renderer.flagMatrix);
          }
          this._translation = v;
          this._translation.bind(Events.Types.change, this._renderer.flagMatrix);
          Shape.FlagMatrix.call(this);
        }
      };

      Object.defineProperty(object, 'translation', translation);
      Object.defineProperty(object, 'position', translation);

      Object.defineProperty(object, 'rotation', {
        enumerable: true,
        get: function() {
          return this._rotation;
        },
        set: function(v) {
          this._rotation = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'scale', {
        enumerable: true,
        get: function() {
          return this._scale;
        },
        set: function(v) {

          if (this._scale instanceof Vector) {
            this._scale.unbind(Events.Types.change, this._renderer.flagMatrix);
          }

          this._scale = v;

          if (this._scale instanceof Vector) {
            this._scale.bind(Events.Types.change, this._renderer.flagMatrix);
          }

          this._flagMatrix = true;
          this._flagScale = true;

        }
      });

      Object.defineProperty(object, 'skewX', {
        enumerable: true,
        get: function() {
          return this._skewX;
        },
        set: function(v) {
          this._skewX = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'skewY', {
        enumerable: true,
        get: function() {
          return this._skewY;
        },
        set: function(v) {
          this._skewY = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'matrix', {
        enumerable: true,
        get: function() {
          return this._matrix;
        },
        set: function(v) {
          this._matrix = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'id', {
        enumerable: true,
        get: function() {
          return this._id;
        },
        set: function(v) {
          var id = this._id;
          if (v === this._id) {
            return;
          }
          this._id = v;
          this._flagId = true;
          if (this.parent) {
            delete this.parent.children.ids[id];
            this.parent.children.ids[this._id] = this;
          }
        }
      });

      Object.defineProperty(object, 'className', {

        enumerable: true,

        get: function() {
          return this._className;
        },

        set: function(v) {

          this._flagClassName = this._className !== v;

          if (this._flagClassName) {

            var prev = this._className.split(/\s+?/);
            var dest = v.split(/\s+?/);

            for (var i = 0; i < prev.length; i++) {
              var className = prev[i];
              var index = Array.prototype.indexOf.call(this.classList, className);
              if (index >= 0) {
                this.classList.splice(index, 1);
              }
            }

            this.classList = this.classList.concat(dest);

          }

          this._className = v;

        }

      });

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

    }

  });

  _.extend(Shape.prototype, Events, {

    constructor: Shape,

    // Flags

    /**
     * @name Two.Shape#_id
     * @private
     * @property {Boolean} - Determines whether the id needs updating.
     */
    _flagId: true,

    /**
     * @name Two.Shape#_flagMatrix
     * @private
     * @property {Boolean} - Determines whether the matrix needs updating.
     */
    _flagMatrix: true,

    /**
     * @name Two.Shape#_flagScale
     * @private
     * @property {Boolean} - Determines whether the scale needs updating.
     */
    _flagScale: false,

    // _flagMask: false,
    // _flagClip: false,

    /**
     * @name Two.Shape#_flagClassName
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#className} need updating.
     */
    _flagClassName: false,

    // Underlying Properties

    _id: '',

    /**
     * @name Two.Shape#_translation
     * @private
     * @property {Two.Vector} - The translation values as a {@link Two.Vector}.
     */
    _translation: null,

    /**
     * @name Two.Shape#_rotation
     * @private
     * @property {Number} - The rotation value in Number.
     */
    _rotation: 0,

    /**
     * @name Two.Shape#_translation
     * @private
     * @property {Two.Vector} - The translation values as a {@link Two.Vector}.
     */
    _scale: 1,

    /**
     * @name Two.Shape#_skewX
     * @private
     * @property {Number} - The rotation value in Number.
     */
    _skewX: 0,

    /**
     * @name Two.Shape#_skewY
     * @private
     * @property {Number} - The rotation value in Number.
     */
    _skewY: 0,

    /**
     * @name Two.Shape#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling.
     * @nota-bene Only available for the SVG renderer.
     */
    _className: '',

    /**
     * @name Two.Shape#addTo
     * @function
     * @param {Two.Group} group - The parent the shape adds itself to.
     * @description Convenience method to add itself to the scenegraph.
     */
    addTo: function(group) {
      group.add(this);
      return this;
    },

    /**
     * @name Two.Shape#clone
     * @function
     * @param {Two.Group} [parent] - Optional argument to automatically add the shape to a scenegraph.
     * @returns {Two.Shape}
     * @description Create a new {@link Two.Shape} with the same values as the current shape.
     */
    clone: function(parent) {

      var clone = new Shape();

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Shape#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function(bubbles) {

      if (!this._matrix.manual && this._flagMatrix) {

        this._matrix
          .identity()
          .translate(this.translation.x, this.translation.y);

          if (this._scale instanceof Vector) {
            this._matrix.scale(this._scale.x, this._scale.y);
          } else {
            this._matrix.scale(this._scale);
          }

          this._matrix.rotate(this.rotation);
          this._matrix.skewX(this.skewX);
          this._matrix.skewY(this.skewY);
      }

      if (bubbles) {
        if (this.parent && this.parent._update) {
          this.parent._update();
        }
      }

      return this;

    },

    /**
     * @name Two.Shape#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagId = this._flagMatrix = this._flagScale =
        this._flagClassName = false;

      return this;

    }

  });

  Shape.MakeObservable(Shape.prototype);

  /**
   * @name Two.Collection
   * @class
   * @extends Two.Events
   * @description An `Array` like object with additional event propagation on actions. `pop`, `shift`, and `splice` trigger `removed` events. `push`, `unshift`, and `splice` with more than 2 arguments trigger 'inserted'. Finally, `sort` and `reverse` trigger `order` events.
   */
  function Collection() {

    Array.call(this);

    if (arguments[0] && Array.isArray(arguments[0])) {
      if (arguments[0].length > 0) {
        Array.prototype.push.apply(this, arguments[0]);
      }
    } else if (arguments.length > 0) {
      Array.prototype.push.apply(this, arguments);
    }

  }

  Collection.prototype = new Array();

  _.extend(Collection.prototype, Events, {

    constructor: Collection,

    pop: function() {
      var popped = Array.prototype.pop.apply(this, arguments);
      this.trigger(Events.Types.remove, [popped]);
      return popped;
    },

    shift: function() {
      var shifted = Array.prototype.shift.apply(this, arguments);
      this.trigger(Events.Types.remove, [shifted]);
      return shifted;
    },

    push: function() {
      var pushed = Array.prototype.push.apply(this, arguments);
      this.trigger(Events.Types.insert, arguments);
      return pushed;
    },

    unshift: function() {
      var unshifted = Array.prototype.unshift.apply(this, arguments);
      this.trigger(Events.Types.insert, arguments);
      return unshifted;
    },

    splice: function() {
      var spliced = Array.prototype.splice.apply(this, arguments);
      var inserted;

      this.trigger(Events.Types.remove, spliced);

      if (arguments.length > 2) {
        inserted = this.slice(arguments[0], arguments[0] + arguments.length - 2);
        this.trigger(Events.Types.insert, inserted);
        this.trigger(Events.Types.order);
      }
      return spliced;
    },

    sort: function() {
      Array.prototype.sort.apply(this, arguments);
      this.trigger(Events.Types.order);
      return this;
    },

    reverse: function() {
      Array.prototype.reverse.apply(this, arguments);
      this.trigger(Events.Types.order);
      return this;
    },

    indexOf: function() {
      return Array.prototype.indexOf.apply(this, arguments);
    }

  });

  /**
   * @class
   * @name Two.Group.Children
   * @extends Two.Collection
   * @description A children collection which is accesible both by index and by object `id`.
   */
  function Children(children) {

    Collection.apply(this, arguments);

    Object.defineProperty(this, '_events', {
      value : {},
      enumerable: false
    });

    /**
     * @name Two.Group.Children#ids
     * @property {Object} - Map of all elements in the list keyed by `id`s.
     */
    this.ids = {};

    this.attach(
      Array.isArray(children) ? children : Array.prototype.slice.call(arguments)
    );

    this.on(Events.Types.insert, this.attach);
    this.on(Events.Types.remove, this.detach);

  }

  Children.prototype = new Collection();

  _.extend(Children.prototype, {

    constructor: Children,

    /**
     * @function
     * @name Two.Group.Children#attach
     * @param {Two.Shape[]} children - The objects which extend {@link Two.Shape} to be added.
     * @description Adds elements to the `ids` map.
     */
    attach: function(children) {
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child && child.id) {
          this.ids[child.id] = child;
        }
      }
      return this;
    },

    /**
     * @function
     * @name Two.Group.Children#detach
     * @param {Two.Shape[]} children - The objects which extend {@link Two.Shape} to be removed.
     * @description Removes elements to the `ids` map.
     */
    detach: function(children) {
      for (var i = 0; i < children.length; i++) {
        delete this.ids[children[i].id];
      }
      return this;
    }

  });

  // Constants

  var min$3 = Math.min, max$3 = Math.max;

  /**
   * @name Two.Group
   * @class
   * @extends Two.Shape
   * @param {Two.Shape[]} [children] - A list of objects that inherit {@link Two.Shape}. For instance, the array could be a {@link Two.Path}, {@link Two.Text}, and {@link Two.RoundedRectangle}.
   * @description This is the primary class for grouping objects that are then drawn in Two.js. In Illustrator this is a group, in After Effects it would be a Null Object. Whichever the case, the `Two.Group` contains a transformation matrix and commands to style its children, but it by itself doesn't render to the screen.
   * @nota-bene The {@link Two#scene} is an instance of `Two.Group`.
   */
  function Group(children) {

    Shape.call(this, true);

    this._renderer.type = 'group';

    /**
     * @name Two.Group#additions
     * @property {Two.Shape[]}
     * @description An automatically updated list of children that need to be appended to the renderer's scenegraph.
     */
    this.additions = [];

    /**
     * @name Two.Group#subtractions
     * @property {Two.Shape[]}
     * @description An automatically updated list of children that need to be removed from the renderer's scenegraph.
     */
    this.subtractions = [];

    /**
     * @name Two.Group#children
     * @property {Two.Group.Children}
     * @description A list of all the children in the scenegraph.
     * @nota-bene Ther order of this list indicates the order each element is rendered to the screen.
     */
    this.children = Array.isArray(children) ? children : Array.prototype.slice.call(arguments);

  }

  _.extend(Group, {

    Children: Children,

    /**
     * @name Two.Group.InsertChildren
     * @function
     * @param {Two.Shape[]} children - The objects to be inserted.
     * @description Cached method to let renderers know children have been added to a {@link Two.Group}.
     */
    InsertChildren: function(children) {
      for (var i = 0; i < children.length; i++) {
        replaceParent.call(this, children[i], this);
      }
    },

    /**
     * @name Two.Group.RemoveChildren
     * @function
     * @param {Two.Shape[]} children - The objects to be removed.
     * @description Cached method to let renderers know children have been removed from a {@link Two.Group}.
     */
    RemoveChildren: function(children) {
      for (var i = 0; i < children.length; i++) {
        replaceParent.call(this, children[i]);
      }
    },

    /**
     * @name Two.Group.OrderChildren
     * @function
     * @description Cached method to let renderers know order has been updated on a {@link Two.Group}.
     */
    OrderChildren: function(children) {
      this._flagOrder = true;
    },

    /**
     * @name Two.Group.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Group}.
     */
    Properties: [
      'fill',
      'stroke',
      'linewidth',
      'cap',
      'join',
      'miter',

      'closed',
      'curved',
      'automatic'
    ],

    /**
     * @name Two.Group.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Group} to any object. Handy if you'd like to extend the {@link Two.Group} class on a custom class.
     */
    MakeObservable: function(object) {

      var properties = Group.Properties;

      Object.defineProperty(object, 'visible', {

        enumerable: true,

        get: function() {
          return this._visible;
        },

        set: function(v) {
          this._flagVisible = this._visible !== v || this._flagVisible;
          this._visible = v;
        }

      });

      Object.defineProperty(object, 'opacity', {

        enumerable: true,

        get: function() {
          return this._opacity;
        },

        set: function(v) {
          this._flagOpacity = this._opacity !== v || this._flagOpacity;
          this._opacity = v;
        }

      });

      Object.defineProperty(object, 'beginning', {

        enumerable: true,

        get: function() {
          return this._beginning;
        },

        set: function(v) {
          this._flagBeginning = this._beginning !== v || this._flagBeginning;
          this._beginning = v;
        }

      });

      Object.defineProperty(object, 'ending', {

        enumerable: true,

        get: function() {
          return this._ending;
        },

        set: function(v) {
          this._flagEnding = this._ending !== v || this._flagEnding;
          this._ending = v;
        }

      });

      Object.defineProperty(object, 'length', {

        enumerable: true,

        get: function() {
          if (this._flagLength || this._length <= 0) {
            this._length = 0;
            if (!this.children) {
              return this._length;
            }
            for (var i = 0; i < this.children.length; i++) {
              var child = this.children[i];
              this._length += child.length;
            }
          }
          return this._length;
        }

      });

      Shape.MakeObservable(object);
      Group.MakeGetterSetters(object, properties);

      Object.defineProperty(object, 'children', {

        enumerable: true,

        get: function() {
          return this._children;
        },

        set: function(children) {

          var insertChildren = Group.InsertChildren.bind(this);
          var removeChildren = Group.RemoveChildren.bind(this);
          var orderChildren = Group.OrderChildren.bind(this);

          if (this._children) {
            this._children.unbind();
            if (this._children.length > 0) {
              removeChildren(this._children);
            }
          }

          this._children = new Children(children);
          this._children.bind(Events.Types.insert, insertChildren);
          this._children.bind(Events.Types.remove, removeChildren);
          this._children.bind(Events.Types.order, orderChildren);

          if (children.length > 0) {
            insertChildren(children);
          }

        }

      });

      Object.defineProperty(object, 'mask', {

        enumerable: true,

        get: function() {
          return this._mask;
        },

        set: function(v) {
          this._mask = v;
          this._flagMask = true;
          if (!v.clip) {
            v.clip = true;
          }
        }

      });

    },

    /**
     * @name Two.Group.MakeGetterSetters
     * @function
     * @param {Two.Group} group - The group to apply getters and setters.
     * @param {Object} properties - A key / value object containing properties to inherit.
     * @description Convenience method to apply getter / setter logic on an array of properties. Used in {@link Two.Group.MakeObservable}.
     */
    MakeGetterSetters: function(group, properties) {

      if (!Array.isArray(properties)) {
        properties = [properties];
      }

      _.each(properties, function(k) {
        Group.MakeGetterSetter(group, k);
      });

    },

    /**
     * @name Two.Group.MakeGetterSetter
     * @function
     * @param {Two.Group} group - The group to apply getters and setters.
     * @param {String} key - The key which will become a property on the group.
     * @description Convenience method to apply getter / setter logic specific to how `Two.Group`s trickle down styles to their children. Used in {@link Two.Group.MakeObservable}.
     */
    MakeGetterSetter: function(group, key) {

      var secret = '_' + key;

      Object.defineProperty(group, key, {

        enumerable: true,

        get: function() {
          return this[secret];
        },

        set: function(v) {
          this[secret] = v;
          // Trickle down styles
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            child[key] = v;
          }
        }

      });

    }

  });

  _.extend(Group.prototype, Shape.prototype, {

    constructor: Group,

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Group#_flagAdditions
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#additions} needs updating.
     */
    _flagAdditions: false,

    /**
     * @name Two.Group#_flagSubtractions
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#subtractions} needs updating.
     */
    _flagSubtractions: false,

    /**
     * @name Two.Group#_flagOrder
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#order} needs updating.
     */
    _flagOrder: false,

    /**
     * @name Two.Group#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#visible} needs updating.
     */

    /**
     * @name Two.Group#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#opacity} needs updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Group#_flagBeginning
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#beginning} needs updating.
     */
    _flagBeginning: false,

    /**
     * @name Two.Group#_flagEnding
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#ending} needs updating.
     */
    _flagEnding: false,

    /**
     * @name Two.Group#_flagLength
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#length} needs updating.
     */
    _flagLength: false,

    /**
     * @name Two.Group#_flagMask
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#mask} needs updating.
     */
    _flagMask: false,

    // Underlying Properties

    /**
     * @name Two.Group#fill
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what all child shapes should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _fill: '#fff',

    /**
     * @name Two.Group#stroke
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what all child shapes should be outlined in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _stroke: '#000',

    /**
     * @name Two.Group#linewidth
     * @property {Number} - The thickness in pixels of the stroke for all child shapes.
     */
    _linewidth: 1.0,

    /**
     * @name Two.Group#opacity
     * @property {Number} - The opaqueness of all child shapes.
     * @nota-bene Becomes multiplied by the individual child's opacity property.
     */
    _opacity: 1.0,

    /**
     * @name Two.Group#visible
     * @property {Boolean} - Display the path or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    _visible: true,

    /**
     * @name Two.Group#cap
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty}
     */
    _cap: 'round',

    /**
     * @name Two.Group#join
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty}
     */
    _join: 'round',

    /**
     * @name Two.Group#miter
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeMiterlimitProperty}
     */
    _miter: 4,

    /**
     * @name Two.Group#closed
     * @property {Boolean} - Determines whether a final line is drawn between the final point in the `vertices` array and the first point of all child shapes.
     */
    _closed: true,

    /**
     * @name Two.Group#curved
     * @property {Boolean} - When the child's path is `automatic = true` this boolean determines whether the lines between the points are curved or not.
     */
    _curved: false,

    /**
     * @name Two.Group#automatic
     * @property {Boolean} - Determines whether or not Two.js should calculate curves, lines, and commands automatically for you or to let the developer manipulate them for themselves.
     */
    _automatic: true,

    /**
     * @name Two.Group#beginning
     * @property {Number} - Number between zero and one to state the beginning of where the path is rendered.
     * @description {@link Two.Group#beginning} is a percentage value that represents at what percentage into all child shapes should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Group#ending}.
     */
    _beginning: 0,

    /**
     * @name Two.Group#ending
     * @property {Number} - Number between zero and one to state the ending of where the path is rendered.
     * @description {@link Two.Group#ending} is a percentage value that represents at what percentage into all child shapes should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Group#beginning}.
     */
    _ending: 1.0,

    /**
     * @name Two.Group#length
     * @property {Number} - The sum of distances between all child lengths.
     */
    _length: 0,

    /**
     * @name Two.Group#mask
     * @property {Two.Shape} - The Two.js object to clip from a group's rendering.
     */
    _mask: null,

    /**
     * @name Two.Group#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Group}
     * @description Create a new instance of {@link Two.Group} with the same properties of the current group.
     */
    clone: function(parent) {

      // /**
      //  * TODO: Group has a gotcha in that it's at the moment required to be bound to
      //  * an instance of two in order to add elements correctly. This needs to
      //  * be rethought and fixed.
      //  */

      var clone = new Group();
      var children = this.children.map(function(child) {
        return child.clone();
      });

      clone.add(children);

      clone.opacity = this.opacity;

      if (this.mask) {
        clone.mask = this.mask;
      }

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.className = this.className;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Group#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the group.
     */
    toObject: function() {

      var result = {
        children: [],
        translation: this.translation.toObject(),
        rotation: this.rotation,
        scale: this.scale instanceof Vector ? this.scale.toObject() : this.scale,
        opacity: this.opacity,
        className: this.className,
        mask: (this.mask ? this.mask.toObject() : null)
      };

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      _.each(this.children, function(child, i) {
        result.children[i] = child.toObject();
      }, this);

      return result;

    },

    /**
     * @name Two.Group#corner
     * @function
     * @description Orient the children of the group to the upper left-hand corner of that group.
     */
    corner: function() {

      var rect = this.getBoundingClientRect(true);

      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.translation.x -= rect.left;
        child.translation.y -= rect.top;
      }

      return this;

    },

    /**
     * @name Two.Group#center
     * @function
     * @description Orient the children of the group to the center of that group.
     */
    center: function() {

      var rect = this.getBoundingClientRect(true);
      var cx = rect.left + rect.width / 2 - this.translation.x;
      var cy = rect.top + rect.height / 2 - this.translation.y;

      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (child.isShape) {
          child.translation.x -= cx;
          child.translation.y -= cy;
        }
      }

      return this;

    },

    /**
     * @name Two.Group#getById
     * @function
     * @description Recursively search for id. Returns the first element found.
     * @returns {Two.Shape} - Or `null` if nothing is found.
     */
    getById: function (id) {
      var found = null;
      function search(node) {
        if (node.id === id) {
          return node;
        } else if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            found = search(node.children[i]);
            if (found) {
              return found;
            }
          }
        }
        return null;
      }
      return search(this);
    },

    /**
     * @name Two.Group#getByClassName
     * @function
     * @description Recursively search for classes. Returns an array of matching elements.
     * @returns {Two.Shape[]} - Or empty array if nothing is found.
     */
    getByClassName: function(className) {
      var found = [];
      function search(node) {
        if (Array.prototype.indexOf.call(node.classList, className) >= 0) {
          found.push(node);
        }
        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            search(child);
          }
        }
        return found;
      }
      return search(this);
    },

    /**
     * @name Two.Group#getByType
     * @function
     * @description Recursively search for children of a specific type, e.g. {@link Two.Path}. Pass a reference to this type as the param. Returns an array of matching elements.
     * @returns {Two.Shape[]} - Empty array if nothing is found.
     */
    getByType: function(type) {
      var found = [];
      function search(node) {
        if (node instanceof type) {
          found.push(node);
        }
        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            search(child);
          }
        }
        return found;
      }
      return search(this);
    },

    /**
     * @name Two.Group#add
     * @function
     * @param {Two.Shape[]} objects - An array of objects to be added. Can be also be supplied as individual arguments.
     * @description Add objects to the group.
     */
    add: function(objects) {

      // Allow to pass multiple objects either as array or as multiple arguments
      // If it's an array also create copy of it in case we're getting passed
      // a childrens array directly.
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      } else {
        objects = objects.slice();
      }

      // Add the objects
      for (var i = 0; i < objects.length; i++) {
        var child = objects[i];
        if (!(child && child.id)) {
          continue;
        }
        var index = Array.prototype.indexOf.call(this.children, child);
        if (index >= 0) {
          this.children.splice(index, 1);
        }
        this.children.push(child);
      }

      return this;

    },

    /**
     * @name Two.Group#add
     * @function
     * @param {Two.Shape[]} objects - An array of objects to be removed. Can be also removed as individual arguments.
     * @description Remove objects from the group.
     */
    remove: function(objects) {

      var l = arguments.length,
        grandparent = this.parent;

      // Allow to call remove without arguments
      // This will detach the object from its own parent.
      if (l <= 0 && grandparent) {
        grandparent.remove(this);
        return this;
      }

      // Allow to pass multiple objects either as array or as multiple arguments
      // If it's an array also create copy of it in case we're getting passed
      // a childrens array directly.
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      } else {
        objects = objects.slice();
      }

      // Remove the objects
      for (var i = 0; i < objects.length; i++) {
        var object = objects[i];
        if (!object || !this.children.ids[object.id]) {
          continue;
        }
        var index = this.children.indexOf(object);
        if (index >= 0) {
          this.children.splice(index, 1);
        }
      }

      return this;

    },

    /**
     * @name Two.Group#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the group.
     */
    getBoundingClientRect: function(shallow) {
      var rect, matrix, a, b, c, d, tc, lc, rc, bc;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      // Variables need to be defined here, because of nested nature of groups.
      var left = Infinity, right = -Infinity,
          top = Infinity, bottom = -Infinity;

      var regex = /texture|gradient/i;

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      for (var i = 0; i < this.children.length; i++) {

        var child = this.children[i];

        if (!child.visible || regex.test(child._renderer.type)) {
          continue;
        }

        rect = child.getBoundingClientRect(shallow);

        tc = typeof rect.top !== 'number' || _.isNaN(rect.top) || !isFinite(rect.top);
        lc = typeof rect.left !== 'number' || _.isNaN(rect.left) || !isFinite(rect.left);
        rc = typeof rect.right !== 'number' || _.isNaN(rect.right) || !isFinite(rect.right);
        bc = typeof rect.bottom !== 'number' || _.isNaN(rect.bottom) || !isFinite(rect.bottom);

        if (tc || lc || rc || bc) {
          continue;
        }

        top = min$3(rect.top, top);
        left = min$3(rect.left, left);
        right = max$3(rect.right, right);
        bottom = max$3(rect.bottom, bottom);

      }

      if (shallow) {

        a = matrix.multiply(left, top, 1);
        b = matrix.multiply(left, bottom, 1);
        c = matrix.multiply(right, top, 1);
        d = matrix.multiply(right, bottom, 1);

        top = min$3(a.y, b.y, c.y, d.y);
        left = min$3(a.x, b.x, c.x, d.x);
        right = max$3(a.x, b.x, c.x, d.x);
        bottom = max$3(a.y, b.y, c.y, d.y);

      }

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Group#noFill
     * @function
     * @description Apply `noFill` method to all child shapes.
     */
    noFill: function() {
      this.children.forEach(function(child) {
        child.noFill();
      });
      return this;
    },

    /**
     * @name Two.Group#noStroke
     * @function
     * @description Apply `noStroke` method to all child shapes.
     */
    noStroke: function() {
      this.children.forEach(function(child) {
        child.noStroke();
      });
      return this;
    },

    /**
     * @name Two.Group#subdivide
     * @function
     * @description Apply `subdivide` method to all child shapes.
     */
    subdivide: function() {
      var args = arguments;
      this.children.forEach(function(child) {
        child.subdivide.apply(child, args);
      });
      return this;
    },

    /**
     * @name Two.Group#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var i, l, child;

      if (this._flagBeginning || this._flagEnding) {

        var beginning = Math.min(this._beginning, this._ending);
        var ending = Math.max(this._beginning, this._ending);
        var length = this.length;
        var sum = 0;

        var bd = beginning * length;
        var ed = ending * length;

        for (i = 0; i < this.children.length; i++) {

          child = this.children[i];
          l = child.length;

          if (bd > sum + l) {
            child.beginning = 1;
            child.ending = 1;
          } else if (ed < sum) {
            child.beginning = 0;
            child.ending = 0;
          } else if (bd > sum && bd < sum + l) {
            child.beginning = (bd - sum) / l;
            child.ending = 1;
          } else if (ed > sum && ed < sum + l) {
            child.beginning = 0;
            child.ending = (ed - sum) / l;
          } else {
            child.beginning = 0;
            child.ending = 1;
          }

          sum += l;

        }

      }

      return Shape.prototype._update.apply(this, arguments);

    },

    /**
     * @name Two.Group#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      if (this._flagAdditions) {
        this.additions.length = 0;
        this._flagAdditions = false;
      }

      if (this._flagSubtractions) {
        this.subtractions.length = 0;
        this._flagSubtractions = false;
      }

      this._flagOrder = this._flagMask = this._flagOpacity =
        this._flagBeginning = this._flagEnding = false;

      Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Group.MakeObservable(Group.prototype);

  // /**
  //  * Helper function used to sync parent-child relationship within the
  //  * `Two.Group.children` object.
  //  *
  //  * Set the parent of the passed object to another object
  //  * and updates parent-child relationships
  //  * Calling with one arguments will simply remove the parenting
  //  */
  function replaceParent(child, newParent) {

    var parent = child.parent;
    var index;

    if (parent === newParent) {
      add();
      return;
    }

    if (parent && parent.children.ids[child.id]) {

      index = Array.prototype.indexOf.call(parent.children, child);
      parent.children.splice(index, 1);

      splice();

    }

    if (newParent) {
      add();
      return;
    }

    splice();

    if (parent._flagAdditions && parent.additions.length === 0) {
      parent._flagAdditions = false;
    }
    if (parent._flagSubtractions && parent.subtractions.length === 0) {
      parent._flagSubtractions = false;
    }

    delete child.parent;

    function add() {

      if (newParent.subtractions.length > 0) {
        index = Array.prototype.indexOf.call(newParent.subtractions, child);

        if (index >= 0) {
          newParent.subtractions.splice(index, 1);
        }
      }

      if (newParent.additions.length > 0) {
        index = Array.prototype.indexOf.call(newParent.additions, child);

        if (index >= 0) {
          newParent.additions.splice(index, 1);
        }
      }

      child.parent = newParent;
      newParent.additions.push(child);
      newParent._flagAdditions = true;

    }

    function splice() {

      index = Array.prototype.indexOf.call(parent.additions, child);

      if (index >= 0) {
        parent.additions.splice(index, 1);
      }

      index = Array.prototype.indexOf.call(parent.subtractions, child);

      if (index < 0) {
        parent.subtractions.push(child);
        parent._flagSubtractions = true;
      }

    }

  }

  // Constants
  var emptyArray = [];
  var TWO_PI$5 = Math.PI * 2,
    max$2 = Math.max,
    min$2 = Math.min,
    abs = Math.abs,
    sin$4 = Math.sin,
    cos$4 = Math.cos,
    acos = Math.acos,
    sqrt = Math.sqrt;

  // Returns true if this is a non-transforming matrix
  var isDefaultMatrix = function (m) {
    return (m[0] == 1 && m[3] == 0 && m[1] == 0 && m[4] == 1 && m[2] == 0 && m[5] == 0);
  };

  var canvas = {

    isHidden: /(undefined|none|transparent)/i,

    alignments: {
      left: 'start',
      middle: 'center',
      right: 'end'
    },

    shim: function(elem, name) {
      elem.tagName = elem.nodeName = name || 'canvas';
      elem.nodeType = 1;
      elem.getAttribute = function(prop) {
        return this[prop];
      };
      elem.setAttribute = function(prop, val) {
        this[prop] = val;
        return this;
      };
      return elem;
    },

    group: {

      renderChild: function(child) {
        canvas[child._renderer.type].render.call(child, this.ctx, true, this.clip);
      },

      render: function(ctx) {

        if (!this._visible) {
          return this;
        }

        this._update();

        var matrix = this._matrix.elements;
        var parent = this.parent;
        this._renderer.opacity = this._opacity
          * (parent && parent._renderer ? parent._renderer.opacity : 1);

        var mask = this._mask;
        // var clip = this._clip;

        var defaultMatrix = isDefaultMatrix(matrix);
        var shouldIsolate = !defaultMatrix || !!mask;

        if (!this._renderer.context) {
          this._renderer.context = {};
        }

        this._renderer.context.ctx = ctx;
        // this._renderer.context.clip = clip;

        if (shouldIsolate) {
          ctx.save();
          if (!defaultMatrix) {
            ctx.transform(matrix[0], matrix[3], matrix[1],
              matrix[4], matrix[2], matrix[5]);
          }
        }

        if (mask) {
          canvas[mask._renderer.type].render.call(mask, ctx, true);
        }

        if (this._opacity > 0 && this._scale !== 0) {
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            canvas[child._renderer.type].render.call(child, ctx);
          }
        }

        if (shouldIsolate) {
          ctx.restore();
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        // if (clip) {
        //   ctx.clip();
        // }

        return this.flagReset();

      }

    },

    path: {

      render: function(ctx, forced, parentClipped) {

        var matrix, stroke, linewidth, fill, opacity, visible, cap, join, miter,
            closed, commands, length, last, next, prev, a, b, c, d, ux, uy, vx, vy,
            ar, bl, br, cl, x, y, mask, clip, defaultMatrix, isOffset, dashes, po;

        po = (this.parent && this.parent._renderer)
          ? this.parent._renderer.opacity : 1;
        mask = this._mask;
        clip = this._clip;
        opacity = this._opacity * (po || 1);
        visible = this._visible;

        if (!forced && (!visible || clip || opacity === 0)) {
          return this;
        }

        this._update();

        matrix = this._matrix.elements;
        stroke = this._stroke;
        linewidth = this._linewidth;
        fill = this._fill;
        cap = this._cap;
        join = this._join;
        miter = this._miter;
        closed = this._closed;
        commands = this._renderer.vertices; // Commands
        length = commands.length;
        last = length - 1;
        defaultMatrix = isDefaultMatrix(matrix);
        dashes = this.dashes;

        // Transform
        if (!defaultMatrix) {
          ctx.save();
          ctx.transform(matrix[0], matrix[3], matrix[1], matrix[4], matrix[2], matrix[5]);
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951
        if (mask) {
          canvas[mask._renderer.type].render.call(mask, ctx, true);
        }

        // Styles
        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            canvas[fill._renderer.type].render.call(fill, ctx);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            canvas[stroke._renderer.type].render.call(stroke, ctx);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
          if (miter) {
            ctx.miterLimit = miter;
          }
          if (join) {
            ctx.lineJoin = join;
          }
          if (!closed && cap) {
            ctx.lineCap = cap;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }

        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        ctx.beginPath();

        for (var i = 0; i < commands.length; i++) {

          b = commands[i];

          x = b.x;
          y = b.y;

          switch (b.command) {

            case Commands.close:
              ctx.closePath();
              break;

            case Commands.arc:

              var rx = b.rx;
              var ry = b.ry;
              var xAxisRotation = b.xAxisRotation;
              var largeArcFlag = b.largeArcFlag;
              var sweepFlag = b.sweepFlag;

              prev = closed ? mod(i - 1, length) : max$2(i - 1, 0);
              a = commands[prev];

              var ax = a.x;
              var ay = a.y;

              canvas.renderSvgArcCommand(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y);
              break;

            case Commands.curve:

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              next = closed ? mod(i + 1, length) : Math.min(i + 1, last);

              a = commands[prev];
              c = commands[next];
              ar = (a.controls && a.controls.right) || Vector.zero;
              bl = (b.controls && b.controls.left) || Vector.zero;

              if (a._relative) {
                vx = (ar.x + a.x);
                vy = (ar.y + a.y);
              } else {
                vx = ar.x;
                vy = ar.y;
              }

              if (b._relative) {
                ux = (bl.x + b.x);
                uy = (bl.y + b.y);
              } else {
                ux = bl.x;
                uy = bl.y;
              }

              ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              if (i >= last && closed) {

                c = d;

                br = (b.controls && b.controls.right) || Vector.zero;
                cl = (c.controls && c.controls.left) || Vector.zero;

                if (b._relative) {
                  vx = (br.x + b.x);
                  vy = (br.y + b.y);
                } else {
                  vx = br.x;
                  vy = br.y;
                }

                if (c._relative) {
                  ux = (cl.x + c.x);
                  uy = (cl.y + c.y);
                } else {
                  ux = cl.x;
                  uy = cl.y;
                }

                x = c.x;
                y = c.y;

                ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              }

              break;

            case Commands.line:
              ctx.lineTo(x, y);
              break;

            case Commands.move:
              d = b;
              ctx.moveTo(x, y);
              break;

          }
        }

        // Loose ends

        if (closed) {
          ctx.closePath();
        }

        if (!clip && !parentClipped) {
          if (!canvas.isHidden.test(fill)) {
            isOffset = fill._renderer && fill._renderer.offset;
            if (isOffset) {
              ctx.save();
              ctx.translate(
                - fill._renderer.offset.x, - fill._renderer.offset.y);
              ctx.scale(fill._renderer.scale.x, fill._renderer.scale.y);
            }
            ctx.fill();
            if (isOffset) {
              ctx.restore();
            }
          }
          if (!canvas.isHidden.test(stroke)) {
            isOffset = stroke._renderer && stroke._renderer.offset;
            if (isOffset) {
              ctx.save();
              ctx.translate(
                - stroke._renderer.offset.x, - stroke._renderer.offset.y);
              ctx.scale(stroke._renderer.scale.x, stroke._renderer.scale.y);
              ctx.lineWidth = linewidth / stroke._renderer.scale.x;
            }
            ctx.stroke();
            if (isOffset) {
              ctx.restore();
            }
          }
        }

        if (!defaultMatrix) {
          ctx.restore();
        }

        if (clip && !parentClipped) {
          ctx.clip();
        }

        if (dashes && dashes.length > 0) {
          ctx.setLineDash(emptyArray);
        }

        return this.flagReset();

      }

    },

    text: {

      render: function(ctx, forced, parentClipped) {

        var po = (this.parent && this.parent._renderer)
          ? this.parent._renderer.opacity : 1;
        var opacity = this._opacity * po;
        var visible = this._visible;
        var mask = this._mask;
        var clip = this._clip;

        if (!forced && (!visible || clip || opacity === 0)) {
          return this;
        }

        this._update();

        var matrix = this._matrix.elements;
        var stroke = this._stroke;
        var linewidth = this._linewidth;
        var fill = this._fill;
        var decoration = this._decoration;
        var defaultMatrix = isDefaultMatrix(matrix);
        var isOffset = fill._renderer && fill._renderer.offset
          && stroke._renderer && stroke._renderer.offset;
        var dashes = this.dashes;
        var alignment = canvas.alignments[this._alignment] || this._alignment;
        var baseline = this._baseline;

        var a, b, c, d, e, sx, sy, x1, y1, x2, y2;

        // Transform
        if (!defaultMatrix) {
          ctx.save();
          ctx.transform(matrix[0], matrix[3], matrix[1], matrix[4], matrix[2], matrix[5]);
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951
        if (mask) {
          canvas[mask._renderer.type].render.call(mask, ctx, true);
        }

        if (!isOffset) {
          ctx.font = [this._style, this._weight, this._size + 'px/' +
            this._leading + 'px', this._family].join(' ');
        }

        ctx.textAlign = alignment;
        ctx.textBaseline = baseline;

        // Styles
        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            canvas[fill._renderer.type].render.call(fill, ctx);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            canvas[stroke._renderer.type].render.call(stroke, ctx);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }
        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        if (!clip && !parentClipped) {

          if (!canvas.isHidden.test(fill)) {

            if (fill._renderer && fill._renderer.offset) {

              sx = fill._renderer.scale.x;
              sy = fill._renderer.scale.y;

              ctx.save();
              ctx.translate( - fill._renderer.offset.x,
                - fill._renderer.offset.y);
              ctx.scale(sx, sy);

              a = this._size / fill._renderer.scale.y;
              b = this._leading / fill._renderer.scale.y;
              ctx.font = [this._style, this._weight, a + 'px/',
                b + 'px', this._family].join(' ');

              c = fill._renderer.offset.x / fill._renderer.scale.x;
              d = fill._renderer.offset.y / fill._renderer.scale.y;

              ctx.fillText(this.value, c, d);
              ctx.restore();

            } else {
              ctx.fillText(this.value, 0, 0);
            }

          }

          if (!canvas.isHidden.test(stroke)) {

            if (stroke._renderer && stroke._renderer.offset) {

              sx = stroke._renderer.scale.x;
              sy = stroke._renderer.scale.y;

              ctx.save();
              ctx.translate(- stroke._renderer.offset.x,
                - stroke._renderer.offset.y);
              ctx.scale(sx, sy);

              a = this._size / stroke._renderer.scale.y;
              b = this._leading / stroke._renderer.scale.y;
              ctx.font = [this._style, this._weight, a + 'px/',
                b + 'px', this._family].join(' ');

              c = stroke._renderer.offset.x / stroke._renderer.scale.x;
              d = stroke._renderer.offset.y / stroke._renderer.scale.y;
              e = linewidth / stroke._renderer.scale.x;

              ctx.lineWidth = e;
              ctx.strokeText(this.value, c, d);
              ctx.restore();

            } else {
              ctx.strokeText(this.value, 0, 0);
            }
          }
        }

        // Handle text-decoration
        if (/(underline|strikethrough)/i.test(decoration)) {

          var metrics = ctx.measureText(this.value);
          var scalar = 1;

          switch (decoration) {
            case 'underline':
              y1 = metrics.actualBoundingBoxAscent;
              y2 = metrics.actualBoundingBoxAscent;
              break;
            case 'strikethrough':
              y1 = 0;
              y2 = 0;
              scalar = 0.5;
              break;
          }

          switch (baseline) {
            case 'top':
              y1 += this._size * scalar;
              y2 += this._size * scalar;
              break;
            case 'baseline':
            case 'bottom':
              y1 -= this._size * scalar;
              y2 -= this._size * scalar;
              break;
          }

          switch (alignment) {
            case 'left':
            case 'start':
              x1 = 0;
              x2 = metrics.width;
              break;
            case 'right':
            case 'end':
              x1 = - metrics.width;
              x2 = 0;
              break;
            default:
              x1 = - metrics.width / 2;
              x2 = metrics.width / 2;
          }

          ctx.lineWidth = Math.max(Math.floor(this._size / 15), 1);
          ctx.strokeStyle = ctx.fillStyle;

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();

        }

        if (!defaultMatrix) {
          ctx.restore();
        }

        // TODO: Test for text
        if (clip && !parentClipped) {
          ctx.clip();
        }

        if (dashes && dashes.length > 0) {
          ctx.setLineDash(emptyArray);
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(ctx) {

        this._update();

        if (!this._renderer.effect || this._flagEndPoints || this._flagStops) {

          this._renderer.effect = ctx.createLinearGradient(
            this.left._x, this.left._y,
            this.right._x, this.right._y
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(ctx) {

        this._update();

        if (!this._renderer.effect || this._flagCenter || this._flagFocal
            || this._flagRadius || this._flagStops) {

          this._renderer.effect = ctx.createRadialGradient(
            this.center._x, this.center._y, 0,
            this.focal._x, this.focal._y, this._radius
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(ctx) {

        this._update();

        var image = this.image;

        if (!this._renderer.effect || ((this._flagLoaded || this._flagImage || this._flagVideo || this._flagRepeat) && this.loaded)) {
          this._renderer.effect = ctx.createPattern(this.image, this._repeat);
        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          if (!(this._renderer.offset instanceof Vector)) {
            this._renderer.offset = new Vector();
          }

          this._renderer.offset.x = - this._offset.x;
          this._renderer.offset.y = - this._offset.y;

          if (image) {

            this._renderer.offset.x += image.width / 2;
            this._renderer.offset.y += image.height / 2;

            if (this._scale instanceof Vector) {
              this._renderer.offset.x *= this._scale.x;
              this._renderer.offset.y *= this._scale.y;
            } else {
              this._renderer.offset.x *= this._scale;
              this._renderer.offset.y *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }

          if (this._scale instanceof Vector) {
            this._renderer.scale.copy(this._scale);
          } else {
            this._renderer.scale.set(this._scale, this._scale);
          }

        }

        return this.flagReset();

      }

    },

    renderSvgArcCommand: function(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y) {

      xAxisRotation = xAxisRotation * Math.PI / 180;

      // Ensure radii are positive
      rx = abs(rx);
      ry = abs(ry);

      // Compute (x1â€², y1â€²)
      var dx2 = (ax - x) / 2.0;
      var dy2 = (ay - y) / 2.0;
      var x1p = cos$4(xAxisRotation) * dx2 + sin$4(xAxisRotation) * dy2;
      var y1p = - sin$4(xAxisRotation) * dx2 + cos$4(xAxisRotation) * dy2;

      // Compute (cxâ€², cyâ€²)
      var rxs = rx * rx;
      var rys = ry * ry;
      var x1ps = x1p * x1p;
      var y1ps = y1p * y1p;

      // Ensure radii are large enough
      var cr = x1ps / rxs + y1ps / rys;

      if (cr > 1) {

        // scale up rx,ry equally so cr == 1
        var s = sqrt(cr);
        rx = s * rx;
        ry = s * ry;
        rxs = rx * rx;
        rys = ry * ry;

      }

      var dq = (rxs * y1ps + rys * x1ps);
      var pq = (rxs * rys - dq) / dq;
      var q = sqrt(max$2(0, pq));
      if (largeArcFlag === sweepFlag) q = - q;
      var cxp = q * rx * y1p / ry;
      var cyp = - q * ry * x1p / rx;

      // Step 3: Compute (cx, cy) from (cxâ€², cyâ€²)
      var cx = cos$4(xAxisRotation) * cxp
        - sin$4(xAxisRotation) * cyp + (ax + x) / 2;
      var cy = sin$4(xAxisRotation) * cxp
        + cos$4(xAxisRotation) * cyp + (ay + y) / 2;

      // Step 4: Compute Î¸1 and Î”Î¸
      var startAngle = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry,
        (- x1p - cxp) / rx, (- y1p - cyp) / ry) % TWO_PI$5;

      var endAngle = startAngle + delta;

      var clockwise = sweepFlag === 0;

      renderArcEstimate(ctx, cx, cy, rx, ry, startAngle, endAngle,
        clockwise, xAxisRotation);

    }

  };

  /**
   * @name Two.CanvasRenderer
   * @class
   * @extends Two.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<canvas />` to draw to. If none given a new one will be constructed.
   * @param {Boolean} [parameters.overdraw] - Determines whether the canvas should clear the background or not. Defaults to `true`.
   * @param {Boolean} [parameters.smoothing=true] - Determines whether the canvas should antialias drawing. Set it to `false` when working with pixel art. `false` can lead to better performance, since it would use a cheaper interpolation algorithm.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.canvas`. It takes Two.js' scenegraph and renders it to a `<canvas />`.
   */
  function Renderer$2(params) {

    // It might not make a big difference on GPU backed canvases.
    var smoothing = (params.smoothing !== false);

    /**
     * @name Two.CanvasRenderer#domElement
     * @property {Element} - The `<canvas />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || document.createElement('canvas');

    /**
     * @name Two.CanvasRenderer#ctx
     * @property {Canvas2DContext} - Associated two dimensional context to render on the `<canvas />`.
     */
    this.ctx = this.domElement.getContext('2d');

    /**
     * @name Two.CanvasRenderer#overdraw
     * @property {Boolean} - Determines whether the canvas clears the background each draw call.
     * @default true
     */
    this.overdraw = params.overdraw || false;

    if (typeof this.ctx.imageSmoothingEnabled !== 'undefined') {
      this.ctx.imageSmoothingEnabled = smoothing;
    }

    /**
     * @name Two.CanvasRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Group();
    this.scene.parent = this;
  }


  _.extend(Renderer$2, {

    /**
     * @name Two.CanvasRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<canvas />`.
     */
    Utils: canvas

  });

  _.extend(Renderer$2.prototype, Events, {

    constructor: Renderer$2,

    /**
     * @name Two.CanvasRenderer#setSize
     * @function
     * @fires resize
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @param {Number} [ratio] - The new pixel ratio (pixel density) of the renderer. Defaults to calculate the pixel density of the user's screen.
     * @description Change the size of the renderer.
     */
    setSize: function(width, height, ratio) {

      this.width = width;
      this.height = height;

      this.ratio = typeof ratio === 'undefined' ? getRatio(this.ctx) : ratio;

      this.domElement.width = width * this.ratio;
      this.domElement.height = height * this.ratio;

      if (this.domElement.style) {
        _.extend(this.domElement.style, {
          width: width + 'px',
          height: height + 'px'
        });
      }

      return this.trigger(Events.Types.resize, width, height, ratio);

    },

    /**
     * @name Two.CanvasRenderer#render
     * @function
     * @description Render the current scene to the `<canvas />`.
     */
    render: function() {

      var isOne = this.ratio === 1;

      if (!isOne) {
        this.ctx.save();
        this.ctx.scale(this.ratio, this.ratio);
      }

      if (!this.overdraw) {
        this.ctx.clearRect(0, 0, this.width, this.height);
      }

      canvas.group.render.call(this.scene, this.ctx);

      if (!isOne) {
        this.ctx.restore();
      }

      return this;

    }

  });

  function renderArcEstimate(ctx, ox, oy, rx, ry, startAngle, endAngle, clockwise, xAxisRotation) {

    var epsilon = Curve.Tolerance.epsilon;
    var deltaAngle = endAngle - startAngle;
    var samePoints = Math.abs(deltaAngle) < epsilon;

    // ensures that deltaAngle is 0 .. 2 PI
    deltaAngle = mod(deltaAngle, TWO_PI$5);

    if (deltaAngle < epsilon) {

      if (samePoints) {

        deltaAngle = 0;

      } else {

        deltaAngle = TWO_PI$5;

      }

    }

    if (clockwise === true && ! samePoints) {

      if (deltaAngle === TWO_PI$5) {

        deltaAngle = - TWO_PI$5;

      } else {

        deltaAngle = deltaAngle - TWO_PI$5;

      }

    }

    for (var i = 0; i < Constants.Resolution; i++) {

      var t = i / (Constants.Resolution - 1);

      var angle = startAngle + t * deltaAngle;
      var x = ox + rx * Math.cos(angle);
      var y = oy + ry * Math.sin(angle);

      if (xAxisRotation !== 0) {

        var cos = Math.cos(xAxisRotation);
        var sin = Math.sin(xAxisRotation);

        var tx = x - ox;
        var ty = y - oy;

        // Rotate the point about the center of the ellipse.
        x = tx * cos - ty * sin + ox;
        y = tx * sin + ty * cos + oy;

      }

      ctx.lineTo(x, y);

    }

  }

  function svgAngle(ux, uy, vx, vy) {

    var dot = ux * vx + uy * vy;
    var len = sqrt(ux * ux + uy * uy) *  sqrt(vx * vx + vy * vy);
    // floating point precision, slightly over values appear
    var ang = acos(max$2(-1, min$2(1, dot / len)));
    if ((ux * vy - uy * vx) < 0) {
      ang = - ang;
    }

    return ang;

  }

  var CanvasShim = {

    Image: null,

    isHeadless: false,

    /**
     * @name Two.Utils.shim
     * @function
     * @param {canvas} canvas - The instanced `Canvas` object provided by `node-canvas`.
     * @param {Image} [Image] - The prototypical `Image` object provided by `node-canvas`. This is only necessary to pass if you're going to load bitmap imagery.
     * @returns {canvas} Returns the instanced canvas object you passed from with additional attributes needed for Two.js.
     * @description Convenience method for defining all the dependencies from the npm package `node-canvas`. See [node-canvas](https://github.com/Automattic/node-canvas) for additional information on setting up HTML5 `<canvas />` drawing in a node.js environment.
     */
    shim: function(canvas, Image) {
      Renderer$2.Utils.shim(canvas);
      if (typeof Image !== 'undefined') {
        CanvasShim.Image = Image;
      }
      CanvasShim.isHeadless = true;
      return canvas;
    }

  };

  var dom = {

    hasEventListeners: typeof root$1.addEventListener === 'function',

    bind: function(elem, event, func, bool) {
      if (this.hasEventListeners) {
        elem.addEventListener(event, func, !!bool);
      } else {
        elem.attachEvent('on' + event, func);
      }
      return dom;
    },

    unbind: function(elem, event, func, bool) {
      if (dom.hasEventListeners) {
        elem.removeEventListeners(event, func, !!bool);
      } else {
        elem.detachEvent('on' + event, func);
      }
      return dom;
    },

    getRequestAnimationFrame: function() {

      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      var request = root$1.requestAnimationFrame, cancel;

      if(!request) {
        for (var i = 0; i < vendors.length; i++) {
          request = root$1[vendors[i] + 'RequestAnimationFrame'] || request;
          cancel = root$1[vendors[i] + 'CancelAnimationFrame']
            || root$1[vendors[i] + 'CancelRequestAnimationFrame'] || cancel;
        }

        request = request || function(callback, element) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = root$1.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }

      return request;

    }

  };

  var temp = (root$1.document ? root$1.document.createElement('div') : {});
  temp.id = 'help-two-load';

  Object.defineProperty(dom, 'temp', {
    enumerable: true,
    get: function() {
      if (_.isElement(temp) && !root$1.document.head.contains(temp)) {
        _.extend(temp.style, {
          display: 'none'
        });
        root$1.document.head.appendChild(temp);
      }
      return temp;
    }
  });

  /**
   * @name Two.Utils.Error
   * @class
   * @description Custom error throwing for Two.js specific identification.
   */
  function TwoError(message) {
    this.name = 'Two.js';
    this.message = message;
  }

  TwoError.prototype = new Error();

  _.extend(TwoError.prototype, {
    constructor: TwoError
  });

  /**
   * @name Two.Utils.defineGetterSetter
   * @function
   * @this Two#
   * @param {String} property - The property to add an enumerable getter / setter to.
   * @description Convenience function to setup the flag based getter / setter that most properties are defined as in Two.js.
   */
  var defineGetterSetter = function(property) {

    var object = this;
    var secret = '_' + property;
    var flag = '_flag' + property.charAt(0).toUpperCase() + property.slice(1);

    Object.defineProperty(object, property, {
      enumerable: true,
      get: function() {
        return this[secret];
      },
      set: function(v) {
        this[secret] = v;
        this[flag] = true;
      }
    });

  };

  /**
   * @name Two.Registry
   * @class
   * @description An arbitrary class to manage a directory of things. Mainly used for keeping tabs of textures in Two.js.
   */
  function Registry() {

    this.map = {};

  }

  _.extend(Registry.prototype, {

    constructor: Registry,

    /**
     * @name Two.Registry#add
     * @function
     * @param {String} id - A unique identifier.
     * @param value - Any type of variable to be registered to the directory.
     * @description Adds any value to the directory. Assigned by the `id`.
     */
    add: function(id, obj) {
      this.map[id] = obj;
      return this;
    },

    /**
     * @name Two.Registry#remove
     * @function
     * @param {String} id - A unique identifier.
     * @description Remove any value from the directory by its `id`.
     */
    remove: function(id) {
      delete this.map[id];
      return this;
    },

    /**
     * @name Two.Registry#get
     * @function
     * @param {String} id - A unique identifier.
     * @returns {?Object} The associated value. If unavailable then `undefined` is returned.
     * @description Get a registered value by its `id`.
     */
    get: function(id) {
      return this.map[id];
    },

    /**
     * @name Two.Registry#contains
     * @function
     * @param {String} id - A unique identifier.
     * @returns {Boolean}
     * @description Convenience method to see if a value is registered to an `id` already.
     */
    contains: function(id) {
      return id in this.map;
    }

  });

  /**
   * @name Two.Stop
   * @class
   * @param {Number} [offset] - The offset percentage of the stop represented as a zero-to-one value. Default value flip flops from zero-to-one as new stops are created.
   * @param {String} [color] - The color of the stop. Default value flip flops from white to black as new stops are created.
   * @param {Number} [opacity] - The opacity value. Default value is 1, cannot be lower than 0.
   * @nota-bene Used specifically in conjunction with {@link Two.Gradient}s to control color graduation.
   */
  function Stop(offset, color, opacity) {

    /**
     * @name Two.Stop#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.type = 'stop';

    /**
     * @name Two.Stop#offset
     * @property {Number} - The offset percentage of the stop represented as a zero-to-one value.
     */
    this.offset = typeof offset === 'number' ? offset
      : Stop.Index <= 0 ? 0 : 1;

    /**
     * @name Two.Stop#opacity
     * @property {Number} - The alpha percentage of the stop represented as a zero-to-one value.
     */
    this.opacity = typeof opacity === 'number' ? opacity : 1;

    /**
     * @name Two.Stop#color
     * @property {String} - The color of the stop.
     */
    this.color = (typeof color === 'string') ? color
      : Stop.Index <= 0 ? '#fff' : '#000';

    Stop.Index = (Stop.Index + 1) % 2;

  }

  _.extend(Stop, {

    /**
     * @name Two.Stop.Index
     * @property {Number} - The current index being referenced for calculating a stop's default offset value.
     */
    Index: 0,

    /**
     * @name Two.Stop.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Stop}.
     */
    Properties: [
      'offset',
      'opacity',
      'color'
    ],

    /**
     * @name Two.Stop.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Stop} to any object. Handy if you'd like to extend the {@link Two.Stop} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Stop.Properties, function(property) {

        var object = this;
        var secret = '_' + property;
        var flag = '_flag' + property.charAt(0).toUpperCase() + property.slice(1);

        Object.defineProperty(object, property, {
          enumerable: true,
          get: function() {
            return this[secret];
          },
          set: function(v) {
            this[secret] = v;
            this[flag] = true;
            if (this.parent) {
              this.parent._flagStops = true;
            }
          }
        });

      }, object);

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

    }

  });

  _.extend(Stop.prototype, Events, {

    constructor: Stop,

    /**
     * @name Two.Stop#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Stop}
     * @description Create a new instance of {@link Two.Stop} with the same properties of the current path.
     */
    clone: function() {

      var clone = new Stop();

      _.each(Stop.Properties, function(property) {
        clone[property] = this[property];
      }, this);

      return clone;

    },

    /**
     * @name Two.Stop#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {};

      _.each(Stop.Properties, function(k) {
        result[k] = this[k];
      }, this);

      return result;

    },

    /**
     * @name Two.Stop#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagOffset = this._flagColor = this._flagOpacity = false;

      return this;

    }

  });

  Stop.MakeObservable(Stop.prototype);

  /**
   * @name Two.Gradient
   * @class
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @description This is the base class for constructing different types of gradients with Two.js. The two common gradients are {@link Two.LinearGradient} and {@link Two.RadialGradient}.
   */
  function Gradient(stops) {

    /**
     * @name Two.Gradient#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.type = 'gradient';

    /**
     * @name Two.Gradient#id
     * @property {String} - Session specific unique identifier.
     * @nota-bene In the {@link Two.SvgRenderer} change this to change the underlying SVG element's id too.
     */
    this.id = Constants.Identifier + Constants.uniqueId();
    this.classList = [];

    this._renderer.flagStops = Gradient.FlagStops.bind(this);
    this._renderer.bindStops = Gradient.BindStops.bind(this);
    this._renderer.unbindStops = Gradient.UnbindStops.bind(this);

    /**
     * @name Two.Gradient#spread
     * @property {String} - Indicates what happens if the gradient starts or ends inside the bounds of the target rectangle. Possible values are `'pad'`, `'reflect'`, and `'repeat'`.
     * @see {@link https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementSpreadMethodAttribute} for more information
     */
    this.spread = 'pad';

    /**
     * @name Two.Gradient#stops
     * @property {Two.Stop[]} - An ordered list of {@link Two.Stop}s for rendering the gradient.
     */
    if (stops) {
      this.stops = stops;
    }

  }

  _.extend(Gradient, {

    /**
     * @name Two.Gradient.Stop
     * @see {@link Two.Stop}
     */
    Stop: Stop,

    /**
     * @name Two.Gradient.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Gradient}.
     */
    Properties: [
      'spread'
    ],

    /**
     * @name Two.Gradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Gradient} to any object. Handy if you'd like to extend the {@link Two.Gradient} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Gradient.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'stops', {

        enumerable: true,

        get: function() {
          return this._stops;
        },

        set: function(stops) {

          var bindStops = this._renderer.bindStops;
          var unbindStops = this._renderer.unbindStops;

          // Remove previous listeners
          if (this._stops) {
            this._stops
              .unbind(Events.Types.insert, bindStops)
              .unbind(Events.Types.remove, unbindStops);
          }

          // Create new Collection with copy of Stops
          this._stops = new Collection((stops || []).slice(0));

          // Listen for Collection changes and bind / unbind
          this._stops
            .bind(Events.Types.insert, bindStops)
            .bind(Events.Types.remove, unbindStops);

          // Bind Initial Stops
          bindStops(this._stops);

        }

      });

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

      Object.defineProperty(object, 'id', {

        enumerable: true,

        get: function() {
          return this._id;
        },

        set: function(v) {
          this._id = v;
        }

      });

    },

    /**
     * @name Two.Gradient.FlagStops
     * @function
     * @description Cached method to let renderers know stops have been updated on a {@link Two.Gradient}.
     */
    FlagStops: function() {
      this._flagStops = true;
    },

    /**
     * @name Two.Gradient.BindVertices
     * @function
     * @description Cached method to let {@link Two.Gradient} know vertices have been added to the instance.
     */
    BindStops: function(items) {

      // This function is called a lot
      // when importing a large SVG
      var i = items.length;
      while(i--) {
        items[i].bind(Events.Types.change, this._renderer.flagStops);
        items[i].parent = this;
      }

      this._renderer.flagStops();

    },

    /**
     * @name Two.Gradient.UnbindStops
     * @function
     * @description Cached method to let {@link Two.Gradient} know vertices have been removed from the instance.
     */
    UnbindStops: function(items) {

      var i = items.length;
      while(i--) {
        items[i].unbind(Events.Types.change, this._renderer.flagStops);
        delete items[i].parent;
      }

      this._renderer.flagStops();

    }

  });

  _.extend(Gradient.prototype, Events, {

    constructor: Gradient,

    /**
     * @name Two.Gradient#_flagId
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#id} needs updating.
     */
    _flagId: false,

    /**
     * @name Two.Gradient#_flagStops
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#stops} needs updating.
     */
    _flagStops: false,
    /**
     * @name Two.Gradient#_flagSpread
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#spread} needs updating.
     */
    _flagSpread: false,

    _id: '',

    /**
     * @name Two.Gradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.Gradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = this.stops.map(function(s) {
        return s.clone();
      });

      var clone = new Gradient(stops);

      _.each(Gradient.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Gradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {
        stops: this.stops.map(function(s) {
          return s.toObject();
        })
      };

      _.each(Gradient.Properties, function(k) {
        result[k] = this[k];
      }, this);

      return result;

    },

    /**
     * @name Two.Gradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagSpread || this._flagStops) {
        this.trigger(Events.Types.change);
      }

      return this;

    },

    /**
     * @name Two.Gradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagSpread = this._flagStops = false;

      return this;

    }

  });

  Gradient.MakeObservable(Gradient.prototype);

  /**
   * @name Two.LinearGradient
   * @class
   * @extends Two.Gradient
   * @param {Number} [x1=0] - The x position of the first end point of the linear gradient.
   * @param {Number} [y1=0] - The y position of the first end point of the linear gradient.
   * @param {Number} [x2=0] - The x position of the second end point of the linear gradient.
   * @param {Number} [y2=0] - The y position of the second end point of the linear gradient.
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @nota-bene The linear gradient lives within the space of the parent object's matrix space.
   */
  function LinearGradient(x1, y1, x2, y2, stops) {

    Gradient.call(this, stops);

    this._renderer.type = 'linear-gradient';

    var flagEndPoints = LinearGradient.FlagEndPoints.bind(this);

    /**
     * @name Two.LinearGradient#left
     * @property {Two.Vector} - The x and y value for where the first end point is placed on the canvas.
     */
    this.left = new Vector().bind(Events.Types.change, flagEndPoints);
    /**
     * @name Two.LinearGradient#right
     * @property {Two.Vector} - The x and y value for where the second end point is placed on the canvas.
     */
    this.right = new Vector().bind(Events.Types.change, flagEndPoints);

    if (typeof x1 === 'number') {
      this.left.x = x1;
    }
    if (typeof y1 === 'number') {
      this.left.y = y1;
    }
    if (typeof x2 === 'number') {
      this.right.x = x2;
    }
    if (typeof y2 === 'number') {
      this.right.y = y2;
    }

  }

  _.extend(LinearGradient, {

    /**
     * @name Two.LinearGradient.Stop
     * @see {@link Two.Stop}
     */
    Stop: Stop,

    /**
     * @name Two.LinearGradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.LinearGradient} to any object. Handy if you'd like to extend the {@link Two.LinearGradient} class on a custom class.
     */
    MakeObservable: function(object) {
      Gradient.MakeObservable(object);
    },

    /**
     * @name Two.LinearGradient.FlagEndPoints
     * @function
     * @description Cached method to let renderers know end points have been updated on a {@link Two.LinearGradient}.
     */
    FlagEndPoints: function() {
      this._flagEndPoints = true;
    }

  });

  _.extend(LinearGradient.prototype, Gradient.prototype, {

    constructor: LinearGradient,

    /**
     * @name Two.LinearGradient#_flagEndPoints
     * @private
     * @property {Boolean} - Determines whether the {@link Two.LinearGradient#left} or {@link Two.LinearGradient#right} changed and needs to update.
     */
    _flagEndPoints: false,

    /**
     * @name Two.LinearGradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.LinearGradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = this.stops.map(function(stop) {
        return stop.clone();
      });

      var clone = new LinearGradient(this.left._x, this.left._y,
        this.right._x, this.right._y, stops);

      _.each(Gradient.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.LinearGradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = Gradient.prototype.toObject.call(this);

      result.left = this.left.toObject();
      result.right = this.right.toObject();

      return result;

    },

    /**
     * @name Two.LinearGradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagEndPoints || this._flagSpread || this._flagStops) {
        this.trigger(Events.Types.change);
      }

      return this;

    },

    /**
     * @name Two.LinearGradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagEndPoints = false;

      Gradient.prototype.flagReset.call(this);

      return this;

    }

  });

  LinearGradient.MakeObservable(LinearGradient.prototype);

  /**
   * @name Two.RadialGradient
   * @class
   * @extends Two.Gradient
   * @param {Number} [x=0] - The x position of the origin of the radial gradient.
   * @param {Number} [y=0] - The y position of the origin of the radial gradient.
   * @param {Number} [radius=0] - The radius of the radial gradient.
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @param {Number} [focalX=0] - The x position of the focal point on the radial gradient.
   * @param {Number} [focalY=0] - The y position of the focal point on the radial gradient.
   * @nota-bene The radial gradient lives within the space of the parent object's matrix space.
   */
  function RadialGradient(cx, cy, r, stops, fx, fy) {

    Gradient.call(this, stops);

    this._renderer.type = 'radial-gradient';

    /**
     * @name Two.RadialGradient#center
     * @property {Two.Vector} - The x and y value for where the origin of the radial gradient is.
     */
    this.center = new Vector()
      .bind(Events.Types.change, (function() {
        this._flagCenter = true;
      }).bind(this));

    this.radius = typeof r === 'number' ? r : 20;

    /**
     * @name Two.RadialGradient#focal
     * @property {Two.Vector} - The x and y value for where the focal point of the radial gradient is.
     * @nota-bene This effects the spray or spread of the radial gradient.
     */
    this.focal = new Vector()
      .bind(Events.Types.change, (function() {
        this._flagFocal = true;
      }).bind(this));

    if (typeof cx === 'number') {
      this.center.x = cx;
    }
    if (typeof cy === 'number') {
      this.center.y = cy;
    }

    this.focal.copy(this.center);

    if (typeof fx === 'number') {
      this.focal.x = fx;
    }
    if (typeof fy === 'number') {
      this.focal.y = fy;
    }

  }

  _.extend(RadialGradient, {

    /**
     * @name Two.RadialGradient.Stop
     * @see {@link Two.Stop}
     */
    Stop: Stop,

    /**
     * @name Two.RadialGradient.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.RadialGradient}.
     */
    Properties: [
      'radius'
    ],

    /**
     * @name Two.RadialGradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.RadialGradient} to any object. Handy if you'd like to extend the {@link Two.RadialGradient} class on a custom class.
     */
    MakeObservable: function(object) {

      Gradient.MakeObservable(object);

      _.each(RadialGradient.Properties, defineGetterSetter, object);

    }

  });

  _.extend(RadialGradient.prototype, Gradient.prototype, {

    constructor: RadialGradient,

    /**
     * @name Two.RadialGradient#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#radius} changed and needs to update.
     */
    _flagRadius: false,
    /**
     * @name Two.RadialGradient#_flagCenter
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#center} changed and needs to update.
     */
    _flagCenter: false,
    /**
     * @name Two.RadialGradient#_flagFocal
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#focal} changed and needs to update.
     */
    _flagFocal: false,

    /**
     * @name Two.RadialGradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.RadialGradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = this.stops.map(function(stop) {
        return stop.clone();
      });

      var clone = new RadialGradient(this.center._x, this.center._y,
          this._radius, stops, this.focal._x, this.focal._y);

      _.each(Gradient.Properties.concat(RadialGradient.Properties), function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.RadialGradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = Gradient.prototype.toObject.call(this);

      _.each(RadialGradient.Properties, function(k) {
        result[k] = this[k];
      }, this);

      result.center = this.center.toObject();
      result.focal = this.focal.toObject();

      return result;

    },

    /**
     * @name Two.RadialGradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagRadius || this._flatCenter || this._flagFocal
        || this._flagSpread || this._flagStops) {
        this.trigger(Events.Types.change);
      }

      return this;

    },

    /**
     * @name Two.RadialGradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagRadius = this._flagCenter = this._flagFocal = false;

      Gradient.prototype.flagReset.call(this);

      return this;

    }

  });

  RadialGradient.MakeObservable(RadialGradient.prototype);

  var anchor;
  var regex$1 = {
    video: /\.(mp4|webm|ogg)$/i,
    image: /\.(jpe?g|png|gif|tiff|webp)$/i,
    effect: /texture|gradient/i
  };

  if (root$1.document) {
    anchor = document.createElement('a');
  }

  /**
   * @name Two.Texture
   * @class
   * @extends Two.Shape
   * @param {String|HTMLImageElement} [src] - The URL path to an image file or an `<img />` element.
   * @param {Function} [callback] - An optional callback function once the image has been loaded.
   * @description Fundamental to work with bitmap data, a.k.a. pregenerated imagery, in Two.js. Supported formats include jpg, png, gif, and tiff. See {@link Two.Texture.RegularExpressions} for a full list of supported formats.
   */
  function Texture(src, callback) {

    /**
     * @name Two.Texture#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.type = 'texture';
    this._renderer.flagOffset = Texture.FlagOffset.bind(this);
    this._renderer.flagScale = Texture.FlagScale.bind(this);

    this.id = Constants.Identifier + Constants.uniqueId();
    this.classList = [];

    /**
     * @name Two.Texture#loaded
     * @property {Boolean} - Shorthand value to determine if image has been loaded into the texture.
     */
    this.loaded = false;

    /**
     * @name Two.Texture#repeat
     * @property {String} - CSS style declaration to tile {@link Two.Path}. Valid values include: `'no-repeat'`, `'repeat'`, `'repeat-x'`, `'repeat-y'`.
     * @see {@link https://www.w3.org/TR/2dcontext/#dom-context-2d-createpattern}
     */
    this.repeat = 'no-repeat';

    /**
     * @name Two.Texture#offset
     * @property {Two.Vector} - A two-component vector describing any pixel offset of the texture when applied to a {@link Two.Path}.
     */
    this.offset = new Vector();

    if (typeof callback === 'function') {
      var loaded = (function() {
        this.unbind(Events.Types.load, loaded);
        if (typeof callback === 'function') {
          callback();
        }
      }).bind(this);
      this.bind(Events.Types.load, loaded);
    }

    /**
     * @name Two.Texture#src
     * @property {String} - The URL path to the image data.
     * @nota-bene This property is ultimately serialized in a {@link Two.Registry} to cache retrieval.
     */
    if (typeof src === 'string') {
      this.src = src;
    } else if (typeof src === 'object') {
      var elemString = Object.prototype.toString.call(src);
      if (
        elemString === '[object HTMLImageElement]' ||
        elemString === '[object HTMLCanvasElement]' ||
        elemString === '[object HTMLVideoElement]' ||
        elemString === '[object Image]'
      ) {
        /**
         * @name Two.Texture#image
         * @property {Element} - The corresponding DOM Element of the texture. Can be a `<img />`, `<canvas />`, or `<video />` element. See {@link Two.Texture.RegularExpressions} for a full list of supported elements.
         * @nota-bene In headless environments this is a `Canvas.Image` object. See {@link https://github.com/Automattic/node-canvas} for more information on headless image objects.
         */
        this.image = src;
      }
    }

    this._update();

  }

  _.extend(Texture, {

    /**
     * @name Two.Texture.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Texture}.
     */
    Properties: [
      'id',
      'src',
      'loaded',
      'repeat'
    ],

    /**
     * @name Two.Texture.RegularExpressions
     * @property {Object} - A map of compatible DOM Elements categorized by media format.
     */
    RegularExpressions: regex$1,

    /**
     * @name Two.Texture.ImageRegistry
     * @property {Two.Registry} - A canonical listing of image data used in a single session of Two.js.
     * @nota-bene This object is used to cache image data between different textures.
     */
    ImageRegistry: new Registry(),

    /**
     * @name Two.Texture.getAbsoluteURL
     * @property {Function} - Serializes a URL as an absolute path for canonical attribution in {@link Two.ImageRegistry}.
     * @param {String} path
     * @returns {String} - The serialized absolute path.
     */
    getAbsoluteURL: function(path) {
      if (!anchor) {
        // TODO: Fix for headless environments
        return path;
      }
      anchor.href = path;
      return anchor.href;
    },

    /**
     * @name Two.Texture.loadHeadlessBuffer
     * @property {Function} - Loads an image as a buffer in headless environments.
     * @param {Two.Texture} texture - The {@link Two.Texture} to be loaded.
     * @param {Function} loaded - The callback function to be triggered once the image is loaded.
     * @nota-bene - This function uses node's `fs.readFileSync` to spoof the `<img />` loading process in the browser.
     */
    loadHeadlessBuffer: function(texture, loaded) {

      texture.image.onload = loaded;
      texture.image.src = texture.src;

    },

    /**
     * @name Two.Texture.getTag
     * @property {Function} - Retrieves the tag name of an image, video, or canvas node.
     * @param {HTMLImageElement} - The image to infer the tag name from.
     * @returns {String} - Returns the tag name of an image, video, or canvas node.
     */
    getTag: function(image) {
      return (image && image.nodeName && image.nodeName.toLowerCase())
        // Headless environments
        || 'img';
    },

    /**
     * @name Two.Texture.getImage
     * @property {Function} - Convenience function to set {@link Two.Texture#image} properties with canonincal versions set in {@link Two.Texture.ImageRegistry}.
     * @param {String} src - The URL path of the image.
     * @returns {HTMLImageElement} - Returns either a cached version of the image or a new one that is registered in {@link Two.Texture.ImageRegistry}.
     */
    getImage: function(src) {

      var absoluteSrc = Texture.getAbsoluteURL(src);

      if (Texture.ImageRegistry.contains(absoluteSrc)) {
        return Texture.ImageRegistry.get(absoluteSrc);
      }

      var image;

      if (CanvasShim.Image) {

        // TODO: Fix for headless environments
        image = new CanvasShim.Image();
        Renderer$2.Utils.shim(image, 'img');

      } else if (root$1.document) {

        if (regex$1.video.test(absoluteSrc)) {
          image = document.createElement('video');
        } else {
          image = document.createElement('img');
        }

      } else {

        console.warn('Two.js: no prototypical image defined for Two.Texture');

      }

      image.crossOrigin = 'anonymous';

      return image;

    },

    /**
     * @name Two.Register
     * @interface
     * @description A collection of functions to register different types of textures. Used internally by a {@link Two.Texture}.
     */
    Register: {
      canvas: function(texture, callback) {
        texture._src = '#' + texture.id;
        Texture.ImageRegistry.add(texture.src, texture.image);
        if (typeof callback === 'function') {
          callback();
        }
      },
      img: function(texture, callback) {

        var image = texture.image;

        var loaded = function(e) {
          if (!CanvasShim.isHeadless && image.removeEventListener && typeof image.removeEventListener === 'function') {
            image.removeEventListener('load', loaded, false);
            image.removeEventListener('error', error, false);
          }
          if (typeof callback === 'function') {
            callback();
          }
        };
        var error = function(e) {
          if (!CanvasShim.isHeadless && typeof image.removeEventListener === 'function') {
            image.removeEventListener('load', loaded, false);
            image.removeEventListener('error', error, false);
          }
          throw new TwoError('unable to load ' + texture.src);
        };

        if (typeof image.width === 'number' && image.width > 0
          && typeof image.height === 'number' && image.height > 0) {
            loaded();
        } else if (!CanvasShim.isHeadless && typeof image.addEventListener === 'function') {
          image.addEventListener('load', loaded, false);
          image.addEventListener('error', error, false);
        }

        texture._src = Texture.getAbsoluteURL(texture._src);

        if (!CanvasShim.isHeadless && image && image.getAttribute('two-src')) {
          return;
        }

        if (!CanvasShim.isHeadless) {
          image.setAttribute('two-src', texture.src);
        }

        Texture.ImageRegistry.add(texture.src, image);

        if (CanvasShim.isHeadless) {

          Texture.loadHeadlessBuffer(texture, loaded);

        } else {

          texture.image.src = texture.src;

        }

      },
      video: function(texture, callback) {

        if (CanvasShim.isHeadless) {
          throw new TwoError('video textures are not implemented in headless environments.');
        }

        var loaded = function(e) {
          texture.image.removeEventListener('canplaythrough', loaded, false);
          texture.image.removeEventListener('error', error, false);
          texture.image.width = texture.image.videoWidth;
          texture.image.height = texture.image.videoHeight;
          if (typeof callback === 'function') {
            callback();
          }
        };
        var error = function(e) {
          texture.image.removeEventListener('canplaythrough', loaded, false);
          texture.image.removeEventListener('error', error, false);
          throw new TwoError('unable to load ' + texture.src);
        };

        texture._src = Texture.getAbsoluteURL(texture._src);

        if (!texture.image.getAttribute('two-src')) {
          texture.image.setAttribute('two-src', texture.src);
          Texture.ImageRegistry.add(texture.src, texture.image);
        }

        if (texture.image.readyState >= 4) {
          loaded();
        } else {
          texture.image.addEventListener('canplaythrough', loaded, false);
          texture.image.addEventListener('error', error, false);
          texture.image.src = texture.src;
          texture.image.load();
        }

      }
    },

    /**
     * @name Two.Texture.load
     * @function
     * @param {Two.Texture} texture - The texture to load.
     * @param {Function} callback - The function to be called once the texture is loaded.
     */
    load: function(texture, callback) {

      var image = texture.image;
      var tag = Texture.getTag(image);

      if (texture._flagImage) {
        if (/canvas/i.test(tag)) {
          Texture.Register.canvas(texture, callback);
        } else {
          texture._src = (!CanvasShim.isHeadless && image.getAttribute('two-src')) || image.src;
          Texture.Register[tag](texture, callback);
        }
      }

      if (texture._flagSrc) {
        if (!image) {
          image = Texture.getImage(texture.src);
          texture.image = image;
        }
        tag = Texture.getTag(image);
        Texture.Register[tag](texture, callback);
      }

    },

    /**
     * @name Two.Texture.FlagOffset
     * @function
     * @description Cached method to let renderers know `offset` has been updated on a {@link Two.Texture}.
     */
    FlagOffset: function() {
      this._flagOffset = true;
    },

    /**
     * @name Two.Texture.FlagScale
     * @function
     * @description Cached method to let renderers know `scale` has been updated on a {@link Two.Texture}.
     */
    FlagScale: function() {
      this._flagScale = true;
    },

    /**
     * @name Two.Texture.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Texture} to any object. Handy if you'd like to extend or inherit the {@link Two.Texture} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Texture.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'image', {
        enumerable: true,
        get: function() {
          return this._image;
        },
        set: function(image) {

          var tag = Texture.getTag(image);
          var index;

          switch (tag) {
            case 'canvas':
              index = '#' + image.id;
              break;
            default:
              index = image.src;
          }

          if (Texture.ImageRegistry.contains(index)) {
            this._image = Texture.ImageRegistry.get(image.src);
          } else {
            this._image = image;
          }

          this._flagImage = true;

        }

      });

      Object.defineProperty(object, 'offset', {
        enumerable: true,
        get: function() {
          return this._offset;
        },
        set: function(v) {
          if (this._offset) {
            this._offset.unbind(Events.Types.change, this._renderer.flagOffset);
          }
          this._offset = v;
          this._offset.bind(Events.Types.change, this._renderer.flagOffset);
          this._flagOffset = true;
        }
      });

      Object.defineProperty(object, 'scale', {
        enumerable: true,
        get: function() {
          return this._scale;
        },
        set: function(v) {

          if (this._scale instanceof Vector) {
            this._scale.unbind(Events.Types.change, this._renderer.flagScale);
          }

          this._scale = v;

          if (this._scale instanceof Vector) {
            this._scale.bind(Events.Types.change, this._renderer.flagScale);
          }

          this._flagScale = true;

        }
      });

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

    }

  });

  _.extend(Texture.prototype, Events, Shape.prototype, {

    constructor: Texture,

    /**
     * @name Two.Texture#_flagId
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#id} needs updating.
     */
    _flagId: false,

    /**
     * @name Two.Texture#_flagSrc
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#src} needs updating.
     */
    _flagSrc: false,

    /**
     * @name Two.Texture#_flagImage
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#image} needs updating.
     */
    _flagImage: false,

    /**
     * @name Two.Texture#_flagVideo
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#video} needs updating.
     */
    _flagVideo: false,

    /**
     * @name Two.Texture#_flagLoaded
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#loaded} needs updating.
     */
    _flagLoaded: false,

    /**
     * @name Two.Texture#_flagRepeat
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#repeat} needs updating.
     */
    _flagRepeat: false,

    /**
     * @name Two.Texture#_flagOffset
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#offset} needs updating.
     */
    _flagOffset: false,

    /**
     * @name Two.Texture#_flagScale
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#scale} needs updating.
     */
    _flagScale: false,

    /**
     * @name Two.Texture#_id
     * @private
     * @see {@link Two.Texture#id}
     */
    _id: '',

    /**
     * @name Two.Texture#_src
     * @private
     * @see {@link Two.Texture#src}
     */
    _src: '',

    /**
     * @name Two.Texture#_image
     * @private
     * @see {@link Two.Texture#image}
     */
    _image: null,

    /**
     * @name Two.Texture#_loaded
     * @private
     * @see {@link Two.Texture#loaded}
     */
    _loaded: false,

    /**
     * @name Two.Texture#_repeat
     * @private
     * @see {@link Two.Texture#repeat}
     */
    _repeat: 'no-repeat',

    /**
     * @name Two.Texture#_scale
     * @private
     * @see {@link Two.Texture#scale}
     */
    _scale: 1,

    /**
     * @name Two.Texture#_offset
     * @private
     * @see {@link Two.Texture#offset}
     */
    _offset: null,

    /**
     * @name Two.Texture#clone
     * @function
     * @returns {Two.Texture}
     * @description Create a new instance of {@link Two.Texture} with the same properties of the current texture.
     */
    clone: function() {
      var clone = new Texture(this.src);
      clone.repeat = this.repeat;
      clone.offset.copy(this.origin);
      clone.scale = this.scale;
      return clone;
    },

    /**
     * @name Two.Texture#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the texture.
     */
    toObject: function() {
      return {
        src: this.src,
        // image: this.image,
        repeat: this.repeat,
        origin: this.origin.toObject(),
        scale: typeof this.scale === 'number' ? this.scale : this.scale.toObject()
      };
    },

    /**
     * @name Two.Texture#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagSrc || this._flagImage) {

        this.trigger(Events.Types.change);

        if (this._flagSrc || this._flagImage) {
          this.loaded = false;
          Texture.load(this, (function() {
            this.loaded = true;
            this
              .trigger(Events.Types.change)
              .trigger(Events.Types.load);
          }).bind(this));
        }

      }

      if (this._image && this._image.readyState >= 4) {
        this._flagVideo = true;
      }

      return this;

    },

    /**
     * @name Two.Texture#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagSrc = this._flagImage = this._flagLoaded
        = this._flagVideo = this._flagScale = this._flagOffset = false;

      return this;

    }

  });

  Texture.MakeObservable(Texture.prototype);

  // Constants

  var min$1 = Math.min, max$1 = Math.max,
    ceil = Math.ceil, floor = Math.floor;

  /**
   * @name Two.Path
   * @class
   * @extends Two.Shape
   * @param {Two.Anchor[]} [vertices] - A list of {@link Two.Anchor}s that represent the order and coordinates to construct the rendered shape.
   * @param {Boolean} [closed=false] - Describes whether the shape is closed or open.
   * @param {Boolean} [curved=false] - Describes whether the shape automatically calculates bezier handles for each vertex.
   * @param {Boolean} [manual=false] - Describes whether the developer controls how vertices are plotted or if Two.js automatically plots coordinates based on closed and curved booleans.
   * @description This is the primary primitive class for creating all drawable shapes in Two.js. Unless specified methods return their instance of `Two.Path` for the purpose of chaining.
   */
  function Path(vertices, closed, curved, manual) {

    Shape.call(this);

    this._renderer.type = 'path';
    this._renderer.flagVertices = Path.FlagVertices.bind(this);
    this._renderer.bindVertices = Path.BindVertices.bind(this);
    this._renderer.unbindVertices = Path.UnbindVertices.bind(this);

    this._renderer.flagFill = Path.FlagFill.bind(this);
    this._renderer.flagStroke = Path.FlagStroke.bind(this);
    this._renderer.vertices = [];
    this._renderer.collection = [];

    /**
     * @name Two.Path#closed
     * @property {Boolean} - Determines whether a final line is drawn between the final point in the `vertices` array and the first point.
     */
    this._closed = !!closed;

    /**
     * @name Two.Path#curved
     * @property {Boolean} - When the path is `automatic = true` this boolean determines whether the lines between the points are curved or not.
     */
    this._curved = !!curved;

    /**
     * @name Two.Path#beginning
     * @property {Number} - Number between zero and one to state the beginning of where the path is rendered.
     * @description {@link Two.Path#beginning} is a percentage value that represents at what percentage into the path should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Path#ending}.
     */
    this.beginning = 0;

    /**
     * @name Two.Path#ending
     * @property {Number} - Number between zero and one to state the ending of where the path is rendered.
     * @description {@link Two.Path#ending} is a percentage value that represents at what percentage into the path should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Path#beginning}.
     */
    this.ending = 1;

    // Style properties

    /**
     * @name Two.Path#fill
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the path should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    this.fill = '#fff';

    /**
     * @name Two.Path#stroke
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the path should be outlined in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    this.stroke = '#000';

    /**
     * @name Two.Path#linewidth
     * @property {Number} - The thickness in pixels of the stroke.
     */
    this.linewidth = 1.0;

    /**
     * @name Two.Path#opacity
     * @property {Number} - The opaqueness of the path.
     * @nota-bene Can be used in conjunction with CSS Colors that have an alpha value.
     */
    this.opacity = 1.0;

    /**
     * @name Two.Path#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling.
     * @nota-bene Only available for the SVG renderer.
     */
    this.className = '';

    /**
     * @name Two.Path#visible
     * @property {Boolean} - Display the path or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    this.visible = true;

    /**
     * @name Two.Path#cap
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty}
     */
    this.cap = 'butt';      // Default of Adobe Illustrator

    /**
     * @name Two.Path#join
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty}
     */
    this.join = 'miter';    // Default of Adobe Illustrator

    /**
     * @name Two.Path#miter
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeMiterlimitProperty}
     */
    this.miter = 4;         // Default of Adobe Illustrator

    /**
     * @name Two.Path#vertices
     * @property {Two.Anchor[]} - An ordered list of anchor points for rendering the path.
     * @description A list of {@link Two.Anchor} objects that consist of what form the path takes.
     * @nota-bene The array when manipulating is actually a {@link Two.Collection}.
     */
    this.vertices = vertices;

    /**
     * @name Two.Path#automatic
     * @property {Boolean} - Determines whether or not Two.js should calculate curves, lines, and commands automatically for you or to let the developer manipulate them for themselves.
     */
    this.automatic = !manual;

    /**
     * @name Two.Path#dashes
     * @property {Number[]} - Array of numbers. Odd indices represent dash length. Even indices represent dash space.
     * @description A list of numbers that represent the repeated dash length and dash space applied to the stroke of the text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more information on the SVG stroke-dasharray attribute.
     */
    this.dashes = [];

    /**
     * @name Two.Path#dashes#offset
     * @property {Number} - A number in pixels to offset {@link Two.Path#dashes} display.
     */
    this.dashes.offset = 0;

  }

  _.extend(Path, {

    /**
     * @name Two.Path.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Path}.
     */
    Properties: [
      'fill',
      'stroke',
      'linewidth',
      'opacity',
      'visible',
      'cap',
      'join',
      'miter',

      'closed',
      'curved',
      'automatic',
      'beginning',
      'ending'
    ],

    Utils: {
      getCurveLength: getCurveLength
    },

    /**
     * @name Two.Path.FlagVertices
     * @function
     * @description Cached method to let renderers know vertices have been updated on a {@link Two.Path}.
     */
    FlagVertices: function() {
      this._flagVertices = true;
      this._flagLength = true;
      if (this.parent) {
        this.parent._flagLength = true;
      }
    },

    /**
     * @name Two.Path.BindVertices
     * @function
     * @description Cached method to let {@link Two.Path} know vertices have been added to the instance.
     */
    BindVertices: function(items) {

      // This function is called a lot
      // when importing a large SVG
      var i = items.length;
      while (i--) {
        items[i].bind(Events.Types.change, this._renderer.flagVertices);
      }

      this._renderer.flagVertices();

    },

    /**
     * @name Two.Path.UnbindVertices
     * @function
     * @description Cached method to let {@link Two.Path} know vertices have been removed from the instance.
     */
    UnbindVertices: function(items) {

      var i = items.length;
      while (i--) {
        items[i].unbind(Events.Types.change, this._renderer.flagVertices);
      }

      this._renderer.flagVertices();

    },

    /**
     * @name Two.Path.FlagFill
     * @function
     * @description Cached method to let {@link Two.Path} know the fill has changed.
     */
    FlagFill: function() {
      this._flagFill = true;
    },

    /**
     * @name Two.Path.FlagFill
     * @function
     * @description Cached method to let {@link Two.Path} know the stroke has changed.
     */
    FlagStroke: function() {
      this._flagStroke = true;
    },

    /**
     * @name Two.Path.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Path} to any object. Handy if you'd like to extend the {@link Two.Path} class on a custom class.
     */
    MakeObservable: function(object) {

      Shape.MakeObservable(object);

      // Only the 7 defined properties are flagged like this. The subsequent
      // properties behave differently and need to be hand written.
      _.each(Path.Properties.slice(2, 8), defineGetterSetter, object);

      Object.defineProperty(object, 'fill', {
        enumerable: true,
        get: function() {
          return this._fill;
        },
        set: function(f) {

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.unbind(Events.Types.change, this._renderer.flagFill);
          }

          this._fill = f;
          this._flagFill = true;

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.bind(Events.Types.change, this._renderer.flagFill);
          }

        }
      });

      Object.defineProperty(object, 'stroke', {
        enumerable: true,
        get: function() {
          return this._stroke;
        },
        set: function(f) {

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.unbind(Events.Types.change, this._renderer.flagStroke);
          }

          this._stroke = f;
          this._flagStroke = true;

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.bind(Events.Types.change, this._renderer.flagStroke);
          }

        }
      });

      /**
       * @name Two.Path#length
       * @property {Number} - The sum of distances between all {@link Two.Path#vertices}.
       */
      Object.defineProperty(object, 'length', {
        get: function() {
          if (this._flagLength) {
            this._updateLength();
          }
          return this._length;
        }
      });

      Object.defineProperty(object, 'closed', {
        enumerable: true,
        get: function() {
          return this._closed;
        },
        set: function(v) {
          this._closed = !!v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'curved', {
        enumerable: true,
        get: function() {
          return this._curved;
        },
        set: function(v) {
          this._curved = !!v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'automatic', {
        enumerable: true,
        get: function() {
          return this._automatic;
        },
        set: function(v) {
          if (v === this._automatic) {
            return;
          }
          this._automatic = !!v;
          var method = this._automatic ? 'ignore' : 'listen';
          _.each(this.vertices, function(v) {
            v[method]();
          });
        }
      });

      Object.defineProperty(object, 'beginning', {
        enumerable: true,
        get: function() {
          return this._beginning;
        },
        set: function(v) {
          this._beginning = v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'ending', {
        enumerable: true,
        get: function() {
          return this._ending;
        },
        set: function(v) {
          this._ending = v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'vertices', {

        enumerable: true,

        get: function() {
          return this._collection;
        },

        set: function(vertices) {

          var bindVertices = this._renderer.bindVertices;
          var unbindVertices = this._renderer.unbindVertices;

          // Remove previous listeners
          if (this._collection) {
            this._collection
              .unbind(Events.Types.insert, bindVertices)
              .unbind(Events.Types.remove, unbindVertices);
          }

          // Create new Collection with copy of vertices
          if (vertices instanceof Collection) {
            this._collection = vertices;
          } else {
            this._collection = new Collection(vertices || []);
          }


          // Listen for Collection changes and bind / unbind
          this._collection
            .bind(Events.Types.insert, bindVertices)
            .bind(Events.Types.remove, unbindVertices);

          // Bind Initial Vertices
          bindVertices(this._collection);

        }

      });

      /**
       * @name Two.Path#mask
       * @property {Two.Shape} - The shape whose alpha property becomes a clipping area for the path.
       * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
       */
      Object.defineProperty(object, 'mask', {

        enumerable: true,

        get: function() {
          return this._mask;
        },

        set: function(v) {
          this._mask = v;
          this._flagMask = true;
          if (!v.clip) {
            v.clip = true;
          }
        }

      });

      /**
       * @name Two.Path#clip
       * @property {Boolean} - Tells Two.js renderer if this object represents a mask for another object (or not).
       */
      Object.defineProperty(object, 'clip', {
        enumerable: true,
        get: function() {
          return this._clip;
        },
        set: function(v) {
          this._clip = v;
          this._flagClip = true;
        }
      });

      Object.defineProperty(object, 'dashes', {
        enumerable: true,
        get: function() {
          return this._dashes;
        },
        set: function(v) {
          if (typeof v.offset !== 'number') {
            v.offset = this._dashes.offset || 0;
          }
          this._dashes = v;
        }
      });

    }

  });

  _.extend(Path.prototype, Shape.prototype, {

    constructor: Path,

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Path#_flagVertices
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#vertices} need updating.
     */
    _flagVertices: true,

    /**
     * @name Two.Path#_flagLength
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#length} needs updating.
     */
    _flagLength: true,

    /**
     * @name Two.Path#_flagFill
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#fill} needs updating.
     */
    _flagFill: true,

    /**
     * @name Two.Path#_flagStroke
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#stroke} needs updating.
     */
    _flagStroke: true,

    /**
     * @name Two.Path#_flagLinewidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#linewidth} needs updating.
     */
    _flagLinewidth: true,

    /**
     * @name Two.Path#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#opacity} needs updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Path#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#visible} needs updating.
     */
    _flagVisible: true,

    /**
     * @name Two.Path#_flagCap
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#cap} needs updating.
     */
    _flagCap: true,

    /**
     * @name Two.Path#_flagJoin
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#join} needs updating.
     */
    _flagJoin: true,

    /**
     * @name Two.Path#_flagMiter
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#miter} needs updating.
     */
    _flagMiter: true,

    /**
     * @name Two.Path#_flagMask
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#mask} needs updating.
     */
    _flagMask: false,

    /**
     * @name Two.Path#_flagClip
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#clip} needs updating.
     */
    _flagClip: false,

    // Underlying Properties

    /**
     * @name Two.Path#_length
     * @private
     * @see {@link Two.Path#length}
     */
    _length: 0,

    /**
     * @name Two.Path#_fill
     * @private
     * @see {@link Two.Path#fill}
     */
    _fill: '#fff',

    /**
     * @name Two.Path#_stroke
     * @private
     * @see {@link Two.Path#stroke}
     */
    _stroke: '#000',

    /**
     * @name Two.Path#_linewidth
     * @private
     * @see {@link Two.Path#linewidth}
     */
    _linewidth: 1.0,

    /**
     * @name Two.Path#_opacity
     * @private
     * @see {@link Two.Path#opacity}
     */
    _opacity: 1.0,

    /**
     * @name Two.Path#_visible
     * @private
     * @see {@link Two.Path#visible}
     */
    _visible: true,

    /**
     * @name Two.Path#_cap
     * @private
     * @see {@link Two.Path#cap}
     */
    _cap: 'round',

    /**
     * @name Two.Path#_join
     * @private
     * @see {@link Two.Path#join}
     */
    _join: 'round',

    /**
     * @name Two.Path#_miter
     * @private
     * @see {@link Two.Path#miter}
     */
    _miter: 4,

    /**
     * @name Two.Path#_closed
     * @private
     * @see {@link Two.Path#closed}
     */
    _closed: true,

    /**
     * @name Two.Path#_curved
     * @private
     * @see {@link Two.Path#curved}
     */
    _curved: false,

    /**
     * @name Two.Path#_automatic
     * @private
     * @see {@link Two.Path#automatic}
     */
    _automatic: true,

    /**
     * @name Two.Path#_beginning
     * @private
     * @see {@link Two.Path#beginning}
     */
    _beginning: 0,

    /**
     * @name Two.Path#_ending
     * @private
     * @see {@link Two.Path#ending}
     */
    _ending: 1.0,

    /**
     * @name Two.Path#_mask
     * @private
     * @see {@link Two.Path#mask}
     */
    _mask: null,

    /**
     * @name Two.Path#_clip
     * @private
     * @see {@link Two.Path#clip}
     */
    _clip: false,

    /**
     * @name Two.Path#_dashes
     * @private
     * @see {@link Two.Path#dashes}
     */
    _dashes: [],

    /**
     * @name Two.Path#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Path}
     * @description Create a new instance of {@link Two.Path} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Path();

      for (var j = 0; j < this.vertices.length; j++) {
        clone.vertices.push(this.vertices[j].clone());
      }

      for (var i = 0; i < Path.Properties.length; i++) {
        var k = Path.Properties[i];
        clone[k] = this[k];
      }

      clone.className = this.className;

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Path#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {
        vertices: this.vertices.map(function(v) {
          return v.toObject();
        })
      };

      _.each(Path.Properties, function(k) {
        result[k] = this[k];
      }, this);

      result.className = this.className;

      result.translation = this.translation.toObject();
      result.rotation = this.rotation;
      result.scale = this.scale instanceof Vector ? this.scale.toObject() : this.scale;
      result.skewX = this.skewX;
      result.skewY = this.skewY;

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      return result;

    },

    /**
     * @name Two.Path#noFill
     * @function
     * @description Short hand method to set fill to `transparent`.
     */
    noFill: function() {
      this.fill = 'transparent';
      return this;
    },

    /**
     * @name Two.Path#noStroke
     * @function
     * @description Short hand method to set stroke to `transparent`.
     */
    noStroke: function() {
      this.stroke = undefined;
      return this;
    },

    /**
     * @name Two.Path#corner
     * @function
     * @description Orient the vertices of the shape to the upper left-hand corner of the path.
     */
    corner: function() {

      var rect = this.getBoundingClientRect(true);
      var hw = rect.width / 2;
      var hh = rect.height / 2;
      var cx = rect.left + rect.width / 2;
      var cy = rect.top + rect.height / 2;

      for (var i = 0; i < this.vertices.length; i++) {
        var v = this.vertices[i];
        v.x -= cx;
        v.y -= cy;
        v.x += hw;
        v.y += hh;
      }

      return this;

    },

    /**
     * @name Two.Path#center
     * @function
     * @description Orient the vertices of the shape to the center of the path.
     */
    center: function() {

      var rect = this.getBoundingClientRect(true);

      var cx = rect.left + rect.width / 2 - this.translation.x;
      var cy = rect.top + rect.height / 2 - this.translation.y;

      for (var i = 0; i < this.vertices.length; i++) {
        var v = this.vertices[i];
        v.x -= cx;
        v.y -= cy;
      }

      return this;

    },

    /**
     * @name Two.Path#remove
     * @function
     * @description Remove self from the scene / parent.
     */
    remove: function() {

      if (!this.parent) {
        return this;
      }

      this.parent.remove(this);

      return this;

    },

    /**
     * @name Two.Path#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the path.
     */
    getBoundingClientRect: function(shallow) {
      var matrix, border, l, i, v0, v1, c0x, c0y, c1x, c1y, a, b, c, d;

      var left = Infinity, right = -Infinity,
          top = Infinity, bottom = -Infinity;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      border = (this.linewidth || 0) / 2;
      l = this._renderer.vertices.length;

      if (l <= 0) {
        return {
          width: 0,
          height: 0
        };
      }

      for (i = 0; i < l; i++) {

        v1 = this._renderer.vertices[i];
        // If i = 0, then this "wraps around" to the last vertex. Otherwise, it's the previous vertex.
        // This is important for handling cyclic paths.
        v0 = this._renderer.vertices[(i + l - 1) % l];

        if (v0.controls && v1.controls) {

          c0x = v0.controls.right.x;
          c0y = v0.controls.right.y;

          if (v0.relative) {
            c0x += v0.x;
            c0y += v0.y;
          }

          c1x = v1.controls.left.x;
          c1y = v1.controls.left.y;

          if (v1.relative) {
            c1x += v1.x;
            c1y += v1.y;
          }

          var bb = getCurveBoundingBox(v0.x, v0.y,
            c0x, c0y, c1x, c1y, v1.x, v1.y);

          top = min$1(bb.min.y - border, top);
          left = min$1(bb.min.x - border, left);
          right = max$1(bb.max.x + border, right);
          bottom = max$1(bb.max.y + border, bottom);

        } else {

          if (i <= 1) {

            top = min$1(v0.y - border, top);
            left = min$1(v0.x - border, left);
            right = max$1(v0.x + border, right);
            bottom = max$1(v0.y + border, bottom);

          }

          top = min$1(v1.y - border, top);
          left = min$1(v1.x - border, left);
          right = max$1(v1.x + border, right);
          bottom = max$1(v1.y + border, bottom);

        }

      }

      a = matrix.multiply(left, top, 1);
      b = matrix.multiply(left, bottom, 1);
      c = matrix.multiply(right, top, 1);
      d = matrix.multiply(right, bottom, 1);

      top = min$1(a.y, b.y, c.y, d.y);
      left = min$1(a.x, b.x, c.x, d.x);
      right = max$1(a.x, b.x, c.x, d.x);
      bottom = max$1(a.y, b.y, c.y, d.y);

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Path#getPointAt
     * @function
     * @param {Boolean} t - Percentage value describing where on the Two.Path to estimate and assign coordinate values.
     * @param {Two.Vector} [obj=undefined] - Object to apply calculated x, y to. If none available returns new Object.
     * @returns {Object}
     * @description Given a float `t` from 0 to 1, return a point or assign a passed `obj`'s coordinates to that percentage on this Two.Path's curve.
     */
    getPointAt: function(t, obj) {

      var ia, ib, result;
      var x, x1, x2, x3, x4, y, y1, y2, y3, y4, left, right;
      var target = this.length * Math.min(Math.max(t, 0), 1);
      var length = this.vertices.length;
      var last = length - 1;

      var a = null;
      var b = null;

      for (var i = 0, l = this._lengths.length, sum = 0; i < l; i++) {

        if (sum + this._lengths[i] >= target) {

          if (this._closed) {
            ia = mod(i, length);
            ib = mod(i - 1, length);
            if (i === 0) {
              ia = ib;
              ib = i;
            }
          } else {
            ia = i;
            ib = Math.min(Math.max(i - 1, 0), last);
          }

          a = this.vertices[ia];
          b = this.vertices[ib];
          target -= sum;
          if (this._lengths[i] !== 0) {
            t = target / this._lengths[i];
          } else {
            t = 0;
          }

          break;

        }

        sum += this._lengths[i];

      }

      if (a === null || b === null) {
        return null;
      }

      if (!a) {
        return b;
      } else if (!b) {
        return a;
      }

      right = b.controls && b.controls.right;
      left = a.controls && a.controls.left;

      x1 = b.x;
      y1 = b.y;
      x2 = (right || b).x;
      y2 = (right || b).y;
      x3 = (left || a).x;
      y3 = (left || a).y;
      x4 = a.x;
      y4 = a.y;

      if (right && b.relative) {
        x2 += b.x;
        y2 += b.y;
      }

      if (left && a.relative) {
        x3 += a.x;
        y3 += a.y;
      }

      x = getComponentOnCubicBezier(t, x1, x2, x3, x4);
      y = getComponentOnCubicBezier(t, y1, y2, y3, y4);

      // Higher order points for control calculation.
      var t1x = lerp(x1, x2, t);
      var t1y = lerp(y1, y2, t);
      var t2x = lerp(x2, x3, t);
      var t2y = lerp(y2, y3, t);
      var t3x = lerp(x3, x4, t);
      var t3y = lerp(y3, y4, t);

      // Calculate the returned points control points.
      var brx = lerp(t1x, t2x, t);
      var bry = lerp(t1y, t2y, t);
      var alx = lerp(t2x, t3x, t);
      var aly = lerp(t2y, t3y, t);

      if (_.isObject(obj)) {

        obj.x = x;
        obj.y = y;

        if (!_.isObject(obj.controls)) {
          Anchor.AppendCurveProperties(obj);
        }

        obj.controls.left.x = brx;
        obj.controls.left.y = bry;
        obj.controls.right.x = alx;
        obj.controls.right.y = aly;

        if (!typeof obj.relative === 'boolean' || obj.relative) {
          obj.controls.left.x -= x;
          obj.controls.left.y -= y;
          obj.controls.right.x -= x;
          obj.controls.right.y -= y;
        }

        obj.t = t;

        return obj;

      }

      result = new Anchor(
        x, y, brx - x, bry - y, alx - x, aly - y,
        this._curved ? Commands.curve : Commands.line
      );

      result.t = t;

      return result;

    },

    /**
     * @name Two.Path#plot
     * @function
     * @description Based on closed / curved and sorting of vertices plot where all points should be and where the respective handles should be too.
     * @nota-bene While this method is public it is internally called by {@link Two.Path#_update} when `automatic = true`.
     */
    plot: function() {

      if (this.curved) {
        getCurveFromPoints(this._collection, this.closed);
        return this;
      }

      for (var i = 0; i < this._collection.length; i++) {
        this._collection[i].command = i === 0 ? Commands.move : Commands.line;
      }

      return this;

    },

    /**
     * @name Two.Path#subdivide
     * @function
     * @param {Number} limit - How many times to recurse subdivisions.
     * @description Insert a {@link Two.Anchor} at the midpoint between every item in {@link Two.Path#vertices}.
     */
    subdivide: function(limit) {
      //TODO: DRYness (function below)
      this._update();

      var last = this.vertices.length - 1;
      var b = this.vertices[last];
      var closed = this._closed || this.vertices[last]._command === Commands.close;
      var points = [];
      _.each(this.vertices, function(a, i) {

        if (i <= 0 && !closed) {
          b = a;
          return;
        }

        if (a.command === Commands.move) {
          points.push(new Anchor(b.x, b.y));
          if (i > 0) {
            points[points.length - 1].command = Commands.line;
          }
          b = a;
          return;
        }

        var verts = getSubdivisions(a, b, limit);
        points = points.concat(verts);

        // Assign commands to all the verts
        _.each(verts, function(v, i) {
          if (i <= 0 && b.command === Commands.move) {
            v.command = Commands.move;
          } else {
            v.command = Commands.line;
          }
        });

        if (i >= last) {

          // TODO: Add check if the two vectors in question are the same values.
          if (this._closed && this._automatic) {

            b = a;

            verts = getSubdivisions(a, b, limit);
            points = points.concat(verts);

            // Assign commands to all the verts
            _.each(verts, function(v, i) {
              if (i <= 0 && b.command === Commands.move) {
                v.command = Commands.move;
              } else {
                v.command = Commands.line;
              }
            });

          } else if (closed) {
            points.push(new Anchor(a.x, a.y));
          }

          points[points.length - 1].command = closed
            ? Commands.close : Commands.line;

        }

        b = a;

      }, this);

      this._automatic = false;
      this._curved = false;
      this.vertices = points;

      return this;

    },

    /**
     * @name Two.Path#_updateLength
     * @function
     * @private
     * @param {Number} [limit=] -
     * @param {Boolean} [silent=false] - If set to `true` then the path isn't updated before calculation. Useful for internal use.
     * @description Recalculate the {@link Two.Path#length} value.
     */
    _updateLength: function(limit, silent) {
      //TODO: DRYness (function above)
      if (!silent) {
        this._update();
      }

      var length = this.vertices.length;
      var last = length - 1;
      var b = this.vertices[last];
      var closed = false;//this._closed || this.vertices[last]._command === Commands.close;
      var sum = 0;

      if (typeof this._lengths === 'undefined') {
        this._lengths = [];
      }

      _.each(this.vertices, function(a, i) {

        if ((i <= 0 && !closed) || a.command === Commands.move) {
          b = a;
          this._lengths[i] = 0;
          return;
        }

        this._lengths[i] = getCurveLength(a, b, limit);
        sum += this._lengths[i];

        if (i >= last && closed) {

          b = this.vertices[(i + 1) % length];

          this._lengths[i + 1] = getCurveLength(a, b, limit);
          sum += this._lengths[i + 1];

        }

        b = a;

      }, this);

      this._length = sum;
      this._flagLength = false;

      return this;

    },

    /**
     * @name Two.Path#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices) {

        if (this._automatic) {
          this.plot();
        }

        if (this._flagLength) {
          this._updateLength(undefined, true);
        }

        var l = this._collection.length;
        var closed = this._closed;

        var beginning = Math.min(this._beginning, this._ending);
        var ending = Math.max(this._beginning, this._ending);

        var bid = getIdByLength(this, beginning * this._length);
        var eid = getIdByLength(this, ending * this._length);

        var low = ceil(bid);
        var high = floor(eid);

        var left, right, prev, next, v;

        this._renderer.vertices.length = 0;

        for (var i = 0; i < l; i++) {

          if (this._renderer.collection.length <= i) {
            // Expected to be `relative` anchor points.
            this._renderer.collection.push(new Anchor());
          }

          if (i > high && !right) {

            v = this._renderer.collection[i];
            v.copy(this._collection[i]);
            this.getPointAt(ending, v);
            v.command = this._renderer.collection[i].command;
            this._renderer.vertices.push(v);

            right = v;
            prev = this._collection[i - 1];

            // Project control over the percentage `t`
            // of the in-between point
            if (prev && prev.controls) {

              v.controls.right.clear();

              this._renderer.collection[i - 1].controls.right
                .clear()
                .lerp(prev.controls.right, v.t);

            }

          } else if (i >= low && i <= high) {

            v = this._renderer.collection[i]
              .copy(this._collection[i]);
            this._renderer.vertices.push(v);

            if (i === high && contains(this, ending)) {
              right = v;
              if (!closed && right.controls) {
                right.controls.right.clear();
              }
            } else if (i === low && contains(this, beginning)) {
              left = v;
              left.command = Commands.move;
              if (!closed && left.controls) {
                left.controls.left.clear();
              }
            }

          }

        }

        // Prepend the trimmed point if necessary.
        if (low > 0 && !left) {

          i = low - 1;

          v = this._renderer.collection[i];
          v.copy(this._collection[i]);
          this.getPointAt(beginning, v);
          v.command = Commands.move;
          this._renderer.vertices.unshift(v);

          left = v;
          next = this._collection[i + 1];

          // Project control over the percentage `t`
          // of the in-between point
          if (next && next.controls) {

            v.controls.left.clear();

            this._renderer.collection[i + 1].controls.left
              .copy(next.controls.left)
              .lerp(Vector.zero, v.t);

          }

        }

      }

      Shape.prototype._update.apply(this, arguments);

      return this;

    },

    /**
     * @name Two.Path#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagVertices =  this._flagFill =  this._flagStroke =
          this._flagLinewidth = this._flagOpacity = this._flagVisible =
          this._flagCap = this._flagJoin = this._flagMiter =
          this._flagClip = false;

      Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Path.MakeObservable(Path.prototype);

    // Utility functions

  function contains(path, t) {

    if (t === 0 || t === 1) {
      return true;
    }

    var length = path._length;
    var target = length * t;
    var elapsed = 0;

    for (var i = 0; i < path._lengths.length; i++) {
      var dist = path._lengths[i];
      if (elapsed >= target) {
        return target - elapsed >= 0;
      }
      elapsed += dist;
    }

    return false;

  }

  /**
   * @private
   * @param {Two.Path} path - The path to analyze against.
   * @param {Number} target - The target length at which to find an anchor.
   * @returns {Number}
   * @description Return the id of an anchor based on a target length.
   */
  function getIdByLength(path, target) {

    var total = path._length;

    if (target <= 0) {
      return 0;
    } else if (target >= total) {
      return path._lengths.length - 1;
    }

    for (var i = 0, sum = 0; i < path._lengths.length; i++) {

      if (sum + path._lengths[i] >= target) {
        target -= sum;
        return Math.max(i - 1, 0) + target / path._lengths[i];
      }

      sum += path._lengths[i];

    }

    return - 1;

  }

  function getCurveLength(a, b, limit) {
    // TODO: DRYness
    var x1, x2, x3, x4, y1, y2, y3, y4;

    var right = b.controls && b.controls.right;
    var left = a.controls && a.controls.left;

    x1 = b.x;
    y1 = b.y;
    x2 = (right || b).x;
    y2 = (right || b).y;
    x3 = (left || a).x;
    y3 = (left || a).y;
    x4 = a.x;
    y4 = a.y;

    if (right && b._relative) {
      x2 += b.x;
      y2 += b.y;
    }

    if (left && a._relative) {
      x3 += a.x;
      y3 += a.y;
    }

    return getCurveLength$1(x1, y1, x2, y2, x3, y3, x4, y4, limit);

  }

  function getSubdivisions(a, b, limit) {
    // TODO: DRYness
    var x1, x2, x3, x4, y1, y2, y3, y4;

    var right = b.controls && b.controls.right;
    var left = a.controls && a.controls.left;

    x1 = b.x;
    y1 = b.y;
    x2 = (right || b).x;
    y2 = (right || b).y;
    x3 = (left || a).x;
    y3 = (left || a).y;
    x4 = a.x;
    y4 = a.y;

    if (right && b._relative) {
      x2 += b.x;
      y2 += b.y;
    }

    if (left && a._relative) {
      x3 += a.x;
      y3 += a.y;
    }

    return subdivide(x1, y1, x2, y2, x3, y3, x4, y4, limit);

  }

  /**
   * @name Two.Rectangle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the rectangle.
   * @param {Number} [y=0] - The y position of the rectangle.
   * @param {Number} [width] - The width value of the rectangle.
   * @param {Number} [height] - The width value of the rectangle.
   */
  function Rectangle(x, y, width, height) {

    Path.call(this, [
      new Anchor(),
      new Anchor(),
      new Anchor(),
      new Anchor()
      // new Anchor() // TODO: Figure out how to handle this for `beginning` / `ending` animations
    ], true, false, true);

    /**
     * @name Two.Rectangle#width
     * @property {Number} - The size of the width of the rectangle.
     */
    this.width = width;
    /**
     * @name Two.Rectangle#height
     * @property {Number} - The size of the height of the rectangle.
     */
    this.height = height;

    /**
     * @name Two.Rectangle#origin
     * @property {Number} - A two-component vector describing the origin offset to draw the rectangle. Default is `0, 0`.
     */
    this.origin = new Vector();
    this.translation.set(x, y);

    this._update();

  }

  _.extend(Rectangle, {

    /**
     * @name Two.Rectangle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Rectangle}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.Rectangle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Rectangle} to any object. Handy if you'd like to extend the {@link Two.Rectangle} class on a custom class.
     */
    MakeObservable: function(object) {

      Path.MakeObservable(object);
      _.each(Rectangle.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'origin', {
        enumerable: true,
        get: function() {
          return this._origin;
        },
        set: function(v) {
          if (this._origin) {
            this._origin.unbind(Events.Types.change, this._renderer.flagVertices);
          }
          this._origin = v;
          this._origin.bind(Events.Types.change, this._renderer.flagVertices);
          this._renderer.flagVertices();
        }
      });

    }

  });

  _.extend(Rectangle.prototype, Path.prototype, {

    constructor: Rectangle,

    /**
     * @name Two.Rectangle#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Rectangle#width} needs updating.
     */
    _flagWidth: 0,
    /**
     * @name Two.Rectangle#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Rectangle#height} needs updating.
     */
    _flagHeight: 0,

    /**
     * @name Two.Rectangle#_width
     * @private
     * @see {@link Two.Rectangle#width}
     */
    _width: 0,
    /**
     * @name Two.Rectangle#_height
     * @private
     * @see {@link Two.Rectangle#height}
     */
    _height: 0,

    _origin: null,

    /**
     * @name Two.Rectangle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight) {

        var xr = this._width / 2;
        var yr = this._height / 2;

        if (!this._closed && this.vertices.length === 4) {
          this.vertices.push(new Anchor());
        }

        this.vertices[0].set(-xr, -yr).add(this._origin).command = Commands.move;
        this.vertices[1].set(xr, -yr).add(this._origin).command = Commands.line;
        this.vertices[2].set(xr, yr).add(this._origin).command = Commands.line;
        this.vertices[3].set(-xr, yr).add(this._origin).command = Commands.line;
        // FYI: Two.Sprite and Two.ImageSequence have 4 verts
        if (this.vertices[4]) {
          this.vertices[4].set(-xr, -yr).add(this._origin).command = Commands.line;
        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Rectangle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Rectangle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Rectangle}
     * @description Create a new instance of {@link Two.Rectangle} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Rectangle(0, 0, this.width, this.height);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Rectangle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);
      object.width = this.width;
      object.height = this.height;
      object.origin = this.origin.toObject();
      return object;

    }

  });

  Rectangle.MakeObservable(Rectangle.prototype);

  /**
   * @name Two.Sprite
   * @class
   * @extends Two.Rectangle
   * @param {String|Two.Texture} [path] - The URL path or {@link Two.Texture} to be used as the bitmap data displayed on the sprite.
   * @param {Number} [ox=0] - The initial `x` position of the Two.Sprite.
   * @param {Number} [oy=0] - The initial `y` position of the Two.Sprite.
   * @param {Number} [cols=1] - The number of columns the sprite contains.
   * @param {Number} [rows=1] - The number of rows the sprite contains.
   * @param {Number} [frameRate=0] - The frame rate at which the partitions of the image should playback at.
   * @description A convenient package to display still or animated images through a tiled image source. For more information on the principals of animated imagery through tiling see [Texture Atlas](https://en.wikipedia.org/wiki/Texture_atlas) on Wikipedia.
   */
  function Sprite(path, ox, oy, cols, rows, frameRate) {

    // Not using default constructor of Rectangle due to odd `beginning` / `ending` behavior.
    // See: https://github.com/jonobr1/two.js/issues/383
    Path.call(this, [
      new Anchor(),
      new Anchor(),
      new Anchor(),
      new Anchor()
    ], true);

    this.noStroke();
    this.noFill();

    /**
     * @name Two.Sprite#texture
     * @property {Two.Texture} - The texture to be used as bitmap data to display image in the scene.
     */
    if (path instanceof Texture) {
      this.texture = path;
    } else if (typeof path === 'string') {
      this.texture = new Texture(path);
    }

    this.origin = new Vector();

    this._update();
    this.translation.set(ox || 0, oy || 0);

    /**
     * @name Two.Sprite#columns
     * @property {Number} - The number of columns to split the texture into. Defaults to `1`.
     */
    if (typeof cols === 'number') {
      this.columns = cols;
    }

    /**
     * @name Two.Sprite#rows
     * @property {Number} - The number of rows to split the texture into. Defaults to `1`.
     */
    if (typeof rows === 'number') {
      this.rows = rows;
    }

    /**
     * @name Two.Sprite#frameRate
     * @property {Number} - The number of frames to animate against per second. Defaults to `0` for non-animated sprites.
     */
    if (typeof frameRate === 'number') {
      this.frameRate = frameRate;
    }

    /**
     * @name Two.Sprite#index
     * @property {Number} - The index of the current tile of the sprite to display. Defaults to `0`.
     */
    this.index = 0;

  }

  _.extend(Sprite, {

    /**
     * @name Two.Sprite.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Sprite}.
     */
    Properties: [
      'texture', 'columns', 'rows', 'frameRate', 'index'
    ],

    /**
     * @name Two.Sprite.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Sprite} to any object. Handy if you'd like to extend or inherit the {@link Two.Sprite} class on a custom class.
     */
    MakeObservable: function(obj) {

      Rectangle.MakeObservable(obj);
      _.each(Sprite.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Sprite.prototype, Rectangle.prototype, {

    constructor: Sprite,

    /**
     * @name Two.Sprite#_flagTexture
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#texture} needs updating.
     */
    _flagTexture: false,

    /**
     * @name Two.Sprite#_flagColumns
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#columns} need updating.
     */
    _flagColumns: false,

    /**
     * @name Two.Sprite#_flagRows
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#rows} need updating.
     */
    _flagRows: false,

    /**
     * @name Two.Sprite#_flagFrameRate
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#flagFrameRate} needs updating.
     */
    _flagFrameRate: false,

    /**
     * @name Two.Sprite#_flagIndex
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#index} needs updating.
     */
    flagIndex: false,

    // Private variables

    /**
     * @name Two.Sprite#_amount
     * @private
     * @property {Number} - Number of frames for a given {@link Two.Sprite}.
     */
    _amount: 1,

    /**
     * @name Two.Sprite#_duration
     * @private
     * @property {Number} - Number of milliseconds a {@link Two.Sprite}.
     */
    _duration: 0,

    /**
     * @name Two.Sprite#_startTime
     * @private
     * @property {Milliseconds} - Epoch time in milliseconds of when the {@link Two.Sprite} started.
     */
    _startTime: 0,

    /**
     * @name Two.Sprite#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.Sprite} is animating or not.
     */
    _playing: false,

    /**
     * @name Two.Sprite#_firstFrame
     * @private
     * @property {Number} - The frame the {@link Two.Sprite} should start with.
     */
    _firstFrame: 0,

    /**
     * @name Two.Sprite#_lastFrame
     * @private
     * @property {Number} - The frame the {@link Two.Sprite} should end with.
     */
    _lastFrame: 0,

    /**
     * @name Two.Sprite#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.Sprite} should loop or not.
     */
    _loop: true,

    // Exposed through getter-setter

    /**
     * @name Two.Sprite#_texture
     * @private
     * @see {@link Two.Sprite#texture}
     */
    _texture: null,

    /**
     * @name Two.Sprite#_columns
     * @private
     * @see {@link Two.Sprite#columns}
     */
    _columns: 1,

    /**
     * @name Two.Sprite#_rows
     * @private
     * @see {@link Two.Sprite#rows}
     */
    _rows: 1,

    /**
     * @name Two.Sprite#_frameRate
     * @private
     * @see {@link Two.Sprite#frameRate}
     */
    _frameRate: 0,

    /**
     * @name Two.Sprite#_index
     * @private
     * @property {Number} - The current frame the {@link Two.Sprite} is currently displaying.
     */
    _index: 0,

    /**
     * @name Two.Sprite#_origin
     * @private
     * @see {@link Two.Sprite#origin}
     */
    _origin: null,

    /**
     * @name Two.Sprite#play
     * @function
     * @param {Number} [firstFrame=0] - The index of the frame to start the animation with.
     * @param {Number} [lastFrame] - The index of the frame to end the animation with. Defaults to the last item in the {@link Two.Sprite#textures}.
     * @param {Function} [onLastFrame] - Optional callback function to be triggered after playing the last frame. This fires multiple times when the sprite is looped.
     * @description Initiate animation playback of a {@link Two.Sprite}.
     */
    play: function(firstFrame, lastFrame, onLastFrame) {

      this._playing = true;
      this._firstFrame = 0;
      this._lastFrame = this.amount - 1;
      this._startTime = _.performance.now();

      if (typeof firstFrame === 'number') {
        this._firstFrame = firstFrame;
      }
      if (typeof lastFrame === 'number') {
        this._lastFrame = lastFrame;
      }
      if (typeof onLastFrame === 'function') {
        this._onLastFrame = onLastFrame;
      } else {
        delete this._onLastFrame;
      }

      if (this._index !== this._firstFrame) {
        this._startTime -= 1000 * Math.abs(this._index - this._firstFrame)
          / this._frameRate;
      }

      return this;

    },

    /**
     * @name Two.Sprite#pause
     * @function
     * @description Halt animation playback of a {@link Two.Sprite}.
     */
    pause: function() {

      this._playing = false;
      return this;

    },

    /**
     * @name Two.Sprite#stop
     * @function
     * @description Halt animation playback of a {@link Two.Sprite} and set the current frame back to the first frame.
     */
    stop: function() {

      this._playing = false;
      this._index = 0;

      return this;

    },

    /**
     * @name Two.Sprite#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Sprite}
     * @description Create a new instance of {@link Two.Sprite} with the same properties of the current sprite.
     */
    clone: function(parent) {

      var clone = new Sprite(
        this.texture, this.translation.x, this.translation.y,
        this.columns, this.rows, this.frameRate
      );

      if (this.playing) {
        clone.play(this._firstFrame, this._lastFrame);
        clone._loop = this._loop;
      }

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Sprite#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {
      var object = Rectangle.prototype.toObject.call(this);
      object.texture = this.texture.toObject();
      object.columns = this.columns;
      object.rows = this.rows;
      object.frameRate = this.frameRate;
      object.index = this.index;
      object._firstFrame = this._firstFrame;
      object._lastFrame = this._lastFrame;
      object._loop = this._loop;
      return object;
    },

    /**
     * @name Two.Sprite#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var effect = this._texture;
      var cols = this._columns;
      var rows = this._rows;

      var width, height, elapsed, amount, duration;
      var index, iw, ih, frames;

      if (this._flagColumns || this._flagRows) {
        this._amount = this._columns * this._rows;
      }

      if (this._flagFrameRate) {
        this._duration = 1000 * this._amount / this._frameRate;
      }

      if (this._flagTexture) {
        this.fill = this._texture;
      }

      if (this._texture.loaded) {

        iw = effect.image.width;
        ih = effect.image.height;

        width = iw / cols;
        height = ih / rows;
        amount = this._amount;

        if (this.width !== width) {
          this.width = width;
        }
        if (this.height !== height) {
          this.height = height;
        }

        if (this._playing && this._frameRate > 0) {

          if (_.isNaN(this._lastFrame)) {
            this._lastFrame = amount - 1;
          }

          // TODO: Offload perf logic to instance of `Two`.
          elapsed = _.performance.now() - this._startTime;
          frames = this._lastFrame + 1;
          duration = 1000 * (frames - this._firstFrame) / this._frameRate;

          if (this._loop) {
            elapsed = elapsed % duration;
          } else {
            elapsed = Math.min(elapsed, duration);
          }

          index = lerp(this._firstFrame, frames, elapsed / duration);
          index = Math.floor(index);

          if (index !== this._index) {
            this._index = index;
            if (index >= this._lastFrame - 1 && this._onLastFrame) {
              this._onLastFrame();  // Shortcut for chainable sprite animations
            }
          }

        }

        var col = this._index % cols;
        var row = Math.floor(this._index / cols);

        var ox = - width * col + (iw - width) / 2;
        var oy = - height * row + (ih - height) / 2;

        // TODO: Improve performance
        if (ox !== effect.offset.x) {
          effect.offset.x = ox;
        }
        if (oy !== effect.offset.y) {
          effect.offset.y = oy;
        }

      }

      Rectangle.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Sprite#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagTexture = this._flagColumns = this._flagRows
        = this._flagFrameRate = false;

      Rectangle.prototype.flagReset.call(this);

      return this;
    }


  });

  Sprite.MakeObservable(Sprite.prototype);

  var TWO_PI$4 = Math.PI * 2, HALF_PI$2 = Math.PI / 2;
  var cos$3 = Math.cos, sin$3 = Math.sin;

  /**
   * @name Two.Circle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the circle.
   * @param {Number} [y=0] - The y position of the circle.
   * @param {Number} [radius=0] - The radius value of the circle.
   * @param {Number} [resolution=4] - The number of vertices used to construct the circle.
   */
  function Circle(ox, oy, r, resolution) {

    // At least 2 vertices are required for proper circlage
    var amount = resolution ? Math.max(resolution, 2) : 4;

    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(new Anchor(0, 0, 0, 0, 0, 0));
    }

    Path.call(this, points, true, true, true);

    /**
     * @name Two.Circle#radius
     * @property {Number} - The size of the radius of the circle.
     */
    if (typeof r === 'number') {
      this.radius = r;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(Circle, {

    /**
     * @name Two.Circle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Circle}.
     */
    Properties: ['radius'],

    /**
     * @name Two.Circle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Circle} to any object. Handy if you'd like to extend the {@link Two.Circle} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Circle.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Circle.prototype, Path.prototype, {

    constructor: Circle,

    /**
     * @name Two.Circle#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Circle#radius} needs updating.
     */
    _flagRadius: false,

    /**
     * @name Two.Circle#_radius
     * @private
     * @see {@link Two.Circle#radius}
     */
    _radius: 0,

    /**
     * @name Two.Circle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagRadius) {

        var length = this.vertices.length;

        if (!this._closed && length > 2) {
          length -= 1;
        }

        // Coefficient for approximating circular arcs with Bezier curves
        var c = (4 / 3) * Math.tan(Math.PI / (length * 2));
        var radius = this._radius;
        var rc = radius * c;

        for (var i = 0; i < this.vertices.length; i++) {
          var pct = i / length;
          var theta = pct * TWO_PI$4;

          var x = radius * cos$3(theta);
          var y = radius * sin$3(theta);

          var lx = rc * cos$3(theta - HALF_PI$2);
          var ly = rc * sin$3(theta - HALF_PI$2);

          var rx = rc * cos$3(theta + HALF_PI$2);
          var ry = rc * sin$3(theta + HALF_PI$2);

          var v = this.vertices[i];

          v.command = i === 0 ? Commands.move : Commands.curve;
          v.set(x, y);
          v.controls.left.set(lx, ly);
          v.controls.right.set(rx, ry);
        }
      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Circle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagRadius = false;

      Path.prototype.flagReset.call(this);
      return this;

    },

    /**
     * @name Two.Circle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Circle}
     * @description Create a new instance of {@link Two.Circle} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Circle(0, 0, this.radius, this.vertices.length);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Circle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Circle.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Circle.MakeObservable(Circle.prototype);

  var TWO_PI$3 = Math.PI * 2, HALF_PI$1 = Math.PI / 2;
  var cos$2 = Math.cos, sin$2 = Math.sin;

  /**
   * @name Two.Ellipse
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the ellipse.
   * @param {Number} [y=0] - The y position of the ellipse.
   * @param {Number} [rx=0] - The radius value of the ellipse in the x direction.
   * @param {Number} [ry=0] - The radius value of the ellipse in the y direction.
   * @param {Number} [resolution=4] - The number of vertices used to construct the ellipse.
   */
  function Ellipse(ox, oy, rx, ry, resolution) {

    if (typeof ry !== 'number' && typeof rx === 'number') {
      ry = rx;
    }

    // At least 2 vertices are required for proper circlage
    var amount = resolution ? Math.max(resolution, 2) : 4;

    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(new Anchor());
    }

    Path.call(this, points, true, true, true);

    /**
     * @name Two.Ellipse#width
     * @property {Number} - The width of the ellipse.
     */
    if (typeof rx === 'number') {
      this.width = rx * 2;
    }

    /**
     * @name Two.Ellipse#height
     * @property {Number} - The height of the ellipse.
     */
    if (typeof ry === 'number') {
      this.height = ry * 2;
    }

    this._update();
    this.translation.set(ox, oy);

  }

  _.extend(Ellipse, {

    /**
     * @name Two.Ellipse.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Ellipse}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.Ellipse.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Ellipse} to any object. Handy if you'd like to extend the {@link Two.Ellipse} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Ellipse.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Ellipse.prototype, Path.prototype, {

    /**
     * @name Two.Ellipse#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Ellipse#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.Ellipse#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Ellipse#height} needs updating.
     */
    _flagHeight: false,

    /**
     * @name Two.Polygon#_width
     * @private
     * @see {@link Two.Ellipse#width}
     */
    _width: 0,
    /**
     * @name Two.Polygon#_height
     * @private
     * @see {@link Two.Ellipse#height}
     */
    _height: 0,

    constructor: Ellipse,

    /**
     * @name Two.Ellipse#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight) {

        var length = this.vertices.length;

        if (!this._closed && length > 2) {
          length -= 1;
        }

        // Coefficient for approximating circular arcs with Bezier curves
        var c = (4 / 3) * Math.tan(Math.PI / (this.vertices.length * 2));
        var radiusX = this._width / 2;
        var radiusY = this._height / 2;

        for (var i = 0; i < this.vertices.length; i++) {
          var pct = i / length;
          var theta = pct * TWO_PI$3;

          var x = radiusX * cos$2(theta);
          var y = radiusY * sin$2(theta);

          var lx = radiusX * c * cos$2(theta - HALF_PI$1);
          var ly = radiusY * c * sin$2(theta - HALF_PI$1);

          var rx = radiusX * c * cos$2(theta + HALF_PI$1);
          var ry = radiusY * c * sin$2(theta + HALF_PI$1);

          var v = this.vertices[i];

          v.command = i === 0 ? Commands.move : Commands.curve;
          v.set(x, y);
          v.controls.left.set(lx, ly);
          v.controls.right.set(rx, ry);
        }
      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Ellipse#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = false;

      Path.prototype.flagReset.call(this);
      return this;

    },

    /**
     * @name Two.Ellipse#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Polygon}
     * @description Create a new instance of {@link Two.Polygon} with the same properties of the current path.
     */
    clone: function(parent) {

      var rx = this.width / 2;
      var ry = this.height / 2;
      var resolution = this.vertices.length;
      var clone = new Ellipse(0, 0, rx, ry, resolution);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Ellipse#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Ellipse.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Ellipse.MakeObservable(Ellipse.prototype);

  /**
   * @name Two.Line
   * @class
   * @extends Two.Path
   * @param {Number} [x1=0] - The x position of the first vertex on the line.
   * @param {Number} [y1=0] - The y position of the first vertex on the line.
   * @param {Number} [x2=0] - The x position of the second vertex on the line.
   * @param {Number} [y2=0] - The y position of the second vertex on the line.
   */
  function Line(x1, y1, x2, y2) {

    Path.call(this, [
        new Anchor(x1, y1),
        new Anchor(x2, y2)
    ]);

    this.vertices[0].command = Commands.move;
    this.vertices[1].command = Commands.line;

    this.automatic = false;

  }

  _.extend(Line.prototype, Path.prototype, {

    constructor: Line

  });

  Path.MakeObservable(Line.prototype);

  /**
   * @name Two.RoundedRectangle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the rounded rectangle.
   * @param {Number} [y=0] - The y position of the rounded rectangle.
   * @param {Number} [width=0] - The width value of the rounded rectangle.
   * @param {Number} [height=0] - The width value of the rounded rectangle.
   * @param {Number} [radius=0] - The radius value of the rounded rectangle.
   * @param {Number} [resolution=12] - The number of vertices used to construct the rounded rectangle.
   */
  function RoundedRectangle(ox, oy, width, height, radius) {

    if (typeof radius === 'undefined' &&
      typeof width === 'number' && typeof height === 'number') {
      radius = Math.floor(Math.min(width, height) / 12);
    }

    var amount = 10;

    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(
        new Anchor(0, 0, 0, 0, 0, 0,
          i === 0 ? Commands.move : Commands.curve)
      );
    }

    // points[points.length - 1].command = Two.Commands.close;

    Path.call(this, points);

    this.closed = true;
    this.automatic = false;

    this._renderer.flagRadius = RoundedRectangle.FlagRadius.bind(this);

    /**
     * @name Two.RoundedRectangle#width
     * @property {Number} - The width of the rounded rectangle.
     */
    if (typeof width === 'number') {
      this.width = width;
    }

    /**
     * @name Two.RoundedRectangle#height
     * @property {Number} - The height of the rounded rectangle.
     */
    if (typeof height === 'number') {
      this.height = height;
    }

    /**
     * @name Two.RoundedRectangle#radius
     * @property {Number} - The size of the radius of the rounded rectangle.
     */
    if (typeof radius === 'number') {
      this.radius = radius;
    }

    this._update();
    this.translation.set(ox, oy);

  }

  _.extend(RoundedRectangle, {

    /**
     * @name Two.RoundedRectangle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.RoundedRectangle}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.RoundedRectangle.FlagRadius
     * @property {Function} - A convenience function to trigger the flag for radius changing.
     */
    FlagRadius: function() {
      this._flagRadius = true;
    },

    /**
     * @name Two.RoundedRectangle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.RoundedRectangle} to any object. Handy if you'd like to extend the {@link Two.RoundedRectangle} class on a custom class.
     */
    MakeObservable: function(object) {

      Path.MakeObservable(object);
      _.each(RoundedRectangle.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'radius', {
        enumerable: true,
        get: function() {
          return this._radius;
        },
        set: function(v) {

          if (this._radius instanceof Vector) {
            this._radius.unbind(Events.Types.change, this._renderer.flagRadius);
          }

          this._radius = v;

          if (this._radius instanceof Vector) {
            this._radius.bind(Events.Types.change, this._renderer.flagRadius);
          }

          this._flagRadius = true;

        }
      });

    }

  });

  _.extend(RoundedRectangle.prototype, Path.prototype, {

    constructor: RoundedRectangle,

    /**
     * @name Two.RoundedRectangle#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.RoundedRectangle#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#height} needs updating.
     */
    _flagHeight: false,
    /**
     * @name Two.RoundedRectangle#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#radius} needs updating.
     */
    _flagRadius: false,

    /**
     * @name Two.RoundedRectangle#_width
     * @private
     * @see {@link Two.RoundedRectangle#width}
     */
    _width: 0,
    /**
     * @name Two.RoundedRectangle#_height
     * @private
     * @see {@link Two.RoundedRectangle#height}
     */
    _height: 0,
    /**
     * @name Two.RoundedRectangle#_radius
     * @private
     * @see {@link Two.RoundedRectangle#radius}
     */
    _radius: 12,

    /**
     * @name Two.RoundedRectangle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight || this._flagRadius) {

        var width = this._width;
        var height = this._height;

        var rx, ry;

        if (this._radius instanceof Vector) {
          rx = this._radius.x;
          ry = this._radius.y;
        } else {
          rx = this._radius;
          ry = this._radius;
        }

        var v;
        var w = width / 2;
        var h = height / 2;

        v = this.vertices[0];
        v.x = - (w - rx);
        v.y = - h;

        // Upper Right Corner

        v = this.vertices[1];
        v.x = (w - rx);
        v.y = - h;
        v.controls.left.clear();
        v.controls.right.x = rx;
        v.controls.right.y = 0;

        v = this.vertices[2];
        v.x = w;
        v.y = - (h - ry);
        v.controls.right.clear();
        v.controls.left.clear();

        // Bottom Right Corner

        v = this.vertices[3];
        v.x = w;
        v.y = (h - ry);
        v.controls.left.clear();
        v.controls.right.x = 0;
        v.controls.right.y = ry;

        v = this.vertices[4];
        v.x = (w - rx);
        v.y = h;
        v.controls.right.clear();
        v.controls.left.clear();

        // Bottom Left Corner

        v = this.vertices[5];
        v.x = - (w - rx);
        v.y = h;
        v.controls.left.clear();
        v.controls.right.x = - rx;
        v.controls.right.y = 0;

        v = this.vertices[6];
        v.x = - w;
        v.y = (h - ry);
        v.controls.left.clear();
        v.controls.right.clear();

        // Upper Left Corner

        v = this.vertices[7];
        v.x = - w;
        v.y = - (h - ry);
        v.controls.left.clear();
        v.controls.right.x = 0;
        v.controls.right.y = - ry;

        v = this.vertices[8];
        v.x = - (w - rx);
        v.y = - h;
        v.controls.left.clear();
        v.controls.right.clear();

        v = this.vertices[9];
        v.copy(this.vertices[8]);

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.RoundedRectangle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = this._flagRadius = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.RoundedRectangle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.RoundedRectangle}
     * @description Create a new instance of {@link Two.RoundedRectangle} with the same properties of the current path.
     */
    clone: function(parent) {

      var width = this.width;
      var height = this.height;
      var radius = this.radius;

      var clone = new RoundedRectangle(0, 0, width, height, radius);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.RoundedRectangle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(RoundedRectangle.Properties, function(property) {
        object[property] = this[property];
      }, this);

      object.radius = typeof this.radius === 'number'
        ? this.radius : this.radius.toObject();

      return object;

    }

  });

  RoundedRectangle.MakeObservable(RoundedRectangle.prototype);

  var min = Math.min, max = Math.max;

  /**
   * @name Two.Text
   * @class
   * @extends Two.Shape
   * @param {String} [message] - The String to be rendered to the scene.
   * @param {Number} [x=0] - The position in the x direction for the object.
   * @param {Number} [y=0] - The position in the y direction for the object.
   * @param {Object} [styles] - An object where styles are applied. Attribute must exist in Two.Text.Properties.
   * @description This is a primitive class for creating drawable text that can be added to the scenegraph.
   * @returns {Two.Text}
   */
  function Text(message, x, y, styles) {

    Shape.call(this);

    this._renderer.type = 'text';
    this._renderer.flagFill = Text.FlagFill.bind(this);
    this._renderer.flagStroke = Text.FlagStroke.bind(this);

    this.value = message;

    if (typeof x === 'number') {
      this.translation.x = x;
    }
    if (typeof y === 'number') {
      this.translation.y = y;
    }

    /**
     * @name Two.Text#dashes
     * @property {Number[]} - Array of numbers. Odd indices represent dash length. Even indices represent dash space.
     * @description A list of numbers that represent the repeated dash length and dash space applied to the stroke of the text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more information on the SVG stroke-dasharray attribute.
     */
    this.dashes = [];

    /**
     * @name Two.Text#dashes#offset
     * @property {Number} - A number in pixels to offset {@link Two.Text#dashes} display.
     */
    this.dashes.offset = 0;

    if (!_.isObject(styles)) {
      return this;
    }

    _.each(Text.Properties, function(property) {

      if (property in styles) {
        this[property] = styles[property];
      }

    }, this);

  }

  _.extend(Text, {

    /**
     * @name Two.Text.Ratio
     * @property {Number} - Approximate aspect ratio of a typeface's character width to height.
     */
    Ratio: 0.6,

    /**
     * @name Two.Text.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Text}.
     */
    Properties: [
      'value', 'family', 'size', 'leading', 'alignment', 'linewidth', 'style',
      'weight', 'decoration', 'baseline', 'opacity', 'visible', 'className',
      'fill', 'stroke',
    ],

    /**
     * @name Two.Text.FlagFill
     * @function
     * @description Cached method to let renderers know the fill property have been updated on a {@link Two.Text}.
     */
    FlagFill: function() {
      this._flagFill = true;
    },

    /**
     * @name Two.Text.FlagStroke
     * @function
     * @description Cached method to let renderers know the stroke property have been updated on a {@link Two.Text}.
     */
    FlagStroke: function() {
      this._flagStroke = true;
    },

    MakeObservable: function(object) {

      Shape.MakeObservable(object);

      _.each(Text.Properties.slice(0, 12), defineGetterSetter, object);

      Object.defineProperty(object, 'fill', {
        enumerable: true,
        get: function() {
          return this._fill;
        },
        set: function(f) {

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.unbind(Events.Types.change, this._renderer.flagFill);
          }

          this._fill = f;
          this._flagFill = true;

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.bind(Events.Types.change, this._renderer.flagFill);
          }

        }
      });

      Object.defineProperty(object, 'stroke', {
        enumerable: true,
        get: function() {
          return this._stroke;
        },
        set: function(f) {

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.unbind(Events.Types.change, this._renderer.flagStroke);
          }

          this._stroke = f;
          this._flagStroke = true;

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.bind(Events.Types.change, this._renderer.flagStroke);
          }

        }
      });

      Object.defineProperty(object, 'mask', {

        enumerable: true,

        get: function() {
          return this._mask;
        },

        set: function(v) {
          this._mask = v;
          this._flagMask = true;
          if (!v.clip) {
            v.clip = true;
          }
        }

      });

      Object.defineProperty(object, 'clip', {
        enumerable: true,
        get: function() {
          return this._clip;
        },
        set: function(v) {
          this._clip = v;
          this._flagClip = true;
        }
      });

      Object.defineProperty(object, 'dashes', {
        enumerable: true,
        get: function() {
          return this._dashes;
        },
        set: function(v) {
          if (typeof v.offset !== 'number') {
            v.offset = this._dashes.offset || 0;
          }
          this._dashes = v;
        }
      });

    }

  });

  _.extend(Text.prototype, Shape.prototype, {

    constructor: Text,

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Text#_flagValue
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#value} need updating.
     */
    _flagValue: true,

    /**
     * @name Two.Text#_flagFamily
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#family} need updating.
     */
    _flagFamily: true,

    /**
     * @name Two.Text#_flagSize
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#size} need updating.
     */
    _flagSize: true,

    /**
     * @name Two.Text#_flagLeading
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#leading} need updating.
     */
    _flagLeading: true,

    /**
     * @name Two.Text#_flagAlignment
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#alignment} need updating.
     */
    _flagAlignment: true,

    /**
     * @name Two.Text#_flagBaseline
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#baseline} need updating.
     */
    _flagBaseline: true,

    /**
     * @name Two.Text#_flagStyle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#style} need updating.
     */
    _flagStyle: true,

    /**
     * @name Two.Text#_flagWeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#weight} need updating.
     */
    _flagWeight: true,

    /**
     * @name Two.Text#_flagDecoration
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#decoration} need updating.
     */
    _flagDecoration: true,

    /**
     * @name Two.Text#_flagFill
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#fill} need updating.
     */
    _flagFill: true,

    /**
     * @name Two.Text#_flagStroke
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#stroke} need updating.
     */
    _flagStroke: true,

    /**
     * @name Two.Text#_flagLinewidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#linewidth} need updating.
     */
    _flagLinewidth: true,

    /**
     * @name Two.Text#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#opacity} need updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Text#_flagClassName
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#className} need updating.
     */
    _flagClassName: true,

    /**
     * @name Two.Text#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#visible} need updating.
     */
    _flagVisible: true,

    /**
     * @name Two.Path#_flagMask
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#mask} needs updating.
     */
    _flagMask: false,

    /**
     * @name Two.Text#_flagClip
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#clip} need updating.
     */
    _flagClip: false,

    // Underlying Properties

    /**
     * @name Two.Text#value
     * @property {String} - The characters to be rendered to the the screen. Referred to in the documentation sometimes as the `message`.
     */
    _value: '',

    /**
     * @name Two.Text#family
     * @property {String} - The font family Two.js should attempt to regsiter for rendering. The default value is `'sans-serif'`. Comma separated font names can be supplied as a "stack", similar to the CSS implementation of `font-family`.
     */
    _family: 'sans-serif',

    /**
     * @name Two.Text#size
     * @property {Number} - The font size in Two.js point space. Defaults to `13`.
     */
    _size: 13,

    /**
     * @name Two.Text#leading
     * @property {Number} - The height between lines measured from base to base in Two.js point space. Defaults to `17`.
     */
    _leading: 17,

    /**
     * @name Two.Text#alignment
     * @property {String} - Alignment of text in relation to {@link Two.Text#translation}'s coordinates. Possible values include `'left'`, `'center'`, `'right'`. Defaults to `'center'`.
     */
    _alignment: 'center',

    /**
     * @name Two.Text#baseline
     * @property {String} - The vertical aligment of the text in relation to {@link Two.Text#translation}'s coordinates. Possible values include `'top'`, `'middle'`, `'bottom'`, and `'baseline'`. Defaults to `'baseline'`.
     */
    _baseline: 'middle',

    /**
     * @name Two.Text#style
     * @property {String} - The font's style. Possible values include '`normal`', `'italic'`. Defaults to `'normal'`.
     */
    _style: 'normal',

    /**
     * @name Two.Text#weight
     * @property {Number} - A number at intervals of 100 to describe the font's weight. This compatibility varies with the typeface's variant weights. Larger values are bolder. Smaller values are thinner. Defaults to `'500'`.
     */
    _weight: 500,

    /**
     * @name Two.Text#decoration
     * @property {String} - String to delineate whether text should be decorated with for instance an `'underline'`. Defaults to `'none'`.
     */
    _decoration: 'none',

    /**
     * @name Two.Text#fill
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the text object should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _fill: '#000',

    /**
     * @name Two.Text#stroke
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the text object should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _stroke: 'transparent',

    /**
     * @name Two.Text#linewidth
     * @property {Number} - The thickness in pixels of the stroke.
     */
    _linewidth: 1,

    /**
     * @name Two.Text#opacity
     * @property {Number} - The opaqueness of the text object.
     * @nota-bene Can be used in conjunction with CSS Colors that have an alpha value.
     */
    _opacity: 1,

    /**
     * @name Two.Text#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling. Only available for the {@link Two.SvgRenderer}.
     */
    _className: '',

    /**
     * @name Two.Text#visible
     * @property {Boolean} - Display the text object or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    _visible: true,

    /**
     * @name Two.Text#mask
     * @property {Two.Shape} - The shape whose alpha property becomes a clipping area for the text.
     * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
     */
    _mask: null,

    /**
     * @name Two.Text#clip
     * @property {Two.Shape} - Object to define clipping area.
     * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
     */
    _clip: false,

    /**
     * @name Two.Text#_dashes
     * @private
     * @see {@link Two.Text#dashes}
     */
    _dashes: [],

    /**
     * @name Two.Text#remove
     * @function
     * @description Remove self from the scene / parent.
     */
    remove: function() {

      if (!this.parent) {
        return this;
      }

      this.parent.remove(this);

      return this;

    },

    /**
     * @name Two.Text#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Text}
     * @description Create a new instance of {@link Two.Text} with the same properties of the current text object.
     */
    clone: function(parent) {

      var clone = new Text(this.value);
      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      _.each(Text.Properties, function(property) {
        clone[property] = this[property];
      }, this);

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Text#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the text object.
     */
    toObject: function() {

      var result = {
        translation: this.translation.toObject(),
        rotation: this.rotation,
        scale: this.scale
      };

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      _.each(Text.Properties, function(property) {
        result[property] = this[property];
      }, this);

      return result;

    },

    /**
     * @name Two.Text#noFill
     * @function
     * @description Short hand method to set fill to `transparent`.
     */
    noFill: function() {
      this.fill = 'transparent';
      return this;
    },

    /**
     * @name Two.Text#noStroke
     * @function
     * @description Short hand method to set stroke to `transparent`.
     */
    noStroke: function() {
      this.stroke = undefined;
      this.linewidth = undefined;
      return this;
    },

    // A shim to not break `getBoundingClientRect` calls.
    // TODO: Implement a way to calculate proper bounding
    // boxes of `Two.Text`.

    /**
     * @name Two.Text#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the text object.
     */
    getBoundingClientRect: function(shallow) {

      var matrix, a, b, c, d;
      var left, right, top, bottom;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      var height = this.leading;
      var width = this.value.length * this.size * Text.Ratio;
      var border = (this._linewidth || 0) / 2;

      switch (this.alignment) {
        case 'left':
          left = - border;
          right = width + border;
          break;
        case 'right':
          left = - (width + border);
          right = border;
          break;
        default:
          left = - (width / 2 + border);
          right = width / 2 + border;
      }

      switch (this.baseline) {
        case 'top':
          top = - border;
          bottom = height + border;
          break;
        case 'bottom':
          top = - (height + border);
          bottom = border;
          break;
        default:
          top = - (height / 2 + border);
          bottom = height / 2 + border;
      }

      a = matrix.multiply(left, top, 1);
      b = matrix.multiply(left, bottom, 1);
      c = matrix.multiply(right, top, 1);
      d = matrix.multiply(right, bottom, 1);

      top = min(a.y, b.y, c.y, d.y);
      left = min(a.x, b.x, c.x, d.x);
      right = max(a.x, b.x, c.x, d.x);
      bottom = max(a.y, b.y, c.y, d.y);

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Text#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagValue = this._flagFamily = this._flagSize =
        this._flagLeading = this._flagAlignment = this._flagFill =
        this._flagStroke = this._flagLinewidth = this._flagOpacity =
        this._flagVisible = this._flagClip = this._flagDecoration =
        this._flagClassName = this._flagBaseline = this._flagWeight =
          this._flagStyle = false;

      Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Text.MakeObservable(Text.prototype);

  // https://github.com/jonobr1/two.js/issues/507#issuecomment-777159213
  var regex = {
    path: /[+-]?(?:\d*\.\d+|\d+)(?:[eE][+-]\d+)?/g
  };

  var alignments = {
    start: 'left',
    middle: 'center',
    end: 'right'
  };

  /**
   * @name Two.Utils.getAlignment
   * @function
   * @param {AlignmentString}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-anchor}
   */
  var getAlignment = function(anchor) {
    return alignments[anchor];
  };

  var getBaseline = function(node) {
    var a = node.getAttribute('dominant-baseline');
    var b = node.getAttribute('alignment-baseline');
    return a || b;
  };

  var getTagName = function(tag) {
    return tag.replace(/svg:/ig, '').toLowerCase();
  };

  var applyTransformsToVector = function(transforms, vector) {

    vector.x += transforms.translateX;
    vector.y += transforms.translateY;

    vector.x *= transforms.scaleX;
    vector.y *= transforms.scaleY;

    if (transforms.rotation !== 0) {
      // TODO: Test further
      var l = vector.length();
      vector.x = l * Math.cos(transforms.rotation);
      vector.y = l * Math.sin(transforms.rotation);
    }

  };

  /**
   * @name Two.Utils.extractCSSText
   * @function
   * @param {String} text - The CSS text body to be parsed and extracted.
   * @param {Object} [styles] - The styles object to apply CSS key values to.
   * @returns {Object} styles
   * @description Parse CSS text body and apply them as key value pairs to a JavaScript object.
   */
  var extractCSSText = function(text, styles) {

    var commands, command, name, value;

    if (!styles) {
      styles = {};
    }

    commands = text.split(';');

    for (var i = 0; i < commands.length; i++) {
      command = commands[i].split(':');
      name = command[0];
      value = command[1];
      if (typeof name === 'undefined' || typeof value === 'undefined') {
        continue;
      }
      styles[name] = value.replace(/\s/, '');
    }

    return styles;

  };

  /**
   * @name Two.Utils.getSvgStyles
   * @function
   * @param {SVGElement} node - The SVG node to parse.
   * @returns {Object} styles
   * @description Get the CSS comands from the `style` attribute of an SVG node and apply them as key value pairs to a JavaScript object.
   */
  var getSvgStyles = function(node) {

    var styles = {};
    var attributes = getSvgAttributes(node);
    var length = Math.max(attributes.length, node.style.length);

    for (var i = 0; i < length; i++) {

      var command = node.style[i];
      var attribute = attributes[i];

      if (command) {
        styles[command] = node.style[command];
      }
      if (attribute) {
        styles[attribute] = node.getAttribute(attribute);
      }

    }

    return styles;

  };

  var getSvgAttributes = function(node) {

    var attributes = node.getAttributeNames();

    // Reserved attributes to remove
    var keywords = ['id', 'class', 'transform', 'xmlns', 'viewBox'];

    for (var i = 0; i < keywords.length; i++) {
      var keyword = keywords[i];
      var index = Array.prototype.indexOf.call(attributes, keyword);
      if (index >= 0) {
        attributes.splice(index, 1);
      }
    }

    return attributes;

  };

  /**
   * @name Two.Utils.applySvgViewBox
   * @function
   * @param {Two.Shape} node - The Two.js object to apply viewbox matrix to
   * @param {String} value - The viewBox value from the SVG attribute
   * @returns {Two.Shape} node
   * @description Applies the transform of the SVG Viewbox on a given node.
   */
  var applySvgViewBox = function(node, value) {

    var elements = value.split(/\s/);

    var x = parseFloat(elements[0]);
    var y = parseFloat(elements[1]);
    var width = parseFloat(elements[2]);
    var height = parseFloat(elements[3]);

    var s = Math.min(this.width / width, this.height / height);

    node.translation.x -= x * s;
    node.translation.y -= y * s;
    node.scale = s;

    return node;

  };

  /**
   * @name Two.Utils.applySvgAttributes
   * @function
   * @param {SVGElement} node - An SVG Node to extrapolate attributes from.
   * @param {Two.Shape} elem - The Two.js object to apply extrapolated attributes to.
   * @returns {Two.Shape} The Two.js object passed now with applied attributes.
   * @description This function iterates through an SVG Node's properties and stores ones of interest. It tries to resolve styles applied via CSS as well.
   * @TODO Reverse calculate {@link Two.Gradient}s for fill / stroke of any given path.
   */
  var applySvgAttributes = function(node, elem, parentStyles) {

    var styles = {}, attributes = {}, extracted = {}, i, m, key, value, attr;
    var transforms, x, y;
    var id, scene, ref, tagName;

    // Not available in non browser environments
    if (root$1.getComputedStyle) {
      // Convert CSSStyleDeclaration to a normal object
      var computedStyles = root$1.getComputedStyle(node);
      i = computedStyles.length;

      while (i--) {
        key = computedStyles[i];
        value = computedStyles[key];
        // Gecko returns undefined for unset properties
        // Webkit returns the default value
        if (typeof value !== 'undefined') {
          styles[key] = value;
        }
      }
    }

    // Convert NodeMap to a normal object
    for (i = 0; i < node.attributes.length; i++) {
      attr = node.attributes[i];
      if (/style/i.test(attr.nodeName)) {
        extractCSSText(attr.value, extracted);
      } else {
        attributes[attr.nodeName] = attr.value;
      }
    }

    // Getting the correct opacity is a bit tricky, since SVG path elements don't
    // support opacity as an attribute, but you can apply it via CSS.
    // So we take the opacity and set (stroke/fill)-opacity to the same value.
    if (typeof styles.opacity !== 'undefined') {
      styles['stroke-opacity'] = styles.opacity;
      styles['fill-opacity'] = styles.opacity;
      delete styles.opacity;
    }

    // Merge attributes and applied styles (attributes take precedence)
    if (parentStyles) {
      _.defaults(styles, parentStyles);
    }
    _.extend(styles, extracted, attributes);

    // Similarly visibility is influenced by the value of both display and visibility.
    // Calculate a unified value here which defaults to `true`.
    styles.visible = !(typeof styles.display === 'undefined' && /none/i.test(styles.display))
      || (typeof styles.visibility === 'undefined' && /hidden/i.test(styles.visibility));

    // Now iterate the whole thing
    for (key in styles) {
      value = styles[key];

      switch (key) {
        case 'gradientTransform':
          // TODO: Check this out https://github.com/paperjs/paper.js/blob/develop/src/svg/SvgImport.js#L315
          if (/none/i.test(value)) break;
          m = (node.gradientTransform && node.gradientTransform.baseVal && node.gradientTransform.baseVal.length > 0)
            ? node.gradientTransform.baseVal[0].matrix
            : (node.getCTM ? node.getCTM() : null);

          if (m === null) break;

          transforms = decomposeMatrix(m);

          switch (elem._renderer.type) {
            case 'linear-gradient':
              applyTransformsToVector(transforms, elem.left);
              applyTransformsToVector(transforms, elem.right);
              break;
            case 'radial-gradient':
              elem.center.x += transforms.translateX;
              elem.center.y += transforms.translateY;

              elem.focal.x += transforms.translateX;
              elem.focal.y += transforms.translateY;

              elem.radius *= Math.max(transforms.scaleX, transforms.scaleY);
              break;
          }

          break;
        case 'transform':
          // TODO: Check this out https://github.com/paperjs/paper.js/blob/develop/src/svg/SvgImport.js#L315
          if (/none/i.test(value)) break;
          m = (node.transform && node.transform.baseVal && node.transform.baseVal.length > 0)
            ? node.transform.baseVal[0].matrix
            : (node.getCTM ? node.getCTM() : null);

          // Might happen when transform string is empty or not valid.
          if (m === null) break;

          if (Constants.AutoCalculateImportedMatrices) {

            // Decompose and infer Two.js related properties.
            transforms = decomposeMatrix(m);

            elem.translation.set(transforms.translateX, transforms.translateY);
            elem.rotation = Math.PI * (transforms.rotation / 180);
            elem.scale = new Vector(transforms.scaleX, transforms.scaleY);

            x = parseFloat((styles.x + '').replace('px'));
            y = parseFloat((styles.y + '').replace('px'));

            // Override based on attributes.
            if (x) {
              elem.translation.x = x;
            }

            if (y) {
              elem.translation.y = y;
            }

          } else {

            // Edit the underlying matrix and don't force an auto calc.
            m = node.getCTM();
            elem._matrix.manual = true;
            elem._matrix.set(m.a, m.b, m.c, m.d, m.e, m.f);

          }

          break;
        case 'viewBox':
          applySvgViewBox.call(this, elem, value);
          break;
        case 'visible':
          if (elem instanceof Group) {
            elem._visible = value;
            break;
          }
          elem.visible = value;
          break;
        case 'stroke-linecap':
          if (elem instanceof Group) {
            elem._cap = value;
            break;
          }
          elem.cap = value;
          break;
        case 'stroke-linejoin':
          if (elem instanceof Group) {
            elem._join = value;
            break;
          }
          elem.join = value;
          break;
        case 'stroke-miterlimit':
          if (elem instanceof Group) {
            elem._miter = value;
            break;
          }
          elem.miter = value;
          break;
        case 'stroke-width':
          if (elem instanceof Group) {
            elem._linewidth = parseFloat(value);
            break;
          }
          elem.linewidth = parseFloat(value);
          break;
        case 'opacity':
        case 'stroke-opacity':
        case 'fill-opacity':
          // Only apply styles to rendered shapes
          // in the scene.
          if (elem instanceof Group) {
            elem._opacity = parseFloat(value);
            break;
          }
          elem.opacity = parseFloat(value);
          break;
        case 'clip-path':
          if (/url\(#.*\)/i.test(value)) {
            id = value.replace(/url\(#(.*)\)/i, '$1');
            if (read.defs.current && read.defs.current.contains(id)) {
              ref = read.defs.current.get(id);
              if (ref && ref.childNodes.length > 0) {
                ref = ref.childNodes[0];
                tagName = getTagName(ref.nodeName);
                elem.mask = read[tagName].call(this, ref, {});
                switch (elem._renderer.type) {
                  case 'text':
                  case 'path':
                    // The matrix here needs to change to insure that the object
                    // clipping is in the same coordinate space as the `elem`.
                    elem.position.add(elem.mask.position);
                    elem.mask.position.clear();
                    break;
                }
              }
            }
          }
          break;
        case 'fill':
        case 'stroke':
          if (elem instanceof Group) {
            key = '_' + key;
          }
          if (/url\(#.*\)/i.test(value)) {
            id = value.replace(/url\(#(.*)\)/i, '$1');
            if (read.defs.current && read.defs.current.contains(id)) {
              ref = read.defs.current.get(id);
              tagName = getTagName(ref.nodeName);
              ref = read[tagName].call(this, ref, {});
            } else {
              scene = getScene(this);
              ref = scene.getById(id);
            }
            elem[key] = ref;
          } else {
            elem[key] = (/none/i.test(value)) ? 'transparent' : value;
          }
          break;
        case 'id':
          elem.id = value;
          // Overwritten id for non-conflicts on same page SVG documents
          // TODO: Make this non-descructive
          node.id = value + '-' + Constants.Identifier + 'applied';
          break;
        case 'class':
        case 'className':
          elem.classList = value.split(' ');
          break;
        case 'x':
        case 'y':
          var ca = elem instanceof Gradient;
          var cb = elem instanceof LinearGradient;
          var cc = elem instanceof RadialGradient;
          if (ca || cb || cc) {
            break;
          }
          if (value.match('[a-z%]$') && !value.endsWith('px')) {
            var error = new TwoError(
              'only pixel values are supported with the ' + key + ' attribute.');
            console.warn(error.name, error.message);
          }
          elem.translation[key] = parseFloat(value);
          break;
        case 'font-family':
          if (elem instanceof Text) {
            elem.family = value;
          }
          break;
        case 'font-size':
          if (elem instanceof Text) {
            elem.size = value;
          }
          break;
        case 'font-weight':
          if (elem instanceof Text) {
            elem.weight = value;
          }
          break;
        case 'font-style':
          if (elem instanceof Text) {
            elem.style = value;
          }
          break;
        case 'text-decoration':
          if (elem instanceof Text) {
            elem.decoration = value;
          }
          break;
        case 'line-height':
          if (elem instanceof Text) {
            elem.leading = value;
          }
          break;
      }
    }

    return styles;

  };

  /**
   * @name Two.Utils.updateDefsCache
   * @function
   * @param {SVGElement} node - The SVG Node with which to update the defs cache.
   * @param {Object} Object - The defs cache to be updated.
   * @description Update the cache of children of <defs /> tags.
   */
  var updateDefsCache = function(node, defsCache) {
    for (var i = 0, l = node.childNodes.length; i < l; i++) {
      var n = node.childNodes[i];
      if (!n.id) continue;

      var tagName = getTagName(node.nodeName);
      if (tagName === '#text') continue;

      defsCache.add(n.id, n);
    }
  };

  /**
   * @name Two.Utils.getScene
   * @param {Two.Shape} node - The currently available object in the scenegraph.
   * @returns {Group} - The highest order {@link Two.Group} in the scenegraph.
   * @property {Function}
   */
  var getScene = function(node) {

    while (node.parent) {
      node = node.parent;
    }

    return node.scene;

  };

  /**
   * @name Two.Utils.read
   * @property {Object} read - A map of functions to read any number of SVG node types and create Two.js equivalents of them. Primarily used by the {@link Two#interpret} method.
   */
  var read = {

    svg: function(node) {

      var defs = read.defs.current = new Registry();
      var elements = node.getElementsByTagName('defs');

      for (var i = 0; i < elements.length; i++) {
        updateDefsCache(elements[i], defs);
      }

      var svg = read.g.call(this, node);
      // var viewBox = node.getAttribute('viewBox');

      svg.defs = defs;  // Export out the <defs /> for later use
      // Utils.applySvgViewBox(svg, viewBox);

      delete read.defs.current;

      return svg;

    },

    defs: function(node) {
      return null;
    },

    use: function(node, styles) {

      var error;
      var href = node.getAttribute('href') || node.getAttribute('xlink:href');
      if (!href) {
        error = new TwoError('encountered <use /> with no href.');
        console.warn(error.name, error.message);
        return null;
      }

      var id = href.slice(1);
      if (!read.defs.current.contains(id)) {
        error = new TwoError(
          'unable to find element for reference ' + href + '.');
        console.warn(error.name, error.message);
        return null;
      }

      var template = read.defs.current.get(id);
      var fullNode = template.cloneNode(true);
      var overwriteAttrs = ['x', 'y', 'width', 'height', 'href', 'xlink:href'];

      for (var i = 0; i < node.attributes.length; i++) {
        var attr = node.attributes[i];
        var ca = overwriteAttrs.includes(attr.nodeName);
        var cb = !fullNode.hasAttribute(attr.nodeName);
        if (ca || cb) {
          fullNode.setAttribute(attr.nodeName, attr.value);
        }
      }

      var tagName = getTagName(fullNode.nodeName);
      return read[tagName].call(this, fullNode, styles);

    },

    g: function(node, parentStyles) {

      var styles;
      var group = new Group();

      applySvgAttributes.call(this, node, group, parentStyles);

      this.add(group);

      // Switched up order to inherit more specific styles
      styles = getSvgStyles.call(this, node);

      for (var i = 0, l = node.childNodes.length; i < l; i++) {
        var n = node.childNodes[i];
        var tag = n.nodeName;
        if (!tag) return;

        var tagName = getTagName(tag);

        if (tagName in read) {
          var o = read[tagName].call(group, n, styles);
          if (!!o && !o.parent) {
            group.add(o);
          }
        }
      }

      return group;

    },

    polygon: function(node, parentStyles) {

      var points = node.getAttribute('points');

      var verts = [];
      points.replace(/(-?[\d.eE-]+)[,|\s](-?[\d.eE-]+)/g, function(match, p1, p2) {
        verts.push(new Anchor(parseFloat(p1), parseFloat(p2)));
      });

      var poly = new Path(verts, true).noStroke();
      poly.fill = 'black';

      applySvgAttributes.call(this, node, poly, parentStyles);

      return poly;

    },

    polyline: function(node, parentStyles) {
      var poly = read.polygon.call(this, node, parentStyles);
      poly.closed = false;
      return poly;
    },

    path: function(node, parentStyles) {

      var path = node.getAttribute('d');
      var points = [];
      var closed = false, relative = false;

      if (path) {

        // Create a Two.Path from the paths.

        var coord = new Anchor();
        var control, coords;
        var commands = path.match(/[a-df-z][^a-df-z]*/ig);
        var last = commands.length - 1;

        // Split up polybeziers

        _.each(commands.slice(0), function(command, i) {

          var items = command.slice(1).trim().match(regex.path);
          var type = command[0];
          var lower = type.toLowerCase();
          var bin, j, l, ct, times, result = [];

          if (i === 0) {
            commands = [];
          }

          switch (lower) {
            case 'h':
            case 'v':
              if (items.length > 1) {
                bin = 1;
              }
              break;
            case 'm':
            case 'l':
            case 't':
              if (items.length > 2) {
                bin = 2;
              }
              break;
            case 's':
            case 'q':
              if (items.length > 4) {
                bin = 4;
              }
              break;
            case 'c':
              if (items.length > 6) {
                bin = 6;
              }
              break;
            case 'a':
              if (items.length > 7) {
                bin = 7;
              }
              break;
          }

          // This means we have a polybezier.
          if (bin) {

            for (j = 0, l = items.length, times = 0; j < l; j+=bin) {

              ct = type;
              if (times > 0) {

                switch (type) {
                  case 'm':
                    ct = 'l';
                    break;
                  case 'M':
                    ct = 'L';
                    break;
                }

              }

              result.push(ct + items.slice(j, j + bin).join(' '));
              times++;

            }

            commands = Array.prototype.concat.apply(commands, result);

          } else {

            commands.push(command);

          }

        });

        // Create the vertices for our Two.Path

        _.each(commands, function(command, i) {

          var result, x, y;
          var type = command[0];
          var lower = type.toLowerCase();

          coords = command.slice(1).trim().match(regex.path);
          relative = type === lower;

          var x1, y1, x2, y2, x3, y3, x4, y4, reflection;

          switch (lower) {

            case 'z':
              if (i >= last) {
                closed = true;
              } else {
                x = coord.x;
                y = coord.y;
                result = new Anchor(
                  x, y,
                  undefined, undefined,
                  undefined, undefined,
                  Commands.close
                );
                // Make coord be the last `m` command
                for (var j = points.length - 1; j >= 0; j--) {
                  var point = points[j];
                  if (/m/i.test(point.command)) {
                    coord = point;
                    break;
                  }
                }
              }
              break;

            case 'm':
            case 'l':

              control = undefined;

              x = parseFloat(coords[0]);
              y = parseFloat(coords[1]);

              result = new Anchor(
                x, y,
                undefined, undefined,
                undefined, undefined,
                /m/i.test(lower) ? Commands.move : Commands.line
              );

              if (relative) {
                result.addSelf(coord);
              }

              // result.controls.left.copy(result);
              // result.controls.right.copy(result);

              coord = result;
              break;

            case 'h':
            case 'v':

              var a = /h/i.test(lower) ? 'x' : 'y';
              var b = /x/i.test(a) ? 'y' : 'x';

              result = new Anchor(
                undefined, undefined,
                undefined, undefined,
                undefined, undefined,
                Commands.line
              );
              result[a] = parseFloat(coords[0]);
              result[b] = coord[b];

              if (relative) {
                result[a] += coord[a];
              }

              // result.controls.left.copy(result);
              // result.controls.right.copy(result);

              coord = result;
              break;

            case 'c':
            case 's':

              x1 = coord.x;
              y1 = coord.y;

              if (!control) {
                control = new Vector();//.copy(coord);
              }

              if (/c/i.test(lower)) {

                x2 = parseFloat(coords[0]);
                y2 = parseFloat(coords[1]);
                x3 = parseFloat(coords[2]);
                y3 = parseFloat(coords[3]);
                x4 = parseFloat(coords[4]);
                y4 = parseFloat(coords[5]);

              } else {

                // Calculate reflection control point for proper x2, y2
                // inclusion.

                reflection = getReflection(coord, control, relative);

                x2 = reflection.x;
                y2 = reflection.y;
                x3 = parseFloat(coords[0]);
                y3 = parseFloat(coords[1]);
                x4 = parseFloat(coords[2]);
                y4 = parseFloat(coords[3]);

              }

              if (relative) {
                x2 += x1;
                y2 += y1;
                x3 += x1;
                y3 += y1;
                x4 += x1;
                y4 += y1;
              }

              if (!_.isObject(coord.controls)) {
                Anchor.AppendCurveProperties(coord);
              }

              coord.controls.right.set(x2 - coord.x, y2 - coord.y);
              result = new Anchor(
                x4, y4,
                x3 - x4, y3 - y4,
                undefined, undefined,
                Commands.curve
              );

              coord = result;
              control = result.controls.left;

              break;

            case 't':
            case 'q':

              x1 = coord.x;
              y1 = coord.y;

              if (!control) {
                control = new Vector();
              }

              if (/q/i.test(lower)) {

                x2 = parseFloat(coords[0]);
                y2 = parseFloat(coords[1]);
                x3 = parseFloat(coords[0]);
                y3 = parseFloat(coords[1]);
                x4 = parseFloat(coords[2]);
                y4 = parseFloat(coords[3]);

              } else {

                reflection = getReflection(coord, control, relative);

                x2 = reflection.x;
                y2 = reflection.y;
                x3 = reflection.x;
                y3 = reflection.y;
                x4 = parseFloat(coords[0]);
                y4 = parseFloat(coords[1]);

              }

              if (relative) {
                x2 += x1;
                y2 += y1;
                x3 += x1;
                y3 += y1;
                x4 += x1;
                y4 += y1;
              }

              if (!_.isObject(coord.controls)) {
                Anchor.AppendCurveProperties(coord);
              }

              coord.controls.right.set(
                (x2 - coord.x) * 0.33, (y2 - coord.y) * 0.33);
              result = new Anchor(
                x4, y4,
                x3 - x4, y3 - y4,
                undefined, undefined,
                Commands.curve
              );

              coord = result;
              control = result.controls.left;

              break;

            case 'a':

              x1 = coord.x;
              y1 = coord.y;

              var rx = parseFloat(coords[0]);
              var ry = parseFloat(coords[1]);
              var xAxisRotation = parseFloat(coords[2]);// * PI / 180;
              var largeArcFlag = parseFloat(coords[3]);
              var sweepFlag = parseFloat(coords[4]);

              x4 = parseFloat(coords[5]);
              y4 = parseFloat(coords[6]);

              if (relative) {
                x4 += x1;
                y4 += y1;
              }

              var anchor = new Anchor(x4, y4);
              anchor.command = Commands.arc;
              anchor.rx = rx;
              anchor.ry = ry;
              anchor.xAxisRotation = xAxisRotation;
              anchor.largeArcFlag = largeArcFlag;
              anchor.sweepFlag = sweepFlag;

              result = anchor;

              coord = anchor;
              control = undefined;

              break;

          }

          if (result) {
            if (Array.isArray(result)) {
              points = points.concat(result);
            } else {
              points.push(result);
            }
          }

        });

      }

      path = new Path(points, closed, undefined, true).noStroke();
      path.fill = 'black';

      var rect = path.getBoundingClientRect(true);

      // Center objects to stay consistent
      // with the rest of the Two.js API.
      rect.centroid = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };

      _.each(path.vertices, function(v) {
        v.subSelf(rect.centroid);
      });

      applySvgAttributes.call(this, node, path, parentStyles);

      path.translation.addSelf(rect.centroid);

      return path;

    },

    circle: function(node, parentStyles) {

      var x = parseFloat(node.getAttribute('cx'));
      var y = parseFloat(node.getAttribute('cy'));
      var r = parseFloat(node.getAttribute('r'));

      var circle = new Circle(0, 0, r).noStroke();
      circle.fill = 'black';

      applySvgAttributes.call(this, node, circle, parentStyles);

      circle.translation.x = x;
      circle.translation.y = y;

      return circle;

    },

    ellipse: function(node, parentStyles) {

      var x = parseFloat(node.getAttribute('cx'));
      var y = parseFloat(node.getAttribute('cy'));
      var width = parseFloat(node.getAttribute('rx'));
      var height = parseFloat(node.getAttribute('ry'));

      var ellipse = new Ellipse(0, 0, width, height).noStroke();
      ellipse.fill = 'black';

      applySvgAttributes.call(this, node, ellipse, parentStyles);

      ellipse.translation.x = x;
      ellipse.translation.y = y;

      return ellipse;

    },

    rect: function(node, parentStyles) {

      var rx = parseFloat(node.getAttribute('rx'));
      var ry = parseFloat(node.getAttribute('ry'));

      if (!_.isNaN(rx) || !_.isNaN(ry)) {
        return read['rounded-rect'](node);
      }

      var width = parseFloat(node.getAttribute('width'));
      var height = parseFloat(node.getAttribute('height'));

      var w2 = width / 2;
      var h2 = height / 2;

      var rect = new Rectangle(0, 0, width, height)
        .noStroke();
      rect.fill = 'black';

      applySvgAttributes.call(this, node, rect, parentStyles);

      // For rectangles, (x, y) is the center of the shape rather than the top
      // left corner.
      rect.translation.x += w2;
      rect.translation.y += h2;

      return rect;

    },

    'rounded-rect': function(node, parentStyles) {

      var rx = parseFloat(node.getAttribute('rx')) || 0;
      var ry = parseFloat(node.getAttribute('ry')) || 0;

      var width = parseFloat(node.getAttribute('width'));
      var height = parseFloat(node.getAttribute('height'));

      var w2 = width / 2;
      var h2 = height / 2;
      var radius = new Vector(rx, ry);

      var rect = new RoundedRectangle(0, 0, width, height, radius)
        .noStroke();
      rect.fill = 'black';

      applySvgAttributes.call(this, node, rect, parentStyles);

      // For rectangles, (x, y) is the center of the shape rather than the top
      // left corner.
      rect.translation.x += w2;
      rect.translation.y += h2;

      return rect;

    },

    line: function(node, parentStyles) {

      var x1 = parseFloat(node.getAttribute('x1'));
      var y1 = parseFloat(node.getAttribute('y1'));
      var x2 = parseFloat(node.getAttribute('x2'));
      var y2 = parseFloat(node.getAttribute('y2'));

      var line = new Line(x1, y1, x2, y2).noFill();

      applySvgAttributes.call(this, node, line, parentStyles);

      return line;

    },

    lineargradient: function(node, parentStyles) {

      var x1 = parseFloat(node.getAttribute('x1'));
      var y1 = parseFloat(node.getAttribute('y1'));
      var x2 = parseFloat(node.getAttribute('x2'));
      var y2 = parseFloat(node.getAttribute('y2'));

      var ox = (x2 + x1) / 2;
      var oy = (y2 + y1) / 2;

      var stops = [];
      for (var i = 0; i < node.children.length; i++) {

        var child = node.children[i];

        var offset = child.getAttribute('offset');
        if (/%/ig.test(offset)) {
          offset = parseFloat(offset.replace(/%/ig, '')) / 100;
        }
        offset = parseFloat(offset);

        var color = child.getAttribute('stop-color');
        var opacity = child.getAttribute('stop-opacity');
        var style = child.getAttribute('style');

        var matches;
        if (color === null) {
          matches = style ? style.match(/stop-color:\s?([#a-fA-F0-9]*)/) : false;
          color = matches && matches.length > 1 ? matches[1] : undefined;
        }

        if (opacity === null) {
          matches = style ? style.match(/stop-opacity:\s?([0-9.-]*)/) : false;
          opacity = matches && matches.length > 1 ? parseFloat(matches[1]) : 1;
        } else {
          opacity = parseFloat(opacity);
        }

        stops.push(new Stop(offset, color, opacity));

      }

      var gradient = new LinearGradient(x1 - ox, y1 - oy, x2 - ox,
        y2 - oy, stops);

      applySvgAttributes.call(this, node, gradient, parentStyles);

      return gradient;

    },

    radialgradient: function(node, parentStyles) {

      var cx = parseFloat(node.getAttribute('cx')) || 0;
      var cy = parseFloat(node.getAttribute('cy')) || 0;
      var r = parseFloat(node.getAttribute('r'));

      var fx = parseFloat(node.getAttribute('fx'));
      var fy = parseFloat(node.getAttribute('fy'));

      if (_.isNaN(fx)) {
        fx = cx;
      }

      if (_.isNaN(fy)) {
        fy = cy;
      }

      var ox = Math.abs(cx + fx) / 2;
      var oy = Math.abs(cy + fy) / 2;

      var stops = [];
      for (var i = 0; i < node.children.length; i++) {

        var child = node.children[i];

        var offset = child.getAttribute('offset');
        if (/%/ig.test(offset)) {
          offset = parseFloat(offset.replace(/%/ig, '')) / 100;
        }
        offset = parseFloat(offset);

        var color = child.getAttribute('stop-color');
        var opacity = child.getAttribute('stop-opacity');
        var style = child.getAttribute('style');

        var matches;
        if (color === null) {
          matches = style ? style.match(/stop-color:\s?([#a-fA-F0-9]*)/) : false;
          color = matches && matches.length > 1 ? matches[1] : undefined;
        }

        if (opacity === null) {
          matches = style ? style.match(/stop-opacity:\s?([0-9.-]*)/) : false;
          opacity = matches && matches.length > 1 ? parseFloat(matches[1]) : 1;
        } else {
          opacity = parseFloat(opacity);
        }

        stops.push(new Stop(offset, color, opacity));

      }

      var gradient = new RadialGradient(cx - ox, cy - oy, r,
        stops, fx - ox, fy - oy);

      applySvgAttributes.call(this, node, gradient, parentStyles);

      return gradient;

    },

    text: function(node, parentStyles) {

      var alignment = getAlignment(node.getAttribute('text-anchor')) || 'left';
      var baseline = getBaseline(node) || 'baseline';
      var message = node.textContent;

      var text = new Text(message);

      applySvgAttributes.call(this, node, text, parentStyles);

      text.alignment = alignment;
      text.baseline = baseline;

      return text;

    },

    clippath: function(node, parentStyles) {
      if (read.defs.current && !read.defs.current.contains(node.id)) {
        read.defs.current.add(node.id, node);
      }
      return null;
    },

    image: function(node, parentStyles) {

      var href = node.getAttribute('href') || node.getAttribute('xlink:href');
      if (!href) {
        var error = new TwoError('encountered <image /> with no href.');
        console.warn(error.name, error.message);
        return null;
      }

      var x = parseFloat(node.getAttribute('x')) || 0;
      var y = parseFloat(node.getAttribute('y')) || 0;
      var width = parseFloat(node.getAttribute('width'));
      var height = parseFloat(node.getAttribute('height'));

      var sprite = new Sprite(href, x, y);

      if (!_.isNaN(width)) {
        sprite.width = width;
      }
      if (!_.isNaN(height)) {
        sprite.height = height;
      }

      applySvgAttributes.call(this, node, sprite, parentStyles);

      return sprite;
    }

  };

  /**
   * @name Two.Utils.xhr
   * @function
   * @param {String} path
   * @param {Function} callback
   * @returns {XMLHttpRequest} The constructed and called XHR request.
   * @description Canonical method to initiate `GET` requests in the browser. Mainly used by {@link Two#load} method.
   */
  function xhr(path, callback) {

    var xhr = new XMLHttpRequest();
    xhr.open('GET', path);

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        callback(xhr.responseText);
      }
    };

    xhr.send();
    return xhr;

  }

  /**
   * @name Two.ImageSequence
   * @class
   * @extends Two.Rectangle
   * @param {String|String[]|Two.Texture|Two.Texture[]} paths - A list of URLs or {@link Two.Texture}s.
   * @param {Number} [ox=0] - The initial `x` position of the Two.ImageSequence.
   * @param {Number} [oy=0] - The initial `y` position of the Two.ImageSequence.
   * @param {Number} [frameRate=30] - The frame rate at which the images should playback at.
   * @description A convenient package to display still or animated images organized as a series of still images.
   */
  function ImageSequence(paths, ox, oy, frameRate) {

    // Not using default constructor of Rectangle due to odd `beginning` / `ending` behavior.
    // See: https://github.com/jonobr1/two.js/issues/383
    Path.call(this, [
      new Anchor(),
      new Anchor(),
      new Anchor(),
      new Anchor()
    ], true);

    this._renderer.flagTextures = ImageSequence.FlagTextures.bind(this);
    this._renderer.bindTextures = ImageSequence.BindTextures.bind(this);
    this._renderer.unbindTextures = ImageSequence.UnbindTextures.bind(this);

    this.noStroke();
    this.noFill();

    /**
     * @name Two.ImageSequence#textures
     * @property {Two.Texture[]} - A list of textures to be used as frames for animating the {@link Two.ImageSequence}.
     */
    if (Array.isArray(paths)) {
      this.textures = paths.map(ImageSequence.GenerateTexture.bind(this));
    } else {
      // If just a single path convert into a single Two.Texture
      this.textures = [ImageSequence.GenerateTexture(paths)];
    }

    this.origin = new Vector();

    this._update();
    this.translation.set(ox || 0, oy || 0);

    /**
     * @name Two.ImageSequence#frameRate
     * @property {Number} - The number of frames to animate against per second.
     */
    if (typeof frameRate === 'number') {
      this.frameRate = frameRate;
    } else {
      this.frameRate = ImageSequence.DefaultFrameRate;
    }

    /**
     * @name Two.ImageSequence#index
     * @property {Number} - The index of the current tile of the sprite to display. Defaults to `0`.
     */
    this.index = 0;

  }

  _.extend(ImageSequence, {

    /**
     * @name Two.ImageSequence.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.ImageSequence}.
     */
    Properties: [
      'frameRate',
      'index'
    ],

    /**
     * @name Two.ImageSequence.DefaultFrameRate
     * @property The default frame rate that {@link Two.ImageSequence#frameRate} is set to when instantiated.
     */
    DefaultFrameRate: 30,

    /**
     * @name Two.ImageSequence.FlagTextures
     * @function
     * @description Cached method to let renderers know textures have been updated on a {@link Two.ImageSequence}.
     */
    FlagTextures: function() {
      this._flagTextures = true;
    },

    /**
     * @name Two.ImageSequence.BindTextures
     * @function
     * @description Cached method to let {@link Two.ImageSequence} know textures have been added to the instance.
     */
    BindTextures: function(items) {

      var i = items.length;
      while (i--) {
        items[i].bind(Events.Types.change, this._renderer.flagTextures);
      }

      this._renderer.flagTextures();

    },

    /**
     * @name Two.ImageSequence.UnbindVertices
     * @function
     * @description Cached method to let {@link Two.ImageSequence} know textures have been removed from the instance.
     */
    UnbindTextures: function(items) {

      var i = items.length;
      while (i--) {
        items[i].unbind(Events.Types.change, this._renderer.flagTextures);
      }

      this._renderer.flagTextures();

    },

    /**
     * @name Two.ImageSequence.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.ImageSequence} to any object. Handy if you'd like to extend or inherit the {@link Two.ImageSequence} class on a custom class.
     */
    MakeObservable: function(obj) {

      Rectangle.MakeObservable(obj);
      _.each(ImageSequence.Properties, defineGetterSetter, obj);

      Object.defineProperty(obj, 'textures', {

        enumerable: true,

        get: function() {
          return this._textures;
        },

        set: function(textures) {

          var bindTextures = this._renderer.bindTextures;
          var unbindTextures = this._renderer.unbindTextures;

          // Remove previous listeners
          if (this._textures) {
            this._textures
              .unbind(Events.Types.insert, bindTextures)
              .unbind(Events.Types.remove, unbindTextures);
          }

          // Create new Collection with copy of vertices
          this._textures = new Collection((textures || []).slice(0));

          // Listen for Collection changes and bind / unbind
          this._textures
            .bind(Events.Types.insert, bindTextures)
            .bind(Events.Types.remove, unbindTextures);

          // Bind Initial Textures
          bindTextures(this._textures);

        }

      });

    },

    /**
     * @name Two.ImageSequence.GenerateTexture
     * @property {Function} - Shorthand function to prepare source image material into readable format by {@link Two.ImageSequence}.
     * @param {String|Two.Texture} textureOrString - The texture or string to create a {@link Two.Texture} from.
     * @description Function used internally by {@link Two.ImageSequence} to parse arguments and return {@link Two.Texture}s.
     * @returns {Two.Texture}
     */
    GenerateTexture: function(obj) {
      if (obj instanceof Texture) {
        return obj;
      } else if (typeof obj === 'string') {
        return new Texture(obj);
      }
    }

  });

  _.extend(ImageSequence.prototype, Rectangle.prototype, {

    constructor: ImageSequence,

    /**
     * @name Two.ImageSequence#_flagTextures
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#textures} need updating.
     */
    _flagTextures: false,

    /**
     * @name Two.ImageSequence#_flagFrameRate
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#frameRate} needs updating.
     */
    _flagFrameRate: false,

    /**
     * @name Two.ImageSequence#_flagIndex
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#index} needs updating.
     */
    _flagIndex: false,

    // Private variables

    /**
     * @name Two.ImageSequence#_amount
     * @private
     * @property {Number} - Number of frames for a given {@link Two.ImageSequence}.
     */
    _amount: 1,

    /**
     * @name Two.ImageSequence#_duration
     * @private
     * @property {Number} - Number of milliseconds a {@link Two.ImageSequence}.
     */
    _duration: 0,

    /**
     * @name Two.ImageSequence#_index
     * @private
     * @property {Number} - The current frame the {@link Two.ImageSequence} is currently displaying.
     */
    _index: 0,

    /**
     * @name Two.ImageSequence#_startTime
     * @private
     * @property {Milliseconds} - Epoch time in milliseconds of when the {@link Two.ImageSequence} started.
     */
    _startTime: 0,

    /**
     * @name Two.ImageSequence#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.ImageSequence} is animating or not.
     */
    _playing: false,

    /**
     * @name Two.ImageSequence#_firstFrame
     * @private
     * @property {Number} - The frame the {@link Two.ImageSequence} should start with.
     */
    _firstFrame: 0,

    /**
     * @name Two.ImageSequence#_lastFrame
     * @private
     * @property {Number} - The frame the {@link Two.ImageSequence} should end with.
     */
    _lastFrame: 0,

    /**
     * @name Two.ImageSequence#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.ImageSequence} should loop or not.
     */
    _loop: true,

    // Exposed through getter-setter

    /**
     * @name Two.ImageSequence#_textures
     * @private
     * @see {@link Two.ImageSequence#textures}
     */
    _textures: null,

    /**
     * @name Two.ImageSequence#_frameRate
     * @private
     * @see {@link Two.ImageSequence#frameRate}
     */
    _frameRate: 0,

    /**
     * @name Two.ImageSequence#_origin
     * @private
     * @see {@link Two.ImageSequence#origin}
     */
    _origin: null,

    /**
     * @name Two.ImageSequence#play
     * @function
     * @param {Number} [firstFrame=0] - The index of the frame to start the animation with.
     * @param {Number} [lastFrame] - The index of the frame to end the animation with. Defaults to the last item in the {@link Two.ImageSequence#textures}.
     * @param {Function} [onLastFrame] - Optional callback function to be triggered after playing the last frame. This fires multiple times when the image sequence is looped.
     * @description Initiate animation playback of a {@link Two.ImageSequence}.
     */
    play: function(firstFrame, lastFrame, onLastFrame) {

      this._playing = true;
      this._firstFrame = 0;
      this._lastFrame = this.amount - 1;
      this._startTime = _.performance.now();

      if (typeof firstFrame === 'number') {
        this._firstFrame = firstFrame;
      }
      if (typeof lastFrame === 'number') {
        this._lastFrame = lastFrame;
      }
      if (typeof onLastFrame === 'function') {
        this._onLastFrame = onLastFrame;
      } else {
        delete this._onLastFrame;
      }

      if (this._index !== this._firstFrame) {
        this._startTime -= 1000 * Math.abs(this._index - this._firstFrame)
          / this._frameRate;
      }

      return this;

    },

    /**
     * @name Two.ImageSequence#pause
     * @function
     * @description Halt animation playback of a {@link Two.ImageSequence}.
     */
    pause: function() {

      this._playing = false;
      return this;

    },

    /**
     * @name Two.ImageSequence#stop
     * @function
     * @description Halt animation playback of a {@link Two.ImageSequence} and set the current frame back to the first frame.
     */
    stop: function() {

      this._playing = false;
      this._index = this._firstFrame;

      return this;

    },

    /**
     * @name Two.ImageSequence#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.ImageSequence}
     * @description Create a new instance of {@link Two.ImageSequence} with the same properties of the current image sequence.
     */
    clone: function(parent) {

      var clone = new ImageSequence(this.textures, this.translation.x,
        this.translation.y, this.frameRate);

      clone._loop = this._loop;

      if (this._playing) {
        clone.play();
      }

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.ImageSequence#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {
      var object = Rectangle.prototype.toObject.call(this);
      object.textures = this.textures.map(function(texture) {
        return texture.toObject();
      });
      object.frameRate = this.frameRate;
      object.index = this.index;
      object._firstFrame = this._firstFrame;
      object._lastFrame = this._lastFrame;
      object._loop = this._loop;
      return object;
    },

    /**
     * @name Two.ImageSequence#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var effects = this._textures;
      var width, height, elapsed, amount, duration, texture;
      var index, frames;

      if (this._flagTextures) {
        this._amount = effects.length;
      }

      if (this._flagFrameRate) {
        this._duration = 1000 * this._amount / this._frameRate;
      }

      if (this._playing && this._frameRate > 0) {

        amount = this._amount;

        if (_.isNaN(this._lastFrame)) {
          this._lastFrame = amount - 1;
        }

        // TODO: Offload perf logic to instance of `Two`.
        elapsed = _.performance.now() - this._startTime;
        frames = this._lastFrame + 1;
        duration = 1000 * (frames - this._firstFrame) / this._frameRate;

        if (this._loop) {
          elapsed = elapsed % duration;
        } else {
          elapsed = Math.min(elapsed, duration);
        }

        index = lerp(this._firstFrame, frames, elapsed / duration);
        index = Math.floor(index);

        if (index !== this._index) {

          this._index = index;
          texture = effects[this._index];

          if (texture.loaded) {

            width = texture.image.width;
            height = texture.image.height;

            if (this.width !== width) {
              this.width = width;
            }
            if (this.height !== height) {
              this.height = height;
            }

            this.fill = texture;

            if (index >= this._lastFrame - 1 && this._onLastFrame) {
              this._onLastFrame();  // Shortcut for chainable sprite animations
            }

          }

        }

      } else if (this._flagIndex || !(this.fill instanceof Texture)) {

        texture = effects[this._index];

        if (texture.loaded) {

          width = texture.image.width;
          height = texture.image.height;

          if (this.width !== width) {
            this.width = width;
          }
          if (this.height !== height) {
            this.height = height;
          }

        }

        this.fill = texture;

      }

      Rectangle.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.ImageSequence#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagTextures = this._flagFrameRate = false;
      Rectangle.prototype.flagReset.call(this);

      return this;

    }

  });

  ImageSequence.MakeObservable(ImageSequence.prototype);

  var TWO_PI$2 = Math.PI * 2, HALF_PI = Math.PI / 2;

  /**
   * @name Two.ArcSegment
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the arc segment.
   * @param {Number} [y=0] - The y position of the arc segment.
   * @param {Number} [innerRadius=0] - The inner radius value of the arc segment.
   * @param {Number} [outerRadius=0] - The outer radius value of the arc segment.
   * @param {Number} [startAngle=0] - The start angle of the arc segment in Number.
   * @param {Number} [endAngle=6.2831] - The end angle of the arc segment in Number.
   * @param {Number} [resolution=24] - The number of vertices used to construct the arc segment.
   */
  function ArcSegment(ox, oy, ir, or, sa, ea, res) {

    var amount = res || (Constants.Resolution * 3);
    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(new Anchor());
    }

    Path.call(this, points, true, false, true);

    /**
     * @name Two.ArcSegment#innerRadius
     * @property {Number} - The size of the inner radius of the arc segment.
     */
    if (typeof ir === 'number') {
      this.innerRadius = ir;
    }

    /**
     * @name Two.ArcSegment#outerRadius
     * @property {Number} - The size of the outer radius of the arc segment.
     */
    if (typeof or === 'number') {
      this.outerRadius = or;
    }

    /**
     * @name Two.ArcSegment#startRadius
     * @property {Number} - The angle of one side for the arc segment.
     */
    if (typeof sa === 'number') {
      this.startAngle = sa;
    }

    /**
     * @name Two.ArcSegment#endAngle
     * @property {Number} - The angle of the other side for the arc segment.
     */
    if (typeof ea === 'number') {
      this.endAngle = ea;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(ArcSegment, {

    /**
     * @name Two.ArcSegment.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.ArcSegment}.
     */
    Properties: ['startAngle', 'endAngle', 'innerRadius', 'outerRadius'],

    /**
     * @name Two.ArcSegment.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.ArcSegment} to any object. Handy if you'd like to extend the {@link Two.ArcSegment} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(ArcSegment.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(ArcSegment.prototype, Path.prototype, {

    constructor: ArcSegment,

    /**
     * @name Two.ArcSegment#_flagStartAngle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#startAngle} needs updating.
     */
    _flagStartAngle: false,
    /**
     * @name Two.ArcSegment#_flagEndAngle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#endAngle} needs updating.
     */
    _flagEndAngle: false,
    /**
     * @name Two.ArcSegment#_flagInnerRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#innerRadius} needs updating.
     */
    _flagInnerRadius: false,
    /**
     * @name Two.ArcSegment#_flagOuterRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#outerRadius} needs updating.
     */
    _flagOuterRadius: false,

    /**
     * @name Two.ArcSegment#_startAngle
     * @private
     * @see {@link Two.ArcSegment#startAngle}
     */
    _startAngle: 0,
    /**
     * @name Two.ArcSegment#_endAngle
     * @private
     * @see {@link Two.ArcSegment#endAngle}
     */
    _endAngle: TWO_PI$2,
    /**
     * @name Two.ArcSegment#_innerRadius
     * @private
     * @see {@link Two.ArcSegment#innerRadius}
     */
    _innerRadius: 0,
    /**
     * @name Two.ArcSegment#_outerRadius
     * @private
     * @see {@link Two.ArcSegment#outerRadius}
     */
    _outerRadius: 0,

    /**
     * @name Two.ArcSegment#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagStartAngle || this._flagEndAngle
        || this._flagInnerRadius || this._flagOuterRadius) {

        var sa = this._startAngle;
        var ea = this._endAngle;

        var ir = this._innerRadius;
        var or = this._outerRadius;

        var connected = mod(sa, TWO_PI$2) === mod(ea, TWO_PI$2);
        var punctured = ir > 0;

        var vertices = this.vertices;
        var length = (punctured ? vertices.length / 2 : vertices.length);
        var command, id = 0;

        if (connected) {
          length--;
        } else if (!punctured) {
          length -= 2;
        }

        /**
         * Outer Circle
         */
        for (var i = 0, last = length - 1; i < length; i++) {

          var pct = i / last;
          var v = vertices[id];
          var theta = pct * (ea - sa) + sa;
          var step = (ea - sa) / length;

          var x = or * Math.cos(theta);
          var y = or * Math.sin(theta);

          switch (i) {
            case 0:
              command = Commands.move;
              break;
            default:
              command = Commands.curve;
          }

          v.command = command;
          v.x = x;
          v.y = y;
          v.controls.left.clear();
          v.controls.right.clear();

          if (v.command === Commands.curve) {
            var amp = or * step / Math.PI;
            v.controls.left.x = amp * Math.cos(theta - HALF_PI);
            v.controls.left.y = amp * Math.sin(theta - HALF_PI);
            v.controls.right.x = amp * Math.cos(theta + HALF_PI);
            v.controls.right.y = amp * Math.sin(theta + HALF_PI);
            if (i === 1) {
              v.controls.left.multiplyScalar(2);
            }
            if (i === last) {
              v.controls.right.multiplyScalar(2);
            }
          }

          id++;

        }

        if (punctured) {

          if (connected) {
            vertices[id].command = Commands.close;
            id++;
          } else {
            length--;
            last = length - 1;
          }

          /**
           * Inner Circle
           */
          for (i = 0; i < length; i++) {

            pct = i / last;
            v = vertices[id];
            theta = (1 - pct) * (ea - sa) + sa;
            step = (ea - sa) / length;

            x = ir * Math.cos(theta);
            y = ir * Math.sin(theta);
            command = Commands.curve;
            if (i <= 0) {
              command = connected ? Commands.move : Commands.line;
            }

            v.command = command;
            v.x = x;
            v.y = y;
            v.controls.left.clear();
            v.controls.right.clear();

            if (v.command === Commands.curve) {
              amp = ir * step / Math.PI;
              v.controls.left.x = amp * Math.cos(theta + HALF_PI);
              v.controls.left.y = amp * Math.sin(theta + HALF_PI);
              v.controls.right.x = amp * Math.cos(theta - HALF_PI);
              v.controls.right.y = amp * Math.sin(theta - HALF_PI);
              if (i === 1) {
                v.controls.left.multiplyScalar(2);
              }
              if (i === last) {
                v.controls.right.multiplyScalar(2);
              }
            }

            id++;

          }

          // Final Point
          vertices[id].copy(vertices[0]);
          vertices[id].command = Commands.line;

        } else if (!connected) {

          vertices[id].command = Commands.line;
          vertices[id].x = 0;
          vertices[id].y = 0;
          id++;

          // Final Point
          vertices[id].copy(vertices[0]);
          vertices[id].command = Commands.line;

        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.ArcSegment#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      Path.prototype.flagReset.call(this);

      this._flagStartAngle = this._flagEndAngle
        = this._flagInnerRadius = this._flagOuterRadius = false;

      return this;

    },

    /**
     * @name Two.ArcSegment#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.ArcSegment}
     * @description Create a new instance of {@link Two.ArcSegment} with the same properties of the current path.
     */
    clone: function(parent) {

      var ir = this.innerRadius;
      var or = this.outerRadius;
      var sa = this.startAngle;
      var ea = this.endAngle;
      var resolution = this.vertices.length;

      var clone = new ArcSegment(0, 0, ir, or, sa, ea, resolution);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.ArcSegment#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(ArcSegment.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  ArcSegment.MakeObservable(ArcSegment.prototype);

  var TWO_PI$1 = Math.PI * 2, cos$1 = Math.cos, sin$1 = Math.sin;

  /**
   * @name Two.Polygon
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the polygon.
   * @param {Number} [y=0] - The y position of the polygon.
   * @param {Number} [radius=0] - The radius value of the polygon.
   * @param {Number} [sides=12] - The number of vertices used to construct the polygon.
   */
  function Polygon(ox, oy, r, sides) {

    sides = Math.max(sides || 0, 3);

    Path.call(this);

    this.closed = true;
    this.automatic = false;

    /**
     * @name Two.Polygon#width
     * @property {Number} - The size of the width of the polygon.
     */
    if (typeof r === 'number') {
      this.width = r * 2;
    }

    /**
     * @name Two.Polygon#height
     * @property {Number} - The size of the height of the polygon.
     */
    if (typeof r === 'number') {
      this.height = r * 2;
    }

    /**
     * @name Two.Polygon#sides
     * @property {Number} - The amount of sides the polyogn has.
     */
    if (typeof sides === 'number') {
      this.sides = sides;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(Polygon, {

    /**
     * @name Two.Polygon.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Polygon}.
     */
    Properties: ['width', 'height', 'sides'],

    /**
     * @name Two.Polygon.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Polygon} to any object. Handy if you'd like to extend the {@link Two.Polygon} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Polygon.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Polygon.prototype, Path.prototype, {

    constructor: Polygon,

    /**
     * @name Two.Polygon#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.Polygon#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#height} needs updating.
     */
    _flagHeight: false,
    /**
     * @name Two.Polygon#_flagSides
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#sides} needs updating.
     */
    _flagSides: false,

    /**
     * @name Two.Polygon#_width
     * @private
     * @see {@link Two.Polygon#width}
     */
    _width: 0,
    /**
     * @name Two.Polygon#_height
     * @private
     * @see {@link Two.Polygon#height}
     */
    _height: 0,
    /**
     * @name Two.Polygon#_sides
     * @private
     * @see {@link Two.Polygon#sides}
     */
    _sides: 0,

    /**
     * @name Two.Polygon#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight || this._flagSides) {

        var sides = this._sides;
        var amount = sides + 1;
        var length = this.vertices.length;

        if (length > sides) {
          this.vertices.splice(sides - 1, length - sides);
          length = sides;
        }

        for (var i = 0; i < amount; i++) {

          var pct = (i + 0.5) / sides;
          var theta = TWO_PI$1 * pct + Math.PI / 2;
          var x = this._width * cos$1(theta) / 2;
          var y = this._height * sin$1(theta) / 2;

          if (i >= length) {
            this.vertices.push(new Anchor(x, y));
          } else {
            this.vertices[i].set(x, y);
          }

          this.vertices[i].command = i === 0 ? Commands.move : Commands.line;

        }

      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Polygon#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = this._flagSides = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Polygon#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Polygon}
     * @description Create a new instance of {@link Two.Polygon} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Polygon(0, 0, this.radius, this.sides);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Polygon#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Polygon.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Polygon.MakeObservable(Polygon.prototype);

  var TWO_PI = Math.PI * 2, cos = Math.cos, sin = Math.sin;

  /**
   * @name Two.Star
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the star.
   * @param {Number} [y=0] - The y position of the star.
   * @param {Number} [innerRadius=0] - The inner radius value of the star.
   * @param {Number} [outerRadius=0] - The outer radius value of the star.
   * @param {Number} [sides=5] - The number of sides used to construct the star.
   */
  function Star(ox, oy, ir, or, sides) {

    if (arguments.length <= 3) {
      or = ir;
      ir = or / 2;
    }

    if (typeof sides !== 'number' || sides <= 0) {
      sides = 5;
    }

    Path.call(this);
    this.closed = true;
    this.automatic = false;

    /**
     * @name Two.Star#innerRadius
     * @property {Number} - The size of the inner radius of the star.
     */
    if (typeof ir === 'number') {
      this.innerRadius = ir;
    }

    /**
     * @name Two.Star#outerRadius
     * @property {Number} - The size of the outer radius of the star.
     */
    if (typeof or === 'number') {
      this.outerRadius = or;
    }

    /**
     * @name Two.Star#sides
     * @property {Number} - The amount of sides the star has.
     */
    if (typeof sides === 'number') {
      this.sides = sides;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(Star, {

    /**
     * @name Two.Star.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Star}.
     */
    Properties: ['innerRadius', 'outerRadius', 'sides'],

    /**
     * @name Two.Star.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Star} to any object. Handy if you'd like to extend the {@link Two.Star} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Star.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Star.prototype, Path.prototype, {

    constructor: Star,

    /**
     * @name Two.Star#_flagInnerRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#innerRadius} needs updating.
     */
    _flagInnerRadius: false,
    /**
     * @name Two.Star#_flagOuterRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#outerRadius} needs updating.
     */
    _flagOuterRadius: false,
    /**
     * @name Two.Star#_flagSides
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#sides} needs updating.
     */
    _flagSides: false,

    /**
     * @name Two.Star#_innerRadius
     * @private
     * @see {@link Two.Star#innerRadius}
     */
    _innerRadius: 0,
    /**
     * @name Two.Star#_outerRadius
     * @private
     * @see {@link Two.Star#outerRadius}
     */
    _outerRadius: 0,
    /**
     * @name Two.Star#_sides
     * @private
     * @see {@link Two.Star#sides}
     */
    _sides: 0,

    /**
     * @name Two.Star#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagInnerRadius || this._flagOuterRadius || this._flagSides) {

        var sides = this._sides * 2;
        var amount = sides + 1;
        var length = this.vertices.length;

        if (length > sides) {
          this.vertices.splice(sides - 1, length - sides);
          length = sides;
        }

        for (var i = 0; i < amount; i++) {

          var pct = (i + 0.5) / sides;
          var theta = TWO_PI * pct;
          var r = (!(i % 2) ? this._innerRadius : this._outerRadius) / 2;
          var x = r * cos(theta);
          var y = r * sin(theta);

          if (i >= length) {
            this.vertices.push(new Anchor(x, y));
          } else {
            this.vertices[i].set(x, y);
          }

          this.vertices[i].command = i === 0 ? Commands.move : Commands.line;

        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Star#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagInnerRadius = this._flagOuterRadius = this._flagSides = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Star#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Star}
     * @description Create a new instance of {@link Two.Star} with the same properties of the current path.
     */
    clone: function(parent) {

      var ir = this.innerRadius;
      var or = this.outerRadius;
      var sides = this.sides;

      var clone = new Star(0, 0, ir, or, sides);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Star#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Star.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Star.MakeObservable(Star.prototype);

  var svg = {

    version: 1.1,

    ns: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink',

    alignments: {
      left: 'start',
      center: 'middle',
      right: 'end'
    },

    // Create an svg namespaced element.
    createElement: function(name, attrs) {
      var tag = name;
      var elem = document.createElementNS(svg.ns, tag);
      if (tag === 'svg') {
        attrs = _.defaults(attrs || {}, {
          version: svg.version
        });
      }
      if (attrs && Object.keys(attrs).length > 0) {
        svg.setAttributes(elem, attrs);
      }
      return elem;
    },

    // Add attributes from an svg element.
    setAttributes: function(elem, attrs) {
      var keys = Object.keys(attrs);
      for (var i = 0; i < keys.length; i++) {
        if (/href/.test(keys[i])) {
          elem.setAttributeNS(svg.xlink, keys[i], attrs[keys[i]]);
        } else {
          elem.setAttribute(keys[i], attrs[keys[i]]);
        }
      }
      return this;
    },

    // Remove attributes from an svg element.
    removeAttributes: function(elem, attrs) {
      for (var key in attrs) {
        elem.removeAttribute(key);
      }
      return this;
    },

    // Turn a set of vertices into a string for the d property of a path
    // element. It is imperative that the string collation is as fast as
    // possible, because this call will be happening multiple times a
    // second.
    toString: function(points, closed) {

      var l = points.length,
        last = l - 1,
        d, // The elusive last Commands.move point
        string = '';

      for (var i = 0; i < l; i++) {
        var b = points[i];
        var command;
        var prev = closed ? mod(i - 1, l) : Math.max(i - 1, 0);
        var next = closed ? mod(i + 1, l) : Math.min(i + 1, last);

        var a = points[prev];
        var c = points[next];

        var vx, vy, ux, uy, ar, bl, br, cl;
        var rx, ry, xAxisRotation, largeArcFlag, sweepFlag;

        // Access x and y directly,
        // bypassing the getter
        var x = toFixed(b.x);
        var y = toFixed(b.y);

        switch (b.command) {

          case Commands.close:
            command = Commands.close;
            break;

          case Commands.arc:

            rx = b.rx;
            ry = b.ry;
            xAxisRotation = b.xAxisRotation;
            largeArcFlag = b.largeArcFlag;
            sweepFlag = b.sweepFlag;

            command = Commands.arc + ' ' + rx + ' ' + ry + ' '
              + xAxisRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' '
              + x + ' ' + y;
            break;

          case Commands.curve:

            ar = (a.controls && a.controls.right) || Vector.zero;
            bl = (b.controls && b.controls.left) || Vector.zero;

            if (a.relative) {
              vx = toFixed((ar.x + a.x));
              vy = toFixed((ar.y + a.y));
            } else {
              vx = toFixed(ar.x);
              vy = toFixed(ar.y);
            }

            if (b.relative) {
              ux = toFixed((bl.x + b.x));
              uy = toFixed((bl.y + b.y));
            } else {
              ux = toFixed(bl.x);
              uy = toFixed(bl.y);
            }

            command = ((i === 0) ? Commands.move : Commands.curve) +
              ' ' + vx + ' ' + vy + ' ' + ux + ' ' + uy + ' ' + x + ' ' + y;
            break;

          case Commands.move:
            d = b;
            command = Commands.move + ' ' + x + ' ' + y;
            break;

          default:
            command = b.command + ' ' + x + ' ' + y;

        }

        // Add a final point and close it off

        if (i >= last && closed) {

          if (b.command === Commands.curve) {

            // Make sure we close to the most previous Commands.move
            c = d;

            br = (b.controls && b.controls.right) || b;
            cl = (c.controls && c.controls.left) || c;

            if (b.relative) {
              vx = toFixed((br.x + b.x));
              vy = toFixed((br.y + b.y));
            } else {
              vx = toFixed(br.x);
              vy = toFixed(br.y);
            }

            if (c.relative) {
              ux = toFixed((cl.x + c.x));
              uy = toFixed((cl.y + c.y));
            } else {
              ux = toFixed(cl.x);
              uy = toFixed(cl.y);
            }

            x = toFixed(c.x);
            y = toFixed(c.y);

            command +=
              ' C ' + vx + ' ' + vy + ' ' + ux + ' ' + uy + ' ' + x + ' ' + y;

          }

          if (b.command !== Commands.close) {
            command += ' Z';
          }

        }

        string += command + ' ';

      }

      return string;

    },

    getClip: function(shape, domElement) {

      var clip = shape._renderer.clip;

      if (!clip) {

        clip = shape._renderer.clip = svg.createElement('clipPath', {
          'clip-rule': 'nonzero'
        });
        domElement.defs.appendChild(clip);

      }

      return clip;

    },

    group: {

      // TODO: Can speed up.
      // TODO: How does this effect a f
      appendChild: function(object) {

        var elem = object._renderer.elem;

        if (!elem) {
          return;
        }

        var tag = elem.nodeName;

        if (!tag || /(radial|linear)gradient/i.test(tag) || object._clip) {
          return;
        }

        this.elem.appendChild(elem);

      },

      removeChild: function(object) {

        var elem = object._renderer.elem;

        if (!elem || elem.parentNode != this.elem) {
          return;
        }

        var tag = elem.nodeName;

        if (!tag) {
          return;
        }

        // Defer subtractions while clipping.
        if (object._clip) {
          return;
        }

        this.elem.removeChild(elem);

      },

      orderChild: function(object) {
        this.elem.appendChild(object._renderer.elem);
      },

      renderChild: function(child) {
        svg[child._renderer.type].render.call(child, this);
      },

      render: function(domElement) {

        // Shortcut for hidden objects.
        // Doesn't reset the flags, so changes are stored and
        // applied once the object is visible again
        if ((!this._visible && !this._flagVisible)
          || (this._opacity === 0 && !this._flagOpacity)) {
          return this;
        }

        this._update();

        if (!this._renderer.elem) {
          this._renderer.elem = svg.createElement('g', {
            id: this.id
          });
          domElement.appendChild(this._renderer.elem);
        }

        // _Update styles for the <g>
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var context = {
          domElement: domElement,
          elem: this._renderer.elem
        };

        if (flagMatrix) {
          this._renderer.elem.setAttribute('transform', 'matrix(' + this._matrix.toString() + ')');
        }

        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          svg[child._renderer.type].render.call(child, domElement);
        }

        if (this._flagId) {
          this._renderer.elem.setAttribute('id', this._id);
        }

        if (this._flagOpacity) {
          this._renderer.elem.setAttribute('opacity', this._opacity);
        }

        if (this._flagVisible) {
          this._renderer.elem.setAttribute('display', this._visible ? 'inline' : 'none');
        }

        if (this._flagClassName) {
          this._renderer.elem.setAttribute('class', this.classList.join(' '));
        }

        if (this._flagAdditions) {
          this.additions.forEach(svg.group.appendChild, context);
        }

        if (this._flagSubtractions) {
          this.subtractions.forEach(svg.group.removeChild, context);
        }

        if (this._flagOrder) {
          this.children.forEach(svg.group.orderChild, context);
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        // if (this._flagClip) {

        //   clip = svg.getClip(this, domElement);
        //   elem = this._renderer.elem;

        //   if (this._clip) {
        //     elem.removeAttribute('id');
        //     clip.setAttribute('id', this.id);
        //     clip.appendChild(elem);
        //   } else {
        //     clip.removeAttribute('id');
        //     elem.setAttribute('id', this.id);
        //     this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
        //   }

        // }

        if (this._flagMask) {
          if (this._mask) {
            svg[this._mask._renderer.type].render.call(this._mask, domElement);
            this._renderer.elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
          } else {
            this._renderer.elem.removeAttribute('clip-path');
          }
        }

        return this.flagReset();

      }

    },

    path: {

      render: function(domElement) {

        // Shortcut for hidden objects.
        // Doesn't reset the flags, so changes are stored and
        // applied once the object is visible again
        if (this._opacity === 0 && !this._flagOpacity) {
          return this;
        }

        this._update();

        // Collect any attribute that needs to be changed here
        var changed = {};

        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagMatrix) {
          changed.transform = 'matrix(' + this._matrix.toString() + ')';
        }

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagVertices) {
          var vertices = svg.toString(this._renderer.vertices, this._closed);
          changed.d = vertices;
        }

        if (this._fill && this._fill._renderer) {
          this._fill._update();
          svg[this._fill._renderer.type].render.call(this._fill, domElement, true);
        }

        if (this._flagFill) {
          changed.fill = this._fill && this._fill.id
            ? 'url(#' + this._fill.id + ')' : this._fill;
        }

        if (this._stroke && this._stroke._renderer) {
          this._stroke._update();
          svg[this._stroke._renderer.type].render.call(this._stroke, domElement, true);
        }

        if (this._flagStroke) {
          changed.stroke = this._stroke && this._stroke.id
            ? 'url(#' + this._stroke.id + ')' : this._stroke;
        }

        if (this._flagLinewidth) {
          changed['stroke-width'] = this._linewidth;
        }

        if (this._flagOpacity) {
          changed['stroke-opacity'] = this._opacity;
          changed['fill-opacity'] = this._opacity;
        }

        if (this._flagClassName) {
          changed['class'] = this.classList.join(' ');
        }

        if (this._flagVisible) {
          changed.visibility = this._visible ? 'visible' : 'hidden';
        }

        if (this._flagCap) {
          changed['stroke-linecap'] = this._cap;
        }

        if (this._flagJoin) {
          changed['stroke-linejoin'] = this._join;
        }

        if (this._flagMiter) {
          changed['stroke-miterlimit'] = this._miter;
        }

        if (this.dashes && this.dashes.length > 0) {
          changed['stroke-dasharray'] = this.dashes.join(' ');
          changed['stroke-dashoffset'] = this.dashes.offset || 0;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this._id;
          this._renderer.elem = svg.createElement('path', changed);
          domElement.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {
          svg.setAttributes(this._renderer.elem, changed);
        }

        if (this._flagClip) {

          var clip = svg.getClip(this, domElement);
          var elem = this._renderer.elem;

          if (this._clip) {
            elem.removeAttribute('id');
            clip.setAttribute('id', this.id);
            clip.appendChild(elem);
          } else {
            clip.removeAttribute('id');
            elem.setAttribute('id', this.id);
            this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
          }

        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        if (this._flagMask) {
          if (this._mask) {
            svg[this._mask._renderer.type].render.call(this._mask, domElement);
            this._renderer.elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
          } else {
            this._renderer.elem.removeAttribute('clip-path');
          }
        }

        return this.flagReset();

      }

    },

    text: {

      render: function(domElement) {

        this._update();

        var changed = {};

        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagMatrix) {
          changed.transform = 'matrix(' + this._matrix.toString() + ')';
        }

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagFamily) {
          changed['font-family'] = this._family;
        }
        if (this._flagSize) {
          changed['font-size'] = this._size;
        }
        if (this._flagLeading) {
          changed['line-height'] = this._leading;
        }
        if (this._flagAlignment) {
          changed['text-anchor'] = svg.alignments[this._alignment] || this._alignment;
        }
        if (this._flagBaseline) {
          changed['alignment-baseline'] = changed['dominant-baseline'] = this._baseline;
        }
        if (this._flagStyle) {
          changed['font-style'] = this._style;
        }
        if (this._flagWeight) {
          changed['font-weight'] = this._weight;
        }
        if (this._flagDecoration) {
          changed['text-decoration'] = this._decoration;
        }
        if (this._fill && this._fill._renderer) {
          this._fill._update();
          svg[this._fill._renderer.type].render.call(this._fill, domElement, true);
        }
        if (this._flagFill) {
          changed.fill = this._fill && this._fill.id
            ? 'url(#' + this._fill.id + ')' : this._fill;
        }
        if (this._stroke && this._stroke._renderer) {
          this._stroke._update();
          svg[this._stroke._renderer.type].render.call(this._stroke, domElement, true);
        }
        if (this._flagStroke) {
          changed.stroke = this._stroke && this._stroke.id
            ? 'url(#' + this._stroke.id + ')' : this._stroke;
        }
        if (this._flagLinewidth) {
          changed['stroke-width'] = this._linewidth;
        }
        if (this._flagOpacity) {
          changed.opacity = this._opacity;
        }
        if (this._flagClassName) {
          changed['class'] = this.classList.join(' ');
        }
        if (this._flagVisible) {
          changed.visibility = this._visible ? 'visible' : 'hidden';
        }
        if (this.dashes && this.dashes.length > 0) {
          changed['stroke-dasharray'] = this.dashes.join(' ');
          changed['stroke-dashoffset'] = this.dashes.offset || 0;
        }

        if (!this._renderer.elem) {

          changed.id = this._id;

          this._renderer.elem = svg.createElement('text', changed);
          domElement.defs.appendChild(this._renderer.elem);

        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagClip) {

          var clip = svg.getClip(this, domElement);
          var elem = this._renderer.elem;

          if (this._clip) {
            elem.removeAttribute('id');
            clip.setAttribute('id', this.id);
            clip.appendChild(elem);
          } else {
            clip.removeAttribute('id');
            elem.setAttribute('id', this.id);
            this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
          }

        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        if (this._flagMask) {
          if (this._mask) {
            svg[this._mask._renderer.type].render.call(this._mask, domElement);
            this._renderer.elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
          } else {
            this._renderer.elem.removeAttribute('clip-path');
          }
        }

        if (this._flagValue) {
          this._renderer.elem.textContent = this._value;
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagEndPoints) {
          changed.x1 = this.left._x;
          changed.y1 = this.left._y;
          changed.x2 = this.right._x;
          changed.y2 = this.right._y;
        }

        if (this._flagSpread) {
          changed.spreadMethod = this._spread;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this._id;
          changed.gradientUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('linearGradient', changed);
          domElement.defs.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagStops) {

          var lengthChanged = this._renderer.elem.childNodes.length
            !== this.stops.length;

          if (lengthChanged) {
            while (this._renderer.elem.lastChild) {
              this._renderer.elem.removeChild(this._renderer.elem.lastChild);
            }
          }

          for (var i = 0; i < this.stops.length; i++) {

            var stop = this.stops[i];
            var attrs = {};

            if (stop._flagOffset) {
              attrs.offset = 100 * stop._offset + '%';
            }
            if (stop._flagColor) {
              attrs['stop-color'] = stop._color;
            }
            if (stop._flagOpacity) {
              attrs['stop-opacity'] = stop._opacity;
            }

            if (!stop._renderer.elem) {
              stop._renderer.elem = svg.createElement('stop', attrs);
            } else {
              svg.setAttributes(stop._renderer.elem, attrs);
            }

            if (lengthChanged) {
              this._renderer.elem.appendChild(stop._renderer.elem);
            }
            stop.flagReset();

          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagCenter) {
          changed.cx = this.center._x;
          changed.cy = this.center._y;
        }
        if (this._flagFocal) {
          changed.fx = this.focal._x;
          changed.fy = this.focal._y;
        }

        if (this._flagRadius) {
          changed.r = this._radius;
        }

        if (this._flagSpread) {
          changed.spreadMethod = this._spread;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this._id;
          changed.gradientUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('radialGradient', changed);
          domElement.defs.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagStops) {

          var lengthChanged = this._renderer.elem.childNodes.length
            !== this.stops.length;

          if (lengthChanged) {
            while (this._renderer.elem.lastChild) {
              this._renderer.elem.removeChild(this._renderer.elem.lastChild);
            }
          }

          for (var i = 0; i < this.stops.length; i++) {

            var stop = this.stops[i];
            var attrs = {};

            if (stop._flagOffset) {
              attrs.offset = 100 * stop._offset + '%';
            }
            if (stop._flagColor) {
              attrs['stop-color'] = stop._color;
            }
            if (stop._flagOpacity) {
              attrs['stop-opacity'] = stop._opacity;
            }

            if (!stop._renderer.elem) {
              stop._renderer.elem = svg.createElement('stop', attrs);
            } else {
              svg.setAttributes(stop._renderer.elem, attrs);
            }

            if (lengthChanged) {
              this._renderer.elem.appendChild(stop._renderer.elem);
            }
            stop.flagReset();

          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};
        var styles = { x: 0, y: 0 };
        var image = this.image;

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagLoaded && this.loaded) {

          switch (image.nodeName.toLowerCase()) {

            case 'canvas':
              styles.href = styles['xlink:href'] = image.toDataURL('image/png');
              break;
            case 'img':
            case 'image':
              styles.href = styles['xlink:href'] = this.src;
              break;

          }

        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          changed.x = this._offset.x;
          changed.y = this._offset.y;

          if (image) {

            changed.x -= image.width / 2;
            changed.y -= image.height / 2;

            if (this._scale instanceof Vector) {
              changed.x *= this._scale.x;
              changed.y *= this._scale.y;
            } else {
              changed.x *= this._scale;
              changed.y *= this._scale;
            }
          }

          if (changed.x > 0) {
            changed.x *= - 1;
          }
          if (changed.y > 0) {
            changed.y *= - 1;
          }

        }

        if (this._flagScale || this._flagLoaded || this._flagRepeat) {

          changed.width = 0;
          changed.height = 0;

          if (image) {

            styles.width = changed.width = image.width;
            styles.height = changed.height = image.height;

            // TODO: Hack / Band-aid
            switch (this._repeat) {
              case 'no-repeat':
                changed.width += 1;
                changed.height += 1;
                break;
            }

            if (this._scale instanceof Vector) {
              changed.width *= this._scale.x;
              changed.height *= this._scale.y;
            } else {
              changed.width *= this._scale;
              changed.height *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {
          if (!this._renderer.image) {
            this._renderer.image = svg.createElement('image', styles);
          } else {
            svg.setAttributes(this._renderer.image, styles);
          }
        }

        if (!this._renderer.elem) {

          changed.id = this._id;
          changed.patternUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('pattern', changed);
          domElement.defs.appendChild(this._renderer.elem);

        } else if (Object.keys(changed).length !== 0) {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._renderer.elem && this._renderer.image && !this._renderer.appended) {
          this._renderer.elem.appendChild(this._renderer.image);
          this._renderer.appended = true;
        }

        return this.flagReset();

      }

    }

  };

  /**
   * @name Two.SVGRenderer
   * @class
   * @extends Two.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<svg />` to draw to. If none given a new one will be constructed.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.svg` (the default type). It takes Two.js' scenegraph and renders it to a `<svg />`.
   */
  function Renderer$1(params) {

    /**
     * @name Two.SVGRenderer#domElement
     * @property {Element} - The `<svg />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || svg.createElement('svg');

    /**
     * @name Two.SVGRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Group();
    this.scene.parent = this;

    /**
     * @name Two.SVGRenderer#defs
     * @property {SvgDefintionsElement} - The `<defs />` to apply gradients, patterns, and bitmap imagery.
     */
    this.defs = svg.createElement('defs');
    this.domElement.appendChild(this.defs);
    this.domElement.defs = this.defs;
    this.domElement.style.overflow = 'hidden';

  }

  _.extend(Renderer$1, {

    /**
     * @name Two.SVGRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<svg />`.
     */
    Utils: svg

  });

  _.extend(Renderer$1.prototype, Events, {

    constructor: Renderer$1,

    /**
     * @name Two.SVGRenderer#setSize
     * @function
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @description Change the size of the renderer.
     * @nota-bene Triggers a `Two.Events.resize`.
     */
    setSize: function(width, height) {

      this.width = width;
      this.height = height;

      svg.setAttributes(this.domElement, {
        width: width,
        height: height
      });

      return this.trigger(Events.Types.resize, width, height);

    },

    /**
     * @name Two.SVGRenderer#render
     * @function
     * @description Render the current scene to the `<svg />`.
     */
    render: function() {

      svg.group.render.call(this.scene, this.domElement);

      return this;

    }

  });

  // Constants

  var multiplyMatrix = Matrix.Multiply,
    identity = [1, 0, 0, 0, 1, 0, 0, 0, 1],
    transformation = new NumArray(9),
    CanvasUtils = Renderer$2.Utils;

  var webgl = {

    isHidden: /(undefined|none|transparent)/i,

    canvas: (root$1.document ? root$1.document.createElement('canvas') : { getContext: function() {} }),

    alignments: {
      left: 'start',
      middle: 'center',
      right: 'end'
    },

    matrix: new Matrix(),

    group: {

      removeChild: function(child, gl) {
        if (child.children) {
          for (var i = 0; i < child.children.length; i++) {
            webgl.group.removeChild(child.children[i], gl);
          }
          return;
        }
        // Deallocate texture to free up gl memory.
        gl.deleteTexture(child._renderer.texture);
        delete child._renderer.texture;
      },

      render: function(gl, program) {

        if (!this._visible) {
          return;
        }

        this._update();

        var parent = this.parent;
        var flagParentMatrix = (parent._matrix && parent._matrix.manual) || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagParentMatrix || flagMatrix) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new NumArray(9);
          }

          // Reduce amount of object / array creation / deletion
          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }

          if (this._scale instanceof Vector) {
            this._renderer.scale.x = this._scale.x;
            this._renderer.scale.y = this._scale.y;
          } else {
            this._renderer.scale.x = this._scale;
            this._renderer.scale.y = this._scale;
          }

          if (!(/renderer/i.test(parent._renderer.type))) {
            this._renderer.scale.x *= parent._renderer.scale.x;
            this._renderer.scale.y *= parent._renderer.scale.y;
          }

          if (flagParentMatrix) {
            this._flagMatrix = true;
          }

        }

        if (this._mask) {

          // Stencil away everything that isn't rendered by the mask
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);

          gl.stencilFunc(gl.ALWAYS, 1, 0);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          // Don't draw the element onto the canvas, only onto the stencil buffer
          gl.colorMask(false, false, false, false);

          webgl[this._mask._renderer.type].render.call(this._mask, gl, program, this);

          gl.stencilFunc(gl.EQUAL, 1, 0xff);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.colorMask(true, true, true, true);

        }

        this._flagOpacity = parent._flagOpacity || this._flagOpacity;

        this._renderer.opacity = this._opacity
          * (parent && parent._renderer ? parent._renderer.opacity : 1);

        var i;
        if (this._flagSubtractions) {
          for (i = 0; i < this.subtractions.length; i++) {
            webgl.group.removeChild(this.subtractions[i], gl);
          }
        }

        for (i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          webgl[child._renderer.type].render.call(child, gl, program);
        }

        if (this._mask) {
          gl.disable(gl.STENCIL_TEST);
        }

        return this.flagReset();

      }

    },

    path: {

      updateCanvas: function(elem) {

        var next, prev, a, c, ux, uy, vx, vy, ar, bl, br, cl, x, y;
        var isOffset;

        var commands = elem._renderer.vertices;
        var canvas = this.canvas;
        var ctx = this.ctx;

        // Styles
        var scale = elem._renderer.scale;
        var stroke = elem._stroke;
        var linewidth = elem._linewidth;
        var fill = elem._fill;
        var opacity = elem._renderer.opacity || elem._opacity;
        var cap = elem._cap;
        var join = elem._join;
        var miter = elem._miter;
        var closed = elem._closed;
        var dashes = elem.dashes;
        var length = commands.length;
        var last = length - 1;

        canvas.width = Math.max(Math.ceil(elem._renderer.rect.width * scale.x), 1);
        canvas.height = Math.max(Math.ceil(elem._renderer.rect.height * scale.y), 1);

        var centroid = elem._renderer.rect.centroid;
        var cx = centroid.x;
        var cy = centroid.y;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            webgl[fill._renderer.type].render.call(fill, ctx, elem);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            webgl[stroke._renderer.type].render.call(stroke, ctx, elem);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
          if (miter) {
            ctx.miterLimit = miter;
          }
          if (join) {
            ctx.lineJoin = join;
          }
          if (!closed && cap) {
            ctx.lineCap = cap;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }

        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        var d;
        ctx.save();
        ctx.scale(scale.x, scale.y);

        ctx.translate(cx, cy);

        ctx.beginPath();
        for (var i = 0; i < commands.length; i++) {

          var b = commands[i];

          x = b.x;
          y = b.y;

          switch (b.command) {

            case Commands.close:
              ctx.closePath();
              break;

            case Commands.arc:

              var rx = b.rx;
              var ry = b.ry;
              var xAxisRotation = b.xAxisRotation;
              var largeArcFlag = b.largeArcFlag;
              var sweepFlag = b.sweepFlag;

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              a = commands[prev];

              var ax = a.x;
              var ay = a.y;

              CanvasUtils.renderSvgArcCommand(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y);
              break;

            case Commands.curve:

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              next = closed ? mod(i + 1, length) : Math.min(i + 1, last);

              a = commands[prev];
              c = commands[next];
              ar = (a.controls && a.controls.right) || Vector.zero;
              bl = (b.controls && b.controls.left) || Vector.zero;

              if (a._relative) {
                vx = ar.x + a.x;
                vy = ar.y + a.y;
              } else {
                vx = ar.x;
                vy = ar.y;
              }

              if (b._relative) {
                ux = bl.x + b.x;
                uy = bl.y + b.y;
              } else {
                ux = bl.x;
                uy = bl.y;
              }

              ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              if (i >= last && closed) {

                c = d;

                br = (b.controls && b.controls.right) || Vector.zero;
                cl = (c.controls && c.controls.left) || Vector.zero;

                if (b._relative) {
                  vx = br.x + b.x;
                  vy = br.y + b.y;
                } else {
                  vx = br.x;
                  vy = br.y;
                }

                if (c._relative) {
                  ux = cl.x + c.x;
                  uy = cl.y + c.y;
                } else {
                  ux = cl.x;
                  uy = cl.y;
                }

                x = c.x;
                y = c.y;

                ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              }

              break;

            case Commands.line:
              ctx.lineTo(x, y);
              break;

            case Commands.move:
              d = b;
              ctx.moveTo(x, y);
              break;

          }

        }

        // Loose ends

        if (closed) {
          ctx.closePath();
        }

        if (!webgl.isHidden.test(fill)) {
          isOffset = fill._renderer && fill._renderer.offset;
          if (isOffset) {
            ctx.save();
            ctx.translate(
              - fill._renderer.offset.x, - fill._renderer.offset.y);
            ctx.scale(fill._renderer.scale.x, fill._renderer.scale.y);
          }
          ctx.fill();
          if (isOffset) {
            ctx.restore();
          }
        }

        if (!webgl.isHidden.test(stroke)) {
          isOffset = stroke._renderer && stroke._renderer.offset;
          if (isOffset) {
            ctx.save();
            ctx.translate(
              - stroke._renderer.offset.x, - stroke._renderer.offset.y);
            ctx.scale(stroke._renderer.scale.x, stroke._renderer.scale.y);
            ctx.lineWidth = linewidth / stroke._renderer.scale.x;
          }
          ctx.stroke();
          if (isOffset) {
            ctx.restore();
          }
        }

        ctx.restore();

      },

      // Returns the rect of a set of verts. Typically takes vertices that are
      // "centered" around 0 and returns them to be anchored upper-left.
      getBoundingClientRect: function(vertices, border, rect) {

        var left = Infinity, right = -Infinity,
            top = Infinity, bottom = -Infinity,
            width, height;

        vertices.forEach(function(v) {

          var x = v.x, y = v.y, controls = v.controls;
          var a, b, c, d, cl, cr;

          top = Math.min(y, top);
          left = Math.min(x, left);
          right = Math.max(x, right);
          bottom = Math.max(y, bottom);

          if (!v.controls) {
            return;
          }

          cl = controls.left;
          cr = controls.right;

          if (!cl || !cr) {
            return;
          }

          a = v._relative ? cl.x + x : cl.x;
          b = v._relative ? cl.y + y : cl.y;
          c = v._relative ? cr.x + x : cr.x;
          d = v._relative ? cr.y + y : cr.y;

          if (!a || !b || !c || !d) {
            return;
          }

          top = Math.min(b, d, top);
          left = Math.min(a, c, left);
          right = Math.max(a, c, right);
          bottom = Math.max(b, d, bottom);

        });

        // Expand borders

        if (typeof border === 'number') {
          top -= border;
          left -= border;
          right += border;
          bottom += border;
        }

        width = right - left;
        height = bottom - top;

        rect.top = top;
        rect.left = left;
        rect.right = right;
        rect.bottom = bottom;
        rect.width = width;
        rect.height = height;

        if (!rect.centroid) {
          rect.centroid = {};
        }

        rect.centroid.x = - left;
        rect.centroid.y = - top;

      },

      render: function(gl, program, forcedParent) {

        if (!this._visible || !this._opacity) {
          return this;
        }

        this._update();

        // Calculate what changed

        var parent = forcedParent || this.parent;
        var flagParentMatrix = parent._matrix.manual || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var parentChanged = this._renderer.parent !== parent;
        var flagTexture = this._flagVertices || this._flagFill
          || (this._fill instanceof LinearGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagEndPoints))
          || (this._fill instanceof RadialGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagRadius || this._fill._flagCenter || this._fill._flagFocal))
          || (this._fill instanceof Texture && (this._fill._flagLoaded && this._fill.loaded || this._fill._flagImage || this._fill._flagVideo || this._fill._flagRepeat || this._fill._flagOffset || this._fill._flagScale))
          || (this._stroke instanceof LinearGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagEndPoints))
          || (this._stroke instanceof RadialGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagRadius || this._stroke._flagCenter || this._stroke._flagFocal))
          || (this._stroke instanceof Texture && (this._stroke._flagLoaded && this._stroke.loaded || this._stroke._flagImage || this._stroke._flagVideo || this._stroke._flagRepeat || this._stroke._flagOffset || this._fill._flagScale))
          || this._flagStroke || this._flagLinewidth || this._flagOpacity
          || parent._flagOpacity || this._flagVisible || this._flagCap
          || this._flagJoin || this._flagMiter || this._flagScale
          || (this.dashes && this.dashes.length > 0)
          || !this._renderer.texture;

        if (flagParentMatrix || flagMatrix || parentChanged) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new NumArray(9);
          }

          // Reduce amount of object / array creation / deletion

          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }
          if (this._scale instanceof Vector) {
            this._renderer.scale.x = this._scale.x * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale.y * parent._renderer.scale.y;
          } else {
            this._renderer.scale.x = this._scale * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale * parent._renderer.scale.y;
          }

          if (parentChanged) {
            this._renderer.parent = parent;
          }
        }

        if (this._mask) {

          // Stencil away everything that isn't rendered by the mask
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);

          gl.stencilFunc(gl.ALWAYS, 1, 0);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          // Don't draw the element onto the canvas, only onto the stencil buffer
          gl.colorMask(false, false, false, false);

          webgl[this._mask._renderer.type].render.call(this._mask, gl, program, this);

          gl.stencilFunc(gl.EQUAL, 1, 0xff);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.colorMask(true, true, true, true);

        }

        if (flagTexture) {

          if (!this._renderer.rect) {
            this._renderer.rect = {};
          }

          this._renderer.opacity = this._opacity * parent._renderer.opacity;

          webgl.path.getBoundingClientRect(this._renderer.vertices, this._linewidth, this._renderer.rect);

          webgl.updateTexture.call(webgl, gl, this);

        } else {

          // We still need to update child Two elements on the fill and
          // stroke properties.
          if (this._fill && this._fill._update) {
            this._fill._update();
          }
          if (this._stroke && this._stroke._update) {
            this._stroke._update();
          }

        }

        if (this._clip && !forcedParent) {
          return;
        }

        // Draw Texture
        gl.bindTexture(gl.TEXTURE_2D, this._renderer.texture);

        // Draw Rect
        var rect = this._renderer.rect;
        gl.uniformMatrix3fv(program.matrix, false, this._renderer.matrix);
        gl.uniform4f(program.rect, rect.left, rect.top, rect.right, rect.bottom);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this._mask) {
          gl.disable(gl.STENCIL_TEST);
        }

        return this.flagReset();

      }

    },

    text: {

      updateCanvas: function(elem) {

        var canvas = this.canvas;
        var ctx = this.ctx;

        // Styles
        var scale = elem._renderer.scale;
        var stroke = elem._stroke;
        var linewidth = elem._linewidth * scale;
        var fill = elem._fill;
        var opacity = elem._renderer.opacity || elem._opacity;
        var dashes = elem.dashes;
        var decoration = elem._decoration;

        canvas.width = Math.max(Math.ceil(elem._renderer.rect.width * scale.x), 1);
        canvas.height = Math.max(Math.ceil(elem._renderer.rect.height * scale.y), 1);

        var centroid = elem._renderer.rect.centroid;
        var cx = centroid.x;
        var cy = centroid.y;

        var a, b, c, d, e, sx, sy, x1, y1, x2, y2;
        var isOffset = fill._renderer && fill._renderer.offset
          && stroke._renderer && stroke._renderer.offset;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!isOffset) {
          ctx.font = [elem._style, elem._weight, elem._size + 'px/' +
            elem._leading + 'px', elem._family].join(' ');
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Styles
        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            webgl[fill._renderer.type].render.call(fill, ctx, elem);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            webgl[stroke._renderer.type].render.call(stroke, ctx, elem);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }
        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        ctx.save();
        ctx.scale(scale.x, scale.y);
        ctx.translate(cx, cy);

        if (!webgl.isHidden.test(fill)) {

          if (fill._renderer && fill._renderer.offset) {

            sx = fill._renderer.scale.x;
            sy = fill._renderer.scale.y;

            ctx.save();
            ctx.translate( - fill._renderer.offset.x,
              - fill._renderer.offset.y);
            ctx.scale(sx, sy);

            a = elem._size / fill._renderer.scale.y;
            b = elem._leading / fill._renderer.scale.y;
            ctx.font = [elem._style, elem._weight, a + 'px/',
              b + 'px', elem._family].join(' ');

            c = fill._renderer.offset.x / fill._renderer.scale.x;
            d = fill._renderer.offset.y / fill._renderer.scale.y;

            ctx.fillText(elem.value, c, d);
            ctx.restore();

          } else {
            ctx.fillText(elem.value, 0, 0);
          }

        }

        if (!webgl.isHidden.test(stroke)) {

          if (stroke._renderer && stroke._renderer.offset) {

            sx = stroke._renderer.scale.x;
            sy = stroke._renderer.scale.y;

            ctx.save();
            ctx.translate(- stroke._renderer.offset.x,
              - stroke._renderer.offset.y);
            ctx.scale(sx, sy);

            a = elem._size / stroke._renderer.scale.y;
            b = elem._leading / stroke._renderer.scale.y;
            ctx.font = [elem._style, elem._weight, a + 'px/',
              b + 'px', elem._family].join(' ');

            c = stroke._renderer.offset.x / stroke._renderer.scale.x;
            d = stroke._renderer.offset.y / stroke._renderer.scale.y;
            e = linewidth / stroke._renderer.scale.x;

            ctx.lineWidth = e;
            ctx.strokeText(elem.value, c, d);
            ctx.restore();

          } else {
            ctx.strokeText(elem.value, 0, 0);
          }

        }

        // Handle text-decoration
        if (/(underline|strikethrough)/i.test(decoration)) {

          var metrics = ctx.measureText(elem.value);

          switch (decoration) {
            case 'underline':
              y1 = metrics.actualBoundingBoxAscent;
              y2 = metrics.actualBoundingBoxAscent;
              break;
            case 'strikethrough':
              y1 = 0;
              y2 = 0;
              break;
          }

          x1 = - metrics.width / 2;
          x2 = metrics.width / 2;

          ctx.lineWidth = Math.max(Math.floor(elem._size / 15), 1);
          ctx.strokeStyle = ctx.fillStyle;

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();

        }

        ctx.restore();

      },

      getBoundingClientRect: function(elem, rect) {

        var ctx = webgl.ctx;

        ctx.font = [elem._style, elem._weight, elem._size + 'px/' +
          elem._leading + 'px', elem._family].join(' ');

        ctx.textAlign = 'center';
        ctx.textBaseline = elem._baseline;

        // TODO: Estimate this better
        var width = ctx.measureText(elem._value).width * 1.25;
        var height = Math.max(elem._size, elem._leading) * 1.25;

        if (this._linewidth && !webgl.isHidden.test(this._stroke)) {
          width += this._linewidth * 2;
          height += this._linewidth * 2;
        }

        var w = width / 2;
        var h = height / 2;

        switch (webgl.alignments[elem._alignment] || elem._alignment) {

          case webgl.alignments.left:
            rect.left = 0;
            rect.right = width;
            break;
          case webgl.alignments.right:
            rect.left = - width;
            rect.right = 0;
            break;
          default:
            rect.left = - w;
            rect.right = w;
        }

        // TODO: Gradients aren't inherited...
        switch (elem._baseline) {
          case 'bottom':
            rect.top = - height;
            rect.bottom = 0;
            break;
          case 'top':
            rect.top = 0;
            rect.bottom = height;
            break;
          default:
            rect.top = - h;
            rect.bottom = h;
        }

        rect.width = width;
        rect.height = height;

        if (!rect.centroid) {
          rect.centroid = {};
        }

        // TODO:
        rect.centroid.x = w;
        rect.centroid.y = h;

      },

      render: function(gl, program, forcedParent) {

        if (!this._visible || !this._opacity) {
          return this;
        }

        this._update();

        // Calculate what changed

        var parent = forcedParent || this.parent;
        var flagParentMatrix = parent._matrix.manual || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var parentChanged = this._renderer.parent !== parent;
        var flagTexture = this._flagVertices || this._flagFill
          || (this._fill instanceof LinearGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagEndPoints))
          || (this._fill instanceof RadialGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagRadius || this._fill._flagCenter || this._fill._flagFocal))
          || (this._fill instanceof Texture && (this._fill._flagLoaded && this._fill.loaded || this._fill._flagImage || this._fill._flagVideo || this._fill._flagRepeat || this._fill._flagOffset || this._fill._flagScale))
          || (this._stroke instanceof LinearGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagEndPoints))
          || (this._stroke instanceof RadialGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagRadius || this._stroke._flagCenter || this._stroke._flagFocal))
          || (this._stroke instanceof Texture && (this._stroke._flagLoaded && this._stroke.loaded || this._stroke._flagImage || this._stroke._flagVideo || this._stroke._flagRepeat || this._stroke._flagOffset || this._fill._flagScale))
          || this._flagStroke || this._flagLinewidth || this._flagOpacity
          || parent._flagOpacity || this._flagVisible || this._flagScale
          || this._flagValue || this._flagFamily || this._flagSize
          || this._flagLeading || this._flagAlignment || this._flagBaseline
          || this._flagStyle || this._flagWeight || this._flagDecoration
          || (this.dashes && this.dashes.length > 0)
          || !this._renderer.texture;

        if (flagParentMatrix || flagMatrix || parentChanged) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new NumArray(9);
          }

          // Reduce amount of object / array creation / deletion

          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }
          if (this._scale instanceof Vector) {
            this._renderer.scale.x = this._scale.x * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale.y * parent._renderer.scale.y;
          } else {
            this._renderer.scale.x = this._scale * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale * parent._renderer.scale.y;
          }

          if (parentChanged) {
            this._renderer.parent = parent;
          }
        }

        if (this._mask) {

          // Stencil away everything that isn't rendered by the mask
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);

          gl.stencilFunc(gl.ALWAYS, 1, 0);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          // Don't draw the element onto the canvas, only onto the stencil buffer
          gl.colorMask(false, false, false, false);

          webgl[this._mask._renderer.type].render.call(this._mask, gl, program, this);

          gl.stencilFunc(gl.EQUAL, 1, 0xff);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.colorMask(true, true, true, true);

        }

        if (flagTexture) {

          if (!this._renderer.rect) {
            this._renderer.rect = {};
          }

          this._renderer.opacity = this._opacity * parent._renderer.opacity;

          webgl.text.getBoundingClientRect(this, this._renderer.rect);

          webgl.updateTexture.call(webgl, gl, this);

        } else {

          // We still need to update child Two elements on the fill and
          // stroke properties.
          if (this._fill && this._fill._update) {
            this._fill._update();
          }
          if (this._stroke && this._stroke._update) {
            this._stroke._update();
          }

        }

        if (this._clip && !forcedParent) {
          return;
        }

        // Draw Texture
        gl.bindTexture(gl.TEXTURE_2D, this._renderer.texture);

        // Draw Rect
        var rect = this._renderer.rect;
        gl.uniformMatrix3fv(program.matrix, false, this._renderer.matrix);
        gl.uniform4f(program.rect, rect.left, rect.top, rect.right, rect.bottom);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this._mask) {
          gl.disable(gl.STENCIL_TEST);
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        if (!this._renderer.effect || this._flagEndPoints || this._flagStops) {

          this._renderer.effect = ctx.createLinearGradient(
            this.left._x, this.left._y,
            this.right._x, this.right._y
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        if (!this._renderer.effect || this._flagCenter || this._flagFocal
            || this._flagRadius || this._flagStops) {

          this._renderer.effect = ctx.createRadialGradient(
            this.center._x, this.center._y, 0,
            this.focal._x, this.focal._y, this._radius
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        var image = this.image;

        if (((this._flagLoaded || this._flagImage || this._flagVideo || this._flagRepeat) && this.loaded)) {
          this._renderer.effect = ctx.createPattern(image, this._repeat);
        } else if (!this._renderer.effect) {
          return this.flagReset();
        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          if (!(this._renderer.offset instanceof Vector)) {
            this._renderer.offset = new Vector();
          }

          this._renderer.offset.x = - this._offset.x;
          this._renderer.offset.y = - this._offset.y;

          if (image) {

            this._renderer.offset.x += image.width / 2;
            this._renderer.offset.y += image.height / 2;

            if (this._scale instanceof Vector) {
              this._renderer.offset.x *= this._scale.x;
              this._renderer.offset.y *= this._scale.y;
            } else {
              this._renderer.offset.x *= this._scale;
              this._renderer.offset.y *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }

          if (this._scale instanceof Vector) {
            this._renderer.scale.copy(this._scale);
          } else {
            this._renderer.scale.set(this._scale, this._scale);
          }

        }

        return this.flagReset();

      }

    },

    updateTexture: function(gl, elem) {

      this[elem._renderer.type].updateCanvas.call(webgl, elem);

      if (!elem._renderer.texture) {
        elem._renderer.texture = gl.createTexture();
      }

      gl.bindTexture(gl.TEXTURE_2D, elem._renderer.texture);

      // Set the parameters so we can render any size image.
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      if (this.canvas.width <= 0 || this.canvas.height <= 0) {
        return;
      }

      // Upload the image into the texture.
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);

    },

    program: {

      create: function(gl, shaders) {
        var program, linked, error;
        program = gl.createProgram();
        _.each(shaders, function(s) {
          gl.attachShader(program, s);
        });

        gl.linkProgram(program);
        linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
          error = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new TwoError('unable to link program: ' + error);
        }

        return program;

      }

    },

    shaders: {

      create: function(gl, source, type) {
        var shader, compiled, error;
        shader = gl.createShader(gl[type]);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!compiled) {
          error = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new TwoError('unable to compile shader ' + shader + ': ' + error);
        }

        return shader;

      },

      types: {
        vertex: 'VERTEX_SHADER',
        fragment: 'FRAGMENT_SHADER'
      },

      vertex: [
        'precision mediump float;',
        'attribute vec2 a_position;',
        '',
        'uniform mat3 u_matrix;',
        'uniform vec2 u_resolution;',
        'uniform vec4 u_rect;',
        '',
        'varying vec2 v_textureCoords;',
        '',
        'void main() {',
        '   vec2 rectCoords = (a_position * (u_rect.zw - u_rect.xy)) + u_rect.xy;',
        '   vec2 projected = (u_matrix * vec3(rectCoords, 1.0)).xy;',
        '   vec2 normal = projected / u_resolution;',
        '   vec2 clipspace = (normal * 2.0) - 1.0;',
        '',
        '   gl_Position = vec4(clipspace * vec2(1.0, -1.0), 0.0, 1.0);',
        '   v_textureCoords = a_position;',
        '}'
      ].join('\n'),

      fragment: [
        'precision mediump float;',
        '',
        'uniform sampler2D u_image;',
        'varying vec2 v_textureCoords;',
        '',
        'void main() {',
        '  vec4 texel = texture2D(u_image, v_textureCoords);',
        '  if (texel.a == 0.0) {',
        '    discard;',
        '  }',
        '  gl_FragColor = texel;',
        '}'
      ].join('\n')

    },

    TextureRegistry: new Registry()

  };

  webgl.ctx = webgl.canvas.getContext('2d');

  /**
   * @name Two.WebGLRenderer
   * @class
   * @extends Two.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<canvas />` to draw to. If none given a new one will be constructed.
   * @param {HTMLCanvasElement} [parameters.offscreenElement] - The offscreen two dimensional `<canvas />` to render each element on WebGL texture updates.
   * @param {Boolean} [parameters.antialias] - Determines whether the canvas should clear render with antialias on.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.webgl`. It takes Two.js' scenegraph and renders it to a `<canvas />` through the WebGL api.
   * @see {@link https://www.khronos.org/registry/webgl/specs/latest/1.0/}
   */
  function Renderer(params) {

    var gl, vs, fs;

    /**
     * @name Two.WebGLRenderer#domElement
     * @property {Element} - The `<canvas />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || document.createElement('canvas');

    if (typeof params.offscreenElement !== 'undefined') {
      webgl.canvas = params.offscreenElement;
      webgl.ctx = webgl.canvas.getContext('2d');
    }

    /**
     * @name Two.WebGLRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Group();
    this.scene.parent = this;

    this._renderer = {
      type: 'renderer',
      matrix: new NumArray(identity),
      scale: 1,
      opacity: 1
    };
    this._flagMatrix = true;

    // http://games.greggman.com/game/webgl-and-alpha/
    // http://www.khronos.org/registry/webgl/specs/latest/#5.2
    params = _.defaults(params || {}, {
      antialias: false,
      alpha: true,
      premultipliedAlpha: true,
      stencil: true,
      preserveDrawingBuffer: true,
      overdraw: false
    });

    /**
     * @name Two.WebGLRenderer#overdraw
     * @property {Boolean} - Determines whether the canvas clears the background each draw call.
     * @default true
     */
    this.overdraw = params.overdraw;

    /**
     * @name Two.WebGLRenderer#ctx
     * @property {WebGLContext} - Associated two dimensional context to render on the `<canvas />`.
     */
    gl = this.ctx = this.domElement.getContext('webgl', params) ||
      this.domElement.getContext('experimental-webgl', params);

    if (!this.ctx) {
      throw new TwoError(
        'unable to create a webgl context. Try using another renderer.');
    }

    // Compile Base Shaders to draw in pixel space.
    vs = webgl.shaders.create(
      gl, webgl.shaders.vertex, webgl.shaders.types.vertex);
    fs = webgl.shaders.create(
      gl, webgl.shaders.fragment, webgl.shaders.types.fragment);

    /**
     * @name Two.WebGLRenderer#program
     * @property {WebGLProgram} - Associated WebGL program to render all elements from the scenegraph.
     */
    this.program = webgl.program.create(gl, [vs, fs]);
    gl.useProgram(this.program);

    // Create and bind the drawing buffer

    // look up where the vertex data needs to go.
    this.program.position = gl.getAttribLocation(this.program, 'a_position');
    this.program.matrix = gl.getUniformLocation(this.program, 'u_matrix');
    this.program.rect = gl.getUniformLocation(this.program, 'u_rect');

    // Bind the vertex buffer
    var positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(this.program.position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.program.position);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new NumArray([
        0, 0,
        1, 0,
        0, 1,
        0, 1,
        1, 0,
        1, 1
      ]),
      gl.STATIC_DRAW);

    // Setup some initial statements of the gl context
    gl.enable(gl.BLEND);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  }

  _.extend(Renderer, {

    /**
     * @name Two.WebGLRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<canvas />` through the WebGL API.
     */
    Utils: webgl

  });

  _.extend(Renderer.prototype, Events, {

    constructor: Renderer,

    /**
     * @name Two.WebGLRenderer#setSize
     * @function
     * @fires resize
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @param {Number} [ratio] - The new pixel ratio (pixel density) of the renderer. Defaults to calculate the pixel density of the user's screen.
     * @description Change the size of the renderer.
     */
    setSize: function(width, height, ratio) {

      this.width = width;
      this.height = height;

      this.ratio = typeof ratio === 'undefined' ? getRatio(this.ctx) : ratio;

      this.domElement.width = width * this.ratio;
      this.domElement.height = height * this.ratio;

      if (_.isObject(this.domElement.style)) {
        _.extend(this.domElement.style, {
          width: width + 'px',
          height: height + 'px'
        });
      }

      // Set for this.stage parent scaling to account for HDPI
      this._renderer.matrix[0] = this._renderer.matrix[4] = this._renderer.scale = this.ratio;

      this._flagMatrix = true;

      this.ctx.viewport(0, 0, width * this.ratio, height * this.ratio);

      var resolutionLocation = this.ctx.getUniformLocation(
        this.program, 'u_resolution');
      this.ctx.uniform2f(resolutionLocation, width * this.ratio, height * this.ratio);

      return this.trigger(Events.Types.resize, width, height, ratio);

    },

    /**
     * @name Two.WebGLRenderer#render
     * @function
     * @description Render the current scene to the `<canvas />`.
     */
    render: function() {

      var gl = this.ctx;

      if (!this.overdraw) {
        gl.clear(gl.COLOR_BUFFER_BIT);
      }

      webgl.group.render.call(this.scene, gl, this.program);
      this._flagMatrix = false;

      return this;

    }

  });

  // Utils

  /**
   * @name Two
   * @class
   * @global
   * @param {Object} [options]
   * @param {Boolean} [options.fullscreen=false] - Set to `true` to automatically make the stage adapt to the width and height of the parent document. This parameter overrides `width` and `height` parameters if set to `true`. This overrides `options.fitted` as well.
   * @param {Boolean} [options.fitted=false] = Set to `true` to automatically make the stage adapt to the width and height of the parent element. This parameter overrides `width` and `height` parameters if set to `true`.
   * @param {Number} [options.width=640] - The width of the stage on construction. This can be set at a later time.
   * @param {Number} [options.height=480] - The height of the stage on construction. This can be set at a later time.
   * @param {String} [options.type=Two.Types.svg] - The type of renderer to setup drawing with. See {@link Two.Types} for available options.
   * @param {Boolean} [options.autostart=false] - Set to `true` to add the instance to draw on `requestAnimationFrame`. This is a convenient substitute for {@link Two#play}.
   * @param {Element} [options.domElement] - The canvas or SVG element to draw into. This overrides the `options.type` argument.
   * @description The entrypoint for Two.js. Instantiate a `new Two` in order to setup a scene to render to. `Two` is also the publicly accessible namespace that all other sub-classes, functions, and utilities attach to.
   */
  function Two(options) {

    // Determine what Renderer to use and setup a scene.

    var params = _.defaults(options || {}, {
      fullscreen: false,
      fitted: false,
      width: 640,
      height: 480,
      type: Two.Types.svg,
      autostart: false
    });

    _.each(params, function(v, k) {
      if (/fullscreen/i.test(k) || /autostart/i.test(k)) {
        return;
      }
      this[k] = v;
    }, this);

    // Specified domElement overrides type declaration only if the element does not support declared renderer type.
    if (_.isElement(params.domElement)) {
      var tagName = params.domElement.tagName.toLowerCase();
      // TODO: Reconsider this if statement's logic.
      if (!/^(CanvasRenderer-canvas|WebGLRenderer-canvas|SVGRenderer-svg)$/.test(this.type+'-'+tagName)) {
        this.type = Two.Types[tagName];
      }
    }

    this.renderer = new Two[this.type](this);
    this.setPlaying(params.autostart);
    this.frameCount = 0;

    /**
     * @name Two#fit
     * @function
     * @description If `options.fullscreen` or `options.fitted` in construction create this function. It sets the `width` and `height` of the instance to its respective parent `window` or `element` depending on the `options` passed.
     */
    if (params.fullscreen) {

      this.fit = fitToWindow.bind(this);
      this.fit.domElement = window;
      this.fit.attached = true;
      _.extend(document.body.style, {
        overflow: 'hidden',
        margin: 0,
        padding: 0,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        position: 'fixed'
      });
      _.extend(this.renderer.domElement.style, {
        display: 'block',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        position: 'fixed'
      });
      dom.bind(this.fit.domElement, 'resize', this.fit);
      this.fit();

    } else if (params.fitted) {

      this.fit = fitToParent.bind(this);
      _.extend(this.renderer.domElement.style, {
        display: 'block'
      });

    } else if (!_.isElement(params.domElement)) {

      this.renderer.setSize(params.width, params.height, this.ratio);
      this.width = params.width;
      this.height = params.height;

    }

    this.renderer.bind(Events.Types.resize, updateDimensions.bind(this));
    this.scene = this.renderer.scene;

    Two.Instances.push(this);
    if (params.autostart) {
      raf.init();
    }

  }

  _.extend(Two, Constants);

  _.extend(Two.prototype, Events, {

    constructor: Two,

    /**
     * @name Two#type
     * @property {String} - A string representing which type of renderer the instance has instantiated.
     */
    type: '',

    /**
     * @name Two#renderer
     * @property {(Two.SVGRenderer|Two.CanvasRenderer|Two.WebGLRenderer)} - The instantiated rendering class for the instance. For a list of possible rendering types check out Two.Types.
     */
    renderer: null,

    /**
     * @name Two#scene
     * @property {Two.Group} - The base level {@link Two.Group} which houses all objects for the instance. Because it is a {@link Two.Group} transformations can be applied to it that will affect all objects in the instance. This is handy as a makeshift inverted camera.
     */
    scene: null,

    /**
     * @name Two#width
     * @property {Number} - The width of the instance's dom element.
     */
    width: 0,

    /**
     * @name Two#height
     * @property {Number} - The height of the instance's dom element.
     */
    height: 0,

    /**
     * @name Two#frameCount
     * @property {Number} - An integer representing how many frames have elapsed.
     */
    frameCount: 0,

    /**
     * @name Two#timeDelta
     * @property {Number} - A number representing how much time has elapsed since the last frame in milliseconds.
     */
    timeDelta: 0,

    /**
     * @name Two#playing
     * @property {Boolean} - A boolean representing whether or not the instance is being updated through the automatic `requestAnimationFrame`.
     */
    playing: false,

    /**
     * @name Two#appendTo
     * @function
     * @param {Element} elem - The DOM element to append the Two.js stage to.
     * @description Shorthand method to append your instance of Two.js to the `document`.
     */
    appendTo: function(elem) {

      elem.appendChild(this.renderer.domElement);

      if (this.fit) {
        if (this.fit.domElement !== window) {
          this.fit.domElement = elem;
          this.fit.attached = false;
        }
        this.update();
      }

      return this;

    },

    /**
     * @name Two#play
     * @function
     * @fires Two.Events.Types.play event
     * @description Call to start an internal animation loop.
     * @nota-bene This function initiates a `requestAnimationFrame` loop.
     */
    play: function() {

      this.playing = true;
      raf.init();
      return this.trigger(Events.Types.play);

    },

    /**
     * @name Two#pause
     * @function
     * @fires Two.Events.Types.pause event
     * @description Call to stop the internal animation loop for a specific instance of Two.js.
     */
    pause: function() {

      this.playing = false;
      return this.trigger(Events.Types.pause);

    },

    setPlaying: function(p) {
      this.playing = p;
    },

    /**
     * @name Two#release
     * @function
     * @param {Object} obj
     * @returns {Object} The object passed for event deallocation.
     * @description Release an arbitrary class' events from the Two.js corpus and recurse through its children and or vertices.
     */
    release: function(obj) {

      var i, v, child;

      if (!_.isObject(obj)) {
        return;
      }

      if (typeof obj.unbind === 'function') {
        obj.unbind();
      }

      if (obj.vertices) {
        if (typeof obj.vertices.unbind === 'function') {
          obj.vertices.unbind();
        }
        for (i = 0; i < obj.vertices.length; i++) {
          v = obj.vertices[i];
          if (typeof v.unbind === 'function') {
            v.unbind();
          }
        }
      }

      if (obj.children) {
        for (i = 0; i < obj.children.length; i++) {
          child = obj.children[i];
          this.release(child);
        }
      }

      return obj;

    },

    /**
     * @name Two#update
     * @function
     * @fires Two.Events.Types.update event
     * @description Update positions and calculations in one pass before rendering. Then render to the canvas.
     * @nota-bene This function is called automatically if using {@link Two#play} or the `autostart` parameter in construction.
     */
    update: function() {

      var animated = !!this._lastFrame;
      var now = _.performance.now();

      if (animated) {
        this.timeDelta = parseFloat((now - this._lastFrame).toFixed(3));
      }
      this._lastFrame = now;

      if (this.fit && this.fit.domElement && !this.fit.attached) {
          dom.bind(this.fit.domElement, 'resize', this.fit);
          this.fit.attached = true;
          this.fit();
      }

      var width = this.width;
      var height = this.height;
      var renderer = this.renderer;

      // Update width / height for the renderer
      if (width !== renderer.width || height !== renderer.height) {
        renderer.setSize(width, height, this.ratio);
      }

      this.trigger(Events.Types.update, this.frameCount, this.timeDelta);

      return this.render();

    },

    /**
     * @name Two#render
     * @function
     * @fires render
     * @description Render all drawable and visible objects of the scene.
     */
    render: function() {

      this.renderer.render();
      return this.trigger(Events.Types.render, this.frameCount++);

    },

    // Convenience Methods

    /**
     * @name Two#add
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - An array of Two.js objects. Alternatively can add objects as individual arguments.
     * @description A shorthand method to add specific Two.js objects to the scene.
     */
    add: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      }

      this.scene.add(objects);
      return this;

    },

    /**
     * @name Two#remove
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - An array of Two.js objects.
     * @description A shorthand method to remove specific Two.js objects from the scene.
     */
    remove: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      }

      this.scene.remove(objects);

      return this;

    },

    /**
     * @name Two#clear
     * @function
     * @description Removes all objects from the instance's scene. If you intend to have the browser garbage collect this, don't forget to delete the references in your application as well.
     */
    clear: function() {

      this.scene.remove(this.scene.children);
      return this;

    },

    /**
     * @name Two#makeLine
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @returns {Two.Line}
     * @description Creates a Two.js line and adds it to the scene.
     */
    makeLine: function(x1, y1, x2, y2) {

      var line = new Line(x1, y1, x2, y2);
      this.scene.add(line);

      return line;

    },

    /**
     * @name Two#makeArrow
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @returns {Two.Path}
     * @description Creates a Two.js arrow and adds it to the scene.
     */
    makeArrow: function(x1, y1, x2, y2, size) {

      var headlen = typeof size === 'number' ? size : 10;

      var angle = Math.atan2(y2 - y1, x2 - x1);

      var vertices = [

        new Anchor(x1, y1, undefined, undefined, undefined, undefined, Commands.move),
        new Anchor(x2, y2, undefined, undefined, undefined, undefined, Commands.line),
        new Anchor(
          x2 - headlen * Math.cos(angle - Math.PI / 4),
          y2 - headlen * Math.sin(angle - Math.PI / 4),
          undefined, undefined, undefined, undefined, Commands.line
        ),

        new Anchor(x2, y2, undefined, undefined, undefined, undefined, Commands.move),
        new Anchor(
          x2 - headlen * Math.cos(angle + Math.PI / 4),
          y2 - headlen * Math.sin(angle + Math.PI / 4),
          undefined, undefined, undefined, undefined, Commands.line
        )

      ];

      var path = new Path(vertices, false, false, true);
      path.noFill();
      path.cap = 'round';
      path.join = 'round';

      this.scene.add(path);

      return path;
    },

    /**
     * @name Two#makeRectangle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @returns {Two.Rectangle}
     * @description Creates a Two.js rectangle and adds it to the scene.
     */
    makeRectangle: function(x, y, width, height) {

      var rect = new Rectangle(x, y, width, height);
      this.scene.add(rect);

      return rect;

    },

    /**
     * @name Two#makeRoundedRectangle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @param {Number} sides
     * @returns {Two.Rectangle}
     * @description Creates a Two.js rounded rectangle and adds it to the scene.
     */
    makeRoundedRectangle: function(x, y, width, height, sides) {

      var rect = new RoundedRectangle(x, y, width, height, sides);
      this.scene.add(rect);

      return rect;

    },

    /**
     * @name Two#makeCircle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} radius
     * @param {Number} [resolution=4]
     * @returns {Two.Circle}
     * @description Creates a Two.js circle and adds it to the scene.
     */
    makeCircle: function(x, y, radius, resolution) {

      var circle = new Circle(x, y, radius, resolution);
      this.scene.add(circle);

      return circle;

    },

    /**
     * @name Two#makeEllipse
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} rx
     * @param {Number} ry
     * @param {Number} [resolution=4]
     * @returns {Two.Ellipse}
     * @description Creates a Two.js ellipse and adds it to the scene.
     */
    makeEllipse: function(x, y, rx, ry, resolution) {

      var ellipse = new Ellipse(x, y, rx, ry, resolution);
      this.scene.add(ellipse);

      return ellipse;

    },

    /**
     * @name Two#makeStar
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} outerRadius
     * @param {Number} innerRadius
     * @param {Number} sides
     * @returns {Two.Star}
     * @description Creates a Two.js star and adds it to the scene.
     */
    makeStar: function(ox, oy, outerRadius, innerRadius, sides) {

      var star = new Star(ox, oy, outerRadius, innerRadius, sides);
      this.scene.add(star);

      return star;

    },

    /**
     * @name Two#makeCurve
     * @function
     * @param {Two.Anchor[]} [points] - An array of {@link Two.Anchor} points.
     * @param {...Number} - Alternatively you can pass alternating `x` / `y` coordinate values as individual arguments. These will be combined into {@link Two.Anchor}s for use in the path.
     * @returns {Two.Path} - Where `path.curved` is set to `true`.
     * @description Creates a Two.js path that is curved and adds it to the scene.
     * @nota-bene In either case of passing an array or passing numbered arguments the last argument is an optional `Boolean` that defines whether the path should be open or closed.
     */
    makeCurve: function(p) {

      var l = arguments.length, points = p;
      if (!Array.isArray(p)) {
        points = [];
        for (var i = 0; i < l; i+=2) {
          var x = arguments[i];
          if (typeof x !== 'number') {
            break;
          }
          var y = arguments[i + 1];
          points.push(new Anchor(x, y));
        }
      }

      var last = arguments[l - 1];
      var curve = new Path(points, !(typeof last === 'boolean' ? last : undefined), true);
      var rect = curve.getBoundingClientRect();
      curve.center().translation
        .set(rect.left + rect.width / 2, rect.top + rect.height / 2);

      this.scene.add(curve);

      return curve;

    },

    /**
     * @name Two#makePolygon
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} radius
     * @param {Number} sides
     * @returns {Two.Polygon}
     * @description Creates a Two.js polygon and adds it to the scene.
     */
    makePolygon: function(x, y, radius, sides) {

      var poly = new Polygon(x, y, radius, sides);
      this.scene.add(poly);

      return poly;

    },

    /**
     * @name Two#makeArcSegment
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} innerRadius
     * @param {Number} outerRadius
     * @param {Number} startAngle
     * @param {Number} endAngle
     * @param {Number} [resolution=Two.Resolution] - The number of vertices that should comprise the arc segment.
     */
    makeArcSegment: function(ox, oy, ir, or, sa, ea, res) {
      var arcSegment = new ArcSegment(ox, oy, ir, or, sa, ea, res);
      this.scene.add(arcSegment);
      return arcSegment;
    },

    /**
     * @name Two#makePath
     * @function
     * @param {Two.Anchor[]} [points] - An array of {@link Two.Anchor} points.
     * @param {...Number} - Alternatively you can pass alternating `x` / `y` coordinate values as individual arguments. These will be combined into {@link Two.Anchor}s for use in the path.
     * @returns {Two.Path}
     * @description Creates a Two.js path and adds it to the scene.
     * @nota-bene In either case of passing an array or passing numbered arguments the last argument is an optional `Boolean` that defines whether the path should be open or closed.
     */
    makePath: function(p) {

      var l = arguments.length, points = p;
      if (!Array.isArray(p)) {
        points = [];
        for (var i = 0; i < l; i+=2) {
          var x = arguments[i];
          if (typeof x !== 'number') {
            break;
          }
          var y = arguments[i + 1];
          points.push(new Anchor(x, y));
        }
      }

      var last = arguments[l - 1];
      var path = new Path(points, !(typeof last === 'boolean' ? last : undefined));
      var rect = path.getBoundingClientRect();
      if (typeof rect.top === 'number'   && typeof rect.left === 'number' &&
          typeof rect.right === 'number' && typeof rect.bottom === 'number') {
        path.center().translation
          .set(rect.left + rect.width / 2, rect.top + rect.height / 2);
      }

      this.scene.add(path);

      return path;

    },

    /**
     * @name Two#makeText
     * @function
     * @param {String} message
     * @param {Number} x
     * @param {Number} y
     * @param {Object} [styles] - An object to describe any of the {@link Two.Text.Properties} including `fill`, `stroke`, `linewidth`, `family`, `alignment`, `leading`, `opacity`, etc..
     * @returns {Two.Text}
     * @description Creates a Two.js text object and adds it to the scene.
     */
    makeText: function(message, x, y, styles) {
      var text = new Text(message, x, y, styles);
      this.add(text);
      return text;
    },

    /**
     * @name Two#makeLinearGradient
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @param {...Two.Stop} stops - Any number of color stops sometimes reffered to as ramp stops. If none are supplied then the default black-to-white two stop gradient is applied.
     * @returns {Two.LinearGradient}
     * @description Creates a Two.js linear gradient and ads it to the scene. In the case of an effect it's added to an invisible "definitions" group.
     */
    makeLinearGradient: function(x1, y1, x2, y2 /* stops */) {

      var stops = Array.prototype.slice.call(arguments, 4);
      var gradient = new LinearGradient(x1, y1, x2, y2, stops);

      this.add(gradient);

      return gradient;

    },

    /**
     * @name Two#makeRadialGradient
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} radius
     * @param {...Two.Stop} stops - Any number of color stops sometimes reffered to as ramp stops. If none are supplied then the default black-to-white two stop gradient is applied.
     * @returns {Two.RadialGradient}
     * @description Creates a Two.js linear-gradient object and ads it to the scene. In the case of an effect it's added to an invisible "definitions" group.
     */
    makeRadialGradient: function(x1, y1, r /* stops */) {

      var stops = Array.prototype.slice.call(arguments, 3);
      var gradient = new RadialGradient(x1, y1, r, stops);

      this.add(gradient);

      return gradient;

    },

    /**
     * @name Two#makeSprite
     * @function
     * @param {(String|Two.Texture)} pathOrTexture - The URL path to an image or an already created {@link Two.Texture}.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} [columns=1]
     * @param {Number} [rows=1]
     * @param {Number} [frameRate=0]
     * @param {Boolean} [autostart=false]
     * @returns {Two.Sprite}
     * @description Creates a Two.js sprite object and adds it to the scene. Sprites can be used for still images as well as animations.
     */
    makeSprite: function(path, x, y, cols, rows, frameRate, autostart) {

      var sprite = new Sprite(path, x, y, cols, rows, frameRate);
      if (autostart) {
        sprite.play();
      }
      this.add(sprite);

      return sprite;

    },

    /**
     * @name Two#makeImageSequence
     * @function
     * @param {(String[]|Two.Texture[])} pathsOrTextures - An array of paths or of {@link Two.Textures}.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} [frameRate=0]
     * @param {Boolean} [autostart=false]
     * @returns {Two.ImageSequence}
     * @description Creates a Two.js image sequence object and adds it to the scene.
     */
    makeImageSequence: function(paths, x, y, frameRate, autostart) {

      var imageSequence = new ImageSequence(paths, x, y, frameRate);
      if (autostart) {
        imageSequence.play();
      }
      this.add(imageSequence);

      return imageSequence;

    },

    /**
     * @name Two#makeTexture
     * @function
     * @param {(String|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)} [pathOrSource] - The URL path to an image or a DOM image-like element.
     * @param {Function} [callback] - Function to be invoked when the image is loaded.
     * @returns {Two.Texture}
     * @description Creates a Two.js texture object.
     */
    makeTexture: function(path, callback) {

      var texture = new Texture(path, callback);
      return texture;

    },

    /**
     * @name Two#makeGroup
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - Two.js objects to be added to the group in the form of an array or as individual arguments.
     * @returns {Two.Group}
     * @description Creates a Two.js group object and adds it to the scene.
     */
    makeGroup: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      }

      var group = new Group();
      this.scene.add(group);
      group.add(objects);

      return group;

    },

    /**
     * @name Two#interpret
     * @function
     * @param {SVGElement} SVGElement - The SVG node to be parsed.
     * @param {Boolean} shallow - Don't create a top-most group but append all content directly.
     * @param {Boolean} add â€“ Automatically add the reconstructed SVG node to scene.
     * @returns {Two.Group}
     * @description Interpret an SVG Node and add it to this instance's scene. The distinction should be made that this doesn't `import` svg's, it solely interprets them into something compatible for Two.js - this is slightly different than a direct transcription.
     */
    interpret: function(SVGElement, shallow, add) {

      var tag = SVGElement.tagName.toLowerCase();

      add = (typeof add !== 'undefined') ? add : true;

      if (!(tag in read)) {
        return null;
      }

      var node = read[tag].call(this, SVGElement);

      if (add) {
        this.add(shallow && node instanceof Group ? node.children : node);
      } else if (node.parent) {
        // Remove `g` tags that have been added to scenegraph / DOM
        // in order to be compatible with `getById` methods.
        node.remove();
      }

      return node;

    },

    /**
     * @name Two#load
     * @function
     * @param {String|SVGElement} pathOrSVGContent - The URL path of an SVG file or an SVG document as text.
     * @param {Function} callback - Function to call once loading has completed.
     * @returns {Two.Group}
     * @description Load an SVG file or SVG text and interpret it into Two.js legible objects.
     */
    load: function(text, callback) {

      var group = new Group();
      var elem, i, j, child;

      var attach = (function(data) {

        dom.temp.innerHTML = data;

        for (i = 0; i < dom.temp.children.length; i++) {
          elem = dom.temp.children[i];
          if (/svg/i.test(elem.nodeName)) {
            child = this.interpret(elem);
            // Two.Utils.applySvgViewBox.call(this, group, elem.getAttribute('viewBox'));
            for (j = 0; j < child.children.length; j++) {
              group.add(child.children[j]);
            }
          } else {
            group.add(this.interpret(elem));
          }
        }

        if (typeof callback === 'function') {
          var svg = dom.temp.children.length <= 1
            ? dom.temp.children[0] : dom.temp.children;
          callback(group, svg);
        }

      }).bind(this);

      if (/.*\.svg/ig.test(text)) {

        xhr(text, attach);

        return group;

      }

      attach(text);

      return group;

    }

  });

  function fitToWindow() {

    var wr = document.body.getBoundingClientRect();

    var width = this.width = wr.width;
    var height = this.height = wr.height;

    this.renderer.setSize(width, height, this.ratio);

  }

  function fitToParent() {

    var parent = this.renderer.domElement.parentElement;
    if (!parent) {
      console.warn('Two.js: Attempting to fit to parent, but no parent found.');
      return;
    }
    var wr = parent.getBoundingClientRect();

    var width = this.width = wr.width;
    var height = this.height = wr.height;

    this.renderer.setSize(width, height, this.ratio);

  }

  function updateDimensions(width, height) {
    this.width = width;
    this.height = height;
    this.trigger(Events.Types.resize, width, height);
  }

  // Request Animation Frame

  var raf = dom.getRequestAnimationFrame();

  function loop() {

    for (var i = 0; i < Two.Instances.length; i++) {
      var t = Two.Instances[i];
      if (t.playing) {
        t.update();
      }
    }

    Two.nextFrameID = raf(loop);

  }

  raf.init = function() {
    loop();
    raf.init = function() {};
  };

  _.extend(Two, {
    Anchor: Anchor,
    Collection: Collection,
    Events: Events,
    Group: Group,
    Matrix: Matrix,
    Path: Path,
    Registry: Registry,
    Shape: Shape,
    Text: Text,
    Vector: Vector,

    Gradient: Gradient,
    ImageSequence: ImageSequence,
    LinearGradient: LinearGradient,
    RadialGradient: RadialGradient,
    Sprite: Sprite,
    Stop: Stop,
    Texture: Texture,

    ArcSegment: ArcSegment,
    Circle: Circle,
    Ellipse: Ellipse,
    Line: Line,
    Polygon: Polygon,
    Rectangle: Rectangle,
    RoundedRectangle: RoundedRectangle,
    Star: Star,

    CanvasRenderer: Renderer$2,
    SVGRenderer: Renderer$1,
    WebGLRenderer: Renderer,

    Commands: Commands,

    /**
     * @name Two.Utils
     * @property {Object} - A massive object filled with utility functions and properties.
     */
    Utils: _.extend({

      Error: TwoError,
      getRatio: getRatio,
      defineGetterSetter: defineGetterSetter,
      read: read,
      xhr: xhr

    }, _, CanvasShim, Curves, math)

  });

  return Two;

})));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],6:[function(require,module,exports){
(function (global){(function (){

global.CANVAS_SKETCH_DEFAULT_STORAGE_KEY = "D:\\Manuel\\canvas-sketch\\examples\\animated-two-overdraw.js";

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[6,1,2,3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvc3JjL2luc3RydW1lbnRhdGlvbi9jbGllbnQtZW5hYmxlLW91dHB1dC5qcyIsIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvc3JjL2luc3RydW1lbnRhdGlvbi9jbGllbnQuanMiLCJhbmltYXRlZC10d28tb3ZlcmRyYXcuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvcmlnaHQtbm93L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9pcy1wcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvaXMtZG9tL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9pc19hcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvZGF0ZWZvcm1hdC9saWIvZGF0ZWZvcm1hdC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL3JlcGVhdC1zdHJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9wYWQtbGVmdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL3NhdmUuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9hY2Nlc3NpYmlsaXR5LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvY29yZS9rZXlib2FyZFNob3J0Y3V0cy5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL3BhcGVyLXNpemVzLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvZGVmaW5lZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2NvbnZlcnQtbGVuZ3RoL2NvbnZlcnQtbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvZGlzdGFuY2VzLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvY29yZS9yZXNpemVDYW52YXMuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9nZXQtY2FudmFzLWNvbnRleHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9jb3JlL2NyZWF0ZUNhbnZhcy5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL2NvcmUvU2tldGNoTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL2NhbnZhcy1za2V0Y2guanMiLCJub2RlX21vZHVsZXMvdHdvLmpzL2J1aWxkL3R3by5qcyIsImNhbnZhcy1za2V0Y2gtY2xpL2luamVjdGVkL3N0b3JhZ2Uta2V5LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQTtBQUNBLE1BQU0sQ0FBQyxtQkFBRCxDQUFOLEdBQThCLE1BQU0sQ0FBQyxtQkFBRCxDQUFOLElBQStCLEVBQTdEO0FBQ0EsTUFBTSxDQUFDLG1CQUFELENBQU4sQ0FBNEIsTUFBNUIsR0FBcUMsSUFBckM7Ozs7O0FDRkEsTUFBTSxTQUFTLEdBQUcs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QUksR0FBRyxDQUFDLENBQUMsQ0FBQztXQUNaLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztXQUNmLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7V0FDN0IsQ0FBQyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1dBQzFFLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztXQUMxRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7V0FDMUUsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1dBQzFFLENBQUMsS0FBSyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxLQUFLLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxFQUFFLENBQUM7V0FDeEcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxH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LENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsTUFBTyxJQUFLLEtBQ2QsQ0FBRTtLQUFPLElBQUssS0FDZCxDQUFFLE1BQU8sSUFBSyxLQUdkLENBQUUsS0FBTSxJQUFLLE1BQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUU7S0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLEdBQUksS0FDWixDQUFFLEtBQU07S0FBSSxJQUNaLENBQUUsS0FBTSxHQUFJLElBQ1osQ0FBRSxNQUFPLEdBQUksSUFDYixDQUFFLE1BQU8sS0FBTSxNQUNmLENBQUUsTUFBTyxLQUFNLE1BQ2YsQ0FBRSxLQUFNO0tBQU0sTUFDZCxDQUFFLEtBQU0sSUFBSyxNQUNiLENBQUUsTUFBTyxJQUFLLE1BQ2QsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLE1BQU8sSUFBSyxLQUNkLENBQUUsS0FBTTtLQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLEdBQUksS0FDWixDQUFFLEtBQU0sR0FBSTtLQUNaLENBQUUsS0FBTSxHQUFJLElBQ1osQ0FBRSxNQUFPLEdBQUksSUFDYixDQUFFLE1BQU8sR0FBSSxJQUNiLENBQUUsTUFBTyxHQUFJLElBQ2IsQ0FBRSxLQUFNLElBQUssTUFDYixDQUFFO0tBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNO0tBQUssS0FDYixDQUFFLEtBQU0sR0FBSSxLQUNaLENBQUUsS0FBTSxHQUFJLElBQ1osQ0FBRSxLQUFNLEdBQUksSUFDWixDQUFFLE1BQU8sR0FBSSxJQUNi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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNWhnQkE7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLy8gTWFyayBvdXRwdXQvZXhwb3J0IGFzIGVuYWJsZWQgZm9yIHRoZSBjbGllbnQgQVBJIHNjcmlwdHMuXG53aW5kb3dbJ2NhbnZhcy1za2V0Y2gtY2xpJ10gPSB3aW5kb3dbJ2NhbnZhcy1za2V0Y2gtY2xpJ10gfHwge307XG53aW5kb3dbJ2NhbnZhcy1za2V0Y2gtY2xpJ10ub3V0cHV0ID0gdHJ1ZTtcbiIsImNvbnN0IE5BTUVTUEFDRSA9ICdjYW52YXMtc2tldGNoLWNsaSc7XG5cbi8vIEdyYWIgdGhlIENMSSBuYW1lc3BhY2VcbndpbmRvd1tOQU1FU1BBQ0VdID0gd2luZG93W05BTUVTUEFDRV0gfHwge307XG5cbmlmICghd2luZG93W05BTUVTUEFDRV0uaW5pdGlhbGl6ZWQpIHtcbiAgaW5pdGlhbGl6ZSgpO1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplICgpIHtcbiAgLy8gQXdhaXRpbmcgZW5hYmxlL2Rpc2FibGUgZXZlbnRcbiAgd2luZG93W05BTUVTUEFDRV0ubGl2ZVJlbG9hZEVuYWJsZWQgPSB1bmRlZmluZWQ7XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLmluaXRpYWxpemVkID0gdHJ1ZTtcblxuICBjb25zdCBkZWZhdWx0UG9zdE9wdGlvbnMgPSB7XG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgY2FjaGU6ICduby1jYWNoZScsXG4gICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbidcbiAgfTtcblxuICAvLyBGaWxlIHNhdmluZyB1dGlsaXR5XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLnNhdmVCbG9iID0gKGJsb2IsIG9wdHMpID0+IHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIGNvbnN0IGZvcm0gPSBuZXcgd2luZG93LkZvcm1EYXRhKCk7XG4gICAgZm9ybS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCBvcHRzLmZpbGVuYW1lKTtcbiAgICByZXR1cm4gd2luZG93LmZldGNoKCcvY2FudmFzLXNrZXRjaC1jbGkvc2F2ZUJsb2InLCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UG9zdE9wdGlvbnMsIHtcbiAgICAgIGJvZHk6IGZvcm1cbiAgICB9KSkudGhlbihyZXMgPT4ge1xuICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXMudGV4dCgpLnRoZW4odGV4dCA9PiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRleHQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgLy8gU29tZSBpc3N1ZSwganVzdCBiYWlsIG91dCBhbmQgcmV0dXJuIG5pbCBoYXNoXG4gICAgICBjb25zb2xlLndhcm4oYFRoZXJlIHdhcyBhIHByb2JsZW0gZXhwb3J0aW5nICR7b3B0cy5maWxlbmFtZX1gKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH07XG5cbiAgY29uc3Qgc3RyZWFtID0gKHVybCwgb3B0cykgPT4ge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgcmV0dXJuIHdpbmRvdy5mZXRjaCh1cmwsIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQb3N0T3B0aW9ucywge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICB9LFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBzYXZlOiBvcHRzLnNhdmUsXG4gICAgICAgIGVuY29kaW5nOiBvcHRzLmVuY29kaW5nLFxuICAgICAgICB0aW1lU3RhbXA6IG9wdHMudGltZVN0YW1wLFxuICAgICAgICBmcHM6IG9wdHMuZnBzLFxuICAgICAgICBmaWxlbmFtZTogb3B0cy5maWxlbmFtZVxuICAgICAgfSlcbiAgICB9KSlcbiAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKHRleHQgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRleHQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAvLyBTb21lIGlzc3VlLCBqdXN0IGJhaWwgb3V0IGFuZCByZXR1cm4gbmlsIGhhc2hcbiAgICAgICAgY29uc29sZS53YXJuKGBUaGVyZSB3YXMgYSBwcm9ibGVtIHN0YXJ0aW5nIHRoZSBzdHJlYW0gZXhwb3J0YCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICB9O1xuXG4gIC8vIEZpbGUgc3RyZWFtaW5nIHV0aWxpdHlcbiAgd2luZG93W05BTUVTUEFDRV0uc3RyZWFtU3RhcnQgPSAob3B0cykgPT4ge1xuICAgIHJldHVybiBzdHJlYW0oJy9jYW52YXMtc2tldGNoLWNsaS9zdHJlYW0tc3RhcnQnLCBvcHRzKTtcbiAgfTtcblxuICB3aW5kb3dbTkFNRVNQQUNFXS5zdHJlYW1FbmQgPSAob3B0cykgPT4ge1xuICAgIHJldHVybiBzdHJlYW0oJy9jYW52YXMtc2tldGNoLWNsaS9zdHJlYW0tZW5kJywgb3B0cyk7XG4gIH07XG5cbiAgLy8gZ2l0IGNvbW1pdCB1dGlsaXR5XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLmNvbW1pdCA9ICgpID0+IHtcbiAgICByZXR1cm4gd2luZG93LmZldGNoKCcvY2FudmFzLXNrZXRjaC1jbGkvY29tbWl0JywgZGVmYXVsdFBvc3RPcHRpb25zKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmVycm9yLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ25vdCBhIGdpdCByZXBvc2l0b3J5JykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgV2FybmluZzogJHtyZXN1bHQuZXJyb3J9YCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vdGlmeSB1c2VyIG9mIGNoYW5nZXNcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0LmNoYW5nZWRcbiAgICAgICAgICA/IGBbZ2l0XSAke3Jlc3VsdC5oYXNofSBDb21taXR0ZWQgY2hhbmdlc2BcbiAgICAgICAgICA6IGBbZ2l0XSAke3Jlc3VsdC5oYXNofSBOb3RoaW5nIGNoYW5nZWRgKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5oYXNoO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAvLyBTb21lIGlzc3VlLCBqdXN0IGJhaWwgb3V0IGFuZCByZXR1cm4gbmlsIGhhc2hcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgY29tbWl0IGNoYW5nZXMgYW5kIGZldGNoIGhhc2gnKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gIH07XG5cbiAgaWYgKCdidWRvLWxpdmVyZWxvYWQnIGluIHdpbmRvdykge1xuICAgIGNvbnN0IGNsaWVudCA9IHdpbmRvd1snYnVkby1saXZlcmVsb2FkJ107XG4gICAgY2xpZW50Lmxpc3RlbihkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLmV2ZW50ID09PSAnaG90LXJlbG9hZCcpIHtcbiAgICAgICAgc2V0dXBMaXZlUmVsb2FkKGRhdGEuZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBPbiBmaXJzdCBsb2FkLCBjaGVjayB0byBzZWUgaWYgd2Ugc2hvdWxkIHNldHVwIGxpdmUgcmVsb2FkIG9yIG5vdFxuICAgIGlmICh3aW5kb3dbTkFNRVNQQUNFXS5ob3QpIHtcbiAgICAgIHNldHVwTGl2ZVJlbG9hZCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dXBMaXZlUmVsb2FkKGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0dXBMaXZlUmVsb2FkIChpc0VuYWJsZWQpIHtcbiAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHdpbmRvd1tOQU1FU1BBQ0VdLmxpdmVSZWxvYWRFbmFibGVkO1xuICBpZiAodHlwZW9mIHByZXZpb3VzU3RhdGUgIT09ICd1bmRlZmluZWQnICYmIGlzRW5hYmxlZCAhPT0gcHJldmlvdXNTdGF0ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gcmVsb2FkIHRoZSBwYWdlIHRvIGVuc3VyZSB0aGUgbmV3IHNrZXRjaCBmdW5jdGlvbiBpc1xuICAgIC8vIG5hbWVkIGZvciBob3QgcmVsb2FkaW5nLCBhbmQvb3IgY2xlYW5lZCB1cCBhZnRlciBob3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkXG4gICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCh0cnVlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaXNFbmFibGVkID09PSB3aW5kb3dbTkFNRVNQQUNFXS5saXZlUmVsb2FkRW5hYmxlZCkge1xuICAgIC8vIE5vIGNoYW5nZSBpbiBzdGF0ZVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIE1hcmsgbmV3IHN0YXRlXG4gIHdpbmRvd1tOQU1FU1BBQ0VdLmxpdmVSZWxvYWRFbmFibGVkID0gaXNFbmFibGVkO1xuXG4gIGlmIChpc0VuYWJsZWQpIHtcbiAgICBpZiAoJ2J1ZG8tbGl2ZXJlbG9hZCcgaW4gd2luZG93KSB7XG4gICAgICBjb25zb2xlLmxvZyhgJWNbY2FudmFzLXNrZXRjaC1jbGldJWMg4pyoIEhvdCBSZWxvYWQgRW5hYmxlZGAsICdjb2xvcjogIzhlOGU4ZTsnLCAnY29sb3I6IGluaXRpYWw7Jyk7XG4gICAgICBjb25zdCBjbGllbnQgPSB3aW5kb3dbJ2J1ZG8tbGl2ZXJlbG9hZCddO1xuICAgICAgY2xpZW50Lmxpc3RlbihvbkNsaWVudERhdGEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNsaWVudERhdGEgKGRhdGEpIHtcbiAgY29uc3QgY2xpZW50ID0gd2luZG93WydidWRvLWxpdmVyZWxvYWQnXTtcbiAgaWYgKCFjbGllbnQpIHJldHVybjtcblxuICBpZiAoZGF0YS5ldmVudCA9PT0gJ2V2YWwnKSB7XG4gICAgaWYgKCFkYXRhLmVycm9yKSB7XG4gICAgICBjbGllbnQuY2xlYXJFcnJvcigpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZXZhbChkYXRhLmNvZGUpO1xuICAgICAgaWYgKCFkYXRhLmVycm9yKSBjb25zb2xlLmxvZyhgJWNbY2FudmFzLXNrZXRjaC1jbGldJWMg4pyoIEhvdCBSZWxvYWRlZGAsICdjb2xvcjogIzhlOGU4ZTsnLCAnY29sb3I6IGluaXRpYWw7Jyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGAlY1tjYW52YXMtc2tldGNoLWNsaV0lYyDwn5qoIEhvdCBSZWxvYWQgZXJyb3JgLCAnY29sb3I6ICM4ZThlOGU7JywgJ2NvbG9yOiBpbml0aWFsOycpO1xuICAgICAgY2xpZW50LnNob3dFcnJvcihlcnIudG9TdHJpbmcoKSk7XG5cbiAgICAgIC8vIFRoaXMgd2lsbCBhbHNvIGxvYWQgdXAgdGhlIHByb2JsZW1hdGljIHNjcmlwdCBzbyB0aGF0IHN0YWNrIHRyYWNlcyB3aXRoXG4gICAgICAvLyBzb3VyY2UgbWFwcyBpcyB2aXNpYmxlXG4gICAgICBjb25zdCBzY3JpcHRFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHRFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgICAgIH07XG4gICAgICBzY3JpcHRFbGVtZW50LnNyYyA9IGRhdGEuc3JjO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JpcHRFbGVtZW50KTtcbiAgICB9XG4gIH1cbn0iLCJjb25zdCBjYW52YXNTa2V0Y2ggPSByZXF1aXJlKCdjYW52YXMtc2tldGNoJyk7XHJcblxyXG4vLyBJbXBvcnQgVHdvLmpzIC0gbWFrZSBzdXJlIHRvIGhhdmUgZ3JlYXRlciB0aGFuIHYwLjcuMC1hbHBoYS4xXHJcbi8vIGJlY2F1c2UgcHJldmlvdXMgdmVyc2lvbnMgZG9uJ3Qgc3VwcG9ydCBtb2R1bGUgbG9hZGluZyBvciBoZWFkbGVzcyBlbnZpcm9ubWVudHNcclxuY29uc3QgVHdvID0gcmVxdWlyZSgndHdvLmpzJyk7XHJcblxyXG5jb25zdCBzZXR0aW5ncyA9IHtcclxuICBkaW1lbnNpb25zOiBbIDIwNDgsIDIwNDggXSxcclxuICAvLyBNYWtlIHRoZSBsb29wIGFuaW1hdGVkXHJcbiAgYW5pbWF0ZTogdHJ1ZVxyXG59O1xyXG5cclxuY29uc3Qgc2tldGNoID0gKHsgY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvIH0pID0+IHtcclxuICAvLyBDcmVhdGUgdGhlIGluc3RhbmNlIG9mIFR3by5qc1xyXG4gIGNvbnN0IHR3byA9IG5ldyBUd28oe1xyXG4gICAgd2lkdGgsXHJcbiAgICBoZWlnaHQsXHJcbiAgICByYXRpbzogcGl4ZWxSYXRpbyxcclxuICAgIGRvbUVsZW1lbnQ6IGNhbnZhcyxcclxuICAgIG92ZXJkcmF3OiB0cnVlXHJcbiAgfSk7XHJcblxyXG4gIC8vIENyZWF0ZSB0aGUgc3ViamVjdCBvZiB0aGUgdmlzdWFsIG91dHB1dFxyXG4gIGNvbnN0IHN0YXIgPSBuZXcgVHdvLlN0YXIoMCwgMCwgdHdvLndpZHRoIC8gMTAsIHR3by53aWR0aCAvIDUsIDUpO1xyXG4gIHN0YXIuc3Ryb2tlID0gJ3doaXRlJztcclxuICBzdGFyLmxpbmV3aWR0aCA9IDg7XHJcbiAgc3Rhci5maWxsID0gJyMwMDAnO1xyXG4gIHR3by5hZGQoc3Rhcik7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICByZXNpemUgKHsgcGl4ZWxSYXRpbywgd2lkdGgsIGhlaWdodCB9KSB7XHJcbiAgICAgIC8vIFVwZGF0ZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIFR3by5qcyBzY2VuZSBiYXNlZCBvblxyXG4gICAgICAvLyBjYW52YXMtc2tldGNoIGF1dG8gY2hhbmdpbmcgdmlld3BvcnQgcGFyYW1ldGVyc1xyXG4gICAgICB0d28ud2lkdGggPSB3aWR0aDtcclxuICAgICAgdHdvLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgdHdvLnJhdGlvID0gcGl4ZWxSYXRpbztcclxuXHJcbiAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgcGFzc2VkIGRvd24gdG8gdGhlIHJlbmRlcmVyJ3Mgd2lkdGggYW5kIGhlaWdodCBhcyB3ZWxsXHJcbiAgICAgIHR3by5yZW5kZXJlci53aWR0aCA9IHR3by53aWR0aDtcclxuICAgICAgdHdvLnJlbmRlcmVyLmhlaWdodCA9IHR3by5oZWlnaHQ7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyICh7IHRpbWUgfSkge1xyXG4gICAgICBjb25zdCB4ID0gTWF0aC5yYW5kb20oKSAqIHR3by53aWR0aDtcclxuICAgICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCkgKiB0d28uaGVpZ2h0O1xyXG5cclxuICAgICAgLy8gUGxhY2UgdGhlIHN0YXIgcmFuZG9tbHkgb24gdGhlIGNhbnZhc1xyXG4gICAgICBzdGFyLnRyYW5zbGF0aW9uLnNldCh4LCB5KTtcclxuICAgICAgLy8gQ2hhbmdlIGhvdyBtYW55IHNpZGVzIGl0IGhhc1xyXG4gICAgICBzdGFyLnNpZGVzID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOCkgKyA0O1xyXG4gICAgICAvLyBDaGFuZ2UgdGhlIHJvdGF0aW9uXHJcbiAgICAgIHN0YXIucm90YXRpb24gPSBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAqIDI7XHJcblxyXG4gICAgICAvLyBTd2FwIHRoZSBzdHJva2UgLyBmaWxsIGV2ZXJ5IGZyYW1lIHJhbmRvbWx5XHJcbiAgICAgIGlmIChNYXRoLnJhbmRvbSgpID4gMC41KSB7XHJcbiAgICAgICAgc3Rhci5zdHJva2UgPSAnIzAwMCc7XHJcbiAgICAgICAgc3Rhci5maWxsID0gJ3doaXRlJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdGFyLnN0cm9rZSA9ICd3aGl0ZSc7XHJcbiAgICAgICAgc3Rhci5maWxsID0gJyMwMDAnO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBVcGRhdGUgdHdvLmpzIHZpYSB0aGUgYHJlbmRlcmAgbWV0aG9kIC0gKm5vdCogdGhlIGB1cGRhdGVgIG1ldGhvZC5cclxuICAgICAgdHdvLnJlbmRlcigpO1xyXG4gICAgfVxyXG4gIH07XHJcbn07XHJcblxyXG5jYW52YXNTa2V0Y2goc2tldGNoLCBzZXR0aW5ncyk7XHJcbiIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9XG4gIGdsb2JhbC5wZXJmb3JtYW5jZSAmJlxuICBnbG9iYWwucGVyZm9ybWFuY2Uubm93ID8gZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKVxuICB9IDogRGF0ZS5ub3cgfHwgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiArbmV3IERhdGVcbiAgfVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpc1Byb21pc2U7XG5cbmZ1bmN0aW9uIGlzUHJvbWlzZShvYmopIHtcbiAgcmV0dXJuICEhb2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbic7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGlzTm9kZVxuXG5mdW5jdGlvbiBpc05vZGUgKHZhbCkge1xuICByZXR1cm4gKCF2YWwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpXG4gICAgPyBmYWxzZVxuICAgIDogKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHR5cGVvZiB3aW5kb3cuTm9kZSA9PT0gJ29iamVjdCcpXG4gICAgICA/ICh2YWwgaW5zdGFuY2VvZiB3aW5kb3cuTm9kZSlcbiAgICAgIDogKHR5cGVvZiB2YWwubm9kZVR5cGUgPT09ICdudW1iZXInKSAmJlxuICAgICAgICAodHlwZW9mIHZhbC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpXG59XG4iLCIvLyBUT0RPOiBXZSBjYW4gcmVtb3ZlIGEgaHVnZSBjaHVuayBvZiBidW5kbGUgc2l6ZSBieSB1c2luZyBhIHNtYWxsZXJcbi8vIHV0aWxpdHkgbW9kdWxlIGZvciBjb252ZXJ0aW5nIHVuaXRzLlxuaW1wb3J0IGlzRE9NIGZyb20gJ2lzLWRvbSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGllbnRBUEkgKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93WydjYW52YXMtc2tldGNoLWNsaSddO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lZCAoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFyZ3VtZW50c1tpXSAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNCcm93c2VyICgpIHtcbiAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dlYkdMQ29udGV4dCAoY3R4KSB7XG4gIHJldHVybiB0eXBlb2YgY3R4LmNsZWFyID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjdHguY2xlYXJDb2xvciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3R4LmJ1ZmZlckRhdGEgPT09ICdmdW5jdGlvbic7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbnZhcyAoZWxlbWVudCkge1xuICByZXR1cm4gaXNET00oZWxlbWVudCkgJiYgL2NhbnZhcy9pLnRlc3QoZWxlbWVudC5ub2RlTmFtZSkgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Q29udGV4dCA9PT0gJ2Z1bmN0aW9uJztcbn1cbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJ1xuICA/IE9iamVjdC5rZXlzIDogc2hpbTtcblxuZXhwb3J0cy5zaGltID0gc2hpbTtcbmZ1bmN0aW9uIHNoaW0gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4iLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuIiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsIi8qXG4gKiBEYXRlIEZvcm1hdCAxLjIuM1xuICogKGMpIDIwMDctMjAwOSBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT5cbiAqIE1JVCBsaWNlbnNlXG4gKlxuICogSW5jbHVkZXMgZW5oYW5jZW1lbnRzIGJ5IFNjb3R0IFRyZW5kYSA8c2NvdHQudHJlbmRhLm5ldD5cbiAqIGFuZCBLcmlzIEtvd2FsIDxjaXhhci5jb20vfmtyaXMua293YWwvPlxuICpcbiAqIEFjY2VwdHMgYSBkYXRlLCBhIG1hc2ssIG9yIGEgZGF0ZSBhbmQgYSBtYXNrLlxuICogUmV0dXJucyBhIGZvcm1hdHRlZCB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBkYXRlLlxuICogVGhlIGRhdGUgZGVmYXVsdHMgdG8gdGhlIGN1cnJlbnQgZGF0ZS90aW1lLlxuICogVGhlIG1hc2sgZGVmYXVsdHMgdG8gZGF0ZUZvcm1hdC5tYXNrcy5kZWZhdWx0LlxuICovXG5cbihmdW5jdGlvbihnbG9iYWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBkYXRlRm9ybWF0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRva2VuID0gL2R7MSw0fXxtezEsNH18eXkoPzp5eSk/fChbSGhNc1R0XSlcXDE/fFtMbG9TWldOXXxcIlteXCJdKlwifCdbXiddKicvZztcbiAgICAgIHZhciB0aW1lem9uZSA9IC9cXGIoPzpbUE1DRUFdW1NEUF1UfCg/OlBhY2lmaWN8TW91bnRhaW58Q2VudHJhbHxFYXN0ZXJufEF0bGFudGljKSAoPzpTdGFuZGFyZHxEYXlsaWdodHxQcmV2YWlsaW5nKSBUaW1lfCg/OkdNVHxVVEMpKD86Wy0rXVxcZHs0fSk/KVxcYi9nO1xuICAgICAgdmFyIHRpbWV6b25lQ2xpcCA9IC9bXi0rXFxkQS1aXS9nO1xuICBcbiAgICAgIC8vIFJlZ2V4ZXMgYW5kIHN1cHBvcnRpbmcgZnVuY3Rpb25zIGFyZSBjYWNoZWQgdGhyb3VnaCBjbG9zdXJlXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGUsIG1hc2ssIHV0YywgZ210KSB7XG4gIFxuICAgICAgICAvLyBZb3UgY2FuJ3QgcHJvdmlkZSB1dGMgaWYgeW91IHNraXAgb3RoZXIgYXJncyAodXNlIHRoZSAnVVRDOicgbWFzayBwcmVmaXgpXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmIGtpbmRPZihkYXRlKSA9PT0gJ3N0cmluZycgJiYgIS9cXGQvLnRlc3QoZGF0ZSkpIHtcbiAgICAgICAgICBtYXNrID0gZGF0ZTtcbiAgICAgICAgICBkYXRlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gIFxuICAgICAgICBkYXRlID0gZGF0ZSB8fCBuZXcgRGF0ZTtcbiAgXG4gICAgICAgIGlmKCEoZGF0ZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBpZiAoaXNOYU4oZGF0ZSkpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgZGF0ZScpO1xuICAgICAgICB9XG4gIFxuICAgICAgICBtYXNrID0gU3RyaW5nKGRhdGVGb3JtYXQubWFza3NbbWFza10gfHwgbWFzayB8fCBkYXRlRm9ybWF0Lm1hc2tzWydkZWZhdWx0J10pO1xuICBcbiAgICAgICAgLy8gQWxsb3cgc2V0dGluZyB0aGUgdXRjL2dtdCBhcmd1bWVudCB2aWEgdGhlIG1hc2tcbiAgICAgICAgdmFyIG1hc2tTbGljZSA9IG1hc2suc2xpY2UoMCwgNCk7XG4gICAgICAgIGlmIChtYXNrU2xpY2UgPT09ICdVVEM6JyB8fCBtYXNrU2xpY2UgPT09ICdHTVQ6Jykge1xuICAgICAgICAgIG1hc2sgPSBtYXNrLnNsaWNlKDQpO1xuICAgICAgICAgIHV0YyA9IHRydWU7XG4gICAgICAgICAgaWYgKG1hc2tTbGljZSA9PT0gJ0dNVDonKSB7XG4gICAgICAgICAgICBnbXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICBcbiAgICAgICAgdmFyIF8gPSB1dGMgPyAnZ2V0VVRDJyA6ICdnZXQnO1xuICAgICAgICB2YXIgZCA9IGRhdGVbXyArICdEYXRlJ10oKTtcbiAgICAgICAgdmFyIEQgPSBkYXRlW18gKyAnRGF5J10oKTtcbiAgICAgICAgdmFyIG0gPSBkYXRlW18gKyAnTW9udGgnXSgpO1xuICAgICAgICB2YXIgeSA9IGRhdGVbXyArICdGdWxsWWVhciddKCk7XG4gICAgICAgIHZhciBIID0gZGF0ZVtfICsgJ0hvdXJzJ10oKTtcbiAgICAgICAgdmFyIE0gPSBkYXRlW18gKyAnTWludXRlcyddKCk7XG4gICAgICAgIHZhciBzID0gZGF0ZVtfICsgJ1NlY29uZHMnXSgpO1xuICAgICAgICB2YXIgTCA9IGRhdGVbXyArICdNaWxsaXNlY29uZHMnXSgpO1xuICAgICAgICB2YXIgbyA9IHV0YyA/IDAgOiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICAgIHZhciBXID0gZ2V0V2VlayhkYXRlKTtcbiAgICAgICAgdmFyIE4gPSBnZXREYXlPZldlZWsoZGF0ZSk7XG4gICAgICAgIHZhciBmbGFncyA9IHtcbiAgICAgICAgICBkOiAgICBkLFxuICAgICAgICAgIGRkOiAgIHBhZChkKSxcbiAgICAgICAgICBkZGQ6ICBkYXRlRm9ybWF0LmkxOG4uZGF5TmFtZXNbRF0sXG4gICAgICAgICAgZGRkZDogZGF0ZUZvcm1hdC5pMThuLmRheU5hbWVzW0QgKyA3XSxcbiAgICAgICAgICBtOiAgICBtICsgMSxcbiAgICAgICAgICBtbTogICBwYWQobSArIDEpLFxuICAgICAgICAgIG1tbTogIGRhdGVGb3JtYXQuaTE4bi5tb250aE5hbWVzW21dLFxuICAgICAgICAgIG1tbW06IGRhdGVGb3JtYXQuaTE4bi5tb250aE5hbWVzW20gKyAxMl0sXG4gICAgICAgICAgeXk6ICAgU3RyaW5nKHkpLnNsaWNlKDIpLFxuICAgICAgICAgIHl5eXk6IHksXG4gICAgICAgICAgaDogICAgSCAlIDEyIHx8IDEyLFxuICAgICAgICAgIGhoOiAgIHBhZChIICUgMTIgfHwgMTIpLFxuICAgICAgICAgIEg6ICAgIEgsXG4gICAgICAgICAgSEg6ICAgcGFkKEgpLFxuICAgICAgICAgIE06ICAgIE0sXG4gICAgICAgICAgTU06ICAgcGFkKE0pLFxuICAgICAgICAgIHM6ICAgIHMsXG4gICAgICAgICAgc3M6ICAgcGFkKHMpLFxuICAgICAgICAgIGw6ICAgIHBhZChMLCAzKSxcbiAgICAgICAgICBMOiAgICBwYWQoTWF0aC5yb3VuZChMIC8gMTApKSxcbiAgICAgICAgICB0OiAgICBIIDwgMTIgPyBkYXRlRm9ybWF0LmkxOG4udGltZU5hbWVzWzBdIDogZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1sxXSxcbiAgICAgICAgICB0dDogICBIIDwgMTIgPyBkYXRlRm9ybWF0LmkxOG4udGltZU5hbWVzWzJdIDogZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1szXSxcbiAgICAgICAgICBUOiAgICBIIDwgMTIgPyBkYXRlRm9ybWF0LmkxOG4udGltZU5hbWVzWzRdIDogZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1s1XSxcbiAgICAgICAgICBUVDogICBIIDwgMTIgPyBkYXRlRm9ybWF0LmkxOG4udGltZU5hbWVzWzZdIDogZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1s3XSxcbiAgICAgICAgICBaOiAgICBnbXQgPyAnR01UJyA6IHV0YyA/ICdVVEMnIDogKFN0cmluZyhkYXRlKS5tYXRjaCh0aW1lem9uZSkgfHwgWycnXSkucG9wKCkucmVwbGFjZSh0aW1lem9uZUNsaXAsICcnKSxcbiAgICAgICAgICBvOiAgICAobyA+IDAgPyAnLScgOiAnKycpICsgcGFkKE1hdGguZmxvb3IoTWF0aC5hYnMobykgLyA2MCkgKiAxMDAgKyBNYXRoLmFicyhvKSAlIDYwLCA0KSxcbiAgICAgICAgICBTOiAgICBbJ3RoJywgJ3N0JywgJ25kJywgJ3JkJ11bZCAlIDEwID4gMyA/IDAgOiAoZCAlIDEwMCAtIGQgJSAxMCAhPSAxMCkgKiBkICUgMTBdLFxuICAgICAgICAgIFc6ICAgIFcsXG4gICAgICAgICAgTjogICAgTlxuICAgICAgICB9O1xuICBcbiAgICAgICAgcmV0dXJuIG1hc2sucmVwbGFjZSh0b2tlbiwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgaWYgKG1hdGNoIGluIGZsYWdzKSB7XG4gICAgICAgICAgICByZXR1cm4gZmxhZ3NbbWF0Y2hdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWF0Y2guc2xpY2UoMSwgbWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KSgpO1xuXG4gIGRhdGVGb3JtYXQubWFza3MgPSB7XG4gICAgJ2RlZmF1bHQnOiAgICAgICAgICAgICAgICdkZGQgbW1tIGRkIHl5eXkgSEg6TU06c3MnLFxuICAgICdzaG9ydERhdGUnOiAgICAgICAgICAgICAnbS9kL3l5JyxcbiAgICAnbWVkaXVtRGF0ZSc6ICAgICAgICAgICAgJ21tbSBkLCB5eXl5JyxcbiAgICAnbG9uZ0RhdGUnOiAgICAgICAgICAgICAgJ21tbW0gZCwgeXl5eScsXG4gICAgJ2Z1bGxEYXRlJzogICAgICAgICAgICAgICdkZGRkLCBtbW1tIGQsIHl5eXknLFxuICAgICdzaG9ydFRpbWUnOiAgICAgICAgICAgICAnaDpNTSBUVCcsXG4gICAgJ21lZGl1bVRpbWUnOiAgICAgICAgICAgICdoOk1NOnNzIFRUJyxcbiAgICAnbG9uZ1RpbWUnOiAgICAgICAgICAgICAgJ2g6TU06c3MgVFQgWicsXG4gICAgJ2lzb0RhdGUnOiAgICAgICAgICAgICAgICd5eXl5LW1tLWRkJyxcbiAgICAnaXNvVGltZSc6ICAgICAgICAgICAgICAgJ0hIOk1NOnNzJyxcbiAgICAnaXNvRGF0ZVRpbWUnOiAgICAgICAgICAgJ3l5eXktbW0tZGRcXCdUXFwnSEg6TU06c3NvJyxcbiAgICAnaXNvVXRjRGF0ZVRpbWUnOiAgICAgICAgJ1VUQzp5eXl5LW1tLWRkXFwnVFxcJ0hIOk1NOnNzXFwnWlxcJycsXG4gICAgJ2V4cGlyZXNIZWFkZXJGb3JtYXQnOiAgICdkZGQsIGRkIG1tbSB5eXl5IEhIOk1NOnNzIFonXG4gIH07XG5cbiAgLy8gSW50ZXJuYXRpb25hbGl6YXRpb24gc3RyaW5nc1xuICBkYXRlRm9ybWF0LmkxOG4gPSB7XG4gICAgZGF5TmFtZXM6IFtcbiAgICAgICdTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnLFxuICAgICAgJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J1xuICAgIF0sXG4gICAgbW9udGhOYW1lczogW1xuICAgICAgJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJywgJ09jdCcsICdOb3YnLCAnRGVjJyxcbiAgICAgICdKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ1xuICAgIF0sXG4gICAgdGltZU5hbWVzOiBbXG4gICAgICAnYScsICdwJywgJ2FtJywgJ3BtJywgJ0EnLCAnUCcsICdBTScsICdQTSdcbiAgICBdXG4gIH07XG5cbmZ1bmN0aW9uIHBhZCh2YWwsIGxlbikge1xuICB2YWwgPSBTdHJpbmcodmFsKTtcbiAgbGVuID0gbGVuIHx8IDI7XG4gIHdoaWxlICh2YWwubGVuZ3RoIDwgbGVuKSB7XG4gICAgdmFsID0gJzAnICsgdmFsO1xuICB9XG4gIHJldHVybiB2YWw7XG59XG5cbi8qKlxuICogR2V0IHRoZSBJU08gODYwMSB3ZWVrIG51bWJlclxuICogQmFzZWQgb24gY29tbWVudHMgZnJvbVxuICogaHR0cDovL3RlY2hibG9nLnByb2N1cmlvcy5ubC9rL242MTgvbmV3cy92aWV3LzMzNzk2LzE0ODYzL0NhbGN1bGF0ZS1JU08tODYwMS13ZWVrLWFuZC15ZWFyLWluLWphdmFzY3JpcHQuaHRtbFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gYGRhdGVgXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFdlZWsoZGF0ZSkge1xuICAvLyBSZW1vdmUgdGltZSBjb21wb25lbnRzIG9mIGRhdGVcbiAgdmFyIHRhcmdldFRodXJzZGF5ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCBkYXRlLmdldE1vbnRoKCksIGRhdGUuZ2V0RGF0ZSgpKTtcblxuICAvLyBDaGFuZ2UgZGF0ZSB0byBUaHVyc2RheSBzYW1lIHdlZWtcbiAgdGFyZ2V0VGh1cnNkYXkuc2V0RGF0ZSh0YXJnZXRUaHVyc2RheS5nZXREYXRlKCkgLSAoKHRhcmdldFRodXJzZGF5LmdldERheSgpICsgNikgJSA3KSArIDMpO1xuXG4gIC8vIFRha2UgSmFudWFyeSA0dGggYXMgaXQgaXMgYWx3YXlzIGluIHdlZWsgMSAoc2VlIElTTyA4NjAxKVxuICB2YXIgZmlyc3RUaHVyc2RheSA9IG5ldyBEYXRlKHRhcmdldFRodXJzZGF5LmdldEZ1bGxZZWFyKCksIDAsIDQpO1xuXG4gIC8vIENoYW5nZSBkYXRlIHRvIFRodXJzZGF5IHNhbWUgd2Vla1xuICBmaXJzdFRodXJzZGF5LnNldERhdGUoZmlyc3RUaHVyc2RheS5nZXREYXRlKCkgLSAoKGZpcnN0VGh1cnNkYXkuZ2V0RGF5KCkgKyA2KSAlIDcpICsgMyk7XG5cbiAgLy8gQ2hlY2sgaWYgZGF5bGlnaHQtc2F2aW5nLXRpbWUtc3dpdGNoIG9jY3VycmVkIGFuZCBjb3JyZWN0IGZvciBpdFxuICB2YXIgZHMgPSB0YXJnZXRUaHVyc2RheS5nZXRUaW1lem9uZU9mZnNldCgpIC0gZmlyc3RUaHVyc2RheS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICB0YXJnZXRUaHVyc2RheS5zZXRIb3Vycyh0YXJnZXRUaHVyc2RheS5nZXRIb3VycygpIC0gZHMpO1xuXG4gIC8vIE51bWJlciBvZiB3ZWVrcyBiZXR3ZWVuIHRhcmdldCBUaHVyc2RheSBhbmQgZmlyc3QgVGh1cnNkYXlcbiAgdmFyIHdlZWtEaWZmID0gKHRhcmdldFRodXJzZGF5IC0gZmlyc3RUaHVyc2RheSkgLyAoODY0MDAwMDAqNyk7XG4gIHJldHVybiAxICsgTWF0aC5mbG9vcih3ZWVrRGlmZik7XG59XG5cbi8qKlxuICogR2V0IElTTy04NjAxIG51bWVyaWMgcmVwcmVzZW50YXRpb24gb2YgdGhlIGRheSBvZiB0aGUgd2Vla1xuICogMSAoZm9yIE1vbmRheSkgdGhyb3VnaCA3IChmb3IgU3VuZGF5KVxuICogXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBkYXRlYFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXREYXlPZldlZWsoZGF0ZSkge1xuICB2YXIgZG93ID0gZGF0ZS5nZXREYXkoKTtcbiAgaWYoZG93ID09PSAwKSB7XG4gICAgZG93ID0gNztcbiAgfVxuICByZXR1cm4gZG93O1xufVxuXG4vKipcbiAqIGtpbmQtb2Ygc2hvcnRjdXRcbiAqIEBwYXJhbSAgeyp9IHZhbFxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG5cbiAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWw7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cblxuICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2YWwpXG4gICAgLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xufTtcblxuXG5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGF0ZUZvcm1hdDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRhdGVGb3JtYXQ7XG4gIH0gZWxzZSB7XG4gICAgZ2xvYmFsLmRhdGVGb3JtYXQgPSBkYXRlRm9ybWF0O1xuICB9XG59KSh0aGlzKTtcbiIsIi8qIVxuICogcmVwZWF0LXN0cmluZyA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvcmVwZWF0LXN0cmluZz5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFJlc3VsdHMgY2FjaGVcbiAqL1xuXG52YXIgcmVzID0gJyc7XG52YXIgY2FjaGU7XG5cbi8qKlxuICogRXhwb3NlIGByZXBlYXRgXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXBlYXQ7XG5cbi8qKlxuICogUmVwZWF0IHRoZSBnaXZlbiBgc3RyaW5nYCB0aGUgc3BlY2lmaWVkIGBudW1iZXJgXG4gKiBvZiB0aW1lcy5cbiAqXG4gKiAqKkV4YW1wbGU6KipcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1zdHJpbmcnKTtcbiAqIHJlcGVhdCgnQScsIDUpO1xuICogLy89PiBBQUFBQVxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGBzdHJpbmdgIFRoZSBzdHJpbmcgdG8gcmVwZWF0XG4gKiBAcGFyYW0ge051bWJlcn0gYG51bWJlcmAgVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIHN0cmluZ1xuICogQHJldHVybiB7U3RyaW5nfSBSZXBlYXRlZCBzdHJpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgbnVtKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4cGVjdGVkIGEgc3RyaW5nJyk7XG4gIH1cblxuICAvLyBjb3ZlciBjb21tb24sIHF1aWNrIHVzZSBjYXNlc1xuICBpZiAobnVtID09PSAxKSByZXR1cm4gc3RyO1xuICBpZiAobnVtID09PSAyKSByZXR1cm4gc3RyICsgc3RyO1xuXG4gIHZhciBtYXggPSBzdHIubGVuZ3RoICogbnVtO1xuICBpZiAoY2FjaGUgIT09IHN0ciB8fCB0eXBlb2YgY2FjaGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2FjaGUgPSBzdHI7XG4gICAgcmVzID0gJyc7XG4gIH0gZWxzZSBpZiAocmVzLmxlbmd0aCA+PSBtYXgpIHtcbiAgICByZXR1cm4gcmVzLnN1YnN0cigwLCBtYXgpO1xuICB9XG5cbiAgd2hpbGUgKG1heCA+IHJlcy5sZW5ndGggJiYgbnVtID4gMSkge1xuICAgIGlmIChudW0gJiAxKSB7XG4gICAgICByZXMgKz0gc3RyO1xuICAgIH1cblxuICAgIG51bSA+Pj0gMTtcbiAgICBzdHIgKz0gc3RyO1xuICB9XG5cbiAgcmVzICs9IHN0cjtcbiAgcmVzID0gcmVzLnN1YnN0cigwLCBtYXgpO1xuICByZXR1cm4gcmVzO1xufVxuIiwiLyohXG4gKiBwYWQtbGVmdCA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvcGFkLWxlZnQ+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlcGVhdCA9IHJlcXVpcmUoJ3JlcGVhdC1zdHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYWRMZWZ0KHN0ciwgbnVtLCBjaCkge1xuICBzdHIgPSBzdHIudG9TdHJpbmcoKTtcblxuICBpZiAodHlwZW9mIG51bSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKGNoID09PSAwKSB7XG4gICAgY2ggPSAnMCc7XG4gIH0gZWxzZSBpZiAoY2gpIHtcbiAgICBjaCA9IGNoLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgY2ggPSAnICc7XG4gIH1cblxuICByZXR1cm4gcmVwZWF0KGNoLCBudW0gLSBzdHIubGVuZ3RoKSArIHN0cjtcbn07XG4iLCJpbXBvcnQgZGF0ZWZvcm1hdCBmcm9tICdkYXRlZm9ybWF0JztcbmltcG9ydCBhc3NpZ24gZnJvbSAnb2JqZWN0LWFzc2lnbic7XG5pbXBvcnQgcGFkTGVmdCBmcm9tICdwYWQtbGVmdCc7XG5pbXBvcnQgeyBnZXRDbGllbnRBUEkgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBub29wID0gKCkgPT4ge307XG5sZXQgbGluaztcbmxldCBkZWZhdWx0RXh0cyA9IHsgZXh0ZW5zaW9uOiAnJywgcHJlZml4OiAnJywgc3VmZml4OiAnJyB9O1xuXG4vLyBBbHRlcm5hdGl2ZSBzb2x1dGlvbiBmb3Igc2F2aW5nIGZpbGVzLFxuLy8gYSBiaXQgc2xvd2VyIGFuZCBkb2VzIG5vdCB3b3JrIGluIFNhZmFyaVxuLy8gZnVuY3Rpb24gZmV0Y2hCbG9iRnJvbURhdGFVUkwgKGRhdGFVUkwpIHtcbi8vICAgcmV0dXJuIHdpbmRvdy5mZXRjaChkYXRhVVJMKS50aGVuKHJlcyA9PiByZXMuYmxvYigpKTtcbi8vIH1cblxuY29uc3Qgc3VwcG9ydGVkRW5jb2RpbmdzID0gW1xuICAnaW1hZ2UvcG5nJyxcbiAgJ2ltYWdlL2pwZWcnLFxuICAnaW1hZ2Uvd2VicCdcbl07XG5cbmZ1bmN0aW9uIHN0cmVhbSAoaXNTdGFydCwgb3B0cyA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgb3B0cyA9IGFzc2lnbih7fSwgZGVmYXVsdEV4dHMsIG9wdHMpO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcmVzb2x2ZUZpbGVuYW1lKE9iamVjdC5hc3NpZ24oe30sIG9wdHMsIHtcbiAgICAgIGV4dGVuc2lvbjogJycsXG4gICAgICBmcmFtZTogdW5kZWZpbmVkXG4gICAgfSkpO1xuICAgIGNvbnN0IGZ1bmMgPSBpc1N0YXJ0ID8gJ3N0cmVhbVN0YXJ0JyA6ICdzdHJlYW1FbmQnO1xuICAgIGNvbnN0IGNsaWVudCA9IGdldENsaWVudEFQSSgpO1xuICAgIGlmIChjbGllbnQgJiYgY2xpZW50Lm91dHB1dCAmJiB0eXBlb2YgY2xpZW50W2Z1bmNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2xpZW50W2Z1bmNdKGFzc2lnbih7fSwgb3B0cywgeyBmaWxlbmFtZSB9KSlcbiAgICAgICAgLnRoZW4oZXYgPT4gcmVzb2x2ZShldikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSh7IGZpbGVuYW1lLCBjbGllbnQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1TdGFydCAob3B0cyA9IHt9KSB7XG4gIHJldHVybiBzdHJlYW0odHJ1ZSwgb3B0cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1FbmQgKG9wdHMgPSB7fSkge1xuICByZXR1cm4gc3RyZWFtKGZhbHNlLCBvcHRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9ydENhbnZhcyAoY2FudmFzLCBvcHQgPSB7fSkge1xuICBjb25zdCBlbmNvZGluZyA9IG9wdC5lbmNvZGluZyB8fCAnaW1hZ2UvcG5nJztcbiAgaWYgKCFzdXBwb3J0ZWRFbmNvZGluZ3MuaW5jbHVkZXMoZW5jb2RpbmcpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY2FudmFzIGVuY29kaW5nICR7ZW5jb2Rpbmd9YCk7XG4gIGxldCBleHRlbnNpb24gPSAoZW5jb2Rpbmcuc3BsaXQoJy8nKVsxXSB8fCAnJykucmVwbGFjZSgvanBlZy9pLCAnanBnJyk7XG4gIGlmIChleHRlbnNpb24pIGV4dGVuc2lvbiA9IGAuJHtleHRlbnNpb259YC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4ge1xuICAgIGV4dGVuc2lvbixcbiAgICB0eXBlOiBlbmNvZGluZyxcbiAgICBkYXRhVVJMOiBjYW52YXMudG9EYXRhVVJMKGVuY29kaW5nLCBvcHQuZW5jb2RpbmdRdWFsaXR5KVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVCbG9iRnJvbURhdGFVUkwgKGRhdGFVUkwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgc3BsaXRJbmRleCA9IGRhdGFVUkwuaW5kZXhPZignLCcpO1xuICAgIGlmIChzcGxpdEluZGV4ID09PSAtMSkge1xuICAgICAgcmVzb2x2ZShuZXcgd2luZG93LkJsb2IoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJhc2U2NCA9IGRhdGFVUkwuc2xpY2Uoc3BsaXRJbmRleCArIDEpO1xuICAgIGNvbnN0IGJ5dGVTdHJpbmcgPSB3aW5kb3cuYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IHR5cGUgPSBkYXRhVVJMLnNsaWNlKDAsIHNwbGl0SW5kZXgpO1xuICAgIGNvbnN0IG1pbWVNYXRjaCA9IC9kYXRhOihbXjtdKykvLmV4ZWModHlwZSk7XG4gICAgY29uc3QgbWltZSA9IChtaW1lTWF0Y2ggPyBtaW1lTWF0Y2hbMV0gOiAnJykgfHwgdW5kZWZpbmVkO1xuICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgICBjb25zdCBpYSA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlhW2ldID0gYnl0ZVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXNvbHZlKG5ldyB3aW5kb3cuQmxvYihbIGFiIF0sIHsgdHlwZTogbWltZSB9KSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZURhdGFVUkwgKGRhdGFVUkwsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gY3JlYXRlQmxvYkZyb21EYXRhVVJMKGRhdGFVUkwpXG4gICAgLnRoZW4oYmxvYiA9PiBzYXZlQmxvYihibG9iLCBvcHRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlQmxvYiAoYmxvYiwgb3B0cyA9IHt9KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBvcHRzID0gYXNzaWduKHt9LCBkZWZhdWx0RXh0cywgb3B0cyk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBvcHRzLmZpbGVuYW1lO1xuXG4gICAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50QVBJKCk7XG4gICAgaWYgKGNsaWVudCAmJiB0eXBlb2YgY2xpZW50LnNhdmVCbG9iID09PSAnZnVuY3Rpb24nICYmIGNsaWVudC5vdXRwdXQpIHtcbiAgICAgIC8vIG5hdGl2ZSBzYXZpbmcgdXNpbmcgYSBDTEkgdG9vbFxuICAgICAgcmV0dXJuIGNsaWVudC5zYXZlQmxvYihibG9iLCBhc3NpZ24oe30sIG9wdHMsIHsgZmlsZW5hbWUgfSkpXG4gICAgICAgIC50aGVuKGV2ID0+IHJlc29sdmUoZXYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yY2UgZG93bmxvYWRcbiAgICAgIGlmICghbGluaykge1xuICAgICAgICBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICBsaW5rLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgbGluay50YXJnZXQgPSAnX2JsYW5rJztcbiAgICAgIH1cbiAgICAgIGxpbmsuZG93bmxvYWQgPSBmaWxlbmFtZTtcbiAgICAgIGxpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgbGluay5vbmNsaWNrID0gbm9vcDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgd2luZG93LlVSTC5yZXZva2VPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgaWYgKGxpbmsucGFyZW50RWxlbWVudCkgbGluay5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGxpbmspO1xuICAgICAgICAgIGxpbmsucmVtb3ZlQXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgcmVzb2x2ZSh7IGZpbGVuYW1lLCBjbGllbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBsaW5rLmNsaWNrKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVGaWxlIChkYXRhLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcGFydHMgPSBBcnJheS5pc0FycmF5KGRhdGEpID8gZGF0YSA6IFsgZGF0YSBdO1xuICBjb25zdCBibG9iID0gbmV3IHdpbmRvdy5CbG9iKHBhcnRzLCB7IHR5cGU6IG9wdHMudHlwZSB8fCAnJyB9KTtcbiAgcmV0dXJuIHNhdmVCbG9iKGJsb2IsIG9wdHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZVN0YW1wICgpIHtcbiAgY29uc3QgZGF0ZUZvcm1hdFN0ciA9IGB5eXl5Lm1tLmRkLUhILk1NLnNzYDtcbiAgcmV0dXJuIGRhdGVmb3JtYXQobmV3IERhdGUoKSwgZGF0ZUZvcm1hdFN0cik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0RmlsZSAocHJlZml4ID0gJycsIHN1ZmZpeCA9ICcnLCBleHQpIHtcbiAgLy8gY29uc3QgZGF0ZUZvcm1hdFN0ciA9IGB5eXl5Lm1tLmRkLUhILk1NLnNzYDtcbiAgY29uc3QgZGF0ZUZvcm1hdFN0ciA9IGB5eXl5LW1tLWRkICdhdCcgaC5NTS5zcyBUVGA7XG4gIHJldHVybiBgJHtwcmVmaXh9JHtkYXRlZm9ybWF0KG5ldyBEYXRlKCksIGRhdGVGb3JtYXRTdHIpfSR7c3VmZml4fSR7ZXh0fWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlRmlsZW5hbWUgKG9wdCA9IHt9KSB7XG4gIG9wdCA9IGFzc2lnbih7fSwgb3B0KTtcblxuICAvLyBDdXN0b20gZmlsZW5hbWUgZnVuY3Rpb25cbiAgaWYgKHR5cGVvZiBvcHQuZmlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHQuZmlsZShvcHQpO1xuICB9IGVsc2UgaWYgKG9wdC5maWxlKSB7XG4gICAgcmV0dXJuIG9wdC5maWxlO1xuICB9XG5cbiAgbGV0IGZyYW1lID0gbnVsbDtcbiAgbGV0IGV4dGVuc2lvbiA9ICcnO1xuICBpZiAodHlwZW9mIG9wdC5leHRlbnNpb24gPT09ICdzdHJpbmcnKSBleHRlbnNpb24gPSBvcHQuZXh0ZW5zaW9uO1xuXG4gIGlmICh0eXBlb2Ygb3B0LmZyYW1lID09PSAnbnVtYmVyJykge1xuICAgIGxldCB0b3RhbEZyYW1lcztcbiAgICBpZiAodHlwZW9mIG9wdC50b3RhbEZyYW1lcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRvdGFsRnJhbWVzID0gb3B0LnRvdGFsRnJhbWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3RhbEZyYW1lcyA9IE1hdGgubWF4KDEwMDAwLCBvcHQuZnJhbWUpO1xuICAgIH1cbiAgICBmcmFtZSA9IHBhZExlZnQoU3RyaW5nKG9wdC5mcmFtZSksIFN0cmluZyh0b3RhbEZyYW1lcykubGVuZ3RoLCAnMCcpO1xuICB9XG5cbiAgY29uc3QgbGF5ZXJTdHIgPSBpc0Zpbml0ZShvcHQudG90YWxMYXllcnMpICYmIGlzRmluaXRlKG9wdC5sYXllcikgJiYgb3B0LnRvdGFsTGF5ZXJzID4gMSA/IGAke29wdC5sYXllcn1gIDogJyc7XG4gIGlmIChmcmFtZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIFsgbGF5ZXJTdHIsIGZyYW1lIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKSArIGV4dGVuc2lvbjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBkZWZhdWx0RmlsZU5hbWUgPSBvcHQudGltZVN0YW1wO1xuICAgIHJldHVybiBbIG9wdC5wcmVmaXgsIG9wdC5uYW1lIHx8IGRlZmF1bHRGaWxlTmFtZSwgbGF5ZXJTdHIsIG9wdC5oYXNoLCBvcHQuc3VmZml4IF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy0nKSArIGV4dGVuc2lvbjtcbiAgfVxufVxuIiwiLy8gSGFuZGxlIHNvbWUgY29tbW9uIHR5cG9zXG5jb25zdCBjb21tb25UeXBvcyA9IHtcbiAgZGltZW5zaW9uOiAnZGltZW5zaW9ucycsXG4gIGFuaW1hdGVkOiAnYW5pbWF0ZScsXG4gIGFuaW1hdGluZzogJ2FuaW1hdGUnLFxuICB1bml0OiAndW5pdHMnLFxuICBQNTogJ3A1JyxcbiAgcGl4ZWxsYXRlZDogJ3BpeGVsYXRlZCcsXG4gIGxvb3Bpbmc6ICdsb29wJyxcbiAgcGl4ZWxQZXJJbmNoOiAncGl4ZWxzJ1xufTtcblxuLy8gSGFuZGxlIGFsbCBvdGhlciB0eXBvc1xuY29uc3QgYWxsS2V5cyA9IFtcbiAgJ2RpbWVuc2lvbnMnLCAndW5pdHMnLCAncGl4ZWxzUGVySW5jaCcsICdvcmllbnRhdGlvbicsXG4gICdzY2FsZVRvRml0JywgJ3NjYWxlVG9WaWV3JywgJ2JsZWVkJywgJ3BpeGVsUmF0aW8nLFxuICAnZXhwb3J0UGl4ZWxSYXRpbycsICdtYXhQaXhlbFJhdGlvJywgJ3NjYWxlQ29udGV4dCcsXG4gICdyZXNpemVDYW52YXMnLCAnc3R5bGVDYW52YXMnLCAnY2FudmFzJywgJ2NvbnRleHQnLCAnYXR0cmlidXRlcycsXG4gICdwYXJlbnQnLCAnZmlsZScsICduYW1lJywgJ3ByZWZpeCcsICdzdWZmaXgnLCAnYW5pbWF0ZScsICdwbGF5aW5nJyxcbiAgJ2xvb3AnLCAnZHVyYXRpb24nLCAndG90YWxGcmFtZXMnLCAnZnBzJywgJ3BsYXliYWNrUmF0ZScsICd0aW1lU2NhbGUnLFxuICAnZnJhbWUnLCAndGltZScsICdmbHVzaCcsICdwaXhlbGF0ZWQnLCAnaG90a2V5cycsICdwNScsICdpZCcsXG4gICdzY2FsZVRvRml0UGFkZGluZycsICdkYXRhJywgJ3BhcmFtcycsICdlbmNvZGluZycsICdlbmNvZGluZ1F1YWxpdHknXG5dO1xuXG4vLyBUaGlzIGlzIGZhaXJseSBvcGluaW9uYXRlZCBhbmQgZm9yY2VzIHVzZXJzIHRvIHVzZSB0aGUgJ2RhdGEnIHBhcmFtZXRlclxuLy8gaWYgdGhleSB3YW50IHRvIHBhc3MgYWxvbmcgbm9uLXNldHRpbmcgb2JqZWN0cy4uLlxuZXhwb3J0IGNvbnN0IGNoZWNrU2V0dGluZ3MgPSAoc2V0dGluZ3MpID0+IHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNldHRpbmdzKTtcbiAga2V5cy5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKGtleSBpbiBjb21tb25UeXBvcykge1xuICAgICAgY29uc3QgYWN0dWFsID0gY29tbW9uVHlwb3Nba2V5XTtcbiAgICAgIGNvbnNvbGUud2FybihgW2NhbnZhcy1za2V0Y2hdIENvdWxkIG5vdCByZWNvZ25pemUgdGhlIHNldHRpbmcgXCIke2tleX1cIiwgZGlkIHlvdSBtZWFuIFwiJHthY3R1YWx9XCI/YCk7XG4gICAgfSBlbHNlIGlmICghYWxsS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFtjYW52YXMtc2tldGNoXSBDb3VsZCBub3QgcmVjb2duaXplIHRoZSBzZXR0aW5nIFwiJHtrZXl9XCJgKTtcbiAgICB9XG4gIH0pO1xufTtcbiIsImltcG9ydCB7IGdldENsaWVudEFQSSB9IGZyb20gJy4uL3V0aWwnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAob3B0ID0ge30pIHtcbiAgY29uc3QgaGFuZGxlciA9IGV2ID0+IHtcbiAgICBpZiAoIW9wdC5lbmFibGVkKCkpIHJldHVybjtcblxuICAgIGNvbnN0IGNsaWVudCA9IGdldENsaWVudEFQSSgpO1xuICAgIGlmIChldi5rZXlDb2RlID09PSA4MyAmJiAhZXYuYWx0S2V5ICYmIChldi5tZXRhS2V5IHx8IGV2LmN0cmxLZXkpKSB7XG4gICAgICAvLyBDbWQgKyBTXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgb3B0LnNhdmUoZXYpO1xuICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgIC8vIFNwYWNlXG4gICAgICAvLyBUT0RPOiB3aGF0IHRvIGRvIHdpdGggdGhpcz8ga2VlcCBpdCwgb3IgcmVtb3ZlIGl0P1xuICAgICAgb3B0LnRvZ2dsZVBsYXkoZXYpO1xuICAgIH0gZWxzZSBpZiAoY2xpZW50ICYmICFldi5hbHRLZXkgJiYgZXYua2V5Q29kZSA9PT0gNzUgJiYgKGV2Lm1ldGFLZXkgfHwgZXYuY3RybEtleSkpIHtcbiAgICAgIC8vIENtZCArIEssIG9ubHkgd2hlbiBjYW52YXMtc2tldGNoLWNsaSBpcyB1c2VkXG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgb3B0LmNvbW1pdChldik7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGF0dGFjaCA9ICgpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICB9O1xuXG4gIGNvbnN0IGRldGFjaCA9ICgpID0+IHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpO1xuICB9O1xuXG4gIHJldHVybiB7XG4gICAgYXR0YWNoLFxuICAgIGRldGFjaFxuICB9O1xufVxuIiwiY29uc3QgZGVmYXVsdFVuaXRzID0gJ21tJztcblxuY29uc3QgZGF0YSA9IFtcbiAgLy8gQ29tbW9uIFBhcGVyIFNpemVzXG4gIC8vIChNb3N0bHkgTm9ydGgtQW1lcmljYW4gYmFzZWQpXG4gIFsgJ3Bvc3RjYXJkJywgMTAxLjYsIDE1Mi40IF0sXG4gIFsgJ3Bvc3Rlci1zbWFsbCcsIDI4MCwgNDMwIF0sXG4gIFsgJ3Bvc3RlcicsIDQ2MCwgNjEwIF0sXG4gIFsgJ3Bvc3Rlci1sYXJnZScsIDYxMCwgOTEwIF0sXG4gIFsgJ2J1c2luZXNzLWNhcmQnLCA1MC44LCA4OC45IF0sXG5cbiAgLy8gUGhvdG9ncmFwaGljIFByaW50IFBhcGVyIFNpemVzXG4gIFsgJzJyJywgNjQsIDg5IF0sXG4gIFsgJzNyJywgODksIDEyNyBdLFxuICBbICc0cicsIDEwMiwgMTUyIF0sXG4gIFsgJzVyJywgMTI3LCAxNzggXSwgLy8gNeKAs3g34oCzXG4gIFsgJzZyJywgMTUyLCAyMDMgXSwgLy8gNuKAs3g44oCzXG4gIFsgJzhyJywgMjAzLCAyNTQgXSwgLy8gOOKAs3gxMOKAs1xuICBbICcxMHInLCAyNTQsIDMwNSBdLCAvLyAxMOKAs3gxMuKAs1xuICBbICcxMXInLCAyNzksIDM1NiBdLCAvLyAxMeKAs3gxNOKAs1xuICBbICcxMnInLCAzMDUsIDM4MSBdLFxuXG4gIC8vIFN0YW5kYXJkIFBhcGVyIFNpemVzXG4gIFsgJ2EwJywgODQxLCAxMTg5IF0sXG4gIFsgJ2ExJywgNTk0LCA4NDEgXSxcbiAgWyAnYTInLCA0MjAsIDU5NCBdLFxuICBbICdhMycsIDI5NywgNDIwIF0sXG4gIFsgJ2E0JywgMjEwLCAyOTcgXSxcbiAgWyAnYTUnLCAxNDgsIDIxMCBdLFxuICBbICdhNicsIDEwNSwgMTQ4IF0sXG4gIFsgJ2E3JywgNzQsIDEwNSBdLFxuICBbICdhOCcsIDUyLCA3NCBdLFxuICBbICdhOScsIDM3LCA1MiBdLFxuICBbICdhMTAnLCAyNiwgMzcgXSxcbiAgWyAnMmEwJywgMTE4OSwgMTY4MiBdLFxuICBbICc0YTAnLCAxNjgyLCAyMzc4IF0sXG4gIFsgJ2IwJywgMTAwMCwgMTQxNCBdLFxuICBbICdiMScsIDcwNywgMTAwMCBdLFxuICBbICdiMSsnLCA3MjAsIDEwMjAgXSxcbiAgWyAnYjInLCA1MDAsIDcwNyBdLFxuICBbICdiMisnLCA1MjAsIDcyMCBdLFxuICBbICdiMycsIDM1MywgNTAwIF0sXG4gIFsgJ2I0JywgMjUwLCAzNTMgXSxcbiAgWyAnYjUnLCAxNzYsIDI1MCBdLFxuICBbICdiNicsIDEyNSwgMTc2IF0sXG4gIFsgJ2I3JywgODgsIDEyNSBdLFxuICBbICdiOCcsIDYyLCA4OCBdLFxuICBbICdiOScsIDQ0LCA2MiBdLFxuICBbICdiMTAnLCAzMSwgNDQgXSxcbiAgWyAnYjExJywgMjIsIDMyIF0sXG4gIFsgJ2IxMicsIDE2LCAyMiBdLFxuICBbICdjMCcsIDkxNywgMTI5NyBdLFxuICBbICdjMScsIDY0OCwgOTE3IF0sXG4gIFsgJ2MyJywgNDU4LCA2NDggXSxcbiAgWyAnYzMnLCAzMjQsIDQ1OCBdLFxuICBbICdjNCcsIDIyOSwgMzI0IF0sXG4gIFsgJ2M1JywgMTYyLCAyMjkgXSxcbiAgWyAnYzYnLCAxMTQsIDE2MiBdLFxuICBbICdjNycsIDgxLCAxMTQgXSxcbiAgWyAnYzgnLCA1NywgODEgXSxcbiAgWyAnYzknLCA0MCwgNTcgXSxcbiAgWyAnYzEwJywgMjgsIDQwIF0sXG4gIFsgJ2MxMScsIDIyLCAzMiBdLFxuICBbICdjMTInLCAxNiwgMjIgXSxcblxuICAvLyBVc2UgaW5jaGVzIGZvciBOb3J0aCBBbWVyaWNhbiBzaXplcyxcbiAgLy8gYXMgaXQgcHJvZHVjZXMgbGVzcyBmbG9hdCBwcmVjaXNpb24gZXJyb3JzXG4gIFsgJ2hhbGYtbGV0dGVyJywgNS41LCA4LjUsICdpbicgXSxcbiAgWyAnbGV0dGVyJywgOC41LCAxMSwgJ2luJyBdLFxuICBbICdsZWdhbCcsIDguNSwgMTQsICdpbicgXSxcbiAgWyAnanVuaW9yLWxlZ2FsJywgNSwgOCwgJ2luJyBdLFxuICBbICdsZWRnZXInLCAxMSwgMTcsICdpbicgXSxcbiAgWyAndGFibG9pZCcsIDExLCAxNywgJ2luJyBdLFxuICBbICdhbnNpLWEnLCA4LjUsIDExLjAsICdpbicgXSxcbiAgWyAnYW5zaS1iJywgMTEuMCwgMTcuMCwgJ2luJyBdLFxuICBbICdhbnNpLWMnLCAxNy4wLCAyMi4wLCAnaW4nIF0sXG4gIFsgJ2Fuc2ktZCcsIDIyLjAsIDM0LjAsICdpbicgXSxcbiAgWyAnYW5zaS1lJywgMzQuMCwgNDQuMCwgJ2luJyBdLFxuICBbICdhcmNoLWEnLCA5LCAxMiwgJ2luJyBdLFxuICBbICdhcmNoLWInLCAxMiwgMTgsICdpbicgXSxcbiAgWyAnYXJjaC1jJywgMTgsIDI0LCAnaW4nIF0sXG4gIFsgJ2FyY2gtZCcsIDI0LCAzNiwgJ2luJyBdLFxuICBbICdhcmNoLWUnLCAzNiwgNDgsICdpbicgXSxcbiAgWyAnYXJjaC1lMScsIDMwLCA0MiwgJ2luJyBdLFxuICBbICdhcmNoLWUyJywgMjYsIDM4LCAnaW4nIF0sXG4gIFsgJ2FyY2gtZTMnLCAyNywgMzksICdpbicgXVxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZGF0YS5yZWR1Y2UoKGRpY3QsIHByZXNldCkgPT4ge1xuICBjb25zdCBpdGVtID0ge1xuICAgIHVuaXRzOiBwcmVzZXRbM10gfHwgZGVmYXVsdFVuaXRzLFxuICAgIGRpbWVuc2lvbnM6IFsgcHJlc2V0WzFdLCBwcmVzZXRbMl0gXVxuICB9O1xuICBkaWN0W3ByZXNldFswXV0gPSBpdGVtO1xuICBkaWN0W3ByZXNldFswXS5yZXBsYWNlKC8tL2csICcgJyldID0gaXRlbTtcbiAgcmV0dXJuIGRpY3Q7XG59LCB7fSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYXJndW1lbnRzW2ldICE9PSB1bmRlZmluZWQpIHJldHVybiBhcmd1bWVudHNbaV07XG4gICAgfVxufTtcbiIsInZhciBkZWZpbmVkID0gcmVxdWlyZSgnZGVmaW5lZCcpO1xudmFyIHVuaXRzID0gWyAnbW0nLCAnY20nLCAnbScsICdwYycsICdwdCcsICdpbicsICdmdCcsICdweCcgXTtcblxudmFyIGNvbnZlcnNpb25zID0ge1xuICAvLyBtZXRyaWNcbiAgbToge1xuICAgIHN5c3RlbTogJ21ldHJpYycsXG4gICAgZmFjdG9yOiAxXG4gIH0sXG4gIGNtOiB7XG4gICAgc3lzdGVtOiAnbWV0cmljJyxcbiAgICBmYWN0b3I6IDEgLyAxMDBcbiAgfSxcbiAgbW06IHtcbiAgICBzeXN0ZW06ICdtZXRyaWMnLFxuICAgIGZhY3RvcjogMSAvIDEwMDBcbiAgfSxcbiAgLy8gaW1wZXJpYWxcbiAgcHQ6IHtcbiAgICBzeXN0ZW06ICdpbXBlcmlhbCcsXG4gICAgZmFjdG9yOiAxIC8gNzJcbiAgfSxcbiAgcGM6IHtcbiAgICBzeXN0ZW06ICdpbXBlcmlhbCcsXG4gICAgZmFjdG9yOiAxIC8gNlxuICB9LFxuICBpbjoge1xuICAgIHN5c3RlbTogJ2ltcGVyaWFsJyxcbiAgICBmYWN0b3I6IDFcbiAgfSxcbiAgZnQ6IHtcbiAgICBzeXN0ZW06ICdpbXBlcmlhbCcsXG4gICAgZmFjdG9yOiAxMlxuICB9XG59O1xuXG5jb25zdCBhbmNob3JzID0ge1xuICBtZXRyaWM6IHtcbiAgICB1bml0OiAnbScsXG4gICAgcmF0aW86IDEgLyAwLjAyNTRcbiAgfSxcbiAgaW1wZXJpYWw6IHtcbiAgICB1bml0OiAnaW4nLFxuICAgIHJhdGlvOiAwLjAyNTRcbiAgfVxufTtcblxuZnVuY3Rpb24gcm91bmQgKHZhbHVlLCBkZWNpbWFscykge1xuICByZXR1cm4gTnVtYmVyKE1hdGgucm91bmQodmFsdWUgKyAnZScgKyBkZWNpbWFscykgKyAnZS0nICsgZGVjaW1hbHMpO1xufVxuXG5mdW5jdGlvbiBjb252ZXJ0RGlzdGFuY2UgKHZhbHVlLCBmcm9tVW5pdCwgdG9Vbml0LCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpIHRocm93IG5ldyBFcnJvcignVmFsdWUgbXVzdCBiZSBhIGZpbml0ZSBudW1iZXInKTtcbiAgaWYgKCFmcm9tVW5pdCB8fCAhdG9Vbml0KSB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBmcm9tIGFuZCB0byB1bml0cycpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB2YXIgcGl4ZWxzUGVySW5jaCA9IGRlZmluZWQob3B0cy5waXhlbHNQZXJJbmNoLCA5Nik7XG4gIHZhciBwcmVjaXNpb24gPSBvcHRzLnByZWNpc2lvbjtcbiAgdmFyIHJvdW5kUGl4ZWwgPSBvcHRzLnJvdW5kUGl4ZWwgIT09IGZhbHNlO1xuXG4gIGZyb21Vbml0ID0gZnJvbVVuaXQudG9Mb3dlckNhc2UoKTtcbiAgdG9Vbml0ID0gdG9Vbml0LnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKHVuaXRzLmluZGV4T2YoZnJvbVVuaXQpID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZyb20gdW5pdCBcIicgKyBmcm9tVW5pdCArICdcIiwgbXVzdCBiZSBvbmUgb2Y6ICcgKyB1bml0cy5qb2luKCcsICcpKTtcbiAgaWYgKHVuaXRzLmluZGV4T2YodG9Vbml0KSA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmcm9tIHVuaXQgXCInICsgdG9Vbml0ICsgJ1wiLCBtdXN0IGJlIG9uZSBvZjogJyArIHVuaXRzLmpvaW4oJywgJykpO1xuXG4gIGlmIChmcm9tVW5pdCA9PT0gdG9Vbml0KSB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBjb252ZXJ0IGZyb20gQSB0byBCIHNpbmNlIHRoZXkgYXJlIHRoZSBzYW1lIGFscmVhZHlcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICB2YXIgdG9GYWN0b3IgPSAxO1xuICB2YXIgZnJvbUZhY3RvciA9IDE7XG4gIHZhciBpc1RvUGl4ZWwgPSBmYWxzZTtcblxuICBpZiAoZnJvbVVuaXQgPT09ICdweCcpIHtcbiAgICBmcm9tRmFjdG9yID0gMSAvIHBpeGVsc1BlckluY2g7XG4gICAgZnJvbVVuaXQgPSAnaW4nO1xuICB9XG4gIGlmICh0b1VuaXQgPT09ICdweCcpIHtcbiAgICBpc1RvUGl4ZWwgPSB0cnVlO1xuICAgIHRvRmFjdG9yID0gcGl4ZWxzUGVySW5jaDtcbiAgICB0b1VuaXQgPSAnaW4nO1xuICB9XG5cbiAgdmFyIGZyb21Vbml0RGF0YSA9IGNvbnZlcnNpb25zW2Zyb21Vbml0XTtcbiAgdmFyIHRvVW5pdERhdGEgPSBjb252ZXJzaW9uc1t0b1VuaXRdO1xuXG4gIC8vIHNvdXJjZSB0byBhbmNob3IgaW5zaWRlIHNvdXJjZSdzIHN5c3RlbVxuICB2YXIgYW5jaG9yID0gdmFsdWUgKiBmcm9tVW5pdERhdGEuZmFjdG9yICogZnJvbUZhY3RvcjtcblxuICAvLyBpZiBzeXN0ZW1zIGRpZmZlciwgY29udmVydCBvbmUgdG8gYW5vdGhlclxuICBpZiAoZnJvbVVuaXREYXRhLnN5c3RlbSAhPT0gdG9Vbml0RGF0YS5zeXN0ZW0pIHtcbiAgICAvLyByZWd1bGFyICdtJyB0byAnaW4nIGFuZCBzbyBmb3J0aFxuICAgIGFuY2hvciAqPSBhbmNob3JzW2Zyb21Vbml0RGF0YS5zeXN0ZW1dLnJhdGlvO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IGFuY2hvciAvIHRvVW5pdERhdGEuZmFjdG9yICogdG9GYWN0b3I7XG4gIGlmIChpc1RvUGl4ZWwgJiYgcm91bmRQaXhlbCkge1xuICAgIHJlc3VsdCA9IE1hdGgucm91bmQocmVzdWx0KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJlY2lzaW9uID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShwcmVjaXNpb24pKSB7XG4gICAgcmVzdWx0ID0gcm91bmQocmVzdWx0LCBwcmVjaXNpb24pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydERpc3RhbmNlO1xubW9kdWxlLmV4cG9ydHMudW5pdHMgPSB1bml0cztcbiIsImltcG9ydCBwYXBlclNpemVzIGZyb20gJy4vcGFwZXItc2l6ZXMnO1xuaW1wb3J0IGNvbnZlcnRMZW5ndGggZnJvbSAnY29udmVydC1sZW5ndGgnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGltZW5zaW9uc0Zyb21QcmVzZXQgKGRpbWVuc2lvbnMsIHVuaXRzVG8gPSAncHgnLCBwaXhlbHNQZXJJbmNoID0gNzIpIHtcbiAgaWYgKHR5cGVvZiBkaW1lbnNpb25zID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGtleSA9IGRpbWVuc2lvbnMudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoIShrZXkgaW4gcGFwZXJTaXplcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGRpbWVuc2lvbiBwcmVzZXQgXCIke2RpbWVuc2lvbnN9XCIgaXMgbm90IHN1cHBvcnRlZCBvciBjb3VsZCBub3QgYmUgZm91bmQ7IHRyeSB1c2luZyBhNCwgYTMsIHBvc3RjYXJkLCBsZXR0ZXIsIGV0Yy5gKVxuICAgIH1cbiAgICBjb25zdCBwcmVzZXQgPSBwYXBlclNpemVzW2tleV07XG4gICAgcmV0dXJuIHByZXNldC5kaW1lbnNpb25zLm1hcChkID0+IHtcbiAgICAgIHJldHVybiBjb252ZXJ0RGlzdGFuY2UoZCwgcHJlc2V0LnVuaXRzLCB1bml0c1RvLCBwaXhlbHNQZXJJbmNoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydERpc3RhbmNlIChkaW1lbnNpb24sIHVuaXRzRnJvbSA9ICdweCcsIHVuaXRzVG8gPSAncHgnLCBwaXhlbHNQZXJJbmNoID0gNzIpIHtcbiAgcmV0dXJuIGNvbnZlcnRMZW5ndGgoZGltZW5zaW9uLCB1bml0c0Zyb20sIHVuaXRzVG8sIHtcbiAgICBwaXhlbHNQZXJJbmNoLFxuICAgIHByZWNpc2lvbjogNCxcbiAgICByb3VuZFBpeGVsOiB0cnVlXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgZ2V0RGltZW5zaW9uc0Zyb21QcmVzZXQsIGNvbnZlcnREaXN0YW5jZSB9IGZyb20gJy4uL2Rpc3RhbmNlcyc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIsIGRlZmluZWQgfSBmcm9tICcuLi91dGlsJztcblxuZnVuY3Rpb24gY2hlY2tJZkhhc0RpbWVuc2lvbnMgKHNldHRpbmdzKSB7XG4gIGlmICghc2V0dGluZ3MuZGltZW5zaW9ucykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHNldHRpbmdzLmRpbWVuc2lvbnMgPT09ICdzdHJpbmcnKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2V0dGluZ3MuZGltZW5zaW9ucykgJiYgc2V0dGluZ3MuZGltZW5zaW9ucy5sZW5ndGggPj0gMikgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFyZW50U2l6ZSAocHJvcHMsIHNldHRpbmdzKSB7XG4gIC8vIFdoZW4gbm8geyBkaW1lbnNpb24gfSBpcyBwYXNzZWQgaW4gbm9kZSwgd2UgZGVmYXVsdCB0byBIVE1MIGNhbnZhcyBzaXplXG4gIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICByZXR1cm4gWyAzMDAsIDE1MCBdO1xuICB9XG5cbiAgbGV0IGVsZW1lbnQgPSBzZXR0aW5ncy5wYXJlbnQgfHwgd2luZG93O1xuXG4gIGlmIChlbGVtZW50ID09PSB3aW5kb3cgfHxcbiAgICAgIGVsZW1lbnQgPT09IGRvY3VtZW50IHx8XG4gICAgICBlbGVtZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIFsgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCBdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gWyB3aWR0aCwgaGVpZ2h0IF07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVzaXplQ2FudmFzIChwcm9wcywgc2V0dGluZ3MpIHtcbiAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gIGxldCBzdHlsZVdpZHRoLCBzdHlsZUhlaWdodDtcbiAgbGV0IGNhbnZhc1dpZHRoLCBjYW52YXNIZWlnaHQ7XG5cbiAgY29uc3QgYnJvd3NlciA9IGlzQnJvd3NlcigpO1xuICBjb25zdCBkaW1lbnNpb25zID0gc2V0dGluZ3MuZGltZW5zaW9ucztcbiAgY29uc3QgaGFzRGltZW5zaW9ucyA9IGNoZWNrSWZIYXNEaW1lbnNpb25zKHNldHRpbmdzKTtcbiAgY29uc3QgZXhwb3J0aW5nID0gcHJvcHMuZXhwb3J0aW5nO1xuICBsZXQgc2NhbGVUb0ZpdCA9IGhhc0RpbWVuc2lvbnMgPyBzZXR0aW5ncy5zY2FsZVRvRml0ICE9PSBmYWxzZSA6IGZhbHNlO1xuICBsZXQgc2NhbGVUb1ZpZXcgPSAoIWV4cG9ydGluZyAmJiBoYXNEaW1lbnNpb25zKSA/IHNldHRpbmdzLnNjYWxlVG9WaWV3IDogdHJ1ZTtcbiAgLy8gaW4gbm9kZSwgY2FuY2VsIGJvdGggb2YgdGhlc2Ugb3B0aW9uc1xuICBpZiAoIWJyb3dzZXIpIHNjYWxlVG9GaXQgPSBzY2FsZVRvVmlldyA9IGZhbHNlO1xuICBjb25zdCB1bml0cyA9IHNldHRpbmdzLnVuaXRzO1xuICBjb25zdCBwaXhlbHNQZXJJbmNoID0gKHR5cGVvZiBzZXR0aW5ncy5waXhlbHNQZXJJbmNoID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzZXR0aW5ncy5waXhlbHNQZXJJbmNoKSkgPyBzZXR0aW5ncy5waXhlbHNQZXJJbmNoIDogNzI7XG4gIGNvbnN0IGJsZWVkID0gZGVmaW5lZChzZXR0aW5ncy5ibGVlZCwgMCk7XG5cbiAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGJyb3dzZXIgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG4gIGNvbnN0IGJhc2VQaXhlbFJhdGlvID0gc2NhbGVUb1ZpZXcgPyBkZXZpY2VQaXhlbFJhdGlvIDogMTtcblxuICBsZXQgcGl4ZWxSYXRpbywgZXhwb3J0UGl4ZWxSYXRpbztcblxuICAvLyBJZiBhIHBpeGVsIHJhdGlvIGlzIHNwZWNpZmllZCwgd2Ugd2lsbCB1c2UgaXQuXG4gIC8vIE90aGVyd2lzZTpcbiAgLy8gIC0+IElmIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQsIHVzZSBiYXNlIHJhdGlvIChpLmUuIHNpemUgZm9yIGV4cG9ydClcbiAgLy8gIC0+IElmIG5vIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQsIHVzZSBkZXZpY2UgcmF0aW8gKGkuZS4gc2l6ZSBmb3Igc2NyZWVuKVxuICBpZiAodHlwZW9mIHNldHRpbmdzLnBpeGVsUmF0aW8gPT09ICdudW1iZXInICYmIGlzRmluaXRlKHNldHRpbmdzLnBpeGVsUmF0aW8pKSB7XG4gICAgLy8gV2hlbiB7IHBpeGVsUmF0aW8gfSBpcyBzcGVjaWZpZWQsIGl0J3MgYWxzbyB1c2VkIGFzIGRlZmF1bHQgZXhwb3J0UGl4ZWxSYXRpby5cbiAgICBwaXhlbFJhdGlvID0gc2V0dGluZ3MucGl4ZWxSYXRpbztcbiAgICBleHBvcnRQaXhlbFJhdGlvID0gZGVmaW5lZChzZXR0aW5ncy5leHBvcnRQaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaGFzRGltZW5zaW9ucykge1xuICAgICAgLy8gV2hlbiBhIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQsIHVzZSB0aGUgYmFzZSByYXRpbyByYXRoZXIgdGhhbiBzY3JlZW4gcmF0aW9cbiAgICAgIHBpeGVsUmF0aW8gPSBiYXNlUGl4ZWxSYXRpbztcbiAgICAgIC8vIERlZmF1bHQgdG8gYSBwaXhlbCByYXRpbyBvZiAxIHNvIHRoYXQgeW91IGVuZCB1cCB3aXRoIHRoZSBzYW1lIGRpbWVuc2lvblxuICAgICAgLy8geW91IHNwZWNpZmllZCwgaS5lLiBbIDUwMCwgNTAwIF0gaXMgZXhwb3J0ZWQgYXMgNTAweDUwMCBweFxuICAgICAgZXhwb3J0UGl4ZWxSYXRpbyA9IGRlZmluZWQoc2V0dGluZ3MuZXhwb3J0UGl4ZWxSYXRpbywgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGRpbWVuc2lvbiBpcyBzcGVjaWZpZWQsIGFzc3VtZSBmdWxsLXNjcmVlbiByZXRpbmEgc2l6aW5nXG4gICAgICBwaXhlbFJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgIC8vIERlZmF1bHQgdG8gc2NyZWVuIHBpeGVsIHJhdGlvLCBzbyB0aGF0IGl0J3MgbGlrZSB0YWtpbmcgYSBkZXZpY2Ugc2NyZWVuc2hvdFxuICAgICAgZXhwb3J0UGl4ZWxSYXRpbyA9IGRlZmluZWQoc2V0dGluZ3MuZXhwb3J0UGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xhbXAgcGl4ZWwgcmF0aW9cbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5tYXhQaXhlbFJhdGlvID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzZXR0aW5ncy5tYXhQaXhlbFJhdGlvKSkge1xuICAgIHBpeGVsUmF0aW8gPSBNYXRoLm1pbihzZXR0aW5ncy5tYXhQaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcbiAgfVxuXG4gIC8vIEhhbmRsZSBleHBvcnQgcGl4ZWwgcmF0aW9cbiAgaWYgKGV4cG9ydGluZykge1xuICAgIHBpeGVsUmF0aW8gPSBleHBvcnRQaXhlbFJhdGlvO1xuICB9XG5cbiAgLy8gcGFyZW50V2lkdGggPSB0eXBlb2YgcGFyZW50V2lkdGggPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdE5vZGVTaXplWzBdIDogcGFyZW50V2lkdGg7XG4gIC8vIHBhcmVudEhlaWdodCA9IHR5cGVvZiBwYXJlbnRIZWlnaHQgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdE5vZGVTaXplWzFdIDogcGFyZW50SGVpZ2h0O1xuXG4gIGxldCBbIHBhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHQgXSA9IGdldFBhcmVudFNpemUocHJvcHMsIHNldHRpbmdzKTtcbiAgbGV0IHRyaW1XaWR0aCwgdHJpbUhlaWdodDtcblxuICAvLyBZb3UgY2FuIHNwZWNpZnkgYSBkaW1lbnNpb25zIGluIHBpeGVscyBvciBjbS9tL2luL2V0Y1xuICBpZiAoaGFzRGltZW5zaW9ucykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGdldERpbWVuc2lvbnNGcm9tUHJlc2V0KGRpbWVuc2lvbnMsIHVuaXRzLCBwaXhlbHNQZXJJbmNoKTtcbiAgICBjb25zdCBoaWdoZXN0ID0gTWF0aC5tYXgocmVzdWx0WzBdLCByZXN1bHRbMV0pO1xuICAgIGNvbnN0IGxvd2VzdCA9IE1hdGgubWluKHJlc3VsdFswXSwgcmVzdWx0WzFdKTtcbiAgICBpZiAoc2V0dGluZ3Mub3JpZW50YXRpb24pIHtcbiAgICAgIGNvbnN0IGxhbmRzY2FwZSA9IHNldHRpbmdzLm9yaWVudGF0aW9uID09PSAnbGFuZHNjYXBlJztcbiAgICAgIHdpZHRoID0gbGFuZHNjYXBlID8gaGlnaGVzdCA6IGxvd2VzdDtcbiAgICAgIGhlaWdodCA9IGxhbmRzY2FwZSA/IGxvd2VzdCA6IGhpZ2hlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gcmVzdWx0WzBdO1xuICAgICAgaGVpZ2h0ID0gcmVzdWx0WzFdO1xuICAgIH1cblxuICAgIHRyaW1XaWR0aCA9IHdpZHRoO1xuICAgIHRyaW1IZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvLyBBcHBseSBibGVlZCB3aGljaCBpcyBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHVuaXRzXG4gICAgd2lkdGggKz0gYmxlZWQgKiAyO1xuICAgIGhlaWdodCArPSBibGVlZCAqIDI7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBwYXJlbnRXaWR0aDtcbiAgICBoZWlnaHQgPSBwYXJlbnRIZWlnaHQ7XG4gICAgdHJpbVdpZHRoID0gd2lkdGg7XG4gICAgdHJpbUhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIC8vIFJlYWwgc2l6ZSBpbiBwaXhlbHMgYWZ0ZXIgUFBJIGlzIHRha2VuIGludG8gYWNjb3VudFxuICBsZXQgcmVhbFdpZHRoID0gd2lkdGg7XG4gIGxldCByZWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICBpZiAoaGFzRGltZW5zaW9ucyAmJiB1bml0cykge1xuICAgIC8vIENvbnZlcnQgdG8gZGlnaXRhbC9waXhlbCB1bml0cyBpZiBuZWNlc3NhcnlcbiAgICByZWFsV2lkdGggPSBjb252ZXJ0RGlzdGFuY2Uod2lkdGgsIHVuaXRzLCAncHgnLCBwaXhlbHNQZXJJbmNoKTtcbiAgICByZWFsSGVpZ2h0ID0gY29udmVydERpc3RhbmNlKGhlaWdodCwgdW5pdHMsICdweCcsIHBpeGVsc1BlckluY2gpO1xuICB9XG5cbiAgLy8gSG93IGJpZyB0byBzZXQgdGhlICd2aWV3JyBvZiB0aGUgY2FudmFzIGluIHRoZSBicm93c2VyIChpLmUuIHN0eWxlKVxuICBzdHlsZVdpZHRoID0gTWF0aC5yb3VuZChyZWFsV2lkdGgpO1xuICBzdHlsZUhlaWdodCA9IE1hdGgucm91bmQocmVhbEhlaWdodCk7XG5cbiAgLy8gSWYgd2Ugd2lzaCB0byBzY2FsZSB0aGUgdmlldyB0byB0aGUgYnJvd3NlciB3aW5kb3dcbiAgaWYgKHNjYWxlVG9GaXQgJiYgIWV4cG9ydGluZyAmJiBoYXNEaW1lbnNpb25zKSB7XG4gICAgY29uc3QgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgY29uc3Qgd2luZG93QXNwZWN0ID0gcGFyZW50V2lkdGggLyBwYXJlbnRIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVUb0ZpdFBhZGRpbmcgPSBkZWZpbmVkKHNldHRpbmdzLnNjYWxlVG9GaXRQYWRkaW5nLCA0MCk7XG4gICAgY29uc3QgbWF4V2lkdGggPSBNYXRoLnJvdW5kKHBhcmVudFdpZHRoIC0gc2NhbGVUb0ZpdFBhZGRpbmcgKiAyKTtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLnJvdW5kKHBhcmVudEhlaWdodCAtIHNjYWxlVG9GaXRQYWRkaW5nICogMik7XG4gICAgaWYgKHN0eWxlV2lkdGggPiBtYXhXaWR0aCB8fCBzdHlsZUhlaWdodCA+IG1heEhlaWdodCkge1xuICAgICAgaWYgKHdpbmRvd0FzcGVjdCA+IGFzcGVjdCkge1xuICAgICAgICBzdHlsZUhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgc3R5bGVXaWR0aCA9IE1hdGgucm91bmQoc3R5bGVIZWlnaHQgKiBhc3BlY3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGVXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICBzdHlsZUhlaWdodCA9IE1hdGgucm91bmQoc3R5bGVXaWR0aCAvIGFzcGVjdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2FudmFzV2lkdGggPSBzY2FsZVRvVmlldyA/IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHN0eWxlV2lkdGgpIDogTWF0aC5yb3VuZChwaXhlbFJhdGlvICogcmVhbFdpZHRoKTtcbiAgY2FudmFzSGVpZ2h0ID0gc2NhbGVUb1ZpZXcgPyBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzdHlsZUhlaWdodCkgOiBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiByZWFsSGVpZ2h0KTtcblxuICBjb25zdCB2aWV3cG9ydFdpZHRoID0gc2NhbGVUb1ZpZXcgPyBNYXRoLnJvdW5kKHN0eWxlV2lkdGgpIDogTWF0aC5yb3VuZChyZWFsV2lkdGgpO1xuICBjb25zdCB2aWV3cG9ydEhlaWdodCA9IHNjYWxlVG9WaWV3ID8gTWF0aC5yb3VuZChzdHlsZUhlaWdodCkgOiBNYXRoLnJvdW5kKHJlYWxIZWlnaHQpO1xuXG4gIGNvbnN0IHNjYWxlWCA9IGNhbnZhc1dpZHRoIC8gd2lkdGg7XG4gIGNvbnN0IHNjYWxlWSA9IGNhbnZhc0hlaWdodCAvIGhlaWdodDtcblxuICAvLyBBc3NpZ24gdG8gY3VycmVudCBwcm9wc1xuICByZXR1cm4ge1xuICAgIGJsZWVkLFxuICAgIHBpeGVsUmF0aW8sXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGRpbWVuc2lvbnM6IFsgd2lkdGgsIGhlaWdodCBdLFxuICAgIHVuaXRzOiB1bml0cyB8fCAncHgnLFxuICAgIHNjYWxlWCxcbiAgICBzY2FsZVksXG4gICAgcGl4ZWxzUGVySW5jaCxcbiAgICB2aWV3cG9ydFdpZHRoLFxuICAgIHZpZXdwb3J0SGVpZ2h0LFxuICAgIGNhbnZhc1dpZHRoLFxuICAgIGNhbnZhc0hlaWdodCxcbiAgICB0cmltV2lkdGgsXG4gICAgdHJpbUhlaWdodCxcbiAgICBzdHlsZVdpZHRoLFxuICAgIHN0eWxlSGVpZ2h0XG4gIH07XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGdldENhbnZhc0NvbnRleHRcbmZ1bmN0aW9uIGdldENhbnZhc0NvbnRleHQgKHR5cGUsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3BlY2lmeSB0eXBlIHN0cmluZycpXG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnICYmICFvcHRzLmNhbnZhcykge1xuICAgIHJldHVybiBudWxsIC8vIGNoZWNrIGZvciBOb2RlXG4gIH1cblxuICB2YXIgY2FudmFzID0gb3B0cy5jYW52YXMgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgaWYgKHR5cGVvZiBvcHRzLndpZHRoID09PSAnbnVtYmVyJykge1xuICAgIGNhbnZhcy53aWR0aCA9IG9wdHMud2lkdGhcbiAgfVxuICBpZiAodHlwZW9mIG9wdHMuaGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgIGNhbnZhcy5oZWlnaHQgPSBvcHRzLmhlaWdodFxuICB9XG5cbiAgdmFyIGF0dHJpYnMgPSBvcHRzXG4gIHZhciBnbFxuICB0cnkge1xuICAgIHZhciBuYW1lcyA9IFsgdHlwZSBdXG4gICAgLy8gcHJlZml4IEdMIGNvbnRleHRzXG4gICAgaWYgKHR5cGUuaW5kZXhPZignd2ViZ2wnKSA9PT0gMCkge1xuICAgICAgbmFtZXMucHVzaCgnZXhwZXJpbWVudGFsLScgKyB0eXBlKVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQobmFtZXNbaV0sIGF0dHJpYnMpXG4gICAgICBpZiAoZ2wpIHJldHVybiBnbFxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGdsID0gbnVsbFxuICB9XG4gIHJldHVybiAoZ2wgfHwgbnVsbCkgLy8gZW5zdXJlIG51bGwgb24gZmFpbFxufVxuIiwiaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QtYXNzaWduJztcbmltcG9ydCBnZXRDYW52YXNDb250ZXh0IGZyb20gJ2dldC1jYW52YXMtY29udGV4dCc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuLi91dGlsJztcblxuZnVuY3Rpb24gY3JlYXRlQ2FudmFzRWxlbWVudCAoKSB7XG4gIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0l0IGFwcGVhcnMgeW91IGFyZSBydW5pbmcgZnJvbSBOb2RlLmpzIG9yIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnQuIFRyeSBwYXNzaW5nIGluIGFuIGV4aXN0aW5nIHsgY2FudmFzIH0gaW50ZXJmYWNlIGluc3RlYWQuJyk7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVDYW52YXMgKHNldHRpbmdzID0ge30pIHtcbiAgbGV0IGNvbnRleHQsIGNhbnZhcztcbiAgbGV0IG93bnNDYW52YXMgPSBmYWxzZTtcbiAgaWYgKHNldHRpbmdzLmNhbnZhcyAhPT0gZmFsc2UpIHtcbiAgICAvLyBEZXRlcm1pbmUgdGhlIGNhbnZhcyBhbmQgY29udGV4dCB0byBjcmVhdGVcbiAgICBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dDtcbiAgICBpZiAoIWNvbnRleHQgfHwgdHlwZW9mIGNvbnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBsZXQgbmV3Q2FudmFzID0gc2V0dGluZ3MuY2FudmFzO1xuICAgICAgaWYgKCFuZXdDYW52YXMpIHtcbiAgICAgICAgbmV3Q2FudmFzID0gY3JlYXRlQ2FudmFzRWxlbWVudCgpO1xuICAgICAgICBvd25zQ2FudmFzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHR5cGUgPSBjb250ZXh0IHx8ICcyZCc7XG4gICAgICBpZiAodHlwZW9mIG5ld0NhbnZhcy5nZXRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNwZWNpZmllZCB7IGNhbnZhcyB9IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhIGdldENvbnRleHQoKSBmdW5jdGlvbiwgbWF5YmUgaXQgaXMgbm90IGEgPGNhbnZhcz4gdGFnP2ApO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IGdldENhbnZhc0NvbnRleHQodHlwZSwgYXNzaWduKHt9LCBzZXR0aW5ncy5hdHRyaWJ1dGVzLCB7IGNhbnZhczogbmV3Q2FudmFzIH0pKTtcbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCBhdCBjYW52YXMuZ2V0Q29udGV4dCgnJHt0eXBlfScpIC0gdGhlIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IHRoaXMgY29udGV4dCwgb3IgYSBkaWZmZXJlbnQgY29udGV4dCBtYXkgYWxyZWFkeSBiZSBpbiB1c2Ugd2l0aCB0aGlzIGNhbnZhcy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAvLyBFbnN1cmUgY29udGV4dCBtYXRjaGVzIHVzZXIncyBjYW52YXMgZXhwZWN0YXRpb25zXG4gICAgaWYgKHNldHRpbmdzLmNhbnZhcyAmJiBjYW52YXMgIT09IHNldHRpbmdzLmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgeyBjYW52YXMgfSBhbmQgeyBjb250ZXh0IH0gc2V0dGluZ3MgbXVzdCBwb2ludCB0byB0aGUgc2FtZSB1bmRlcmx5aW5nIGNhbnZhcyBlbGVtZW50Jyk7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgcGl4ZWxhdGlvbiB0byBjYW52YXMgaWYgbmVjZXNzYXJ5LCB0aGlzIGlzIG1vc3RseSBhIGNvbnZlbmllbmNlIHV0aWxpdHlcbiAgICBpZiAoc2V0dGluZ3MucGl4ZWxhdGVkKSB7XG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dC5tb3pJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQub0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgY29udGV4dC53ZWJraXRJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQubXNJbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNhbnZhcy5zdHlsZVsnaW1hZ2UtcmVuZGVyaW5nJ10gPSAncGl4ZWxhdGVkJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0LCBvd25zQ2FudmFzIH07XG59XG4iLCJpbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuaW1wb3J0IHJpZ2h0Tm93IGZyb20gJ3JpZ2h0LW5vdyc7XG5pbXBvcnQgaXNQcm9taXNlIGZyb20gJ2lzLXByb21pc2UnO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBkZWZpbmVkLCBpc1dlYkdMQ29udGV4dCwgaXNDYW52YXMsIGdldENsaWVudEFQSSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IGRlZXBFcXVhbCBmcm9tICdkZWVwLWVxdWFsJztcbmltcG9ydCB7XG4gIHJlc29sdmVGaWxlbmFtZSxcbiAgc2F2ZUZpbGUsXG4gIHNhdmVEYXRhVVJMLFxuICBnZXRUaW1lU3RhbXAsXG4gIGV4cG9ydENhbnZhcyxcbiAgc3RyZWFtU3RhcnQsXG4gIHN0cmVhbUVuZFxufSBmcm9tICcuLi9zYXZlJztcbmltcG9ydCB7IGNoZWNrU2V0dGluZ3MgfSBmcm9tICcuLi9hY2Nlc3NpYmlsaXR5JztcblxuaW1wb3J0IGtleWJvYXJkU2hvcnRjdXRzIGZyb20gJy4va2V5Ym9hcmRTaG9ydGN1dHMnO1xuaW1wb3J0IHJlc2l6ZUNhbnZhcyBmcm9tICcuL3Jlc2l6ZUNhbnZhcyc7XG5pbXBvcnQgY3JlYXRlQ2FudmFzIGZyb20gJy4vY3JlYXRlQ2FudmFzJztcblxuY2xhc3MgU2tldGNoTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLl9zZXR0aW5ncyA9IHt9O1xuICAgIHRoaXMuX3Byb3BzID0ge307XG4gICAgdGhpcy5fc2tldGNoID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3JhZiA9IG51bGw7XG4gICAgdGhpcy5fcmVjb3JkVGltZW91dCA9IG51bGw7XG5cbiAgICAvLyBTb21lIGhhY2t5IHRoaW5ncyByZXF1aXJlZCB0byBnZXQgYXJvdW5kIHA1LmpzIHN0cnVjdHVyZVxuICAgIHRoaXMuX2xhc3RSZWRyYXdSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5faXNQNVJlc2l6aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLl9rZXlib2FyZFNob3J0Y3V0cyA9IGtleWJvYXJkU2hvcnRjdXRzKHtcbiAgICAgIGVuYWJsZWQ6ICgpID0+IHRoaXMuc2V0dGluZ3MuaG90a2V5cyAhPT0gZmFsc2UsXG4gICAgICBzYXZlOiAoZXYpID0+IHtcbiAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMucmVjb3JkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmVuZFJlY29yZCgpO1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgICB9IGVsc2UgdGhpcy5yZWNvcmQoKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5wcm9wcy5yZWNvcmRpbmcpIHtcbiAgICAgICAgICB0aGlzLmV4cG9ydEZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0b2dnbGVQbGF5OiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLnBsYXlpbmcpIHRoaXMucGF1c2UoKTtcbiAgICAgICAgZWxzZSB0aGlzLnBsYXkoKTtcbiAgICAgIH0sXG4gICAgICBjb21taXQ6IChldikgPT4ge1xuICAgICAgICB0aGlzLmV4cG9ydEZyYW1lKHsgY29tbWl0OiB0cnVlIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5fYW5pbWF0ZUhhbmRsZXIgPSAoKSA9PiB0aGlzLmFuaW1hdGUoKTtcblxuICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5yZXNpemUoKTtcbiAgICAgIC8vIE9ubHkgcmUtcmVuZGVyIHdoZW4gc2l6ZSBhY3R1YWxseSBjaGFuZ2VzXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBnZXQgc2tldGNoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2tldGNoO1xuICB9XG5cbiAgZ2V0IHNldHRpbmdzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2V0dGluZ3M7XG4gIH1cblxuICBnZXQgcHJvcHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9wcztcbiAgfVxuXG4gIF9jb21wdXRlUGxheWhlYWQgKGN1cnJlbnRUaW1lLCBkdXJhdGlvbikge1xuICAgIGNvbnN0IGhhc0R1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShkdXJhdGlvbik7XG4gICAgcmV0dXJuIGhhc0R1cmF0aW9uID8gY3VycmVudFRpbWUgLyBkdXJhdGlvbiA6IDA7XG4gIH1cblxuICBfY29tcHV0ZUZyYW1lIChwbGF5aGVhZCwgdGltZSwgdG90YWxGcmFtZXMsIGZwcykge1xuICAgIHJldHVybiAoaXNGaW5pdGUodG90YWxGcmFtZXMpICYmIHRvdGFsRnJhbWVzID4gMSlcbiAgICAgID8gTWF0aC5mbG9vcihwbGF5aGVhZCAqICh0b3RhbEZyYW1lcyAtIDEpKVxuICAgICAgOiBNYXRoLmZsb29yKGZwcyAqIHRpbWUpO1xuICB9XG5cbiAgX2NvbXB1dGVDdXJyZW50RnJhbWUgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21wdXRlRnJhbWUoXG4gICAgICB0aGlzLnByb3BzLnBsYXloZWFkLCB0aGlzLnByb3BzLnRpbWUsXG4gICAgICB0aGlzLnByb3BzLnRvdGFsRnJhbWVzLCB0aGlzLnByb3BzLmZwc1xuICAgICk7XG4gIH1cblxuICBfZ2V0U2l6ZVByb3BzICgpIHtcbiAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBwcm9wcy53aWR0aCxcbiAgICAgIGhlaWdodDogcHJvcHMuaGVpZ2h0LFxuICAgICAgcGl4ZWxSYXRpbzogcHJvcHMucGl4ZWxSYXRpbyxcbiAgICAgIGNhbnZhc1dpZHRoOiBwcm9wcy5jYW52YXNXaWR0aCxcbiAgICAgIGNhbnZhc0hlaWdodDogcHJvcHMuY2FudmFzSGVpZ2h0LFxuICAgICAgdmlld3BvcnRXaWR0aDogcHJvcHMudmlld3BvcnRXaWR0aCxcbiAgICAgIHZpZXdwb3J0SGVpZ2h0OiBwcm9wcy52aWV3cG9ydEhlaWdodFxuICAgIH07XG4gIH1cblxuICBydW4gKCkge1xuICAgIGlmICghdGhpcy5za2V0Y2gpIHRocm93IG5ldyBFcnJvcignc2hvdWxkIHdhaXQgdW50aWwgc2tldGNoIGlzIGxvYWRlZCBiZWZvcmUgdHJ5aW5nIHRvIHBsYXkoKScpO1xuXG4gICAgLy8gU3RhcnQgYW4gYW5pbWF0aW9uIGZyYW1lIGxvb3AgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucGxheWluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucGxheSgpO1xuICAgIH1cblxuICAgIC8vIExldCdzIGxldCB0aGlzIHdhcm5pbmcgaGFuZyBhcm91bmQgZm9yIGEgZmV3IHZlcnNpb25zLi4uXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNrZXRjaC5kaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0luIGNhbnZhcy1za2V0Y2hAMC4wLjIzIHRoZSBkaXNwb3NlKCkgZXZlbnQgaGFzIGJlZW4gcmVuYW1lZCB0byB1bmxvYWQoKScpO1xuICAgIH1cblxuICAgIC8vIEluIGNhc2Ugd2UgYXJlbid0IHBsYXlpbmcgb3IgYW5pbWF0ZWQsIG1ha2Ugc3VyZSB3ZSBzdGlsbCB0cmlnZ2VyIGJlZ2luIG1lc3NhZ2UuLi5cbiAgICBpZiAoIXRoaXMucHJvcHMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fc2lnbmFsQmVnaW4oKTtcbiAgICAgIHRoaXMucHJvcHMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gUmVuZGVyIGFuIGluaXRpYWwgZnJhbWVcbiAgICB0aGlzLnRpY2soKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2NhbmNlbFRpbWVvdXRzICgpIHtcbiAgICBpZiAodGhpcy5fcmFmICE9IG51bGwgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZik7XG4gICAgICB0aGlzLl9yYWYgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVjb3JkVGltZW91dCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVjb3JkVGltZW91dCk7XG4gICAgICB0aGlzLl9yZWNvcmRUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwbGF5ICgpIHtcbiAgICBsZXQgYW5pbWF0ZSA9IHRoaXMuc2V0dGluZ3MuYW5pbWF0ZTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gdGhpcy5zZXR0aW5ncykge1xuICAgICAgYW5pbWF0ZSA9IHRydWU7XG4gICAgICBjb25zb2xlLndhcm4oJ1tjYW52YXMtc2tldGNoXSB7IGFuaW1hdGlvbiB9IGhhcyBiZWVuIHJlbmFtZWQgdG8geyBhbmltYXRlIH0nKTtcbiAgICB9XG4gICAgaWYgKCFhbmltYXRlKSByZXR1cm47XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgY29uc29sZS5lcnJvcignW2NhbnZhcy1za2V0Y2hdIFdBUk46IFVzaW5nIHsgYW5pbWF0ZSB9IGluIE5vZGUuanMgaXMgbm90IHlldCBzdXBwb3J0ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcHMucGxheWluZykgcmV0dXJuO1xuICAgIGlmICghdGhpcy5wcm9wcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLl9zaWduYWxCZWdpbigpO1xuICAgICAgdGhpcy5wcm9wcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygncGxheScsIHRoaXMucHJvcHMudGltZSlcblxuICAgIC8vIFN0YXJ0IGEgcmVuZGVyIGxvb3BcbiAgICB0aGlzLnByb3BzLnBsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMuX2NhbmNlbFRpbWVvdXRzKCk7XG4gICAgdGhpcy5fbGFzdFRpbWUgPSByaWdodE5vdygpO1xuICAgIHRoaXMuX3JhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0ZUhhbmRsZXIpO1xuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIGlmICh0aGlzLnByb3BzLnJlY29yZGluZykgdGhpcy5lbmRSZWNvcmQoKTtcbiAgICB0aGlzLnByb3BzLnBsYXlpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuX2NhbmNlbFRpbWVvdXRzKCk7XG4gIH1cblxuICB0b2dnbGVQbGF5ICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5wbGF5aW5nKSB0aGlzLnBhdXNlKCk7XG4gICAgZWxzZSB0aGlzLnBsYXkoKTtcbiAgfVxuXG4gIC8vIFN0b3AgYW5kIHJlc2V0IHRvIGZyYW1lIHplcm9cbiAgc3RvcCAoKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIHRoaXMucHJvcHMuZnJhbWUgPSAwO1xuICAgIHRoaXMucHJvcHMucGxheWhlYWQgPSAwO1xuICAgIHRoaXMucHJvcHMudGltZSA9IDA7XG4gICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSAwO1xuICAgIHRoaXMucHJvcHMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICByZWNvcmQgKCkge1xuICAgIGlmICh0aGlzLnByb3BzLnJlY29yZGluZykgcmV0dXJuO1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYW52YXMtc2tldGNoXSBXQVJOOiBSZWNvcmRpbmcgZnJvbSBOb2RlLmpzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5wcm9wcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLnByb3BzLnJlY29yZGluZyA9IHRydWU7XG5cbiAgICBjb25zdCBleHBvcnRPcHRzID0gdGhpcy5fY3JlYXRlRXhwb3J0T3B0aW9ucyh7IHNlcXVlbmNlOiB0cnVlIH0pO1xuXG4gICAgY29uc3QgZnJhbWVJbnRlcnZhbCA9IDEgLyB0aGlzLnByb3BzLmZwcztcbiAgICAvLyBSZW5kZXIgZWFjaCBmcmFtZSBpbiB0aGUgc2VxdWVuY2VcbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0cygpO1xuICAgIGNvbnN0IHRpY2sgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucHJvcHMucmVjb3JkaW5nKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLnByb3BzLmRlbHRhVGltZSA9IGZyYW1lSW50ZXJ2YWw7XG4gICAgICB0aGlzLnRpY2soKTtcbiAgICAgIHJldHVybiB0aGlzLmV4cG9ydEZyYW1lKGV4cG9ydE9wdHMpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMucHJvcHMucmVjb3JkaW5nKSByZXR1cm47IC8vIHdhcyBjYW5jZWxsZWQgYmVmb3JlXG4gICAgICAgICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSAwO1xuICAgICAgICAgIHRoaXMucHJvcHMuZnJhbWUrKztcbiAgICAgICAgICBpZiAodGhpcy5wcm9wcy5mcmFtZSA8IHRoaXMucHJvcHMudG90YWxGcmFtZXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcHMudGltZSArPSBmcmFtZUludGVydmFsO1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5wbGF5aGVhZCA9IHRoaXMuX2NvbXB1dGVQbGF5aGVhZCh0aGlzLnByb3BzLnRpbWUsIHRoaXMucHJvcHMuZHVyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fcmVjb3JkVGltZW91dCA9IHNldFRpbWVvdXQodGljaywgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGaW5pc2hlZCByZWNvcmRpbmcnKTtcbiAgICAgICAgICAgIHRoaXMuX3NpZ25hbEVuZCgpO1xuICAgICAgICAgICAgdGhpcy5lbmRSZWNvcmQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5ydW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBUcmlnZ2VyIGEgc3RhcnQgZXZlbnQgYmVmb3JlIHdlIGJlZ2luIHJlY29yZGluZ1xuICAgIGlmICghdGhpcy5wcm9wcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLl9zaWduYWxCZWdpbigpO1xuICAgICAgdGhpcy5wcm9wcy5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUcmlnZ2VyICdiZWdpbiByZWNvcmQnIGV2ZW50XG4gICAgaWYgKHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC5iZWdpblJlY29yZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JhcENvbnRleHRTY2FsZShwcm9wcyA9PiB0aGlzLnNrZXRjaC5iZWdpblJlY29yZChwcm9wcykpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYXRlIGEgc3RyZWFtaW5nIHN0YXJ0IGlmIG5lY2Vzc2FyeVxuICAgIHN0cmVhbVN0YXJ0KGV4cG9ydE9wdHMpXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgdGhpcy5fcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aWNrKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgX3NpZ25hbEJlZ2luICgpIHtcbiAgICBpZiAodGhpcy5za2V0Y2ggJiYgdHlwZW9mIHRoaXMuc2tldGNoLmJlZ2luID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93cmFwQ29udGV4dFNjYWxlKHByb3BzID0+IHRoaXMuc2tldGNoLmJlZ2luKHByb3BzKSk7XG4gICAgfVxuICB9XG5cbiAgX3NpZ25hbEVuZCAoKSB7XG4gICAgaWYgKHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC5lbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3dyYXBDb250ZXh0U2NhbGUocHJvcHMgPT4gdGhpcy5za2V0Y2guZW5kKHByb3BzKSk7XG4gICAgfVxuICB9XG5cbiAgZW5kUmVjb3JkICgpIHtcbiAgICBjb25zdCB3YXNSZWNvcmRpbmcgPSB0aGlzLnByb3BzLnJlY29yZGluZztcblxuICAgIHRoaXMuX2NhbmNlbFRpbWVvdXRzKCk7XG4gICAgdGhpcy5wcm9wcy5yZWNvcmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnByb3BzLmRlbHRhVGltZSA9IDA7XG4gICAgdGhpcy5wcm9wcy5wbGF5aW5nID0gZmFsc2U7XG5cbiAgICAvLyB0ZWxsIENMSSB0aGF0IHN0cmVhbSBoYXMgZmluaXNoZWRcbiAgICByZXR1cm4gc3RyZWFtRW5kKClcbiAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICB9KVxuICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAvLyBUcmlnZ2VyICdlbmQgcmVjb3JkJyBldmVudFxuICAgICAgICBpZiAod2FzUmVjb3JkaW5nICYmIHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC5lbmRSZWNvcmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aGlzLl93cmFwQ29udGV4dFNjYWxlKHByb3BzID0+IHRoaXMuc2tldGNoLmVuZFJlY29yZChwcm9wcykpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVFeHBvcnRPcHRpb25zIChvcHQgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXF1ZW5jZTogb3B0LnNlcXVlbmNlLFxuICAgICAgc2F2ZTogb3B0LnNhdmUsXG4gICAgICBmcHM6IHRoaXMucHJvcHMuZnBzLFxuICAgICAgZnJhbWU6IG9wdC5zZXF1ZW5jZSA/IHRoaXMucHJvcHMuZnJhbWUgOiB1bmRlZmluZWQsXG4gICAgICBmaWxlOiB0aGlzLnNldHRpbmdzLmZpbGUsXG4gICAgICBuYW1lOiB0aGlzLnNldHRpbmdzLm5hbWUsXG4gICAgICBwcmVmaXg6IHRoaXMuc2V0dGluZ3MucHJlZml4LFxuICAgICAgc3VmZml4OiB0aGlzLnNldHRpbmdzLnN1ZmZpeCxcbiAgICAgIGVuY29kaW5nOiB0aGlzLnNldHRpbmdzLmVuY29kaW5nLFxuICAgICAgZW5jb2RpbmdRdWFsaXR5OiB0aGlzLnNldHRpbmdzLmVuY29kaW5nUXVhbGl0eSxcbiAgICAgIHRpbWVTdGFtcDogb3B0LnRpbWVTdGFtcCB8fCBnZXRUaW1lU3RhbXAoKSxcbiAgICAgIHRvdGFsRnJhbWVzOiBpc0Zpbml0ZSh0aGlzLnByb3BzLnRvdGFsRnJhbWVzKSA/IE1hdGgubWF4KDAsIHRoaXMucHJvcHMudG90YWxGcmFtZXMpIDogMTAwMFxuICAgIH07XG4gIH1cblxuICBleHBvcnRGcmFtZSAob3B0ID0ge30pIHtcbiAgICBpZiAoIXRoaXMuc2tldGNoKSByZXR1cm4gUHJvbWlzZS5hbGwoW10pO1xuICAgIGlmICh0eXBlb2YgdGhpcy5za2V0Y2gucHJlRXhwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnNrZXRjaC5wcmVFeHBvcnQoKTtcbiAgICB9XG5cbiAgICAvLyBPcHRpb25zIGZvciBleHBvcnQgZnVuY3Rpb25cbiAgICBsZXQgZXhwb3J0T3B0cyA9IHRoaXMuX2NyZWF0ZUV4cG9ydE9wdGlvbnMob3B0KTtcblxuICAgIGNvbnN0IGNsaWVudCA9IGdldENsaWVudEFQSSgpO1xuICAgIGxldCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgaWYgKGNsaWVudCAmJiBvcHQuY29tbWl0ICYmIHR5cGVvZiBjbGllbnQuY29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCBjb21taXRPcHRzID0gYXNzaWduKHt9LCBleHBvcnRPcHRzKTtcbiAgICAgIGNvbnN0IGhhc2ggPSBjbGllbnQuY29tbWl0KGNvbW1pdE9wdHMpO1xuICAgICAgaWYgKGlzUHJvbWlzZShoYXNoKSkgcCA9IGhhc2g7XG4gICAgICBlbHNlIHAgPSBQcm9taXNlLnJlc29sdmUoaGFzaCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHAudGhlbihoYXNoID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kb0V4cG9ydEZyYW1lKGFzc2lnbih7fSwgZXhwb3J0T3B0cywgeyBoYXNoOiBoYXNoIHx8ICcnIH0pKTtcbiAgICB9KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAvLyBNb3N0IGNvbW1vbiB1c2VjYXNlIGlzIHRvIGV4cG9ydCBhIHNpbmdsZSBsYXllcixcbiAgICAgIC8vIHNvIGxldCdzIG9wdGltaXplIHRoZSB1c2VyIGV4cGVyaWVuY2UgZm9yIHRoYXQuXG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIHJlc3VsdFswXTtcbiAgICAgIGVsc2UgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuXG4gIF9kb0V4cG9ydEZyYW1lIChleHBvcnRPcHRzID0ge30pIHtcbiAgICB0aGlzLl9wcm9wcy5leHBvcnRpbmcgPSB0cnVlO1xuXG4gICAgLy8gUmVzaXplIHRvIG91dHB1dCByZXNvbHV0aW9uXG4gICAgdGhpcy5yZXNpemUoKTtcblxuICAgIC8vIERyYXcgYXQgdGhpcyBvdXRwdXQgcmVzb2x1dGlvblxuICAgIGxldCBkcmF3UmVzdWx0ID0gdGhpcy5yZW5kZXIoKTtcblxuICAgIC8vIFRoZSBzZWxmIG93bmVkIGNhbnZhcyAobWF5IGJlIHVuZGVmaW5lZC4uLiEpXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5wcm9wcy5jYW52YXM7XG5cbiAgICAvLyBHZXQgbGlzdCBvZiByZXN1bHRzIGZyb20gcmVuZGVyXG4gICAgaWYgKHR5cGVvZiBkcmF3UmVzdWx0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZHJhd1Jlc3VsdCA9IFsgY2FudmFzIF07XG4gICAgfVxuICAgIGRyYXdSZXN1bHQgPSBbXS5jb25jYXQoZHJhd1Jlc3VsdCkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZSBjYW52YXMvZmlsZSBkZXNjcmlwdG9ycyBpbnRvIGEgY29uc2lzdGVudCBmb3JtYXQsXG4gICAgLy8gYW5kIHB1bGwgb3V0IGFueSBkYXRhIFVSTHMgZnJvbSBjYW52YXMgZWxlbWVudHNcbiAgICBkcmF3UmVzdWx0ID0gZHJhd1Jlc3VsdC5tYXAocmVzdWx0ID0+IHtcbiAgICAgIGNvbnN0IGhhc0RhdGFPYmplY3QgPSB0eXBlb2YgcmVzdWx0ID09PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgKCdkYXRhJyBpbiByZXN1bHQgfHwgJ2RhdGFVUkwnIGluIHJlc3VsdCk7XG4gICAgICBjb25zdCBkYXRhID0gaGFzRGF0YU9iamVjdCA/IHJlc3VsdC5kYXRhIDogcmVzdWx0O1xuICAgICAgY29uc3Qgb3B0cyA9IGhhc0RhdGFPYmplY3QgPyBhc3NpZ24oe30sIHJlc3VsdCwgeyBkYXRhIH0pIDogeyBkYXRhIH07XG4gICAgICBpZiAoaXNDYW52YXMoZGF0YSkpIHtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nIHx8IGV4cG9ydE9wdHMuZW5jb2Rpbmc7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nUXVhbGl0eSA9IGRlZmluZWQob3B0cy5lbmNvZGluZ1F1YWxpdHksIGV4cG9ydE9wdHMuZW5jb2RpbmdRdWFsaXR5LCAwLjk1KTtcbiAgICAgICAgY29uc3QgeyBkYXRhVVJMLCBleHRlbnNpb24sIHR5cGUgfSA9IGV4cG9ydENhbnZhcyhkYXRhLCB7IGVuY29kaW5nLCBlbmNvZGluZ1F1YWxpdHkgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9wdHMsIHsgZGF0YVVSTCwgZXh0ZW5zaW9uLCB0eXBlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBOb3cgcmV0dXJuIHRvIHJlZ3VsYXIgcmVuZGVyaW5nIG1vZGVcbiAgICB0aGlzLl9wcm9wcy5leHBvcnRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIHRoaXMucmVuZGVyKCk7XG5cbiAgICAvLyBBbmQgbm93IHdlIGNhbiBzYXZlIGVhY2ggcmVzdWx0XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGRyYXdSZXN1bHQubWFwKChyZXN1bHQsIGksIGxheWVyTGlzdCkgPT4ge1xuICAgICAgLy8gQnkgZGVmYXVsdCwgaWYgcmVuZGVyaW5nIG11bHRpcGxlIGxheWVycyB3ZSB3aWxsIGdpdmUgdGhlbSBpbmRpY2VzXG4gICAgICBjb25zdCBjdXJPcHQgPSBhc3NpZ24oe1xuICAgICAgICBleHRlbnNpb246ICcnLFxuICAgICAgICBwcmVmaXg6ICcnLFxuICAgICAgICBzdWZmaXg6ICcnXG4gICAgICB9LCBleHBvcnRPcHRzLCByZXN1bHQsIHtcbiAgICAgICAgbGF5ZXI6IGksXG4gICAgICAgIHRvdGFsTGF5ZXJzOiBsYXllckxpc3QubGVuZ3RoXG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgZXhwb3J0IGlzIGV4cGxpY2l0bHkgbm90IHNhdmluZywgbWFrZSBzdXJlIG5vdGhpbmcgc2F2ZXNcbiAgICAgIC8vIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBsYXllciBzYXZlIG9wdGlvbiwgb3IgZmFsbGJhY2sgdG8gdHJ1ZVxuICAgICAgY29uc3Qgc2F2ZVBhcmFtID0gZXhwb3J0T3B0cy5zYXZlID09PSBmYWxzZSA/IGZhbHNlIDogcmVzdWx0LnNhdmU7XG4gICAgICBjdXJPcHQuc2F2ZSA9IHNhdmVQYXJhbSAhPT0gZmFsc2U7XG5cbiAgICAgIC8vIFJlc29sdmUgYSBmdWxsIGZpbGVuYW1lIGZyb20gYWxsIHRoZSBvcHRpb25zXG4gICAgICBjdXJPcHQuZmlsZW5hbWUgPSByZXNvbHZlRmlsZW5hbWUoY3VyT3B0KTtcblxuICAgICAgLy8gQ2xlYW4gdXAgc29tZSBwYXJhbWV0ZXJzIHRoYXQgbWF5IGJlIGFtYmlndW91cyB0byB0aGUgdXNlclxuICAgICAgZGVsZXRlIGN1ck9wdC5lbmNvZGluZztcbiAgICAgIGRlbGV0ZSBjdXJPcHQuZW5jb2RpbmdRdWFsaXR5O1xuXG4gICAgICAvLyBDbGVhbiBpdCB1cCBmdXJ0aGVyIGJ5IGp1c3QgcmVtb3ZpbmcgdW5kZWZpbmVkIHZhbHVlc1xuICAgICAgZm9yIChsZXQgayBpbiBjdXJPcHQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJPcHRba10gPT09ICd1bmRlZmluZWQnKSBkZWxldGUgY3VyT3B0W2tdO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2F2ZVByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgICAgaWYgKGN1ck9wdC5zYXZlKSB7XG4gICAgICAgIC8vIFdoZXRoZXIgdG8gYWN0dWFsbHkgc2F2ZSAoZG93bmxvYWQpIHRoaXMgZnJhZ21lbnRcbiAgICAgICAgY29uc3QgZGF0YSA9IGN1ck9wdC5kYXRhO1xuICAgICAgICBpZiAoY3VyT3B0LmRhdGFVUkwpIHtcbiAgICAgICAgICBjb25zdCBkYXRhVVJMID0gY3VyT3B0LmRhdGFVUkw7XG4gICAgICAgICAgc2F2ZVByb21pc2UgPSBzYXZlRGF0YVVSTChkYXRhVVJMLCBjdXJPcHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNhdmVQcm9taXNlID0gc2F2ZUZpbGUoZGF0YSwgY3VyT3B0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNhdmVQcm9taXNlLnRoZW4oc2F2ZVJlc3VsdCA9PiB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjdXJPcHQsIHNhdmVSZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSkpLnRoZW4oZXYgPT4ge1xuICAgICAgY29uc3Qgc2F2ZWRFdmVudHMgPSBldi5maWx0ZXIoZSA9PiBlLnNhdmUpO1xuICAgICAgaWYgKHNhdmVkRXZlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gTG9nIHRoZSBzYXZlZCBleHBvcnRzXG4gICAgICAgIGNvbnN0IGV2ZW50V2l0aE91dHB1dCA9IHNhdmVkRXZlbnRzLmZpbmQoZSA9PiBlLm91dHB1dE5hbWUpO1xuICAgICAgICBjb25zdCBpc0NsaWVudCA9IHNhdmVkRXZlbnRzLnNvbWUoZSA9PiBlLmNsaWVudCk7XG4gICAgICAgIGNvbnN0IGlzU3RyZWFtaW5nID0gc2F2ZWRFdmVudHMuc29tZShlID0+IGUuc3RyZWFtKTtcbiAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgIC8vIG1hbnkgZmlsZXMsIGp1c3QgbG9nIGhvdyBtYW55IHdlcmUgZXhwb3J0ZWRcbiAgICAgICAgaWYgKHNhdmVkRXZlbnRzLmxlbmd0aCA+IDEpIGl0ZW0gPSBzYXZlZEV2ZW50cy5sZW5ndGg7XG4gICAgICAgIC8vIGluIENMSSwgd2Uga25vdyBleGFjdCBwYXRoIGRpcm5hbWVcbiAgICAgICAgZWxzZSBpZiAoZXZlbnRXaXRoT3V0cHV0KSBpdGVtID0gYCR7ZXZlbnRXaXRoT3V0cHV0Lm91dHB1dE5hbWV9LyR7c2F2ZWRFdmVudHNbMF0uZmlsZW5hbWV9YDtcbiAgICAgICAgLy8gaW4gYnJvd3Nlciwgd2UgY2FuIG9ubHkga25vdyBpdCB3ZW50IHRvIFwiYnJvd3NlciBkb3dubG9hZCBmb2xkZXJcIlxuICAgICAgICBlbHNlIGl0ZW0gPSBgJHtzYXZlZEV2ZW50c1swXS5maWxlbmFtZX1gO1xuICAgICAgICBsZXQgb2ZTZXEgPSAnJztcbiAgICAgICAgaWYgKGV4cG9ydE9wdHMuc2VxdWVuY2UpIHtcbiAgICAgICAgICBjb25zdCBoYXNUb3RhbEZyYW1lcyA9IGlzRmluaXRlKHRoaXMucHJvcHMudG90YWxGcmFtZXMpO1xuICAgICAgICAgIG9mU2VxID0gaGFzVG90YWxGcmFtZXMgPyBgIChmcmFtZSAke2V4cG9ydE9wdHMuZnJhbWUgKyAxfSAvICR7dGhpcy5wcm9wcy50b3RhbEZyYW1lc30pYCA6IGAgKGZyYW1lICR7ZXhwb3J0T3B0cy5mcmFtZX0pYDtcbiAgICAgICAgfSBlbHNlIGlmIChzYXZlZEV2ZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgb2ZTZXEgPSBgIGZpbGVzYDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbGllbnQgPSBpc0NsaWVudCA/ICdjYW52YXMtc2tldGNoLWNsaScgOiAnY2FudmFzLXNrZXRjaCc7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IGlzU3RyZWFtaW5nID8gJ1N0cmVhbWluZyBpbnRvJyA6ICdFeHBvcnRlZCc7XG4gICAgICAgIGNvbnNvbGUubG9nKGAlY1ske2NsaWVudH1dJWMgJHthY3Rpb259ICVjJHtpdGVtfSVjJHtvZlNlcX1gLCAnY29sb3I6ICM4ZThlOGU7JywgJ2NvbG9yOiBpbml0aWFsOycsICdmb250LXdlaWdodDogYm9sZDsnLCAnZm9udC13ZWlnaHQ6IGluaXRpYWw7Jyk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHRoaXMuc2tldGNoLnBvc3RFeHBvcnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5za2V0Y2gucG9zdEV4cG9ydCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV2O1xuICAgIH0pO1xuICB9XG5cbiAgX3dyYXBDb250ZXh0U2NhbGUgKGNiKSB7XG4gICAgdGhpcy5fcHJlUmVuZGVyKCk7XG4gICAgY2IodGhpcy5wcm9wcyk7XG4gICAgdGhpcy5fcG9zdFJlbmRlcigpO1xuICB9XG5cbiAgX3ByZVJlbmRlciAoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gU2NhbGUgY29udGV4dCBmb3IgdW5pdCBzaXppbmdcbiAgICBpZiAoIXRoaXMucHJvcHMuZ2wgJiYgcHJvcHMuY29udGV4dCAmJiAhcHJvcHMucDUpIHtcbiAgICAgIHByb3BzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2NhbGVDb250ZXh0ICE9PSBmYWxzZSkge1xuICAgICAgICBwcm9wcy5jb250ZXh0LnNjYWxlKHByb3BzLnNjYWxlWCwgcHJvcHMuc2NhbGVZKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BzLnA1KSB7XG4gICAgICBwcm9wcy5wNS5zY2FsZShwcm9wcy5zY2FsZVggLyBwcm9wcy5waXhlbFJhdGlvLCBwcm9wcy5zY2FsZVkgLyBwcm9wcy5waXhlbFJhdGlvKTtcbiAgICB9XG4gIH1cblxuICBfcG9zdFJlbmRlciAoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgaWYgKCF0aGlzLnByb3BzLmdsICYmIHByb3BzLmNvbnRleHQgJiYgIXByb3BzLnA1KSB7XG4gICAgICBwcm9wcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICAvLyBGbHVzaCBieSBkZWZhdWx0LCB0aGlzIG1heSBiZSByZXZpc2l0ZWQgYXQgYSBsYXRlciBwb2ludC5cbiAgICAvLyBXZSBkbyB0aGlzIHRvIGVuc3VyZSB0b0RhdGFVUkwgY2FuIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlci5cbiAgICAvLyBNb3N0IGxpa2VseSBicm93c2VycyBhbHJlYWR5IGhhbmRsZSB0aGlzLCBzbyB3ZSBtYXkgcmV2aXNpdCB0aGlzIGFuZFxuICAgIC8vIHJlbW92ZSBpdCBpZiBpdCBpbXByb3ZlcyBwZXJmb3JtYW5jZSB3aXRob3V0IGFueSB1c2FiaWxpdHkgaXNzdWVzLlxuICAgIGlmIChwcm9wcy5nbCAmJiB0aGlzLnNldHRpbmdzLmZsdXNoICE9PSBmYWxzZSAmJiAhcHJvcHMucDUpIHtcbiAgICAgIHByb3BzLmdsLmZsdXNoKCk7XG4gICAgfVxuICB9XG5cbiAgdGljayAoKSB7XG4gICAgaWYgKHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC50aWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl9wcmVSZW5kZXIoKTtcbiAgICAgIHRoaXMuc2tldGNoLnRpY2sodGhpcy5wcm9wcyk7XG4gICAgICB0aGlzLl9wb3N0UmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgcmVuZGVyICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5wNSkge1xuICAgICAgdGhpcy5fbGFzdFJlZHJhd1Jlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucHJvcHMucDUucmVkcmF3KCk7XG4gICAgICByZXR1cm4gdGhpcy5fbGFzdFJlZHJhd1Jlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc3VibWl0RHJhd0NhbGwoKTtcbiAgICB9XG4gIH1cblxuICBzdWJtaXREcmF3Q2FsbCAoKSB7XG4gICAgaWYgKCF0aGlzLnNrZXRjaCkgcmV0dXJuO1xuXG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHRoaXMuX3ByZVJlbmRlcigpO1xuXG4gICAgbGV0IGRyYXdSZXN1bHQ7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuc2tldGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkcmF3UmVzdWx0ID0gdGhpcy5za2V0Y2gocHJvcHMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuc2tldGNoLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZHJhd1Jlc3VsdCA9IHRoaXMuc2tldGNoLnJlbmRlcihwcm9wcyk7XG4gICAgfVxuXG4gICAgdGhpcy5fcG9zdFJlbmRlcigpO1xuXG4gICAgcmV0dXJuIGRyYXdSZXN1bHQ7XG4gIH1cblxuICB1cGRhdGUgKG9wdCA9IHt9KSB7XG4gICAgLy8gQ3VycmVudGx5IHVwZGF0ZSgpIGlzIG9ubHkgZm9jdXNlZCBvbiByZXNpemluZyxcbiAgICAvLyBidXQgbGF0ZXIgd2Ugd2lsbCBzdXBwb3J0IG90aGVyIG9wdGlvbnMgbGlrZSBzd2l0Y2hpbmdcbiAgICAvLyBmcmFtZXMgYW5kIHN1Y2guXG4gICAgY29uc3Qgbm90WWV0U3VwcG9ydGVkID0gW1xuICAgICAgJ2FuaW1hdGUnXG4gICAgXTtcblxuICAgIE9iamVjdC5rZXlzKG9wdCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKG5vdFlldFN1cHBvcnRlZC5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNvcnJ5LCB0aGUgeyAke2tleX0gfSBvcHRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgd2l0aCB1cGRhdGUoKS5gKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9sZENhbnZhcyA9IHRoaXMuX3NldHRpbmdzLmNhbnZhcztcbiAgICBjb25zdCBvbGRDb250ZXh0ID0gdGhpcy5fc2V0dGluZ3MuY29udGV4dDtcblxuICAgIC8vIE1lcmdlIG5ldyBvcHRpb25zIGludG8gc2V0dGluZ3NcbiAgICBmb3IgKGxldCBrZXkgaW4gb3B0KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9wdFtrZXldO1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gaWdub3JlIHVuZGVmaW5lZFxuICAgICAgICB0aGlzLl9zZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgaW4gdGltZSBwcm9wc1xuICAgIGNvbnN0IHRpbWVPcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fc2V0dGluZ3MsIG9wdCk7XG4gICAgaWYgKCd0aW1lJyBpbiBvcHQgJiYgJ2ZyYW1lJyBpbiBvcHQpIHRocm93IG5ldyBFcnJvcignWW91IHNob3VsZCBzcGVjaWZ5IHsgdGltZSB9IG9yIHsgZnJhbWUgfSBidXQgbm90IGJvdGgnKTtcbiAgICBlbHNlIGlmICgndGltZScgaW4gb3B0KSBkZWxldGUgdGltZU9wdHMuZnJhbWU7XG4gICAgZWxzZSBpZiAoJ2ZyYW1lJyBpbiBvcHQpIGRlbGV0ZSB0aW1lT3B0cy50aW1lO1xuICAgIGlmICgnZHVyYXRpb24nIGluIG9wdCAmJiAndG90YWxGcmFtZXMnIGluIG9wdCkgdGhyb3cgbmV3IEVycm9yKCdZb3Ugc2hvdWxkIHNwZWNpZnkgeyBkdXJhdGlvbiB9IG9yIHsgdG90YWxGcmFtZXMgfSBidXQgbm90IGJvdGgnKTtcbiAgICBlbHNlIGlmICgnZHVyYXRpb24nIGluIG9wdCkgZGVsZXRlIHRpbWVPcHRzLnRvdGFsRnJhbWVzO1xuICAgIGVsc2UgaWYgKCd0b3RhbEZyYW1lcycgaW4gb3B0KSBkZWxldGUgdGltZU9wdHMuZHVyYXRpb247XG5cbiAgICAvLyBNZXJnZSBpbiB1c2VyIGRhdGEgd2l0aG91dCBjb3B5aW5nXG4gICAgaWYgKCdkYXRhJyBpbiBvcHQpIHRoaXMuX3Byb3BzLmRhdGEgPSBvcHQuZGF0YTtcblxuICAgIGNvbnN0IHRpbWVQcm9wcyA9IHRoaXMuZ2V0VGltZVByb3BzKHRpbWVPcHRzKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Byb3BzLCB0aW1lUHJvcHMpO1xuXG4gICAgLy8gSWYgZWl0aGVyIGNhbnZhcyBvciBjb250ZXh0IGlzIGNoYW5nZWQsIHdlIHNob3VsZCByZS11cGRhdGVcbiAgICBpZiAob2xkQ2FudmFzICE9PSB0aGlzLl9zZXR0aW5ncy5jYW52YXMgfHwgb2xkQ29udGV4dCAhPT0gdGhpcy5fc2V0dGluZ3MuY29udGV4dCkge1xuICAgICAgY29uc3QgeyBjYW52YXMsIGNvbnRleHQgfSA9IGNyZWF0ZUNhbnZhcyh0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICAgIHRoaXMucHJvcHMuY2FudmFzID0gY2FudmFzO1xuICAgICAgdGhpcy5wcm9wcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgICAgLy8gRGVsZXRlIG9yIGFkZCBhICdnbCcgcHJvcCBmb3IgY29udmVuaWVuY2VcbiAgICAgIHRoaXMuX3NldHVwR0xLZXkoKTtcblxuICAgICAgLy8gUmUtbW91bnQgdGhlIG5ldyBjYW52YXMgaWYgaXQgaGFzIG5vIHBhcmVudFxuICAgICAgdGhpcy5fYXBwZW5kQ2FudmFzSWZOZWVkZWQoKTtcbiAgICB9XG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBQNS5qc1xuICAgIGlmIChvcHQucDUgJiYgdHlwZW9mIG9wdC5wNSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5wcm9wcy5wNSA9IG9wdC5wNTtcbiAgICAgIHRoaXMucHJvcHMucDUuZHJhdyA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzUDVSZXNpemluZykgcmV0dXJuO1xuICAgICAgICB0aGlzLl9sYXN0UmVkcmF3UmVzdWx0ID0gdGhpcy5zdWJtaXREcmF3Q2FsbCgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgcGxheWluZyBzdGF0ZSBpZiBuZWNlc3NhcnlcbiAgICBpZiAoJ3BsYXlpbmcnIGluIG9wdCkge1xuICAgICAgaWYgKG9wdC5wbGF5aW5nKSB0aGlzLnBsYXkoKTtcbiAgICAgIGVsc2UgdGhpcy5wYXVzZSgpO1xuICAgIH1cblxuICAgIGNoZWNrU2V0dGluZ3ModGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgLy8gRHJhdyBuZXcgZnJhbWVcbiAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gICAgcmV0dXJuIHRoaXMucHJvcHM7XG4gIH1cblxuICByZXNpemUgKCkge1xuICAgIGNvbnN0IG9sZFNpemVzID0gdGhpcy5fZ2V0U2l6ZVByb3BzKCk7XG5cbiAgICBjb25zdCBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gUmVjb21wdXRlIG5ldyBwcm9wZXJ0aWVzIGJhc2VkIG9uIGN1cnJlbnQgc2V0dXBcbiAgICBjb25zdCBuZXdQcm9wcyA9IHJlc2l6ZUNhbnZhcyhwcm9wcywgc2V0dGluZ3MpO1xuXG4gICAgLy8gQXNzaWduIHRvIGN1cnJlbnQgcHJvcHNcbiAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Byb3BzLCBuZXdQcm9wcyk7XG5cbiAgICAvLyBOb3cgd2UgYWN0dWFsbHkgdXBkYXRlIHRoZSBjYW52YXMgd2lkdGgvaGVpZ2h0IGFuZCBzdHlsZSBwcm9wc1xuICAgIGNvbnN0IHtcbiAgICAgIHBpeGVsUmF0aW8sXG4gICAgICBjYW52YXNXaWR0aCxcbiAgICAgIGNhbnZhc0hlaWdodCxcbiAgICAgIHN0eWxlV2lkdGgsXG4gICAgICBzdHlsZUhlaWdodFxuICAgIH0gPSB0aGlzLnByb3BzO1xuXG4gICAgLy8gVXBkYXRlIGNhbnZhcyBzZXR0aW5nc1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucHJvcHMuY2FudmFzO1xuICAgIGlmIChjYW52YXMgJiYgc2V0dGluZ3MucmVzaXplQ2FudmFzICE9PSBmYWxzZSkge1xuICAgICAgaWYgKHByb3BzLnA1KSB7XG4gICAgICAgIC8vIFA1LmpzIHNwZWNpZmljIGVkZ2UgY2FzZVxuICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgICB0aGlzLl9pc1A1UmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgIC8vIFRoaXMgY2F1c2VzIGEgcmUtZHJhdyA6XFwgc28gd2UgaWdub3JlIGRyYXdzIGluIHRoZSBtZWFuIHRpbWUuLi4gc29ydGEgaGFja3lcbiAgICAgICAgICBwcm9wcy5wNS5waXhlbERlbnNpdHkocGl4ZWxSYXRpbyk7XG4gICAgICAgICAgcHJvcHMucDUucmVzaXplQ2FudmFzKGNhbnZhc1dpZHRoIC8gcGl4ZWxSYXRpbywgY2FudmFzSGVpZ2h0IC8gcGl4ZWxSYXRpbywgZmFsc2UpO1xuICAgICAgICAgIHRoaXMuX2lzUDVSZXNpemluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3JjZSBjYW52YXMgc2l6ZVxuICAgICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCkgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGg7XG4gICAgICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIGNhbnZhcy5oZWlnaHQgPSBjYW52YXNIZWlnaHQ7XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgY2FudmFzIHN0eWxlXG4gICAgICBpZiAoaXNCcm93c2VyKCkgJiYgc2V0dGluZ3Muc3R5bGVDYW52YXMgIT09IGZhbHNlKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke3N0eWxlV2lkdGh9cHhgO1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7c3R5bGVIZWlnaHR9cHhgO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG5ld1NpemVzID0gdGhpcy5fZ2V0U2l6ZVByb3BzKCk7XG4gICAgbGV0IGNoYW5nZWQgPSAhZGVlcEVxdWFsKG9sZFNpemVzLCBuZXdTaXplcyk7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkKCk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG5cbiAgX3NpemVDaGFuZ2VkICgpIHtcbiAgICAvLyBTZW5kIHJlc2l6ZSBldmVudCB0byBza2V0Y2hcbiAgICBpZiAodGhpcy5za2V0Y2ggJiYgdHlwZW9mIHRoaXMuc2tldGNoLnJlc2l6ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5za2V0Y2gucmVzaXplKHRoaXMucHJvcHMpO1xuICAgIH1cbiAgfVxuXG4gIGFuaW1hdGUgKCkge1xuICAgIGlmICghdGhpcy5wcm9wcy5wbGF5aW5nKSByZXR1cm47XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSkge1xuICAgICAgY29uc29sZS5lcnJvcignW2NhbnZhcy1za2V0Y2hdIFdBUk46IEFuaW1hdGlvbiBpbiBOb2RlLmpzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX3JhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5fYW5pbWF0ZUhhbmRsZXIpO1xuXG4gICAgbGV0IG5vdyA9IHJpZ2h0Tm93KCk7XG5cbiAgICBjb25zdCBmcHMgPSB0aGlzLnByb3BzLmZwcztcbiAgICBjb25zdCBmcmFtZUludGVydmFsTVMgPSAxMDAwIC8gZnBzO1xuICAgIGxldCBkZWx0YVRpbWVNUyA9IG5vdyAtIHRoaXMuX2xhc3RUaW1lO1xuXG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLnByb3BzLmR1cmF0aW9uO1xuICAgIGNvbnN0IGhhc0R1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShkdXJhdGlvbik7XG5cbiAgICBsZXQgaXNOZXdGcmFtZSA9IHRydWU7XG4gICAgY29uc3QgcGxheWJhY2tSYXRlID0gdGhpcy5zZXR0aW5ncy5wbGF5YmFja1JhdGU7XG4gICAgaWYgKHBsYXliYWNrUmF0ZSA9PT0gJ2ZpeGVkJykge1xuICAgICAgZGVsdGFUaW1lTVMgPSBmcmFtZUludGVydmFsTVM7XG4gICAgfSBlbHNlIGlmIChwbGF5YmFja1JhdGUgPT09ICd0aHJvdHRsZScpIHtcbiAgICAgIGlmIChkZWx0YVRpbWVNUyA+IGZyYW1lSW50ZXJ2YWxNUykge1xuICAgICAgICBub3cgPSBub3cgLSAoZGVsdGFUaW1lTVMgJSBmcmFtZUludGVydmFsTVMpO1xuICAgICAgICB0aGlzLl9sYXN0VGltZSA9IG5vdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzTmV3RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGFzdFRpbWUgPSBub3c7XG4gICAgfVxuXG4gICAgY29uc3QgZGVsdGFUaW1lID0gZGVsdGFUaW1lTVMgLyAxMDAwO1xuICAgIGxldCBuZXdUaW1lID0gdGhpcy5wcm9wcy50aW1lICsgZGVsdGFUaW1lICogdGhpcy5wcm9wcy50aW1lU2NhbGU7XG5cbiAgICAvLyBIYW5kbGUgcmV2ZXJzZSB0aW1lIHNjYWxlXG4gICAgaWYgKG5ld1RpbWUgPCAwICYmIGhhc0R1cmF0aW9uKSB7XG4gICAgICBuZXdUaW1lID0gZHVyYXRpb24gKyBuZXdUaW1lO1xuICAgIH1cblxuICAgIC8vIFJlLXN0YXJ0IGFuaW1hdGlvblxuICAgIGxldCBpc0ZpbmlzaGVkID0gZmFsc2U7XG4gICAgbGV0IGlzTG9vcFN0YXJ0ID0gZmFsc2U7XG5cbiAgICBjb25zdCBsb29waW5nID0gdGhpcy5zZXR0aW5ncy5sb29wICE9PSBmYWxzZTtcblxuICAgIGlmIChoYXNEdXJhdGlvbiAmJiBuZXdUaW1lID49IGR1cmF0aW9uKSB7XG4gICAgICAvLyBSZS1zdGFydCBhbmltYXRpb25cbiAgICAgIGlmIChsb29waW5nKSB7XG4gICAgICAgIGlzTmV3RnJhbWUgPSB0cnVlO1xuICAgICAgICBuZXdUaW1lID0gbmV3VGltZSAlIGR1cmF0aW9uO1xuICAgICAgICBpc0xvb3BTdGFydCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc05ld0ZyYW1lID0gZmFsc2U7XG4gICAgICAgIG5ld1RpbWUgPSBkdXJhdGlvbjtcbiAgICAgICAgaXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NpZ25hbEVuZCgpO1xuICAgIH1cblxuICAgIGlmIChpc05ld0ZyYW1lKSB7XG4gICAgICB0aGlzLnByb3BzLmRlbHRhVGltZSA9IGRlbHRhVGltZTtcbiAgICAgIHRoaXMucHJvcHMudGltZSA9IG5ld1RpbWU7XG4gICAgICB0aGlzLnByb3BzLnBsYXloZWFkID0gdGhpcy5fY29tcHV0ZVBsYXloZWFkKG5ld1RpbWUsIGR1cmF0aW9uKTtcbiAgICAgIGNvbnN0IGxhc3RGcmFtZSA9IHRoaXMucHJvcHMuZnJhbWU7XG4gICAgICB0aGlzLnByb3BzLmZyYW1lID0gdGhpcy5fY29tcHV0ZUN1cnJlbnRGcmFtZSgpO1xuICAgICAgaWYgKGlzTG9vcFN0YXJ0KSB0aGlzLl9zaWduYWxCZWdpbigpO1xuICAgICAgaWYgKGxhc3RGcmFtZSAhPT0gdGhpcy5wcm9wcy5mcmFtZSkgdGhpcy50aWNrKCk7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSAwO1xuICAgIH1cblxuICAgIGlmIChpc0ZpbmlzaGVkKSB7XG4gICAgICB0aGlzLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgZGlzcGF0Y2ggKGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdtdXN0IHBhc3MgZnVuY3Rpb24gaW50byBkaXNwYXRjaCgpJyk7XG4gICAgY2IodGhpcy5wcm9wcyk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIG1vdW50ICgpIHtcbiAgICB0aGlzLl9hcHBlbmRDYW52YXNJZk5lZWRlZCgpO1xuICB9XG5cbiAgdW5tb3VudCAoKSB7XG4gICAgaWYgKGlzQnJvd3NlcigpKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplSGFuZGxlcik7XG4gICAgICB0aGlzLl9rZXlib2FyZFNob3J0Y3V0cy5kZXRhY2goKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHJvcHMuY2FudmFzLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgIHRoaXMucHJvcHMuY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5wcm9wcy5jYW52YXMpO1xuICAgIH1cbiAgfVxuXG4gIF9hcHBlbmRDYW52YXNJZk5lZWRlZCAoKSB7XG4gICAgaWYgKCFpc0Jyb3dzZXIoKSkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnNldHRpbmdzLnBhcmVudCAhPT0gZmFsc2UgJiYgKHRoaXMucHJvcHMuY2FudmFzICYmICF0aGlzLnByb3BzLmNhbnZhcy5wYXJlbnRFbGVtZW50KSkge1xuICAgICAgY29uc3QgZGVmYXVsdFBhcmVudCA9IHRoaXMuc2V0dGluZ3MucGFyZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgICBkZWZhdWx0UGFyZW50LmFwcGVuZENoaWxkKHRoaXMucHJvcHMuY2FudmFzKTtcbiAgICB9XG4gIH1cblxuICBfc2V0dXBHTEtleSAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuY29udGV4dCkge1xuICAgICAgaWYgKGlzV2ViR0xDb250ZXh0KHRoaXMucHJvcHMuY29udGV4dCkpIHtcbiAgICAgICAgdGhpcy5fcHJvcHMuZ2wgPSB0aGlzLnByb3BzLmNvbnRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHMuZ2w7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0VGltZVByb3BzIChzZXR0aW5ncyA9IHt9KSB7XG4gICAgLy8gR2V0IHRpbWluZyBkYXRhXG4gICAgbGV0IGR1cmF0aW9uID0gc2V0dGluZ3MuZHVyYXRpb247XG4gICAgbGV0IHRvdGFsRnJhbWVzID0gc2V0dGluZ3MudG90YWxGcmFtZXM7XG4gICAgY29uc3QgdGltZVNjYWxlID0gZGVmaW5lZChzZXR0aW5ncy50aW1lU2NhbGUsIDEpO1xuICAgIGNvbnN0IGZwcyA9IGRlZmluZWQoc2V0dGluZ3MuZnBzLCAyNCk7XG4gICAgY29uc3QgaGFzRHVyYXRpb24gPSB0eXBlb2YgZHVyYXRpb24gPT09ICdudW1iZXInICYmIGlzRmluaXRlKGR1cmF0aW9uKTtcbiAgICBjb25zdCBoYXNUb3RhbEZyYW1lcyA9IHR5cGVvZiB0b3RhbEZyYW1lcyA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodG90YWxGcmFtZXMpO1xuXG4gICAgY29uc3QgdG90YWxGcmFtZXNGcm9tRHVyYXRpb24gPSBoYXNEdXJhdGlvbiA/IE1hdGguZmxvb3IoZnBzICogZHVyYXRpb24pIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGR1cmF0aW9uRnJvbVRvdGFsRnJhbWVzID0gaGFzVG90YWxGcmFtZXMgPyAodG90YWxGcmFtZXMgLyBmcHMpIDogdW5kZWZpbmVkO1xuICAgIGlmIChoYXNEdXJhdGlvbiAmJiBoYXNUb3RhbEZyYW1lcyAmJiB0b3RhbEZyYW1lc0Zyb21EdXJhdGlvbiAhPT0gdG90YWxGcmFtZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHNob3VsZCBzcGVjaWZ5IGVpdGhlciBkdXJhdGlvbiBvciB0b3RhbEZyYW1lcywgYnV0IG5vdCBib3RoLiBPciwgdGhleSBtdXN0IG1hdGNoIGV4YWN0bHkuJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kaW1lbnNpb25zID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygc2V0dGluZ3MudW5pdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4oYFlvdSd2ZSBzcGVjaWZpZWQgYSB7IHVuaXRzIH0gc2V0dGluZyBidXQgbm8geyBkaW1lbnNpb24gfSwgc28gdGhlIHVuaXRzIHdpbGwgYmUgaWdub3JlZC5gKTtcbiAgICB9XG5cbiAgICB0b3RhbEZyYW1lcyA9IGRlZmluZWQodG90YWxGcmFtZXMsIHRvdGFsRnJhbWVzRnJvbUR1cmF0aW9uLCBJbmZpbml0eSk7XG4gICAgZHVyYXRpb24gPSBkZWZpbmVkKGR1cmF0aW9uLCBkdXJhdGlvbkZyb21Ub3RhbEZyYW1lcywgSW5maW5pdHkpO1xuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gc2V0dGluZ3MudGltZTtcbiAgICBjb25zdCBzdGFydEZyYW1lID0gc2V0dGluZ3MuZnJhbWU7XG4gICAgY29uc3QgaGFzU3RhcnRUaW1lID0gdHlwZW9mIHN0YXJ0VGltZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoc3RhcnRUaW1lKTtcbiAgICBjb25zdCBoYXNTdGFydEZyYW1lID0gdHlwZW9mIHN0YXJ0RnJhbWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHN0YXJ0RnJhbWUpO1xuXG4gICAgLy8gc3RhcnQgYXQgemVybyB1bmxlc3MgdXNlciBzcGVjaWZpZXMgZnJhbWUgb3IgdGltZSAoYnV0IG5vdCBib3RoIG1pc21hdGNoZWQpXG4gICAgbGV0IHRpbWUgPSAwO1xuICAgIGxldCBmcmFtZSA9IDA7XG4gICAgbGV0IHBsYXloZWFkID0gMDtcbiAgICBpZiAoaGFzU3RhcnRUaW1lICYmIGhhc1N0YXJ0RnJhbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IHNob3VsZCBzcGVjaWZ5IGVpdGhlciBzdGFydCBmcmFtZSBvciB0aW1lLCBidXQgbm90IGJvdGguJyk7XG4gICAgfSBlbHNlIGlmIChoYXNTdGFydFRpbWUpIHtcbiAgICAgIC8vIFVzZXIgc3BlY2lmaWVzIHRpbWUsIHdlIGluZmVyIGZyYW1lcyBmcm9tIEZQU1xuICAgICAgdGltZSA9IHN0YXJ0VGltZTtcbiAgICAgIHBsYXloZWFkID0gdGhpcy5fY29tcHV0ZVBsYXloZWFkKHRpbWUsIGR1cmF0aW9uKTtcbiAgICAgIGZyYW1lID0gdGhpcy5fY29tcHV0ZUZyYW1lKFxuICAgICAgICBwbGF5aGVhZCwgdGltZSxcbiAgICAgICAgdG90YWxGcmFtZXMsIGZwc1xuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGhhc1N0YXJ0RnJhbWUpIHtcbiAgICAgIC8vIFVzZXIgc3BlY2lmaWVzIGZyYW1lIG51bWJlciwgd2UgaW5mZXIgdGltZSBmcm9tIEZQU1xuICAgICAgZnJhbWUgPSBzdGFydEZyYW1lO1xuICAgICAgdGltZSA9IGZyYW1lIC8gZnBzO1xuICAgICAgcGxheWhlYWQgPSB0aGlzLl9jb21wdXRlUGxheWhlYWQodGltZSwgZHVyYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwbGF5aGVhZCxcbiAgICAgIHRpbWUsXG4gICAgICBmcmFtZSxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdG90YWxGcmFtZXMsXG4gICAgICBmcHMsXG4gICAgICB0aW1lU2NhbGVcbiAgICB9O1xuICB9XG5cbiAgc2V0dXAgKHNldHRpbmdzID0ge30pIHtcbiAgICBpZiAodGhpcy5za2V0Y2gpIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgc2V0dXAoKSBjYWxscyBub3QgeWV0IHN1cHBvcnRlZC4nKTtcblxuICAgIHRoaXMuX3NldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MsIHRoaXMuX3NldHRpbmdzKTtcblxuICAgIGNoZWNrU2V0dGluZ3ModGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgLy8gR2V0IGluaXRpYWwgY2FudmFzICYgY29udGV4dFxuICAgIGNvbnN0IHsgY29udGV4dCwgY2FudmFzIH0gPSBjcmVhdGVDYW52YXModGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgY29uc3QgdGltZVByb3BzID0gdGhpcy5nZXRUaW1lUHJvcHModGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgLy8gSW5pdGlhbCByZW5kZXIgc3RhdGUgZmVhdHVyZXNcbiAgICB0aGlzLl9wcm9wcyA9IHtcbiAgICAgIC4uLnRpbWVQcm9wcyxcbiAgICAgIGNhbnZhcyxcbiAgICAgIGNvbnRleHQsXG4gICAgICBkZWx0YVRpbWU6IDAsXG4gICAgICBzdGFydGVkOiBmYWxzZSxcbiAgICAgIGV4cG9ydGluZzogZmFsc2UsXG4gICAgICBwbGF5aW5nOiBmYWxzZSxcbiAgICAgIHJlY29yZGluZzogZmFsc2UsXG4gICAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICAgIGRhdGE6IHRoaXMuc2V0dGluZ3MuZGF0YSxcblxuICAgICAgLy8gRXhwb3J0IHNvbWUgc3BlY2lmaWMgYWN0aW9ucyB0byB0aGUgc2tldGNoXG4gICAgICByZW5kZXI6ICgpID0+IHRoaXMucmVuZGVyKCksXG4gICAgICB0b2dnbGVQbGF5OiAoKSA9PiB0aGlzLnRvZ2dsZVBsYXkoKSxcbiAgICAgIGRpc3BhdGNoOiAoY2IpID0+IHRoaXMuZGlzcGF0Y2goY2IpLFxuICAgICAgdGljazogKCkgPT4gdGhpcy50aWNrKCksXG4gICAgICByZXNpemU6ICgpID0+IHRoaXMucmVzaXplKCksXG4gICAgICB1cGRhdGU6IChvcHQpID0+IHRoaXMudXBkYXRlKG9wdCksXG4gICAgICBleHBvcnRGcmFtZTogb3B0ID0+IHRoaXMuZXhwb3J0RnJhbWUob3B0KSxcbiAgICAgIHJlY29yZDogKCkgPT4gdGhpcy5yZWNvcmQoKSxcbiAgICAgIHBsYXk6ICgpID0+IHRoaXMucGxheSgpLFxuICAgICAgcGF1c2U6ICgpID0+IHRoaXMucGF1c2UoKSxcbiAgICAgIHN0b3A6ICgpID0+IHRoaXMuc3RvcCgpXG4gICAgfTtcblxuICAgIC8vIEZvciBXZWJHTCBza2V0Y2hlcywgYSBnbCB2YXJpYWJsZSByZWFkcyBhIGJpdCBiZXR0ZXJcbiAgICB0aGlzLl9zZXR1cEdMS2V5KCk7XG5cbiAgICAvLyBUcmlnZ2VyIGluaXRpYWwgcmVzaXplIG5vdyBzbyB0aGF0IGNhbnZhcyBpcyBhbHJlYWR5IHNpemVkXG4gICAgLy8gYnkgdGhlIHRpbWUgd2UgbG9hZCB0aGUgc2tldGNoXG4gICAgdGhpcy5yZXNpemUoKTtcbiAgfVxuXG4gIGxvYWRBbmRSdW4gKGNhbnZhc1NrZXRjaCwgbmV3U2V0dGluZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkKGNhbnZhc1NrZXRjaCwgbmV3U2V0dGluZ3MpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG5cbiAgdW5sb2FkICgpIHtcbiAgICB0aGlzLnBhdXNlKCk7XG4gICAgaWYgKCF0aGlzLnNrZXRjaCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdGhpcy5za2V0Y2gudW5sb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93cmFwQ29udGV4dFNjYWxlKHByb3BzID0+IHRoaXMuc2tldGNoLnVubG9hZChwcm9wcykpO1xuICAgIH1cbiAgICB0aGlzLl9za2V0Y2ggPSBudWxsO1xuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgdGhpcy51bmxvYWQoKTtcbiAgICB0aGlzLnVubW91bnQoKTtcbiAgfVxuXG4gIGxvYWQgKGNyZWF0ZVNrZXRjaCwgbmV3U2V0dGluZ3MpIHtcbiAgICAvLyBVc2VyIGRpZG4ndCBzcGVjaWZ5IGEgZnVuY3Rpb25cbiAgICBpZiAodHlwZW9mIGNyZWF0ZVNrZXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZnVuY3Rpb24gbXVzdCB0YWtlIGluIGEgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IHBhcmFtZXRlci4gRXhhbXBsZTpcXG4gIGNhbnZhc1NrZXRjaGVyKCgpID0+IHsgLi4uIH0sIHNldHRpbmdzKScpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNrZXRjaCkge1xuICAgICAgdGhpcy51bmxvYWQoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld1NldHRpbmdzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy51cGRhdGUobmV3U2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSB0cmlja3kgY2FzZTsgd2Ugc2V0IHVwIHRoZSBhdXRvLXNjYWxpbmcgaGVyZVxuICAgIC8vIGluIGNhc2UgdGhlIHVzZXIgZGVjaWRlcyB0byByZW5kZXIgYW55dGhpbmcgdG8gdGhlIGNvbnRleHQgKmJlZm9yZSogdGhlXG4gICAgLy8gcmVuZGVyKCkgZnVuY3Rpb24uLi4gSG93ZXZlciwgdXNlcnMgc2hvdWxkIGluc3RlYWQgdXNlIGJlZ2luKCkgZnVuY3Rpb24gZm9yIHRoYXQuXG4gICAgdGhpcy5fcHJlUmVuZGVyKCk7XG5cbiAgICBsZXQgcHJlbG9hZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgLy8gQmVjYXVzZSBvZiBQNS5qcydzIHVudXN1YWwgc3RydWN0dXJlLCB3ZSBoYXZlIHRvIGRvIGEgYml0IG9mXG4gICAgLy8gbGlicmFyeS1zcGVjaWZpYyBjaGFuZ2VzIHRvIHN1cHBvcnQgaXQgcHJvcGVybHkuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MucDUpIHtcbiAgICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbY2FudmFzLXNrZXRjaF0gRVJST1I6IFVzaW5nIHA1LmpzIGluIE5vZGUuanMgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgcHJlbG9hZCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBsZXQgUDVDb25zdHJ1Y3RvciA9IHRoaXMuc2V0dGluZ3MucDU7XG4gICAgICAgIGxldCBwcmVsb2FkO1xuICAgICAgICBpZiAoUDVDb25zdHJ1Y3Rvci5wNSkge1xuICAgICAgICAgIHByZWxvYWQgPSBQNUNvbnN0cnVjdG9yLnByZWxvYWQ7XG4gICAgICAgICAgUDVDb25zdHJ1Y3RvciA9IFA1Q29uc3RydWN0b3IucDU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgc2tldGNoIHNldHVwOyBkaXNhYmxlIGxvb3AsIHNldCBzaXppbmcsIGV0Yy5cbiAgICAgICAgY29uc3QgcDVTa2V0Y2ggPSBwNSA9PiB7XG4gICAgICAgICAgLy8gSG9vayBpbiBwcmVsb2FkIGlmIG5lY2Vzc2FyeVxuICAgICAgICAgIGlmIChwcmVsb2FkKSBwNS5wcmVsb2FkID0gKCkgPT4gcHJlbG9hZChwNSk7XG4gICAgICAgICAgcDUuc2V0dXAgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCBpc0dMID0gdGhpcy5zZXR0aW5ncy5jb250ZXh0ID09PSAnd2ViZ2wnO1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBpc0dMID8gcDUuV0VCR0wgOiBwNS5QMkQ7XG4gICAgICAgICAgICBwNS5ub0xvb3AoKTtcbiAgICAgICAgICAgIHA1LnBpeGVsRGVuc2l0eShwcm9wcy5waXhlbFJhdGlvKTtcbiAgICAgICAgICAgIHA1LmNyZWF0ZUNhbnZhcyhwcm9wcy52aWV3cG9ydFdpZHRoLCBwcm9wcy52aWV3cG9ydEhlaWdodCwgcmVuZGVyZXIpO1xuICAgICAgICAgICAgaWYgKGlzR0wgJiYgdGhpcy5zZXR0aW5ncy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIHA1LnNldEF0dHJpYnV0ZXModGhpcy5zZXR0aW5ncy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBwNSwgY2FudmFzOiBwNS5jYW52YXMsIGNvbnRleHQ6IHA1Ll9yZW5kZXJlci5kcmF3aW5nQ29udGV4dCB9KTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1cHBvcnQgZ2xvYmFsIGFuZCBpbnN0YW5jZSBQNS5qcyBtb2Rlc1xuICAgICAgICBpZiAodHlwZW9mIFA1Q29uc3RydWN0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBuZXcgUDVDb25zdHJ1Y3RvcihwNVNrZXRjaCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuY3JlYXRlQ2FudmFzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ7IHA1IH0gc2V0dGluZyBpcyBwYXNzZWQgYnV0IGNhbid0IGZpbmQgcDUuanMgaW4gZ2xvYmFsICh3aW5kb3cpIHNjb3BlLiBNYXliZSB5b3UgZGlkIG5vdCBjcmVhdGUgaXQgZ2xvYmFsbHk/XFxubmV3IHA1KCk7IC8vIDwtLSBhdHRhY2hlcyB0byBnbG9iYWwgc2NvcGVcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHA1U2tldGNoKHdpbmRvdyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVsb2FkLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gTG9hZCB0aGUgdXNlcidzIHNrZXRjaFxuICAgICAgbGV0IGxvYWRlciA9IGNyZWF0ZVNrZXRjaCh0aGlzLnByb3BzKTtcbiAgICAgIGlmICghaXNQcm9taXNlKGxvYWRlcikpIHtcbiAgICAgICAgbG9hZGVyID0gUHJvbWlzZS5yZXNvbHZlKGxvYWRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9hZGVyO1xuICAgIH0pLnRoZW4oc2tldGNoID0+IHtcbiAgICAgIGlmICghc2tldGNoKSBza2V0Y2ggPSB7fTtcbiAgICAgIHRoaXMuX3NrZXRjaCA9IHNrZXRjaDtcblxuICAgICAgLy8gT25jZSB0aGUgc2tldGNoIGlzIGxvYWRlZCB3ZSBjYW4gYWRkIHRoZSBldmVudHNcbiAgICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgICB0aGlzLl9rZXlib2FyZFNob3J0Y3V0cy5hdHRhY2goKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wb3N0UmVuZGVyKCk7XG5cbiAgICAgIC8vIFRoZSBpbml0aWFsIHJlc2l6ZSgpIGluIHRoZSBjb25zdHJ1Y3RvciB3aWxsIG5vdCBoYXZlXG4gICAgICAvLyB0cmlnZ2VyZWQgYSByZXNpemUoKSBldmVudCBvbiB0aGUgc2tldGNoLCBzaW5jZSBpdCB3YXMgYmVmb3JlXG4gICAgICAvLyB0aGUgc2tldGNoIHdhcyBsb2FkZWQuIFNvIHdlIHNlbmQgdGhlIHNpZ25hbCBoZXJlLCBhbGxvd2luZ1xuICAgICAgLy8gdXNlcnMgdG8gcmVhY3QgdG8gdGhlIGluaXRpYWwgc2l6ZSBiZWZvcmUgZmlyc3QgcmVuZGVyLlxuICAgICAgdGhpcy5fc2l6ZUNoYW5nZWQoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBzdGFydCBza2V0Y2gsIHRoZSBhc3luYyBsb2FkaW5nIGZ1bmN0aW9uIHJlamVjdGVkIHdpdGggYW4gZXJyb3I6XFxuICAgIEVycm9yOiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNrZXRjaE1hbmFnZXI7XG4iLCJpbXBvcnQgU2tldGNoTWFuYWdlciBmcm9tICcuL2NvcmUvU2tldGNoTWFuYWdlcic7XG5pbXBvcnQgUGFwZXJTaXplcyBmcm9tICcuL3BhcGVyLXNpemVzJztcbmltcG9ydCB7IGdldENsaWVudEFQSSwgZGVmaW5lZCB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IENBQ0hFID0gJ2hvdC1pZC1jYWNoZSc7XG5jb25zdCBydW50aW1lQ29sbGlzaW9ucyA9IFtdO1xuXG5mdW5jdGlvbiBpc0hvdFJlbG9hZCAoKSB7XG4gIGNvbnN0IGNsaWVudCA9IGdldENsaWVudEFQSSgpO1xuICByZXR1cm4gY2xpZW50ICYmIGNsaWVudC5ob3Q7XG59XG5cbmZ1bmN0aW9uIGNhY2hlR2V0IChpZCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgaWYgKCFjbGllbnQpIHJldHVybiB1bmRlZmluZWQ7XG4gIGNsaWVudFtDQUNIRV0gPSBjbGllbnRbQ0FDSEVdIHx8IHt9O1xuICByZXR1cm4gY2xpZW50W0NBQ0hFXVtpZF07XG59XG5cbmZ1bmN0aW9uIGNhY2hlUHV0IChpZCwgZGF0YSkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgaWYgKCFjbGllbnQpIHJldHVybiB1bmRlZmluZWQ7XG4gIGNsaWVudFtDQUNIRV0gPSBjbGllbnRbQ0FDSEVdIHx8IHt9O1xuICBjbGllbnRbQ0FDSEVdW2lkXSA9IGRhdGE7XG59XG5cbmZ1bmN0aW9uIGdldFRpbWVQcm9wIChvbGRNYW5hZ2VyLCBuZXdTZXR0aW5ncykge1xuICAvLyBTdGF0aWMgc2tldGNoZXMgaWdub3JlIHRoZSB0aW1lIHBlcnNpc3RlbmN5XG4gIHJldHVybiBuZXdTZXR0aW5ncy5hbmltYXRlID8geyB0aW1lOiBvbGRNYW5hZ2VyLnByb3BzLnRpbWUgfSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gY2FudmFzU2tldGNoIChza2V0Y2gsIHNldHRpbmdzID0ge30pIHtcbiAgaWYgKHNldHRpbmdzLnA1KSB7XG4gICAgaWYgKHNldHRpbmdzLmNhbnZhcyB8fCAoc2V0dGluZ3MuY29udGV4dCAmJiB0eXBlb2Ygc2V0dGluZ3MuY29udGV4dCAhPT0gJ3N0cmluZycpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluIHsgcDUgfSBtb2RlLCB5b3UgY2FuJ3QgcGFzcyB5b3VyIG93biBjYW52YXMgb3IgY29udGV4dCwgdW5sZXNzIHRoZSBjb250ZXh0IGlzIGEgXCJ3ZWJnbFwiIG9yIFwiMmRcIiBzdHJpbmdgKTtcbiAgICB9XG5cbiAgICAvLyBEbyBub3QgY3JlYXRlIGEgY2FudmFzIG9uIHN0YXJ0dXAsIHNpbmNlIFA1LmpzIGRvZXMgdGhhdCBmb3IgdXNcbiAgICBjb25zdCBjb250ZXh0ID0gdHlwZW9mIHNldHRpbmdzLmNvbnRleHQgPT09ICdzdHJpbmcnID8gc2V0dGluZ3MuY29udGV4dCA6IGZhbHNlO1xuICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgc2V0dGluZ3MsIHsgY2FudmFzOiBmYWxzZSwgY29udGV4dCB9KTtcbiAgfVxuXG4gIGNvbnN0IGlzSG90ID0gaXNIb3RSZWxvYWQoKTtcbiAgbGV0IGhvdElEO1xuICBpZiAoaXNIb3QpIHtcbiAgICAvLyBVc2UgYSBtYWdpYyBuYW1lIGJ5IGRlZmF1bHQsIGZvcmNlIHVzZXIgdG8gZGVmaW5lIGVhY2ggc2tldGNoIGlmIHRoZXlcbiAgICAvLyByZXF1aXJlIG1vcmUgdGhhbiBvbmUgaW4gYW4gYXBwbGljYXRpb24uIE9wZW4gdG8gb3RoZXIgaWRlYXMgb24gaG93IHRvIHRhY2tsZVxuICAgIC8vIHRoaXMgYXMgd2VsbC4uLlxuICAgIGhvdElEID0gZGVmaW5lZChzZXR0aW5ncy5pZCwgJyRfX0RFRkFVTFRfQ0FOVkFTX1NLRVRDSF9JRF9fJCcpO1xuICB9XG4gIGxldCBpc0luamVjdGluZyA9IGlzSG90ICYmIHR5cGVvZiBob3RJRCA9PT0gJ3N0cmluZyc7XG5cbiAgaWYgKGlzSW5qZWN0aW5nICYmIHJ1bnRpbWVDb2xsaXNpb25zLmluY2x1ZGVzKGhvdElEKSkge1xuICAgIGNvbnNvbGUud2FybihgV2FybmluZzogWW91IGhhdmUgbXVsdGlwbGUgY2FsbHMgdG8gY2FudmFzU2tldGNoKCkgaW4gLS1ob3QgbW9kZS4gWW91IG11c3QgcGFzcyB1bmlxdWUgeyBpZCB9IHN0cmluZ3MgaW4gc2V0dGluZ3MgdG8gZW5hYmxlIGhvdCByZWxvYWQgYWNyb3NzIG11bHRpcGxlIHNrZXRjaGVzLiBgLCBob3RJRCk7XG4gICAgaXNJbmplY3RpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGxldCBwcmVsb2FkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbiAgaWYgKGlzSW5qZWN0aW5nKSB7XG4gICAgLy8gTWFyayB0aGlzIGFzIGFscmVhZHkgc3BvdHRlZCBpbiB0aGlzIHJ1bnRpbWUgaW5zdGFuY2VcbiAgICBydW50aW1lQ29sbGlzaW9ucy5wdXNoKGhvdElEKTtcblxuICAgIGNvbnN0IHByZXZpb3VzRGF0YSA9IGNhY2hlR2V0KGhvdElEKTtcbiAgICBpZiAocHJldmlvdXNEYXRhKSB7XG4gICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAvLyBHcmFiIG5ldyBwcm9wcyBmcm9tIG9sZCBza2V0Y2ggaW5zdGFuY2VcbiAgICAgICAgY29uc3QgbmV3UHJvcHMgPSBnZXRUaW1lUHJvcChwcmV2aW91c0RhdGEubWFuYWdlciwgc2V0dGluZ3MpO1xuICAgICAgICAvLyBEZXN0cm95IHRoZSBvbGQgaW5zdGFuY2VcbiAgICAgICAgcHJldmlvdXNEYXRhLm1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICAvLyBQYXNzIGFsb25nIG5ldyBwcm9wc1xuICAgICAgICByZXR1cm4gbmV3UHJvcHM7XG4gICAgICB9O1xuXG4gICAgICAvLyBNb3ZlIGFsb25nIHRoZSBuZXh0IGRhdGEuLi5cbiAgICAgIHByZWxvYWQgPSBwcmV2aW91c0RhdGEubG9hZC50aGVuKG5leHQpLmNhdGNoKG5leHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmVsb2FkLnRoZW4obmV3UHJvcHMgPT4ge1xuICAgIGNvbnN0IG1hbmFnZXIgPSBuZXcgU2tldGNoTWFuYWdlcigpO1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKHNrZXRjaCkge1xuICAgICAgLy8gTWVyZ2Ugd2l0aCBpbmNvbWluZyBkYXRhXG4gICAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLCBuZXdQcm9wcyk7XG5cbiAgICAgIC8vIEFwcGx5IHNldHRpbmdzIGFuZCBjcmVhdGUgYSBjYW52YXNcbiAgICAgIG1hbmFnZXIuc2V0dXAoc2V0dGluZ3MpO1xuXG4gICAgICAvLyBNb3VudCB0byBET01cbiAgICAgIG1hbmFnZXIubW91bnQoKTtcblxuICAgICAgLy8gbG9hZCB0aGUgc2tldGNoIGZpcnN0XG4gICAgICByZXN1bHQgPSBtYW5hZ2VyLmxvYWRBbmRSdW4oc2tldGNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gUHJvbWlzZS5yZXNvbHZlKG1hbmFnZXIpO1xuICAgIH1cbiAgICBpZiAoaXNJbmplY3RpbmcpIHtcbiAgICAgIGNhY2hlUHV0KGhvdElELCB7IGxvYWQ6IHJlc3VsdCwgbWFuYWdlciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSk7XG59XG5cbi8vIFRPRE86IEZpZ3VyZSBvdXQgYSBuaWNlIHdheSB0byBleHBvcnQgdGhpbmdzLlxuY2FudmFzU2tldGNoLmNhbnZhc1NrZXRjaCA9IGNhbnZhc1NrZXRjaDtcbmNhbnZhc1NrZXRjaC5QYXBlclNpemVzID0gUGFwZXJTaXplcztcblxuZXhwb3J0IGRlZmF1bHQgY2FudmFzU2tldGNoO1xuIiwiLypcbk1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxMiAtIDIwMjEgam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuU09GVFdBUkUuXG4qL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuVHdvID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uQ29tbWFuZHNcbiAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gTWFwIG9mIHBvc3NpYmxlIHBhdGggY29tbWFuZHMuIFRha2VuIGZyb20gdGhlIFNWRyBzcGVjaWZpY2F0aW9uLlxuICAgKi9cbiAgdmFyIENvbW1hbmRzID0ge1xuICAgIG1vdmU6ICdNJyxcbiAgICBsaW5lOiAnTCcsXG4gICAgY3VydmU6ICdDJyxcbiAgICBhcmM6ICdBJyxcbiAgICBjbG9zZTogJ1onXG4gIH07XG5cbiAgdmFyIHJvb3Q7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJvb3QgPSB3aW5kb3c7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByb290ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJvb3QgPSBzZWxmO1xuICB9XG5cbiAgdmFyIHJvb3QkMSA9IHJvb3Q7XG5cbiAgdmFyIE1hdHJpeCQxO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZGVjb21wb3NlTWF0cml4XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IG1hdHJpeCAtIFRoZSBtYXRyaXggdG8gZGVjb21wb3NlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyByZWxldmFudCBza2V3IHZhbHVlcy5cbiAgICogQGRlc2NyaXB0aW9uIERlY29tcG9zZSBhIDJEIDN4MyBNYXRyaXggdG8gZmluZCB0aGUgc2tldy5cbiAgICovXG4gIHZhciBkZWNvbXBvc2VNYXRyaXggPSBmdW5jdGlvbihtYXRyaXgpIHtcblxuICAgIC8vIFRPRE86IEluY2x1ZGUgc2tld1gsIHNrZXdZXG4gICAgLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8yMzczNjkvZ2l2ZW4tdGhpcy10cmFuc2Zvcm1hdGlvbi1tYXRyaXgtaG93LWRvLWktZGVjb21wb3NlLWl0LWludG8tdHJhbnNsYXRpb24tcm90YXRpLzQxNzgxM1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ1MTU5MzE0L2RlY29tcG9zZS0yZC10cmFuc2Zvcm1hdGlvbi1tYXRyaXhcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRyYW5zbGF0ZVg6IG1hdHJpeC5lLFxuICAgICAgICB0cmFuc2xhdGVZOiBtYXRyaXguZixcbiAgICAgICAgc2NhbGVYOiBNYXRoLnNxcnQobWF0cml4LmEgKiBtYXRyaXguYSArIG1hdHJpeC5iICogbWF0cml4LmIpLFxuICAgICAgICBzY2FsZVk6IE1hdGguc3FydChtYXRyaXguYyAqIG1hdHJpeC5jICsgbWF0cml4LmQgKiBtYXRyaXguZCksXG4gICAgICAgIHJvdGF0aW9uOiAxODAgKiBNYXRoLmF0YW4yKG1hdHJpeC5iLCBtYXRyaXguYSkgLyBNYXRoLlBJXG4gICAgfTtcblxuICB9O1xuXG4gIHZhciBzZXRNYXRyaXggPSBmdW5jdGlvbihNKSB7XG4gICAgTWF0cml4JDEgPSBNO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q29tcHV0ZWRNYXRyaXhcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7VHdvLlNoYXBlfSBvYmplY3QgLSBUaGUgVHdvLmpzIG9iamVjdCB0aGF0IGhhcyBhIG1hdHJpeCBwcm9wZXJ0eSB0byBjYWxjdWxhdGUgZnJvbS5cbiAgICogQHBhcmFtIHtUd28uTWF0cml4fSBbbWF0cml4XSAtIFRoZSBtYXRyaXggdG8gYXBwbHkgY2FsY3VsYXRlZCB0cmFuc2Zvcm1hdGlvbnMgdG8gaWYgYXZhaWxhYmxlLlxuICAgKiBAcmV0dXJucyB7VHdvLk1hdHJpeH0gVGhlIGNvbXB1dGVkIG1hdHJpeCBvZiBhIG5lc3RlZCBvYmplY3QuIElmIG5vIGBtYXRyaXhgIHdhcyBwYXNzZWQgaW4gYXJndW1lbnRzIHRoZW4gYSBgbmV3IFR3by5NYXRyaXhgIGlzIHJldHVybmVkLlxuICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRvIGdldCB0aGUgd29ybGQgc3BhY2UgdHJhbnNmb3JtYXRpb24gb2YgYSBnaXZlbiBvYmplY3QgaW4gYSBUd28uanMgc2NlbmUuXG4gICAqL1xuICB2YXIgZ2V0Q29tcHV0ZWRNYXRyaXggPSBmdW5jdGlvbihvYmplY3QsIG1hdHJpeCkge1xuXG4gICAgbWF0cml4ID0gKG1hdHJpeCAmJiBtYXRyaXguaWRlbnRpdHkoKSkgfHwgbmV3IE1hdHJpeCQxKCk7XG4gICAgdmFyIHBhcmVudCA9IG9iamVjdCwgbWF0cmljZXMgPSBbXTtcblxuICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9tYXRyaXgpIHtcbiAgICAgIG1hdHJpY2VzLnB1c2gocGFyZW50Ll9tYXRyaXgpO1xuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICB9XG5cbiAgICBtYXRyaWNlcy5yZXZlcnNlKCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hdHJpY2VzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIHZhciBtID0gbWF0cmljZXNbaV07XG4gICAgICB2YXIgZSA9IG0uZWxlbWVudHM7XG4gICAgICBtYXRyaXgubXVsdGlwbHkoXG4gICAgICAgIGVbMF0sIGVbMV0sIGVbMl0sIGVbM10sIGVbNF0sIGVbNV0sIGVbNl0sIGVbN10sIGVbOF0sIGVbOV0pO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdHJpeDtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMubGVycFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBTdGFydCB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGIgLSBFbmQgdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0IC0gWmVyby10by1vbmUgdmFsdWUgZGVzY3JpYmluZyBwZXJjZW50YWdlIGJldHdlZW4gYSBhbmQgYi5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIExpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZhbHVlcyBgYWAgYW5kIGBiYCBieSBhbiBhbW91bnQgYHRgLlxuICAgKi9cbiAgdmFyIGxlcnAgPSBmdW5jdGlvbihhLCBiLCB0KSB7XG4gICAgcmV0dXJuIHQgKiAoYiAtIGEpICsgYTtcbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLm1vZFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHYgLSBUaGUgdmFsdWUgdG8gbW9kdWxvXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBsIC0gVGhlIHZhbHVlIHRvIG1vZHVsbyBieVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gTW9kdWxvIHdpdGggYWRkZWQgZnVuY3Rpb25hbGl0eSB0byBoYW5kbGUgbmVnYXRpdmUgdmFsdWVzIGluIGEgcG9zaXRpdmUgbWFubmVyLlxuICAgKi9cbiAgdmFyIG1vZCA9IGZ1bmN0aW9uKHYsIGwpIHtcblxuICAgIHdoaWxlICh2IDwgMCkge1xuICAgICAgdiArPSBsO1xuICAgIH1cblxuICAgIHJldHVybiB2ICUgbDtcblxuICB9O1xuXG4gIHZhciBOdW1BcnJheSA9IHJvb3QkMS5GbG9hdDMyQXJyYXkgfHwgQXJyYXk7XG5cbiAgLyoqXG4gICogQG5hbWUgVHdvLlV0aWxzLnRvRml4ZWRcbiAgKiBAZnVuY3Rpb25cbiAgKiBAcGFyYW0ge051bWJlcn0gdiAtIEFueSBmbG9hdFxuICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoYXQgZmxvYXQgdHJpbW1lZCB0byB0aGUgdGhpcmQgZGVjaW1hbCBwbGFjZS5cbiAgKiBAZGVzY3JpcHRpb24gQSBwcmV0dHkgZmFzdCB0b0ZpeGVkKDMpIGFsdGVybmF0aXZlLlxuICAqIEBzZWUge0BsaW5rIGh0dHA6Ly9qc3BlcmYuY29tL3BhcnNlZmxvYXQtdG9maXhlZC12cy1tYXRoLXJvdW5kLzE4fVxuICAqL1xuICB2YXIgdG9GaXhlZCA9IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcih2ICogMTAwMDAwMCkgLyAxMDAwMDAwO1xuICB9O1xuXG4gIHZhciBtYXRoID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBkZWNvbXBvc2VNYXRyaXg6IGRlY29tcG9zZU1hdHJpeCxcbiAgICBnZXRDb21wdXRlZE1hdHJpeDogZ2V0Q29tcHV0ZWRNYXRyaXgsXG4gICAgc2V0TWF0cml4OiBzZXRNYXRyaXgsXG4gICAgbGVycDogbGVycCxcbiAgICBtb2Q6IG1vZCxcbiAgICBOdW1BcnJheTogTnVtQXJyYXksXG4gICAgdG9GaXhlZDogdG9GaXhlZFxuICB9KTtcblxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIGlmIChjb2xsZWN0aW9uID09PSBudWxsIHx8IGNvbGxlY3Rpb24gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAvLyBBcnJheXMgY2Fubm90IGhvbGQgbW9yZSB0aGFuIDJeMzIgLSAxIGl0ZW1zXG4gICAgcmV0dXJuICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGxlbmd0aCA+PSAwICYmIGxlbmd0aCA8IDQyOTQ5NjcyOTYpO1xuICB9O1xuXG4gIHZhciBfID0ge1xuICAgIGlzTmFOOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnbnVtYmVyJyAmJiBvYmogIT09ICtvYmo7XG4gICAgfSxcbiAgICBpc0VsZW1lbnQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICAgIH0sXG4gICAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gICAgfSxcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBzb3VyY2VzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgIGJhc2Vba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH0sXG4gICAgZGVmYXVsdHM6IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICAgIHZhciBzb3VyY2VzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmogPSBzb3VyY2VzW2ldO1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgIGlmIChiYXNlW2tdID09PSB2b2lkIDApIHtcbiAgICAgICAgICBiYXNlW2tdID0gb2JqW2tdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSxcbiAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgY3R4ID0gY29udGV4dCB8fCB0aGlzO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgdmFyIGxlbmd0aCA9IChrZXlzIHx8IG9iaikubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgayA9IGtleXMgPyBrZXlzW2ldIDogaTtcbiAgICAgICAgaXRlcmF0ZWUuY2FsbChjdHgsIG9ialtrXSwgaywgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVXRpbHMucGVyZm9ybWFuY2VcbiAgICAgKiBAcHJvcGVydHkge0RhdGV9IC0gQSBzcGVjaWFsIGBEYXRlYCBsaWtlIG9iamVjdCB0byBnZXQgdGhlIGN1cnJlbnQgbWlsbGlzIG9mIHRoZSBzZXNzaW9uLiBVc2VkIGludGVybmFsbHkgdG8gY2FsY3VsYXRlIHRpbWUgYmV0d2VlbiBmcmFtZXMuXG4gICAgICogZS5nOiBgVXRpbHMucGVyZm9ybWFuY2Uubm93KCkgLy8gbWlsbGlzZWNvbmRzIHNpbmNlIGVwb2NoYFxuICAgICAqL1xuICAgIHBlcmZvcm1hbmNlOiAoKHJvb3QkMS5wZXJmb3JtYW5jZSAmJiByb290JDEucGVyZm9ybWFuY2Uubm93KSA/IHJvb3QkMS5wZXJmb3JtYW5jZSA6IERhdGUpLFxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uRXZlbnRzXG4gICAqIEBjbGFzc1xuICAgKiBAZGVzY3JpcHRpb24gT2JqZWN0IGluaGVyaXRlZCBieSBtYW55IFR3by5qcyBvYmplY3RzIGluIG9yZGVyIHRvIGZhY2lsaXRhdGUgY3VzdG9tIGV2ZW50cy5cbiAgICovXG4gIHZhciBFdmVudHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRXZlbnRzI29uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBiaW5kIGEgZnVuY3Rpb24gdG8uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgZXZlbnQgaXMgZGlzcGF0Y2hlZC5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbCB0byBhZGQgYSBsaXN0ZW5lciB0byBhIHNwZWNpZmljIGV2ZW50IG5hbWUuXG4gICAgICovXG4gICAgb246IGFkZEV2ZW50TGlzdGVuZXIsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRXZlbnRzI29mZlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZV0gLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgaW50ZW5kZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBUaGUgaGFuZGxlciBpbnRlbmRlZCB0byBiZSByZW9tdmVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIHJlbW92ZSBsaXN0ZW5lcnMgZnJvbSBhIHNwZWNpZmljIGV2ZW50LiBJZiBvbmx5IGBuYW1lYCBpcyBwYXNzZWQgdGhlbiBhbGwgdGhlIGhhbmRsZXJzIGF0dGFjaGVkIHRvIHRoYXQgYG5hbWVgIHdpbGwgYmUgcmVtb3ZlZC4gSWYgbm8gYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhlbiBhbGwgaGFuZGxlcnMgZm9yIGV2ZXJ5IGV2ZW50IG9uIHRoZSBvYmVqY3QgYXJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgb2ZmOiByZW1vdmVFdmVudExpc3RlbmVyLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkV2ZW50cyN0cmlnZ2VyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZGlzcGF0Y2guXG4gICAgICogQHBhcmFtIGFyZ3VtZW50cyAtIEFueXRoaW5nIGNhbiBiZSBwYXNzZWQgYWZ0ZXIgdGhlIG5hbWUgYW5kIHRob3NlIHdpbGwgYmUgcGFzc2VkIG9uIHRvIGhhbmRsZXJzIGF0dGFjaGVkIHRvIHRoZSBldmVudCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcGFzc2VkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIHRyaWdnZXIgYSBjdXN0b20gZXZlbnQuIEFueSBhZGRpdGlvbmFsIGFyZ3VtZW50cyBwYXNzZWQgYWZ0ZXIgdGhlIG5hbWUgd2lsbCBiZSBwYXNzZWQgYWxvbmcgdG8gdGhlIGF0dGFjaGVkIGhhbmRsZXJzLlxuICAgICAqL1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICBpZiAoIXNjb3BlLl9ldmVudHMpIHJldHVybiBzY29wZTtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgIHZhciBldmVudHMgPSBzY29wZS5fZXZlbnRzW25hbWVdO1xuICAgICAgaWYgKGV2ZW50cykgZGlzcGF0Y2goc2NvcGUsIGV2ZW50cywgYXJncyk7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfSxcblxuICAgIGxpc3RlbjogZnVuY3Rpb24ob2JqLCBuYW1lLCBoYW5kbGVyKSB7XG5cbiAgICAgIHZhciBib3VuZCA9IHRoaXM7XG5cbiAgICAgIGlmIChvYmopIHtcblxuICAgICAgICB2YXIgZXZlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaGFuZGxlci5hcHBseShib3VuZCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBZGQgcmVmZXJlbmNlcyBhYm91dCB0aGUgb2JqZWN0IHRoYXQgYXNzaWduZWQgdGhpcyBsaXN0ZW5lclxuICAgICAgICBldmVudC5vYmogPSBvYmo7XG4gICAgICAgIGV2ZW50Lm5hbWUgPSBuYW1lO1xuICAgICAgICBldmVudC5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgICBvYmoub24obmFtZSwgZXZlbnQpO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib3VuZDtcblxuICAgIH0sXG5cbiAgICBpZ25vcmU6IGZ1bmN0aW9uKG9iaiwgbmFtZSwgaGFuZGxlcikge1xuXG4gICAgICB2YXIgc2NvcGUgPSB0aGlzO1xuICAgICAgb2JqLm9mZihuYW1lLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybiBzY29wZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRXZlbnRzLlR5cGVzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gT2JqZWN0IG9mIGRpZmZlcmVudCB0eXBlcyBvZiBUd28uanMgc3BlY2lmaWMgZXZlbnRzLlxuICAgICAqL1xuICAgIFR5cGVzOiB7XG4gICAgICBwbGF5OiAncGxheScsXG4gICAgICBwYXVzZTogJ3BhdXNlJyxcbiAgICAgIHVwZGF0ZTogJ3VwZGF0ZScsXG4gICAgICByZW5kZXI6ICdyZW5kZXInLFxuICAgICAgcmVzaXplOiAncmVzaXplJyxcbiAgICAgIGNoYW5nZTogJ2NoYW5nZScsXG4gICAgICByZW1vdmU6ICdyZW1vdmUnLFxuICAgICAgaW5zZXJ0OiAnaW5zZXJ0JyxcbiAgICAgIG9yZGVyOiAnb3JkZXInLFxuICAgICAgbG9hZDogJ2xvYWQnXG4gICAgfVxuXG4gIH07XG5cblxuICAvKipcbiAgICogQG5hbWUgVHdvLkV2ZW50cy5iaW5kXG4gICAqIEBmdW5jdGlvblxuICAgKiBAZGVzY3JpcHRpb24gQWxpYXMgZm9yIHtAbGluayBUd28uRXZlbnRzLm9ufS5cbiAgICovXG4gIEV2ZW50cy5iaW5kID0gYWRkRXZlbnRMaXN0ZW5lcjtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLkV2ZW50cy51bmJpbmRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5FdmVudHMub2ZmfS5cbiAgICovXG4gIEV2ZW50cy51bmJpbmQgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7VHdvLkV2ZW50c30gLSBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIHNlbGYgZm9yIHRoZSBwdXJwb3NlIG9mIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgc2NvcGUuX2V2ZW50cyB8fCAoc2NvcGUuX2V2ZW50cyA9IHt9KTtcbiAgICB2YXIgbGlzdCA9IHNjb3BlLl9ldmVudHNbbmFtZV0gfHwgKHNjb3BlLl9ldmVudHNbbmFtZV0gPSBbXSk7XG5cbiAgICBsaXN0LnB1c2goaGFuZGxlcik7XG5cbiAgICByZXR1cm4gc2NvcGU7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcmV0dXJucyB7VHdvLkV2ZW50c30gLSBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIHNlbGYgZm9yIHRoZSBwdXJwb3NlIG9mIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG5cbiAgICB2YXIgc2NvcGUgPSB0aGlzO1xuXG4gICAgaWYgKCFzY29wZS5fZXZlbnRzKSB7XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuICAgIGlmICghbmFtZSAmJiAhaGFuZGxlcikge1xuICAgICAgc2NvcGUuX2V2ZW50cyA9IHt9O1xuICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cblxuICAgIHZhciBuYW1lcyA9IG5hbWUgPyBbbmFtZV0gOiBPYmplY3Qua2V5cyhzY29wZS5fZXZlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXG4gICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICB2YXIgbGlzdCA9IHNjb3BlLl9ldmVudHNbbmFtZV07XG5cbiAgICAgIGlmIChsaXN0KSB7XG4gICAgICAgIHZhciBldmVudHMgPSBbXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IGxpc3QubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZXYgPSBsaXN0W2pdO1xuICAgICAgICAgICAgZXYgPSBldi5oYW5kbGVyID8gZXYuaGFuZGxlciA6IGV2O1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIgJiYgaGFuZGxlciAhPT0gZXYpIHtcbiAgICAgICAgICAgICAgZXZlbnRzLnB1c2goZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY29wZS5fZXZlbnRzW25hbWVdID0gZXZlbnRzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY29wZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoKG9iaiwgZXZlbnRzLCBhcmdzKSB7XG4gICAgdmFyIG1ldGhvZDtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOlxuICAgICAgbWV0aG9kID0gZnVuY3Rpb24oaSkge1xuICAgICAgICBldmVudHNbaV0uY2FsbChvYmosIGFyZ3NbMF0pO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgZXZlbnRzW2ldLmNhbGwob2JqLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBtZXRob2QgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIGV2ZW50c1tpXS5jYWxsKG9iaiwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgbWV0aG9kID0gZnVuY3Rpb24oaSkge1xuICAgICAgICBldmVudHNbaV0uY2FsbChvYmosIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtZXRob2QgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIGV2ZW50c1tpXS5hcHBseShvYmosIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG1ldGhvZChpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgVHdvLlZlY3RvclxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gQW55IG51bWJlciB0byByZXByZXNlbnQgdGhlIGhvcml6b250YWwgeC1jb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gQW55IG51bWJlciB0byByZXByZXNlbnQgdGhlIHZlcnRpY2FsIHktY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXG4gICAqIEBkZXNjcmlwdGlvbiBBIGNsYXNzIHRvIHN0b3JlIHggLyB5IGNvbXBvbmVudCB2ZWN0b3IgZGF0YS4gSW4gYWRkaXRpb24gdG8gc3RvcmluZyBkYXRhIGBUd28uVmVjdG9yYCBoYXMgc3VwZWQgdXAgbWV0aG9kcyBmb3IgY29tbW9ucGxhY2UgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMuXG4gICAqL1xuICBmdW5jdGlvbiBWZWN0b3IoeCwgeSkge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciN4XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGhvcml6b250YWwgeC1jb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cbiAgICAgKi9cbiAgICB0aGlzLnggPSB4IHx8IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3lcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdmVydGljYWwgeS1jb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cbiAgICAgKi9cbiAgICB0aGlzLnkgPSB5IHx8IDA7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFZlY3Rvciwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci56ZXJvXG4gICAgICogQHJlYWRvbmx5XG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIEhhbmR5IHJlZmVyZW5jZSB0byBhIHZlY3RvciB3aXRoIGNvbXBvbmVudCB2YWx1ZXMgMCwgMCBhdCBhbGwgdGltZXMuXG4gICAgICovXG4gICAgemVybzogbmV3IFZlY3RvcigpLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5hZGRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYxXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MlxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfVxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgdHdvIHZlY3RvcnMgdG9nZXRoZXIuXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yKHYxLnggKyB2Mi54LCB2MS55ICsgdjIueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Iuc3ViXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MVxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlZlY3Rvcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gU3VidHJhY3QgdHdvIHZlY3RvcnM6IGB2MmAgZnJvbSBgdjFgLlxuICAgICAqL1xuICAgIHN1YjogZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgICByZXR1cm4gbmV3IFZlY3Rvcih2MS54IC0gdjIueCwgdjEueSAtIHYyLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yLnN1YnRyYWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFsaWFzIGZvciB7QGxpbmsgVHdvLlZlY3Rvci5zdWJ9LlxuICAgICAqL1xuICAgIHN1YnRyYWN0OiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgIHJldHVybiBWZWN0b3Iuc3ViKHYxLCB2Mik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IucmF0aW9CZXR3ZWVuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSBBXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSBCXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIHJhdGlvIGJldHdlbiB0d28gcG9pbnRzIGB2MWAgYW5kIGB2MmAuXG4gICAgICovXG4gICAgcmF0aW9CZXR3ZWVuOiBmdW5jdGlvbih2MSwgdjIpIHtcblxuICAgICAgcmV0dXJuICh2MS54ICogdjIueCArIHYxLnkgKiB2Mi55KSAvICh2MS5sZW5ndGgoKSAqIHYyLmxlbmd0aCgpKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yLmFuZ2xlQmV0d2VlblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjFcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYyXG4gICAgICogQHJldHVybnMge051bWJlcn0gVGhlIGFuZ2xlIGJldHdlZW4gcG9pbnRzIGB2MWAgYW5kIGB2MmAuXG4gICAgICovXG4gICAgYW5nbGVCZXR3ZWVuOiBmdW5jdGlvbih2MSwgdjIpIHtcblxuICAgICAgdmFyIGR4LCBkeTtcblxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkge1xuXG4gICAgICAgIGR4ID0gYXJndW1lbnRzWzBdIC0gYXJndW1lbnRzWzJdO1xuICAgICAgICBkeSA9IGFyZ3VtZW50c1sxXSAtIGFyZ3VtZW50c1szXTtcblxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMihkeSwgZHgpO1xuXG4gICAgICB9XG5cbiAgICAgIGR4ID0gdjEueCAtIHYyLng7XG4gICAgICBkeSA9IHYxLnkgLSB2Mi55O1xuXG4gICAgICByZXR1cm4gTWF0aC5hdGFuMihkeSwgZHgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IuZGlzdGFuY2VCZXR3ZWVuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MVxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgZGlzdGFuY2UgYmV0d2VlbiBwb2ludHMgYHYxYCBhbmQgYHYyYC4gRGlzdGFuY2UgaXMgYWx3YXlzIHBvc2l0aXZlLlxuICAgICAqL1xuICAgIGRpc3RhbmNlQmV0d2VlbjogZnVuY3Rpb24odjEsIHYyKSB7XG5cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoVmVjdG9yLmRpc3RhbmNlQmV0d2VlblNxdWFyZWQodjEsIHYyKSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5kaXN0YW5jZUJldHdlZW5TcXVhcmVkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MVxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBgdjFgIGFuZCBgdjJgLlxuICAgICAqL1xuICAgIGRpc3RhbmNlQmV0d2VlblNxdWFyZWQ6IGZ1bmN0aW9uKHYxLCB2Mikge1xuXG4gICAgICB2YXIgZHggPSB2MS54IC0gdjIueDtcbiAgICAgIHZhciBkeSA9IHYxLnkgLSB2Mi55O1xuXG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlZlY3Rvcn0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uVmVjdG9yfSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgIC8vIC8qKlxuICAgICAgLy8gICogT3ZlcnJpZGUgQmFja2JvbmUgYmluZCAvIG9uIGluIG9yZGVyIHRvIGFkZCBwcm9wZXJseSBicm9hZGNhc3RpbmcuXG4gICAgICAvLyAgKiBUaGlzIGFsbG93cyBUd28uVmVjdG9yIHRvIG5vdCBicm9hZGNhc3QgZXZlbnRzIHVubGVzcyBldmVudCBsaXN0ZW5lcnNcbiAgICAgIC8vICAqIGFyZSBleHBsaWNpdHkgYm91bmQgdG8gaXQuXG4gICAgICAvLyAgKi9cblxuICAgICAgb2JqZWN0LmJpbmQgPSBvYmplY3Qub24gPSBmdW5jdGlvbigpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2JvdW5kKSB7XG4gICAgICAgICAgdGhpcy5feCA9IHRoaXMueDtcbiAgICAgICAgICB0aGlzLl95ID0gdGhpcy55O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAneCcsIHhncyk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd5JywgeWdzKTtcbiAgICAgICAgICBfLmV4dGVuZCh0aGlzLCBCb3VuZFByb3RvKTtcbiAgICAgICAgICB0aGlzLl9ib3VuZCA9IHRydWU7IC8vIFJlc2VydmVkIGZvciBldmVudCBpbml0aWFsaXphdGlvbiBjaGVja1xuICAgICAgICB9XG5cbiAgICAgICAgRXZlbnRzLmJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgfTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChWZWN0b3IucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBWZWN0b3IsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3NldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSB4IC8geSBjb21wb25lbnRzIG9mIGEgdmVjdG9yIHRvIHNwZWNpZmljIG51bWJlciB2YWx1ZXMuXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2NvcHlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29weSB0aGUgeCAvIHkgY29tcG9uZW50cyBvZiBhbm90aGVyIG9iamVjdCBgdmAuXG4gICAgICovXG4gICAgY29weTogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgdGhpcy55ID0gdi55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjY2xlYXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSB4IC8geSBjb21wb25lbnQgdmFsdWVzIG9mIHRoZSB2ZWN0b3IgdG8gemVyby5cbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyB2ZWN0b3IgYW5kIGNvcHkgdGhlIGV4aXN0aW5nIHZhbHVlcyBvbnRvIHRoZSBuZXdseSBjcmVhdGVkIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNhZGRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGFuIG9iamVjdCB3aXRoIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgdG8gdGhlIGluc3RhbmNlLlxuICAgICAqIEBvdmVybG9hZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2FkZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCB0aGUgKipzYW1lKiogbnVtYmVyIHRvIGJvdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjYWRkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYHhgIC8gYHlgIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGNvbXBvbmVudCB2YWx1ZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy54ICs9IHg7XG4gICAgICAgICAgdGhpcy55ICs9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeC54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeC55ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMueCArPSB4Lng7XG4gICAgICAgICAgdGhpcy55ICs9IHgueTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ICs9IHg7XG4gICAgICAgIHRoaXMueSArPSB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjYWRkU2VsZlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5WZWN0b3IuYWRkfS5cbiAgICAgKi9cbiAgICBhZGRTZWxmOiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzdWJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gU3VidHJhY3QgYW4gb2JqZWN0IHdpdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyB0byB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc3ViXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gU3VidHJhY3QgdGhlICoqc2FtZSoqIG51bWJlciB0byBib3RoIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlLlxuICAgICAqIEBvdmVybG9hZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3N1YlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAZGVzY3JpcHRpb24gU3VidHJhY3QgYHhgIC8gYHlgIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGNvbXBvbmVudCB2YWx1ZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cbiAgICBzdWI6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy54IC09IHg7XG4gICAgICAgICAgdGhpcy55IC09IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeC54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeC55ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMueCAtPSB4Lng7XG4gICAgICAgICAgdGhpcy55IC09IHgueTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54IC09IHg7XG4gICAgICAgIHRoaXMueSAtPSB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc3VidHJhY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQWxpYXMgZm9yIHtAbGluayBUd28uVmVjdG9yLnN1Yn0uXG4gICAgICovXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3ViLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc3ViU2VsZlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5WZWN0b3Iuc3VifS5cbiAgICAgKi9cbiAgICBzdWJTZWxmOiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzdWJ0cmFjdFNlbGZcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQWxpYXMgZm9yIHtAbGluayBUd28uVmVjdG9yLnN1Yn0uXG4gICAgICovXG4gICAgc3VidHJhY3RTZWxmOiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNtdWx0aXBseVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdlxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBhbiBvYmplY3Qgd2l0aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNtdWx0aXBseVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gICAgICogQGRlc2NyaXB0aW9uIE11bHRpcGx5IHRoZSAqKnNhbWUqKiBudW1iZXIgdG8gYm90aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIG9mIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNtdWx0aXBseVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsdGlwbHkgYHhgIC8gYHlgIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGNvbXBvbmVudCB2YWx1ZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLnggKj0geDtcbiAgICAgICAgICB0aGlzLnkgKj0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4LnggPT09ICdudW1iZXInICYmIHR5cGVvZiB4LnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy54ICo9IHgueDtcbiAgICAgICAgICB0aGlzLnkgKj0geC55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggKj0geDtcbiAgICAgICAgdGhpcy55ICo9IHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNtdWx0aXBseVNlbGZcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQWxpYXMgZm9yIHtAbGluayBUd28uVmVjdG9yLm11bHRpcGx5fS5cbiAgICAgKi9cbiAgICBtdWx0aXBseVNlbGY6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjbXVsdGlwbHlTY2FsYXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyAtIFRoZSBzY2FsYXIgdG8gbXVsdGlwbHkgYnkuXG4gICAgICogQGRlc2NyaXB0aW9uIE11bGl0aXBseSB0aGUgdmVjdG9yIGJ5IGEgc2luZ2xlIG51bWJlci4gU2hvcnRoYW5kIHRvIGNhbGwge0BsaW5rIFR3by5WZWN0b3IjbXVsdGlwbHl9IGRpcmVjdGx5LlxuICAgICAqL1xuICAgIG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXZpZGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gRGl2aWRlIGFuIG9iamVjdCB3aXRoIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgdG8gdGhlIGluc3RhbmNlLlxuICAgICAqIEBvdmVybG9hZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2RpdmlkZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gICAgICogQGRlc2NyaXB0aW9uIERpdmlkZSB0aGUgKipzYW1lKiogbnVtYmVyIHRvIGJvdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZGl2aWRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBkZXNjcmlwdGlvbiBEaXZpZGUgYHhgIC8gYHlgIHZhbHVlcyB0byB0aGVpciByZXNwZWN0aXZlIGNvbXBvbmVudCB2YWx1ZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy54IC89IHg7XG4gICAgICAgICAgdGhpcy55IC89IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeC54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeC55ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMueCAvPSB4Lng7XG4gICAgICAgICAgdGhpcy55IC89IHgueTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54IC89IHg7XG4gICAgICAgIHRoaXMueSAvPSB5O1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNOYU4odGhpcy54KSkge1xuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNOYU4odGhpcy55KSkge1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZGl2aWRlU2VsZlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5WZWN0b3IuZGl2aWRlfS5cbiAgICAgKi9cbiAgICBkaXZpZGVTZWxmOiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXZpZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXZpZGVTY2FsYXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcyAtIFRoZSBzY2FsYXIgdG8gZGl2aWRlIGJ5LlxuICAgICAqIEBkZXNjcmlwdGlvbiBEaXZpZGUgdGhlIHZlY3RvciBieSBhIHNpbmdsZSBudW1iZXIuIFNob3J0aGFuZCB0byBjYWxsIHtAbGluayBUd28uVmVjdG9yI2RpdmlkZX0gZGlyZWN0bHkuXG4gICAgICovXG4gICAgZGl2aWRlU2NhbGFyOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXZpZGUocyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjbmVnYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEludmVydCBlYWNoIGNvbXBvbmVudCdzIHNpZ24gdmFsdWUuXG4gICAgICovXG4gICAgbmVnYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNuZWdhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIFtkb3QgcHJvZHVjdF0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG90X3Byb2R1Y3QpIG9mIHRoZSB2ZWN0b3IuXG4gICAgICovXG4gICAgZG90OiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2xlbmd0aFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yLlxuICAgICAqL1xuICAgIGxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHRoaXMubGVuZ3RoU3F1YXJlZCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNsZW5ndGhTcXVhcmVkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciB0byB0aGUgcG93ZXIgb2YgdHdvLiBXaWRlbHkgdXNlZCBhcyBsZXNzIGV4cGVuc2l2ZSB0aGFuIHtAbGluayBUd28uVmVjdG9yI2xlbmd0aH0sIGJlY2F1c2UgaXQgaXNuJ3Qgc3F1YXJlLXJvb3RpbmcgYW55IG51bWJlcnMuXG4gICAgICovXG4gICAgbGVuZ3RoU3F1YXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI25vcm1hbGl6ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBOb3JtYWxpemUgdGhlIHZlY3RvciBmcm9tIG5lZ2F0aXZlIG9uZSB0byBvbmUuXG4gICAgICovXG4gICAgbm9ybWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZVNjYWxhcih0aGlzLmxlbmd0aCgpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXN0YW5jZVRvXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxuICAgICAqL1xuICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kaXN0YW5jZVRvU3F1YXJlZCh2KSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZGlzdGFuY2VUb1NxdWFyZWRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlY3RvcnMgdG8gdGhlIHBvd2VyIG9mIHR3by4gV2lkZWx5IHVzZWQgYXMgbGVzcyBleHBlbnNpdmUgdGhhbiB7QGxpbmsgVHdvLlZlY3RvciNkaXN0YW5jZVRvfSwgYmVjYXVzZSBpdCBpc24ndCBzcXVhcmUtcm9vdGluZyBhbnkgbnVtYmVycy5cbiAgICAgKi9cbiAgICBkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24odikge1xuICAgICAgdmFyIGR4ID0gdGhpcy54IC0gdi54LFxuICAgICAgICAgIGR5ID0gdGhpcy55IC0gdi55O1xuICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3NldExlbmd0aFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsIC0gbGVuZ3RoIHRvIHNldCB2ZWN0b3IgdG8uXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgbGVuZ3RoIG9mIGEgdmVjdG9yLlxuICAgICAqL1xuICAgIHNldExlbmd0aDogZnVuY3Rpb24obCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIobCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZXF1YWxzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2IC0gVGhlIHZlY3RvciB0byBjb21wYXJlIGFnYWluc3QuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlcHM9MC4wMDAxXSAtIEFuIG9wdGlvbnMgZXBzaWxvbiBmb3IgcHJlY2lzaW9uLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBkZXNjcmlwdGlvbiBRdWFsaWZ5IGlmIG9uZSB2ZWN0b3Igcm91Z2hseSBlcXVhbCBhbm90aGVyLiBXaXRoIGEgbWFyZ2luIG9mIGVycm9yIGRlZmluZWQgYnkgZXBzaWxvbi5cbiAgICAgKi9cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKHYsIGVwcykge1xuICAgICAgZXBzID0gKHR5cGVvZiBlcHMgPT09ICd1bmRlZmluZWQnKSA/ICAwLjAwMDEgOiBlcHM7XG4gICAgICByZXR1cm4gKHRoaXMuZGlzdGFuY2VUbyh2KSA8IGVwcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjbGVycFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdiAtIFRoZSBkZXN0aW5hdGlvbiB2ZWN0b3IgdG8gc3RlcCB0b3dhcmRzLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB0IC0gVGhlIHplcm8gdG8gb25lIHZhbHVlIG9mIGhvdyBjbG9zZSB0aGUgY3VycmVudCB2ZWN0b3IgZ2V0cyB0byB0aGUgZGVzdGluYXRpb24gdmVjdG9yLlxuICAgICAqIEBkZXNjcmlwdGlvbiBMaW5lYXIgaW50ZXJwb2xhdGUgb25lIHZlY3RvciB0byBhbm90aGVyIGJ5IGFuIGFtb3VudCBgdGAgZGVmaW5lZCBhcyBhIHplcm8gdG8gb25lIG51bWJlci5cbiAgICAgKiBAc2VlIFtNYXR0IERlc0xhdXJpZXJzXShodHRwczovL3R3aXR0ZXIuY29tL21hdHRkZXNsL3N0YXR1cy8xMDMxMzA1Mjc5MjI3NDc4MDE2KSBoYXMgYSBnb29kIHRocmVhZCBhYm91dCB0aGlzLlxuICAgICAqL1xuICAgIGxlcnA6IGZ1bmN0aW9uKHYsIHQpIHtcbiAgICAgIHZhciB4ID0gKHYueCAtIHRoaXMueCkgKiB0ICsgdGhpcy54O1xuICAgICAgdmFyIHkgPSAodi55IC0gdGhpcy55KSAqIHQgKyB0aGlzLnk7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjaXNaZXJvXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlcHM9MC4wMDAxXSAtIE9wdGlvbmFsIHByZWNpc2lvbiBhbW91bnQgdG8gY2hlY2sgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2hlY2sgdG8gc2VlIGlmIHZlY3RvciBpcyByb3VnaGx5IHplcm8sIGJhc2VkIG9uIHRoZSBgZXBzaWxvbmAgcHJlY2lzaW9uIHZhbHVlLlxuICAgICAqL1xuICAgIGlzWmVybzogZnVuY3Rpb24oZXBzKSB7XG4gICAgICBlcHMgPSAodHlwZW9mIGVwcyA9PT0gJ3VuZGVmaW5lZCcpID8gIDAuMDAwMSA6IGVwcztcbiAgICAgIHJldHVybiAodGhpcy5sZW5ndGgoKSA8IGVwcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjdG9TdHJpbmdcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIG9mIHgsIHkgdmFsdWUuIEdyZWF0IGZvciBzdG9yaW5nIGluIGEgZGF0YWJhc2UuXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMueCArICcsICcgKyB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgdmVjdG9yLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMueCwgeTogdGhpcy55IH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijcm90YXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IE51bWJlciAtIFRoZSBhbW91biB0byByb3RhdGUgdGhlIHZlY3RvciBieS5cbiAgICAgKiBAZGVzY3JpcHRpb24gUm90YXRlIGEgdmVjdG9yLlxuICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24oTnVtYmVyKSB7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MoTnVtYmVyKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihOdW1iZXIpO1xuICAgICAgdGhpcy54ID0gdGhpcy54ICogY29zIC0gdGhpcy55ICogc2luO1xuICAgICAgdGhpcy55ID0gdGhpcy54ICogc2luICsgdGhpcy55ICogY29zO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIFRoZSBzYW1lIHNldCBvZiBwcm90b3R5cGljYWwgZnVuY3Rpb25zLCBidXQgdXNpbmcgdGhlIHVuZGVybHlpbmdcbiAgLy8gZ2V0dGVyIG9yIHNldHRlciBmb3IgYHhgIGFuZCBgeWAgdmFsdWVzLiBUaGlzIHNldCBvZiBmdW5jdGlvbnNcbiAgLy8gaXMgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcmV2aW91c2x5IGRvY3VtZW50ZWQgb25lcyBhYm92ZSB3aGVuXG4gIC8vIFR3by5WZWN0b3IjYmluZCBpcyBpbnZva2VkIGFuZCB0aGVyZSBpcyBldmVudCBkaXNwYXRjaGluZyBwcm9jZXNzZWRcbiAgLy8gb24geCAvIHkgcHJvcGVydHkgY2hhbmdlcy5cbiAgdmFyIEJvdW5kUHJvdG8gPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVmVjdG9yLFxuXG4gICAgc2V0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLl94ID0geDtcbiAgICAgIHRoaXMuX3kgPSB5O1xuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICB9LFxuXG4gICAgY29weTogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5feCA9IHYueDtcbiAgICAgIHRoaXMuX3kgPSB2Lnk7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl94ID0gMDtcbiAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICB9LFxuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy5feCwgdGhpcy5feSk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl94ICs9IHg7XG4gICAgICAgICAgdGhpcy5feSArPSB4O1xuICAgICAgICB9ICBlbHNlIGlmICh4ICYmIHR5cGVvZiB4LnggPT09ICdudW1iZXInICYmIHR5cGVvZiB4LnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5feCArPSB4Lng7XG4gICAgICAgICAgdGhpcy5feSArPSB4Lnk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ggKz0geDtcbiAgICAgICAgdGhpcy5feSArPSB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICB9LFxuXG4gICAgc3ViOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3ggLT0geDtcbiAgICAgICAgICB0aGlzLl95IC09IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeC54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeC55ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3ggLT0geC54O1xuICAgICAgICAgIHRoaXMuX3kgLT0geC55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl94IC09IHg7XG4gICAgICAgIHRoaXMuX3kgLT0geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgfSxcblxuICAgIG11bHRpcGx5OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3ggKj0geDtcbiAgICAgICAgICB0aGlzLl95ICo9IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeC54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeC55ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3ggKj0geC54O1xuICAgICAgICAgIHRoaXMuX3kgKj0geC55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl94ICo9IHg7XG4gICAgICAgIHRoaXMuX3kgKj0geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgfSxcblxuICAgIGRpdmlkZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl94IC89IHg7XG4gICAgICAgICAgdGhpcy5feSAvPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKHggJiYgdHlwZW9mIHgueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHgueSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl94IC89IHgueDtcbiAgICAgICAgICB0aGlzLl95IC89IHgueTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5feCAvPSB4O1xuICAgICAgICB0aGlzLl95IC89IHk7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc05hTih0aGlzLl94KSkge1xuICAgICAgICB0aGlzLl94ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzTmFOKHRoaXMuX3kpKSB7XG4gICAgICAgIHRoaXMuX3kgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICB9LFxuXG4gICAgZG90OiBmdW5jdGlvbih2KSB7XG4gICAgICByZXR1cm4gdGhpcy5feCAqIHYueCArIHRoaXMuX3kgKiB2Lnk7XG4gICAgfSxcblxuICAgIGxlbmd0aFNxdWFyZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ggKiB0aGlzLl94ICsgdGhpcy5feSAqIHRoaXMuX3k7XG4gICAgfSxcblxuICAgIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgZHggPSB0aGlzLl94IC0gdi54LFxuICAgICAgICAgIGR5ID0gdGhpcy5feSAtIHYueTtcbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9LFxuXG4gICAgbGVycDogZnVuY3Rpb24odiwgdCkge1xuICAgICAgdmFyIHggPSAodi54IC0gdGhpcy5feCkgKiB0ICsgdGhpcy5feDtcbiAgICAgIHZhciB5ID0gKHYueSAtIHRoaXMuX3kpICogdCArIHRoaXMuX3k7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoeCwgeSk7XG4gICAgfSxcblxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl94ICsgJywgJyArIHRoaXMuX3k7XG4gICAgfSxcblxuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IHg6IHRoaXMuX3gsIHk6IHRoaXMuX3kgfTtcbiAgICB9LFxuXG4gICAgcm90YXRlOiBmdW5jdGlvbiAoTnVtYmVyKSB7XG4gICAgICB2YXIgY29zID0gTWF0aC5jb3MoTnVtYmVyKTtcbiAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihOdW1iZXIpO1xuICAgICAgdGhpcy5feCA9IHRoaXMuX3ggKiBjb3MgLSB0aGlzLl95ICogc2luO1xuICAgICAgdGhpcy5feSA9IHRoaXMuX3ggKiBzaW4gKyB0aGlzLl95ICogY29zO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH07XG5cbiAgdmFyIHhncyA9IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5feDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5feCA9IHY7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSwgJ3gnKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHlncyA9IHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5feTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5feSA9IHY7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSwgJ3knKTtcbiAgICB9XG4gIH07XG5cbiAgVmVjdG9yLk1ha2VPYnNlcnZhYmxlKFZlY3Rvci5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQG5hbWUgVHdvLkFuY2hvclxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcm9vdCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSByb290IGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtseD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBsZWZ0IGhhbmRsZSBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtseT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBsZWZ0IGhhbmRsZSBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSByaWdodCBoYW5kbGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcnk9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcmlnaHQgaGFuZGxlIHBvaW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW2NvbW1hbmQ9VHdvLkNvbW1hbmRzLm1vdmVdIC0gVGhlIGNvbW1hbmQgdG8gZGVzY3JpYmUgaG93IHRvIHJlbmRlci4gQXBwbGljYWJsZSBjb21tYW5kcyBhcmUge0BsaW5rIFR3by5Db21tYW5kc31cbiAgICogQGV4dGVuZHMgVHdvLlZlY3RvclxuICAgKiBAZGVzY3JpcHRpb24gQW4gb2JqZWN0IHRoYXQgaG9sZHMgMyB7QGxpbmsgVHdvLlZlY3Rvcn1zLCB0aGUgYW5jaG9yIHBvaW50IGFuZCBpdHMgY29ycmVzcG9uZGluZyBoYW5kbGVzOiBgbGVmdGAgYW5kIGByaWdodGAuIEluIG9yZGVyIHRvIHByb3Blcmx5IGRlc2NyaWJlIHRoZSBiZXppZXIgY3VydmUgYWJvdXQgdGhlIHBvaW50IHRoZXJlIGlzIGFsc28gYSBjb21tYW5kIHByb3BlcnR5IHRvIGRlc2NyaWJlIHdoYXQgdHlwZSBvZiBkcmF3aW5nIHNob3VsZCBvY2N1ciB3aGVuIFR3by5qcyByZW5kZXJzIHRoZSBhbmNob3JzLlxuICAgKi9cbiAgZnVuY3Rpb24gQW5jaG9yKHgsIHksIGx4LCBseSwgcngsIHJ5LCBjb21tYW5kKSB7XG5cbiAgICBWZWN0b3IuY2FsbCh0aGlzLCB4LCB5KTtcblxuICAgIHRoaXMuX2Jyb2FkY2FzdCA9IChmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fY29tbWFuZCA9IGNvbW1hbmQgfHwgQ29tbWFuZHMubW92ZTtcbiAgICB0aGlzLl9yZWxhdGl2ZSA9IHRydWU7XG5cbiAgICB2YXIgaWx4ID0gdHlwZW9mIGx4ID09PSAnbnVtYmVyJztcbiAgICB2YXIgaWx5ID0gdHlwZW9mIGx5ID09PSAnbnVtYmVyJztcbiAgICB2YXIgaXJ4ID0gdHlwZW9mIHJ4ID09PSAnbnVtYmVyJztcbiAgICB2YXIgaXJ5ID0gdHlwZW9mIHJ5ID09PSAnbnVtYmVyJztcblxuICAgIC8vIEFwcGVuZCB0aGUgYGNvbnRyb2xzYCBvYmplY3Qgb25seSBpZiBjb250cm9sIHBvaW50cyBhcmUgc3BlY2lmaWVkLFxuICAgIC8vIGtlZXBpbmcgdGhlIFR3by5BbmNob3IgaW5saW5lIHdpdGggYSBUd28uVmVjdG9yIHVudGlsIGl0IG5lZWRzIHRvXG4gICAgLy8gZXZvbHZlIGJleW9uZCB0aG9zZSBmdW5jdGlvbnMgLSBlLmc6IGEgc2ltcGxlIDIgY29tcG9uZW50IHZlY3Rvci5cbiAgICBpZiAoaWx4IHx8IGlseSB8fCBpcnggfHwgaXJ5KSB7XG4gICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChpbHgpIHtcbiAgICAgIHRoaXMuY29udHJvbHMubGVmdC54ID0gbHg7XG4gICAgfVxuICAgIGlmIChpbHkpIHtcbiAgICAgIHRoaXMuY29udHJvbHMubGVmdC55ID0gbHk7XG4gICAgfVxuICAgIGlmIChpcngpIHtcbiAgICAgIHRoaXMuY29udHJvbHMucmlnaHQueCA9IHJ4O1xuICAgIH1cbiAgICBpZiAoaXJ5KSB7XG4gICAgICB0aGlzLmNvbnRyb2xzLnJpZ2h0LnkgPSByeTtcbiAgICB9XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKEFuY2hvciwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5BbmNob3J9IGFuY2hvciAtIFRoZSBpbnN0YW5jZSB0byBhcHBlbmQgdGhlIGBjb250cm9sYG9iamVjdCB0by5cbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyB0aGUgYGNvbnRyb2xzYCBwcm9wZXJ0eSBhcyBhbiBvYmplY3Qgd2l0aCBgbGVmdGAgYW5kIGByaWdodGAgcHJvcGVydGllcyB0byBhY2Nlc3MgdGhlIGJlemllciBjb250cm9sIGhhbmRsZXMgdGhhdCBkZWZpbmUgaG93IHRoZSBjdXJ2ZSBpcyBkcmF3bi4gSXQgYWxzbyBzZXRzIHRoZSBgcmVsYXRpdmVgIHByb3BlcnR5IHRvIGB0cnVlYCBtYWtpbmcgdmVjdG9ycyBpbiB0aGUgYGNvbnRyb2xzYCBvYmplY3QgcmVsYXRpdmUgdG8gdGhlaXIgY29ycmVzcG9uZGluZyByb290IGFuY2hvciBwb2ludC5cbiAgICAgKi9cbiAgICBBcHBlbmRDdXJ2ZVByb3BlcnRpZXM6IGZ1bmN0aW9uKGFuY2hvcikge1xuXG4gICAgICBhbmNob3IucmVsYXRpdmUgPSB0cnVlO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIFR3by5BbmNob3IjY29udHJvbHNcbiAgICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBjb250cm9sc1xuICAgICAgICogQGRlc2NyaXB0aW9uIEFuIHBsYWluIG9iamVjdCB0aGF0IGhvbGRzIHRoZSBjb250cm9scyBoYW5kbGVzIGZvciBhIHtAbGluayBUd28uQW5jaG9yfS5cbiAgICAgICAqL1xuICAgICAgYW5jaG9yLmNvbnRyb2xzID0ge307XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgVHdvLkFuY2hvciNjb250cm9scyNsZWZ0XG4gICAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IGxlZnRcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgXCJsZWZ0XCIgY29udHJvbCBwb2ludCB0byBkZWZpbmUgaGFuZGxlcyBvbiBhIGJlemllciBjdXJ2ZS5cbiAgICAgICAqL1xuICAgICAgYW5jaG9yLmNvbnRyb2xzLmxlZnQgPSBuZXcgVmVjdG9yKDAsIDApO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIFR3by5BbmNob3IjY29udHJvbHMjcmlnaHRcbiAgICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gcmlnaHRcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgXCJsZWZ0XCIgY29udHJvbCBwb2ludCB0byBkZWZpbmUgaGFuZGxlcyBvbiBhIGJlemllciBjdXJ2ZS5cbiAgICAgICAqL1xuICAgICAgYW5jaG9yLmNvbnRyb2xzLnJpZ2h0ID0gbmV3IFZlY3RvcigwLCAwKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uQW5jaG9yfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5BbmNob3J9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBUd28uQW5jaG9yI2NvbW1hbmRcbiAgICAgICAqIEBwcm9wZXJ0eSB7VHdvLkNvbW1hbmRzfVxuICAgICAgICogQGRlc2NyaXB0aW9uIEEgZHJhdyBjb21tYW5kIGFzc29jaWF0ZWQgd2l0aCB0aGUgYW5jaG9yIHBvaW50LlxuICAgICAgICovXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY29tbWFuZCcsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgdGhpcy5fY29tbWFuZCA9IGM7XG4gICAgICAgICAgaWYgKHRoaXMuX2NvbW1hbmQgPT09IENvbW1hbmRzLmN1cnZlICYmICFfLmlzT2JqZWN0KHRoaXMuY29udHJvbHMpKSB7XG4gICAgICAgICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgVHdvLkFuY2hvciNyZWxhdGl2ZVxuICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufVxuICAgICAgICogQGRlc2NyaXB0aW9uIEEgYm9vbGVhbiB0byByZW5kZXIgY29udHJvbCBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIHJvb3QgYW5jaG9yIHBvaW50IG9yIGluIGdsb2JhbCBjb29yZGluYXRlLXNwYWNlIHRvIHRoZSByZXN0IG9mIHRoZSBzY2VuZS5cbiAgICAgICAqL1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3JlbGF0aXZlJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVsYXRpdmU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbGF0aXZlICE9IGIpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0aXZlID0gISFiO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgXy5leHRlbmQob2JqZWN0LCBWZWN0b3IucHJvdG90eXBlLCBBbmNob3JQcm90byk7XG5cbiAgICAgIC8vIE1ha2UgaXQgcG9zc2libGUgdG8gYmluZCBhbmQgc3RpbGwgaGF2ZSB0aGUgQW5jaG9yIHNwZWNpZmljXG4gICAgICAvLyBpbmhlcml0YW5jZSBmcm9tIFR3by5WZWN0b3IuIEluIHRoaXMgY2FzZSByZWx5aW5nIG9uIGBUd28uVmVjdG9yYFxuICAgICAgLy8gdG8gZG8gbXVjaCBvZiB0aGUgaGVhdnkgZXZlbnQtbGlzdGVuZXIgYmluZGluZyAvIHVuYmluZGluZy5cbiAgICAgIG9iamVjdC5iaW5kID0gb2JqZWN0Lm9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3VuZCA9IHRoaXMuX2JvdW5kO1xuICAgICAgICBWZWN0b3IucHJvdG90eXBlLmJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFib3VuZCkge1xuICAgICAgICAgIF8uZXh0ZW5kKHRoaXMsIEFuY2hvclByb3RvKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgIH1cblxuICB9KTtcblxuICB2YXIgQW5jaG9yUHJvdG8gPSB7XG5cbiAgICBjb25zdHJ1Y3RvcjogQW5jaG9yLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFuY2hvciNsaXN0ZW5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbWV0aG9kIHVzZWQgbWFpbmx5IGJ5IHtAbGluayBUd28uUGF0aCN2ZXJ0aWNlc30gdG8gbGlzdGVuIGFuZCBwcm9wYWdhdGUgY2hhbmdlcyBmcm9tIGNvbnRyb2wgcG9pbnRzIHVwIHRvIHRoZWlyIHJlc3BlY3RpdmUgYW5jaG9ycyBhbmQgZnVydGhlciBpZiBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgbGlzdGVuOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHRoaXMuY29udHJvbHMpKSB7XG4gICAgICAgIEFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXModGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udHJvbHMubGVmdC5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX2Jyb2FkY2FzdCk7XG4gICAgICB0aGlzLmNvbnRyb2xzLnJpZ2h0LmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fYnJvYWRjYXN0KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFuY2hvciNpZ25vcmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbWV0aG9kIHVzZWQgbWFpbmx5IGJ5IHtAbGluayBUd28uUGF0aCN2ZXJ0aWNlc30gdG8gaWdub3JlIGNoYW5nZXMgZnJvbSBhIHNwZWNpZmljIGFuY2hvcidzIGNvbnRyb2wgcG9pbnRzLlxuICAgICAqL1xuICAgIGlnbm9yZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuY29udHJvbHMubGVmdC51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fYnJvYWRjYXN0KTtcbiAgICAgIHRoaXMuY29udHJvbHMucmlnaHQudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX2Jyb2FkY2FzdCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BbmNob3IjY29weVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkFuY2hvcn0gdiAtIFRoZSBhbmNob3IgdG8gYXBwbHkgdmFsdWVzIHRvLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9mIG9uZSB7QGxpbmsgVHdvLkFuY2hvcn0gb250byBhbm90aGVyLlxuICAgICAqL1xuICAgIGNvcHk6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgdGhpcy54ID0gdi54O1xuICAgICAgdGhpcy55ID0gdi55O1xuXG4gICAgICBpZiAodHlwZW9mIHYuY29tbWFuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kID0gdi5jb21tYW5kO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNPYmplY3Qodi5jb250cm9scykpIHtcbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KHRoaXMuY29udHJvbHMpKSB7XG4gICAgICAgICAgQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBEbyB3ZSBuZWVkIHRvIGxpc3RlbiBoZXJlP1xuICAgICAgICB0aGlzLmNvbnRyb2xzLmxlZnQuY29weSh2LmNvbnRyb2xzLmxlZnQpO1xuICAgICAgICB0aGlzLmNvbnRyb2xzLnJpZ2h0LmNvcHkodi5jb250cm9scy5yaWdodCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHYucmVsYXRpdmUgPT09ICdib29sZWFuJykge1xuICAgICAgICB0aGlzLnJlbGF0aXZlID0gdi5yZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogSGFjayBmb3IgYFR3by5Db21tYW5kcy5hcmNgXG4gICAgICBpZiAodGhpcy5jb21tYW5kID09PSBDb21tYW5kcy5hcmMpIHtcbiAgICAgICAgdGhpcy5yeCA9IHYucng7XG4gICAgICAgIHRoaXMucnkgPSB2LnJ5O1xuICAgICAgICB0aGlzLnhBeGlzUm90YXRpb24gPSB2LnhBeGlzUm90YXRpb247XG4gICAgICAgIHRoaXMubGFyZ2VBcmNGbGFnID0gdi5sYXJnZUFyY0ZsYWc7XG4gICAgICAgIHRoaXMuc3dlZXBGbGFnID0gdi5zd2VlcEZsYWc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BbmNob3IjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7VHdvLkFuY2hvcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IHtAbGluayBUd28uQW5jaG9yfSwgc2V0IGFsbCBpdHMgdmFsdWVzIHRvIHRoZSBjdXJyZW50IGluc3RhbmNlIGFuZCByZXR1cm4gaXQgZm9yIHVzZS5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBjb250cm9scyA9IHRoaXMuY29udHJvbHM7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBBbmNob3IoXG4gICAgICAgIHRoaXMueCxcbiAgICAgICAgdGhpcy55LFxuICAgICAgICBjb250cm9scyAmJiBjb250cm9scy5sZWZ0LngsXG4gICAgICAgIGNvbnRyb2xzICYmIGNvbnRyb2xzLmxlZnQueSxcbiAgICAgICAgY29udHJvbHMgJiYgY29udHJvbHMucmlnaHQueCxcbiAgICAgICAgY29udHJvbHMgJiYgY29udHJvbHMucmlnaHQueSxcbiAgICAgICAgdGhpcy5jb21tYW5kXG4gICAgICApO1xuICAgICAgY2xvbmUucmVsYXRpdmUgPSB0aGlzLl9yZWxhdGl2ZTtcbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yI3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH0gLSBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGZpbGxlZCBvdXQgdG8gbWlycm9yIHtAbGluayBUd28uQW5jaG9yfS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCBvZiB0aGUgY3VycmVudCBpbnN0YW5jZS4gSW50ZW5kZWQgZm9yIHVzZSB3aXRoIHN0b3JpbmcgdmFsdWVzIGluIGEgZGF0YWJhc2UuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG8gPSB7XG4gICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgeTogdGhpcy55XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuX2NvbW1hbmQpIHtcbiAgICAgICAgby5jb21tYW5kID0gdGhpcy5fY29tbWFuZDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9yZWxhdGl2ZSkge1xuICAgICAgICBvLnJlbGF0aXZlID0gdGhpcy5fcmVsYXRpdmU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250cm9scykge1xuICAgICAgICBvLmNvbnRyb2xzID0ge1xuICAgICAgICAgIGxlZnQ6IHRoaXMuY29udHJvbHMubGVmdC50b09iamVjdCgpLFxuICAgICAgICAgIHJpZ2h0OiB0aGlzLmNvbnRyb2xzLnJpZ2h0LnRvT2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yI3RvU3RyaW5nXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1N0cmluZ30gLSBBIFN0cmluZyB3aXRoIGNvbW1hLXNlcGFyYXRlZCB2YWx1ZXMgcmVmbGVjdGluZyB0aGUgdmFyaW91cyB2YWx1ZXMgb24gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIHN0cmluZyBmb3JtIG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLiBJbnRlbmRlZCBmb3IgdXNlIHdpdGggc3RvcmluZyB2YWx1ZXMgaW4gYSBkYXRhYmFzZS4gVGhpcyBpcyBsaWdodGVyIHRvIHN0b3JlIHRoYW4gdGhlIEpTT04gY29tcGF0aWJsZSB7QGxpbmsgVHdvLkFuY2hvciN0b09iamVjdH0uXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRyb2xzKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5feCwgdGhpcy5feV0uam9pbignLCAnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbdGhpcy5feCwgdGhpcy5feSwgdGhpcy5jb250cm9scy5sZWZ0LngsIHRoaXMuY29udHJvbHMubGVmdC55LFxuICAgICAgICB0aGlzLmNvbnRyb2xzLnJpZ2h0LngsIHRoaXMuY29udHJvbHMucmlnaHQueSwgdGhpcy5fY29tbWFuZCxcbiAgICAgICAgdGhpcy5fcmVsYXRpdmUgPyAxIDogMF0uam9pbignLCAnKTtcbiAgICB9XG5cbiAgfTtcblxuICBBbmNob3IuTWFrZU9ic2VydmFibGUoQW5jaG9yLnByb3RvdHlwZSk7XG5cbiAgdmFyIGNvdW50ID0gMDtcblxuICB2YXIgQ29uc3RhbnRzID0ge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLm5leHRGcmFtZUlEXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9XG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBpZCBvZiB0aGUgbmV4dCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgbmV4dEZyYW1lSUQ6IG51bGwsXG5cbiAgICAvLyBQcmltaXRpdmVcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UeXBlc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIFRoZSBkaWZmZXJlbnQgcmVuZGVyaW5nIHR5cGVzIGF2YWlsYWJsZSBpbiB0aGUgbGlicmFyeS5cbiAgICAgKi9cbiAgICBUeXBlczoge1xuICAgICAgd2ViZ2w6ICdXZWJHTFJlbmRlcmVyJyxcbiAgICAgIHN2ZzogJ1NWR1JlbmRlcmVyJyxcbiAgICAgIGNhbnZhczogJ0NhbnZhc1JlbmRlcmVyJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVyc2lvblxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBjdXJyZW50IHdvcmtpbmcgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS5cbiAgICAgKi9cbiAgICBWZXJzaW9uOiAndjAuNy44JyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QdWJsaXNoRGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBwdWJsaXNoIGRhdGUgaW4gdGhlIGJ1aWxkIHByb2Nlc3MgdG8gdmVyaWZ5IHZlcnNpb24gcmVsZWFzZSBjYW5kaWRhdGVzLlxuICAgICAqL1xuICAgIFB1Ymxpc2hEYXRlOiAnMjAyMS0wNy0xNFQwMjoxNToyMy42OTdaJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JZGVudGlmaWVyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gU3RyaW5nIHByZWZpeCBmb3IgYWxsIFR3by5qcyBvYmplY3QncyBpZHMuIFRoaXMgdHJpY2tsZXMgZG93biB0byBTVkcgaWRzLlxuICAgICAqL1xuICAgIElkZW50aWZpZXI6ICd0d28tJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZXNvbHV0aW9uXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gRGVmYXVsdCBhbW91bnQgb2YgdmVydGljZXMgdG8gYmUgdXNlZCBmb3IgaW50ZXJwcmV0aW5nIEFyY3MgYW5kIEFyY1NlZ21lbnRzLlxuICAgICAqL1xuICAgIFJlc29sdXRpb246IDEyLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkF1dG9DYWxjdWxhdGVJbXBvcnRlZE1hdHJpY2VzXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIFdoZW4gaW1wb3J0aW5nIFNWR3MgdGhyb3VnaCB0aGUge0BsaW5rIHR3byNpbnRlcnByZXR9IGFuZCB7QGxpbmsgdHdvI2xvYWR9LCB0aGlzIGJvb2xlYW4gZGV0ZXJtaW5lcyB3aGV0aGVyIFR3by5qcyBpbmZlcnMgYW5kIHRoZW4gb3ZlcnJpZGVzIHRoZSBleGFjdCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIHJlZmVyZW5jZSBTVkcuXG4gICAgICogQG5vdGEtYmVuZSBgZmFsc2VgIGNvcGllcyB0aGUgZXhhY3QgdHJhbnNmb3JtYXRpb24gbWF0cml4IHZhbHVlcywgYnV0IGFsc28gc2V0cyB0aGUgcGF0aCdzIGBtYXRyaXgubWFudWFsID0gdHJ1ZWAuXG4gICAgICovXG4gICAgQXV0b0NhbGN1bGF0ZUltcG9ydGVkTWF0cmljZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW5zdGFuY2VzXG4gICAgICogQHByb3BlcnR5IHtUd29bXX0gLSBSZWdpc3RlcmVkIGxpc3Qgb2YgYWxsIFR3by5qcyBpbnN0YW5jZXMgaW4gdGhlIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBJbnN0YW5jZXM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uIFR3by51bmlxdWVJZFxuICAgICAqIEBkZXNjcmlwdGlvbiBTaW1wbGUgbWV0aG9kIHRvIGFjY2VzcyBhbiBpbmNyZW1lbnRpbmcgdmFsdWUuIFVzZWQgZm9yIGBpZGAgYWxsb2NhdGlvbiBvbiBhbGwgVHdvLmpzIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge051bWJlcn0gRXZlciBpbmNyZWFzaW5nIE51bWJlci5cbiAgICAgKi9cbiAgICB1bmlxdWVJZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gY291bnQrKztcbiAgICB9XG5cbiAgfTtcblxuICB2YXIgSEFMRl9QSSQzID0gTWF0aC5QSSAvIDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5DdXJ2ZVxuICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBBZGRpdGlvbmFsIHV0aWxpdHkgY29uc3RhbnQgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY3VydmUgbWF0aCBhbmQgY2FsY3VsYXRpb25zLlxuICAgKi9cbiAgdmFyIEN1cnZlID0ge1xuXG4gICAgQ29sbGluZWFyaXR5RXBzaWxvbjogTWF0aC5wb3coMTAsIC0zMCksXG5cbiAgICBSZWN1cnNpb25MaW1pdDogMTYsXG5cbiAgICBDdXNwTGltaXQ6IDAsXG5cbiAgICBUb2xlcmFuY2U6IHtcbiAgICAgIGRpc3RhbmNlOiAwLjI1LFxuICAgICAgYW5nbGU6IDAsXG4gICAgICBlcHNpbG9uOiBOdW1iZXIuRVBTSUxPTlxuICAgIH0sXG5cbiAgICAvLyBMb29rdXAgdGFibGVzIGZvciBhYnNjaXNzYXMgYW5kIHdlaWdodHMgd2l0aCB2YWx1ZXMgZm9yIG4gPSAyIC4uIDE2LlxuICAgIC8vIEFzIHZhbHVlcyBhcmUgc3ltbWV0cmljLCBvbmx5IHN0b3JlIGhhbGYgb2YgdGhlbSBhbmQgYWRhcHQgYWxnb3JpdGhtXG4gICAgLy8gdG8gZmFjdG9yIGluIHN5bW1ldHJ5LlxuICAgIGFic2Npc3NhczogW1xuICAgICAgWyAgMC41NzczNTAyNjkxODk2MjU3NjQ1MDkxNDg4XSxcbiAgICAgIFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG4gICAgICBbICAwLjMzOTk4MTA0MzU4NDg1NjI2NDgwMjY2NTgsMC44NjExMzYzMTE1OTQwNTI1NzUyMjM5NDY1XSxcbiAgICAgIFswLDAuNTM4NDY5MzEwMTA1NjgzMDkxMDM2MzE0NCwwLjkwNjE3OTg0NTkzODY2Mzk5Mjc5NzYyNjldLFxuICAgICAgWyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuICAgICAgWzAsMC40MDU4NDUxNTEzNzczOTcxNjY5MDY2MDY0LDAuNzQxNTMxMTg1NTk5Mzk0NDM5ODYzODY0OCwwLjk0OTEwNzkxMjM0Mjc1ODUyNDUyNjE4OTddLFxuICAgICAgWyAgMC4xODM0MzQ2NDI0OTU2NDk4MDQ5Mzk0NzYxLDAuNTI1NTMyNDA5OTE2MzI4OTg1ODE3NzM5MCwwLjc5NjY2NjQ3NzQxMzYyNjczOTU5MTU1MzksMC45NjAyODk4NTY0OTc1MzYyMzE2ODM1NjA5XSxcbiAgICAgIFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG4gICAgICBbICAwLjE0ODg3NDMzODk4MTYzMTIxMDg4NDgyNjAsMC40MzMzOTUzOTQxMjkyNDcxOTA3OTkyNjU5LDAuNjc5NDA5NTY4Mjk5MDI0NDA2MjM0MzI3NCwwLjg2NTA2MzM2NjY4ODk4NDUxMDczMjA5NjcsMC45NzM5MDY1Mjg1MTcxNzE3MjAwNzc5NjQwXSxcbiAgICAgIFswLDAuMjY5NTQzMTU1OTUyMzQ0OTcyMzMxNTMyMCwwLjUxOTA5NjEyOTIwNjgxMTgxNTkyNTcyNTcsMC43MzAxNTIwMDU1NzQwNDkzMjQwOTM0MTYzLDAuODg3MDYyNTk5NzY4MDk1Mjk5MDc1MTU3OCwwLjk3ODIyODY1ODE0NjA1Njk5MjgwMzkzODBdLFxuICAgICAgWyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuICAgICAgWzAsMC4yMzA0NTgzMTU5NTUxMzQ3OTQwNjU1MjgxLDAuNDQ4NDkyNzUxMDM2NDQ2ODUyODc3OTEyOSwwLjY0MjM0OTMzOTQ0MDM0MDIyMDY0Mzk4NDYsMC44MDE1NzgwOTA3MzMzMDk5MTI3OTQyMDY1LDAuOTE3NTk4Mzk5MjIyOTc3OTY1MjA2NTQ3OCwwLjk4NDE4MzA1NDcxODU4ODE0OTQ3MjgyOTRdLFxuICAgICAgWyAgMC4xMDgwNTQ5NDg3MDczNDM2NjIwNjYyNDQ3LDAuMzE5MTEyMzY4OTI3ODg5NzYwNDM1NjcxOCwwLjUxNTI0ODYzNjM1ODE1NDA5MTk2NTI5MDcsMC42ODcyOTI5MDQ4MTE2ODU0NzAxNDgwMTk4LDAuODI3MjAxMzE1MDY5NzY0OTkzMTg5Nzk0NywwLjkyODQzNDg4MzY2MzU3MzUxNzMzNjM5MTEsMC45ODYyODM4MDg2OTY4MTIzMzg4NDE1OTczXSxcbiAgICAgIFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG4gICAgICBbICAwLjA5NTAxMjUwOTgzNzYzNzQ0MDE4NTMxOTMsMC4yODE2MDM1NTA3NzkyNTg5MTMyMzA0NjA1LDAuNDU4MDE2Nzc3NjU3MjI3Mzg2MzQyNDE5NCwwLjYxNzg3NjI0NDQwMjY0Mzc0ODQ0NjY3MTgsMC43NTU0MDQ0MDgzNTUwMDMwMzM4OTUxMDEyLDAuODY1NjMxMjAyMzg3ODMxNzQzODgwNDY3OSwwLjk0NDU3NTAyMzA3MzIzMjU3NjA3Nzk4ODQsMC45ODk0MDA5MzQ5OTE2NDk5MzI1OTYxNTQyXVxuICAgIF0sXG5cbiAgICB3ZWlnaHRzOiBbXG4gICAgICBbMV0sXG4gICAgICBbMC44ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1Nl0sXG4gICAgICBbMC42NTIxNDUxNTQ4NjI1NDYxNDI2MjY5MzYxLDAuMzQ3ODU0ODQ1MTM3NDUzODU3MzczMDYzOV0sXG4gICAgICBbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuICAgICAgWzAuNDY3OTEzOTM0NTcyNjkxMDQ3Mzg5ODcwMywwLjM2MDc2MTU3MzA0ODEzODYwNzU2OTgzMzUsMC4xNzEzMjQ0OTIzNzkxNzAzNDUwNDAyOTYxXSxcbiAgICAgIFswLjQxNzk1OTE4MzY3MzQ2OTM4Nzc1NTEwMjAsMC4zODE4MzAwNTA1MDUxMTg5NDQ5NTAzNjk4LDAuMjc5NzA1MzkxNDg5Mjc2NjY3OTAxNDY3OCwwLjEyOTQ4NDk2NjE2ODg2OTY5MzI3MDYxMTRdLFxuICAgICAgWzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG4gICAgICBbMC4zMzAyMzkzNTUwMDEyNTk3NjMxNjQ1MjUxLDAuMzEyMzQ3MDc3MDQwMDAyODQwMDY4NjMwNCwwLjI2MDYxMDY5NjQwMjkzNTQ2MjMxODc0MjksMC4xODA2NDgxNjA2OTQ4NTc0MDQwNTg0NzIwLDAuMDgxMjc0Mzg4MzYxNTc0NDExOTcxODkyMl0sXG4gICAgICBbMC4yOTU1MjQyMjQ3MTQ3NTI4NzAxNzM4OTMwLDAuMjY5MjY2NzE5MzA5OTk2MzU1MDkxMjI2OSwwLjIxOTA4NjM2MjUxNTk4MjA0Mzk5NTUzNDksMC4xNDk0NTEzNDkxNTA1ODA1OTMxNDU3NzYzLDAuMDY2NjcxMzQ0MzA4Njg4MTM3NTkzNTY4OF0sXG4gICAgICBbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuICAgICAgWzAuMjQ5MTQ3MDQ1ODEzNDAyNzg1MDAwNTYyNCwwLjIzMzQ5MjUzNjUzODM1NDgwODc2MDg0OTksMC4yMDMxNjc0MjY3MjMwNjU5MjE3NDkwNjQ1LDAuMTYwMDc4MzI4NTQzMzQ2MjI2MzM0NjUyNSwwLjEwNjkzOTMyNTk5NTMxODQzMDk2MDI1NDcsMC4wNDcxNzUzMzYzODY1MTE4MjcxOTQ2MTYwXSxcbiAgICAgIFswLjIzMjU1MTU1MzIzMDg3MzkxMDE5NDU4OTUsMC4yMjYyODMxODAyNjI4OTcyMzg0MTIwOTAyLDAuMjA3ODE2MDQ3NTM2ODg4NTAyMzEyNTIzMiwwLjE3ODE0NTk4MDc2MTk0NTczODI4MDA0NjcsMC4xMzg4NzM1MTAyMTk3ODcyMzg0NjM2MDE4LDAuMDkyMTIxNDk5ODM3NzI4NDQ3OTE0NDIxOCwwLjA0MDQ4NDAwNDc2NTMxNTg3OTUyMDAyMTZdLFxuICAgICAgWzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG4gICAgICBbMC4yMDI1NzgyNDE5MjU1NjEyNzI4ODA2MjAyLDAuMTk4NDMxNDg1MzI3MTExNTc2NDU2MTE4MywwLjE4NjE2MTAwMDAxNTU2MjIxMTAyNjgwMDYsMC4xNjYyNjkyMDU4MTY5OTM5MzM1NTMyMDA5LDAuMTM5NTcwNjc3OTI2MTU0MzE0NDQ3ODA0OCwwLjEwNzE1OTIyMDQ2NzE3MTkzNTAxMTg2OTUsMC4wNzAzNjYwNDc0ODgxMDgxMjQ3MDkyNjc0LDAuMDMwNzUzMjQxOTk2MTE3MjY4MzU0NjI4NF0sXG4gICAgICBbMC4xODk0NTA2MTA0NTUwNjg0OTYyODUzOTY3LDAuMTgyNjAzNDE1MDQ0OTIzNTg4ODY2NzYzNywwLjE2OTE1NjUxOTM5NTAwMjUzODE4OTMxMjEsMC4xNDk1OTU5ODg4MTY1NzY3MzIwODE1MDE3LDAuMTI0NjI4OTcxMjU1NTMzODcyMDUyNDc2MywwLjA5NTE1ODUxMTY4MjQ5Mjc4NDgwOTkyNTEsMC4wNjIyNTM1MjM5Mzg2NDc4OTI4NjI4NDM4LDAuMDI3MTUyNDU5NDExNzU0MDk0ODUxNzgwNl1cbiAgICBdXG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldENvbXBvbmVudE9uQ3ViaWNCZXppZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0IC0gWmVyby10by1vbmUgdmFsdWUgZGVzY3JpYmluZyB3aGF0IHBlcmNlbnRhZ2UgdG8gY2FsY3VsYXRlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gYSAtIFRoZSBmaXJ0IHBvaW50J3MgY29tcG9uZW50IHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIFRoZSBmaXJzdCBwb2ludCdzIGJlemllciBjb21wb25lbnQgdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjIC0gVGhlIHNlY29uZCBwb2ludCdzIGJlemllciBjb21wb25lbnQgdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBkIC0gVGhlIHNlY29uZCBwb2ludCdzIGNvbXBvbmVudCB2YWx1ZS5cbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIGNvb3JkaW5hdGUgdmFsdWUgZm9yIGEgc3BlY2lmaWMgY29tcG9uZW50IGFsb25nIGEgY3ViaWMgYmV6aWVyIGN1cnZlIGJ5IGB0YC5cbiAgICovXG4gIHZhciBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyID0gZnVuY3Rpb24odCwgYSwgYiwgYywgZCkge1xuICAgIHZhciBrID0gMSAtIHQ7XG4gICAgcmV0dXJuIChrICogayAqIGsgKiBhKSArICgzICogayAqIGsgKiB0ICogYikgKyAoMyAqIGsgKiB0ICogdCAqIGMpICtcbiAgICAgICAgKHQgKiB0ICogdCAqIGQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuc3ViZGl2aWRlXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0geDEgLSB4IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkxIC0geSBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MiAtIHggcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50J3MgXCJyaWdodFwiIGJlemllciBoYW5kbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MiAtIHkgcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50J3MgXCJyaWdodFwiIGJlemllciBoYW5kbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MyAtIHggcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludCdzIFwibGVmdFwiIGJlemllciBoYW5kbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MyAtIHkgcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludCdzIFwibGVmdFwiIGJlemllciBoYW5kbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4NCAtIHggcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHk0IC0geSBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0PVR3by5VdGlscy5DdXJ2ZS5SZWN1cnNpb25MaW1pdF0gLSBUaGUgYW1vdW50IG9mIHZlcnRpY2VzIHRvIGNyZWF0ZSBieSBzdWJkaXZpZGluZy5cbiAgICogQHJldHVybnMge0FuY2hvcltdfSBBIGxpc3Qgb2YgYW5jaG9yIHBvaW50cyBvcmRlcmVkIGluIGJldHdlZW4gYHgxYCwgYHkxYCBhbmQgYHg0YCwgYHk0YFxuICAgKiBAZGVzY3JpcHRpb24gR2l2ZW4gMiBwb2ludHMgKGEsIGIpIGFuZCBjb3JyZXNwb25kaW5nIGNvbnRyb2wgcG9pbnQgZm9yIGVhY2ggcmV0dXJuIGFuIGFycmF5IG9mIHBvaW50cyB0aGF0IHJlcHJlc2VudCBwb2ludHMgcGxvdHRlZCBhbG9uZyB0aGUgY3VydmUuIFRoZSBudW1iZXIgb2YgcmV0dXJuZWQgcG9pbnRzIGlzIGRldGVybWluZWQgYnkgYGxpbWl0YC5cbiAgICovXG4gIHZhciBzdWJkaXZpZGUgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGxpbWl0KSB7XG5cbiAgICBsaW1pdCA9IGxpbWl0IHx8IEN1cnZlLlJlY3Vyc2lvbkxpbWl0O1xuICAgIHZhciBhbW91bnQgPSBsaW1pdCArIDE7XG5cbiAgICAvLyBUT0RPOiBBYnN0cmFjdCAwLjAwMSB0byBhIGxpbWl0aW5nIHZhcmlhYmxlXG4gICAgLy8gRG9uJ3QgcmVjdXJzZSBpZiB0aGUgZW5kIHBvaW50cyBhcmUgaWRlbnRpY2FsXG4gICAgaWYgKE1hdGguYWJzKHgxIC0geDQpIDwgMC4wMDEgJiYgTWF0aC5hYnMoeTEgLSB5NCkgPCAwLjAwMSkge1xuICAgICAgcmV0dXJuIFtuZXcgQW5jaG9yKHg0LCB5NCldO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgIHZhciB0ID0gaSAvIGFtb3VudDtcbiAgICAgIHZhciB4ID0gZ2V0Q29tcG9uZW50T25DdWJpY0Jlemllcih0LCB4MSwgeDIsIHgzLCB4NCk7XG4gICAgICB2YXIgeSA9IGdldENvbXBvbmVudE9uQ3ViaWNCZXppZXIodCwgeTEsIHkyLCB5MywgeTQpO1xuICAgICAgcmVzdWx0LnB1c2gobmV3IEFuY2hvcih4LCB5KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q3VydmVMZW5ndGhcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSAtIHggcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgLSB5IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIC0geCBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIC0geSBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzIC0geSBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHg0IC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTQgLSB5IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXQ9VHdvLlV0aWxzLkN1cnZlLlJlY3Vyc2lvbkxpbWl0XSAtIFRoZSBhbW91bnQgb2YgdmVydGljZXMgdG8gY3JlYXRlIGJ5IHN1YmRpdmlkaW5nLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbGVuZ3RoIG9mIGEgY3VydmUuXG4gICAqIEBkZXNjcmlwdGlvbiBHaXZlbiAyIHBvaW50cyAoYSwgYikgYW5kIGNvcnJlc3BvbmRpbmcgY29udHJvbCBwb2ludCBmb3IgZWFjaCwgcmV0dXJuIGEgZmxvYXQgdGhhdCByZXByZXNlbnRzIHRoZSBsZW5ndGggb2YgdGhlIGN1cnZlIHVzaW5nIEdhdXNzLUxlZ2VuZHJlIGFsZ29yaXRobS4gTGltaXQgaXRlcmF0aW9ucyBvZiBjYWxjdWxhdGlvbiBieSBgbGltaXRgLlxuICAgKi9cbiAgdmFyIGdldEN1cnZlTGVuZ3RoJDEgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGxpbWl0KSB7XG5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgLyBmdXp6aWVyIGVxdWFsaXR5IGNoZWNrXG4gICAgLy8gTGluZWFyIGNhbGN1bGF0aW9uXG4gICAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIgJiYgeDMgPT09IHg0ICYmIHkzID09PSB5NCkge1xuICAgICAgdmFyIGR4ID0geDQgLSB4MTtcbiAgICAgIHZhciBkeSA9IHk0IC0geTE7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB9XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGNvZWZmaWNpZW50cyBvZiBhIEJlemllciBkZXJpdmF0aXZlLlxuICAgIHZhciBheCA9IDkgKiAoeDIgLSB4MykgKyAzICogKHg0IC0geDEpLFxuICAgICAgYnggPSA2ICogKHgxICsgeDMpIC0gMTIgKiB4MixcbiAgICAgIGN4ID0gMyAqICh4MiAtIHgxKSxcblxuICAgICAgYXkgPSA5ICogKHkyIC0geTMpICsgMyAqICh5NCAtIHkxKSxcbiAgICAgIGJ5ID0gNiAqICh5MSArIHkzKSAtIDEyICogeTIsXG4gICAgICBjeSA9IDMgKiAoeTIgLSB5MSk7XG5cbiAgICB2YXIgaW50ZWdyYW5kID0gZnVuY3Rpb24odCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHF1YWRyYXRpYyBlcXVhdGlvbnMgb2YgZGVyaXZhdGl2ZXMgZm9yIHggYW5kIHlcbiAgICAgIHZhciBkeCA9IChheCAqIHQgKyBieCkgKiB0ICsgY3gsXG4gICAgICAgIGR5ID0gKGF5ICogdCArIGJ5KSAqIHQgKyBjeTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW50ZWdyYXRlKFxuICAgICAgaW50ZWdyYW5kLCAwLCAxLCBsaW1pdCB8fCBDdXJ2ZS5SZWN1cnNpb25MaW1pdFxuICAgICk7XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldEN1cnZlQm91bmRpbmdCb3hcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSAtIHggcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgLSB5IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIC0geCBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIC0geSBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzIC0geSBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHg0IC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTQgLSB5IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IE9iamVjdCBjb250YWlucyBtaW4gYW5kIG1heCBgeGAgLyBgeWAgYm91bmRzLlxuICAgKiBAc2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vYWRvYmUtd2VicGxhdGZvcm0vU25hcC5zdmcvYmxvYi9tYXN0ZXIvc3JjL3BhdGguanMjTDg1Nn1cbiAgICovXG4gIHZhciBnZXRDdXJ2ZUJvdW5kaW5nQm94ID0gZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0KSB7XG5cbiAgICB2YXIgdHZhbHVlcyA9IFtdO1xuICAgIHZhciBib3VuZHMgPSBbW10sIFtdXTtcbiAgICB2YXIgYSwgYiwgYywgdCwgdDEsIHQyLCBiMmFjLCBzcXJ0YjJhYztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICBiID0gNiAqIHgxIC0gMTIgKiB4MiArIDYgKiB4MztcbiAgICAgICAgICBhID0gLTMgKiB4MSArIDkgKiB4MiAtIDkgKiB4MyArIDMgKiB4NDtcbiAgICAgICAgICBjID0gMyAqIHgyIC0gMyAqIHgxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGIgPSA2ICogeTEgLSAxMiAqIHkyICsgNiAqIHkzO1xuICAgICAgICAgIGEgPSAtMyAqIHkxICsgOSAqIHkyIC0gOSAqIHkzICsgMyAqIHk0O1xuICAgICAgICAgIGMgPSAzICogeTIgLSAzICogeTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE1hdGguYWJzKGEpIDwgMWUtMTIpIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgICAgaWYgKDAgPCB0ICYmIHQgPCAxKSB7XG4gICAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgICAgc3FydGIyYWMgPSBNYXRoLnNxcnQoYjJhYyk7XG4gICAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHQxID0gKC1iICsgc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgICB9XG4gICAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godDIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGogPSB0dmFsdWVzLmxlbmd0aDtcbiAgICB2YXIgamxlbiA9IGo7XG4gICAgdmFyIG10O1xuXG4gICAgd2hpbGUgKGotLSkge1xuICAgICAgdCA9IHR2YWx1ZXNbal07XG4gICAgICBtdCA9IDEgLSB0O1xuICAgICAgYm91bmRzWzBdW2pdID0gbXQgKiBtdCAqIG10ICogeDEgKyAzICogbXQgKiBtdCAqIHQgKiB4MiArIDMgKiBtdCAqIHQgKiB0ICogeDMgKyB0ICogdCAqIHQgKiB4NDtcbiAgICAgIGJvdW5kc1sxXVtqXSA9IG10ICogbXQgKiBtdCAqIHkxICsgMyAqIG10ICogbXQgKiB0ICogeTIgKyAzICogbXQgKiB0ICogdCAqIHkzICsgdCAqIHQgKiB0ICogeTQ7XG4gICAgfVxuXG4gICAgYm91bmRzWzBdW2psZW5dID0geDE7XG4gICAgYm91bmRzWzFdW2psZW5dID0geTE7XG4gICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHg0O1xuICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5NDtcbiAgICBib3VuZHNbMF0ubGVuZ3RoID0gYm91bmRzWzFdLmxlbmd0aCA9IGpsZW4gKyAyO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogeyB4OiBNYXRoLm1pbi5hcHBseSgwLCBib3VuZHNbMF0pLCB5OiBNYXRoLm1pbi5hcHBseSgwLCBib3VuZHNbMV0pIH0sXG4gICAgICBtYXg6IHsgeDogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzBdKSwgeTogTWF0aC5tYXguYXBwbHkoMCwgYm91bmRzWzFdKSB9XG4gICAgfTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuaW50ZWdyYXRlXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuXG4gICAqIEBkZXNjcmlwdGlvbiBJbnRlZ3JhdGlvbiBmb3IgYGdldEN1cnZlTGVuZ3RoYCBjYWxjdWxhdGlvbnMuXG4gICAqIEBzZWUgW1BhcGVyLmpzXShAbGluayBodHRwczovL2dpdGh1Yi5jb20vcGFwZXJqcy9wYXBlci5qcy9ibG9iL21hc3Rlci9zcmMvdXRpbC9OdW1lcmljYWwuanMjTDEwMSlcbiAgICovXG4gIHZhciBpbnRlZ3JhdGUgPSBmdW5jdGlvbihmLCBhLCBiLCBuKSB7XG4gICAgdmFyIHggPSBDdXJ2ZS5hYnNjaXNzYXNbbiAtIDJdLFxuICAgICAgdyA9IEN1cnZlLndlaWdodHNbbiAtIDJdLFxuICAgICAgQSA9IDAuNSAqIChiIC0gYSksXG4gICAgICBCID0gQSArIGEsXG4gICAgICBpID0gMCxcbiAgICAgIG0gPSAobiArIDEpID4+IDEsXG4gICAgICBzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwOyAvLyBIYW5kbGUgb2RkIG5cbiAgICB3aGlsZSAoaSA8IG0pIHtcbiAgICAgIHZhciBBeCA9IEEgKiB4W2ldO1xuICAgICAgc3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuICAgIH1cbiAgICByZXR1cm4gQSAqIHN1bTtcbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldEN1cnZlRnJvbVBvaW50c1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBbmNob3JbXX0gcG9pbnRzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvc2VkXG4gICAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBiZXppZXIgaGFuZGxlcyBvbiB7QGxpbmsgQW5jaG9yfXMgaW4gdGhlIGBwb2ludHNgIGxpc3Qgd2l0aCBlc3RpbWF0ZWQgdmFsdWVzIHRvIGNyZWF0ZSBhIGNhdG11bGwtcm9tIGxpa2UgY3VydmUuIFVzZWQgYnkge0BsaW5rIFR3by5QYXRoI3Bsb3R9LlxuICAgKi9cbiAgdmFyIGdldEN1cnZlRnJvbVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cywgY2xvc2VkKSB7XG5cbiAgICB2YXIgbCA9IHBvaW50cy5sZW5ndGgsIGxhc3QgPSBsIC0gMTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgaWYgKCFfLmlzT2JqZWN0KHBvaW50LmNvbnRyb2xzKSkge1xuICAgICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKHBvaW50KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGwpIDogTWF0aC5tYXgoaSAtIDEsIDApO1xuICAgICAgdmFyIG5leHQgPSBjbG9zZWQgPyBtb2QoaSArIDEsIGwpIDogTWF0aC5taW4oaSArIDEsIGxhc3QpO1xuXG4gICAgICB2YXIgYSA9IHBvaW50c1twcmV2XTtcbiAgICAgIHZhciBiID0gcG9pbnQ7XG4gICAgICB2YXIgYyA9IHBvaW50c1tuZXh0XTtcbiAgICAgIGdldENvbnRyb2xQb2ludHMoYSwgYiwgYyk7XG5cbiAgICAgIGIuY29tbWFuZCA9IGkgPT09IDAgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMuY3VydmU7XG5cbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldENvbnRyb2xQb2ludHNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7QW5jaG9yfSBhXG4gICAqIEBwYXJhbSB7QW5jaG9yfSBiXG4gICAqIEBwYXJhbSB7QW5jaG9yfSBjXG4gICAqIEByZXR1cm5zIHtBbmNob3J9IFJldHVybnMgdGhlIHBhc3NlZCBtaWRkbGUgcG9pbnQgYGJgLlxuICAgKiBAZGVzY3JpcHRpb24gR2l2ZW4gdGhyZWUgY29vcmRpbmF0ZXMgc2V0IHRoZSBjb250cm9sIHBvaW50cyBmb3IgdGhlIG1pZGRsZSwgYiwgdmVydGV4IGJhc2VkIG9uIGl0cyBwb3NpdGlvbiB3aXRoIHRoZSBhZGphY2VudCBwb2ludHMuXG4gICAqL1xuICB2YXIgZ2V0Q29udHJvbFBvaW50cyA9IGZ1bmN0aW9uKGEsIGIsIGMpIHtcblxuICAgIHZhciBhMSA9IFZlY3Rvci5hbmdsZUJldHdlZW4oYSwgYik7XG4gICAgdmFyIGEyID0gVmVjdG9yLmFuZ2xlQmV0d2VlbihjLCBiKTtcblxuICAgIHZhciBkMSA9IFZlY3Rvci5kaXN0YW5jZUJldHdlZW4oYSwgYik7XG4gICAgdmFyIGQyID0gVmVjdG9yLmRpc3RhbmNlQmV0d2VlbihjLCBiKTtcblxuICAgIHZhciBtaWQgPSAoYTEgKyBhMikgLyAyO1xuXG4gICAgLy8gVE9ETzogSXNzdWUgNzNcbiAgICBpZiAoZDEgPCAwLjAwMDEgfHwgZDIgPCAwLjAwMDEpIHtcbiAgICAgIGlmICh0eXBlb2YgYi5yZWxhdGl2ZSA9PT0gJ2Jvb2xlYW4nICYmICFiLnJlbGF0aXZlKSB7XG4gICAgICAgIGIuY29udHJvbHMubGVmdC5jb3B5KGIpO1xuICAgICAgICBiLmNvbnRyb2xzLnJpZ2h0LmNvcHkoYik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYjtcbiAgICB9XG5cbiAgICBkMSAqPSAwLjMzOyAvLyBXaHkgMC4zMz9cbiAgICBkMiAqPSAwLjMzO1xuXG4gICAgaWYgKGEyIDwgYTEpIHtcbiAgICAgIG1pZCArPSBIQUxGX1BJJDM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pZCAtPSBIQUxGX1BJJDM7XG4gICAgfVxuXG4gICAgYi5jb250cm9scy5sZWZ0LnggPSBNYXRoLmNvcyhtaWQpICogZDE7XG4gICAgYi5jb250cm9scy5sZWZ0LnkgPSBNYXRoLnNpbihtaWQpICogZDE7XG5cbiAgICBtaWQgLT0gTWF0aC5QSTtcblxuICAgIGIuY29udHJvbHMucmlnaHQueCA9IE1hdGguY29zKG1pZCkgKiBkMjtcbiAgICBiLmNvbnRyb2xzLnJpZ2h0LnkgPSBNYXRoLnNpbihtaWQpICogZDI7XG5cbiAgICBpZiAodHlwZW9mIGIucmVsYXRpdmUgPT09ICdib29sZWFuJyAmJiAhYi5yZWxhdGl2ZSkge1xuICAgICAgYi5jb250cm9scy5sZWZ0LnggKz0gYi54O1xuICAgICAgYi5jb250cm9scy5sZWZ0LnkgKz0gYi55O1xuICAgICAgYi5jb250cm9scy5yaWdodC54ICs9IGIueDtcbiAgICAgIGIuY29udHJvbHMucmlnaHQueSArPSBiLnk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGI7XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldFJlZmxlY3Rpb25cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7VmVjdG9yfSBhXG4gICAqIEBwYXJhbSB7VmVjdG9yfSBiXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXVxuICAgKiBAcmV0dXJucyB7VmVjdG9yfSBOZXcge0BsaW5rIFZlY3Rvcn0gdGhhdCByZXByZXNlbnRzIHRoZSByZWZsZWN0aW9uIHBvaW50LlxuICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSByZWZsZWN0aW9uIG9mIGEgcG9pbnQgYGJgIGFib3V0IHBvaW50IGBhYC4gV2hlcmUgYGFgIGlzIGluIGFic29sdXRlIHNwYWNlIGFuZCBgYmAgaXMgcmVsYXRpdmUgdG8gYGFgLlxuICAgKiBAc2VlIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9pbXBsbm90ZS5odG1sI1BhdGhFbGVtZW50SW1wbGVtZW50YXRpb25Ob3Rlc31cbiAgICovXG4gIHZhciBnZXRSZWZsZWN0aW9uID0gZnVuY3Rpb24oYSwgYiwgcmVsYXRpdmUpIHtcblxuICAgIHJldHVybiBuZXcgVmVjdG9yKFxuICAgICAgMiAqIGEueCAtIChiLnggKyBhLngpIC0gKHJlbGF0aXZlID8gYS54IDogMCksXG4gICAgICAyICogYS55IC0gKGIueSArIGEueSkgLSAocmVsYXRpdmUgPyBhLnkgOiAwKVxuICAgICk7XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldEFuY2hvcnNGcm9tQXJjRGF0YVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtWZWN0b3J9IGNlbnRlclxuICAgKiBAcGFyYW0ge051bWJlcn0geEF4aXNSb3RhdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gcnggLSB4IHJhZGl1c1xuICAgKiBAcGFyYW0ge051bWJlcn0gcnkgLSB5IHJhZGl1c1xuICAgKiBAcGFyYW0ge051bWJlcn0gdHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHRkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Njdz1mYWxzZV0gLSBTZXQgcGF0aCB0cmF2ZXJzYWwgdG8gY291bnRlci1jbG9ja3dpc2VcbiAgICovXG4gIHZhciBnZXRBbmNob3JzRnJvbUFyY0RhdGEgPSBmdW5jdGlvbihjZW50ZXIsIHhBeGlzUm90YXRpb24sIHJ4LCByeSwgdHMsIHRkLCBjY3cpIHtcblxuICAgIHZhciByZXNvbHV0aW9uID0gQ29uc3RhbnRzLlJlc29sdXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc29sdXRpb247IGkrKykge1xuICAgICAgdmFyIHBjdCA9IChpICsgMSkgLyByZXNvbHV0aW9uO1xuICAgICAgaWYgKGNjdykge1xuICAgICAgICBwY3QgPSAxIC0gcGN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgdGhldGEgPSBwY3QgKiB0ZCArIHRzO1xuICAgICAgdmFyIHggPSByeCAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciB5ID0gcnkgKiBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgIC8vIHggKz0gY2VudGVyLng7XG4gICAgICAvLyB5ICs9IGNlbnRlci55O1xuXG4gICAgICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcih4LCB5KTtcbiAgICAgIEFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXMoYW5jaG9yKTtcbiAgICAgIGFuY2hvci5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcbiAgICB9XG5cbiAgfTtcblxuICB2YXIgQ3VydmVzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBDdXJ2ZTogQ3VydmUsXG4gICAgZ2V0Q29tcG9uZW50T25DdWJpY0JlemllcjogZ2V0Q29tcG9uZW50T25DdWJpY0JlemllcixcbiAgICBzdWJkaXZpZGU6IHN1YmRpdmlkZSxcbiAgICBnZXRDdXJ2ZUxlbmd0aDogZ2V0Q3VydmVMZW5ndGgkMSxcbiAgICBnZXRDdXJ2ZUJvdW5kaW5nQm94OiBnZXRDdXJ2ZUJvdW5kaW5nQm94LFxuICAgIGludGVncmF0ZTogaW50ZWdyYXRlLFxuICAgIGdldEN1cnZlRnJvbVBvaW50czogZ2V0Q3VydmVGcm9tUG9pbnRzLFxuICAgIGdldENvbnRyb2xQb2ludHM6IGdldENvbnRyb2xQb2ludHMsXG4gICAgZ2V0UmVmbGVjdGlvbjogZ2V0UmVmbGVjdGlvbixcbiAgICBnZXRBbmNob3JzRnJvbUFyY0RhdGE6IGdldEFuY2hvcnNGcm9tQXJjRGF0YVxuICB9KTtcblxuICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHJvb3QkMS5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cbiAgdmFyIGdldEJhY2tpbmdTdG9yZVJhdGlvID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgcmV0dXJuIGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldFJhdGlvXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSByYXRpbyBvZiBhIHVuaXQgaW4gVHdvLmpzIHRvIHRoZSBwaXhlbCBkZW5zaXR5IG9mIGEgc2Vzc2lvbidzIHNjcmVlbi5cbiAgICogQHNlZSBbSGlnaCBEUEkgUmVuZGVyaW5nXShodHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaGlkcGkvKVxuICAgKi9cbiAgdmFyIGdldFJhdGlvID0gZnVuY3Rpb24oY3R4KSB7XG4gICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW8gLyBnZXRCYWNraW5nU3RvcmVSYXRpbyhjdHgpO1xuICB9O1xuXG4gIC8vIENvbnN0YW50c1xuXG4gIHZhciBjb3MkNSA9IE1hdGguY29zLCBzaW4kNSA9IE1hdGguc2luLCB0YW4gPSBNYXRoLnRhbjtcbiAgdmFyIGFycmF5ID0gW107XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5NYXRyaXhcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYT0xXSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCBmaXJzdCByb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYj0wXSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgc2Vjb25kIGNvbHVtbiBhbmQgZmlyc3Qgcm93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2M9MF0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgZmlyc3Qgcm93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Q9MF0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgc2Vjb25kIHJvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlPTFdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBzZWNvbmQgcm93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2Y9MF0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgc2Vjb25kIHJvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtnPTBdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoPTBdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCB0aGlyZCByb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaT0xXSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCB0aGlyZCByb3cuXG4gICAqIEBkZXNjcmlwdGlvbiBBIGNsYXNzIHRvIHN0b3JlIDMgeCAzIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBpbmZvcm1hdGlvbi4gSW4gYWRkaXRpb24gdG8gc3RvcmluZyBkYXRhIGBUd28uTWF0cml4YCBoYXMgc3VwZWQgdXAgbWV0aG9kcyBmb3IgY29tbW9ucGxhY2UgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbnMuXG4gICAqIEBub3RhLWJlbmUgT3JkZXIgaXMgYmFzZWQgb24gaG93IHRvIGNvbnN0cnVjdCB0cmFuc2Zvcm1hdGlvbiBzdHJpbmdzIGZvciB0aGUgYnJvd3Nlci5cbiAgICovXG4gIGZ1bmN0aW9uIE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I2VsZW1lbnRzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJbXX0gLSBUaGUgdW5kZXJseWluZyBkYXRhIHN0b3JlZCBhcyBhbiBhcnJheS5cbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRzID0gbmV3IE51bUFycmF5KDkpO1xuXG4gICAgdmFyIGVsZW1lbnRzID0gYTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICBlbGVtZW50cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgZWxlbWVudHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICB0aGlzLmlkZW50aXR5KCk7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5zZXQoZWxlbWVudHMpO1xuICAgIH1cblxuICB9XG5cbiAgc2V0TWF0cml4KE1hdHJpeCk7XG5cbiAgXy5leHRlbmQoTWF0cml4LCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4LklkZW50aXR5XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJbXX0gLSBBIHN0b3JlZCByZWZlcmVuY2UgdG8gdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSAzIHggMyBtYXRyaXguXG4gICAgICovXG4gICAgSWRlbnRpdHk6IFtcbiAgICAgIDEsIDAsIDAsXG4gICAgICAwLCAxLCAwLFxuICAgICAgMCwgMCwgMVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4Lk11bHRpcGx5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uTWF0cml4fSBBXG4gICAgICogQHBhcmFtIHtUd28uTWF0cml4fSBCXG4gICAgICogQHBhcmFtIHtUd28uTWF0cml4fSBbQ10gLSBBbiBvcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdGhlIG11bHRpcGxpY2F0aW9uIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uTWF0cml4fSAtIElmIGFuIG9wdGlvbmFsIGBDYCBtYXRyaXggaXNuJ3QgcGFzc2VkIHRoZW4gYSBuZXcgb25lIGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSB0d28gbWF0cmljZXMgdG9nZXRoZXIgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIE11bHRpcGx5OiBmdW5jdGlvbihBLCBCLCBDKSB7XG5cbiAgICAgIGlmIChCLmxlbmd0aCA8PSAzKSB7IC8vIE11bHRpcGx5IFZlY3RvclxuXG4gICAgICAgIHZhciB4LCB5LCB6LCBlID0gQTtcblxuICAgICAgICB2YXIgYSA9IEJbMF0gfHwgMCxcbiAgICAgICAgICAgIGIgPSBCWzFdIHx8IDAsXG4gICAgICAgICAgICBjID0gQlsyXSB8fCAwO1xuXG4gICAgICAgIC8vIEdvIGRvd24gcm93cyBmaXJzdFxuICAgICAgICAvLyBhLCBkLCBnLCBiLCBlLCBoLCBjLCBmLCBpXG5cbiAgICAgICAgeCA9IGVbMF0gKiBhICsgZVsxXSAqIGIgKyBlWzJdICogYztcbiAgICAgICAgeSA9IGVbM10gKiBhICsgZVs0XSAqIGIgKyBlWzVdICogYztcbiAgICAgICAgeiA9IGVbNl0gKiBhICsgZVs3XSAqIGIgKyBlWzhdICogYztcblxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB6OiB6IH07XG5cbiAgICAgIH1cblxuICAgICAgdmFyIEEwID0gQVswXSwgQTEgPSBBWzFdLCBBMiA9IEFbMl07XG4gICAgICB2YXIgQTMgPSBBWzNdLCBBNCA9IEFbNF0sIEE1ID0gQVs1XTtcbiAgICAgIHZhciBBNiA9IEFbNl0sIEE3ID0gQVs3XSwgQTggPSBBWzhdO1xuXG4gICAgICB2YXIgQjAgPSBCWzBdLCBCMSA9IEJbMV0sIEIyID0gQlsyXTtcbiAgICAgIHZhciBCMyA9IEJbM10sIEI0ID0gQls0XSwgQjUgPSBCWzVdO1xuICAgICAgdmFyIEI2ID0gQls2XSwgQjcgPSBCWzddLCBCOCA9IEJbOF07XG5cbiAgICAgIEMgPSBDIHx8IG5ldyBOdW1BcnJheSg5KTtcblxuICAgICAgQ1swXSA9IEEwICogQjAgKyBBMSAqIEIzICsgQTIgKiBCNjtcbiAgICAgIENbMV0gPSBBMCAqIEIxICsgQTEgKiBCNCArIEEyICogQjc7XG4gICAgICBDWzJdID0gQTAgKiBCMiArIEExICogQjUgKyBBMiAqIEI4O1xuICAgICAgQ1szXSA9IEEzICogQjAgKyBBNCAqIEIzICsgQTUgKiBCNjtcbiAgICAgIENbNF0gPSBBMyAqIEIxICsgQTQgKiBCNCArIEE1ICogQjc7XG4gICAgICBDWzVdID0gQTMgKiBCMiArIEE0ICogQjUgKyBBNSAqIEI4O1xuICAgICAgQ1s2XSA9IEE2ICogQjAgKyBBNyAqIEIzICsgQTggKiBCNjtcbiAgICAgIENbN10gPSBBNiAqIEIxICsgQTcgKiBCNCArIEE4ICogQjc7XG4gICAgICBDWzhdID0gQTYgKiBCMiArIEE3ICogQjUgKyBBOCAqIEI4O1xuXG4gICAgICByZXR1cm4gQztcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChNYXRyaXgucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBNYXRyaXgsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I21hbnVhbFxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgVHdvLmpzIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlcyB0aGUgdmFsdWVzIGZvciB0aGUgbWF0cml4IG9yIGlmIHRoZSBkZXZlbG9wZXIgaW50ZW5kcyB0byBtYW5hZ2UgdGhlIG1hdHJpeC5cbiAgICAgKiBAbm90YS1iZW5lIC0gU2V0dGluZyB0byBgdHJ1ZWAgbnVsbGlmaWVzIHtAbGluayBUd28uU2hhcGUjdHJhbnNsYXRpb259LCB7QGxpbmsgVHdvLlNoYXBlI3JvdGF0aW9ufSwgYW5kIHtAbGluayBUd28uU2hhcGUjc2NhbGV9LlxuICAgICAqL1xuICAgIG1hbnVhbDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3NldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIGZpcnN0IHJvdy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgc2Vjb25kIGNvbHVtbiBhbmQgZmlyc3Qgcm93LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIGZpcnN0IHJvdy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZCAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCBzZWNvbmQgcm93LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBzZWNvbmQgcm93LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIHNlY29uZCByb3cuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGcgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgdGhpcmQgcm93LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCB0aGlyZCByb3cuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGkgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgdGhpcmQgcm93LlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYW4gYXJyYXkgb2YgdmFsdWVzIG9udG8gdGhlIG1hdHJpeC4gT3JkZXIgZGVzY3JpYmVkIGluIHtAbGluayBUd28uTWF0cml4fS5cbiAgICAgKi9cblxuICAgICAgLyoqXG4gICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2V0XG4gICAgICAqIEBmdW5jdGlvblxuICAgICAgKiBAcGFyYW0ge051bWJlcltdfSBhIC0gVGhlIGFycmF5IG9mIGVsZW1lbnRzIHRvIGFwcGx5LlxuICAgICAgKiBAZGVzY3JpcHRpb24gU2V0IGFuIGFycmF5IG9mIHZhbHVlcyBvbnRvIHRoZSBtYXRyaXguIE9yZGVyIGRlc2NyaWJlZCBpbiB7QGxpbmsgVHdvLk1hdHJpeH0uXG4gICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge1xuXG4gICAgICB2YXIgZWxlbWVudHM7XG5cbiAgICAgIGlmICh0eXBlb2YgYiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZWxlbWVudHMgPSBhO1xuICAgICAgICBhID0gZWxlbWVudHNbMF07XG4gICAgICAgIGIgPSBlbGVtZW50c1sxXTtcbiAgICAgICAgYyA9IGVsZW1lbnRzWzJdO1xuICAgICAgICBkID0gZWxlbWVudHNbM107XG4gICAgICAgIGUgPSBlbGVtZW50c1s0XTtcbiAgICAgICAgZiA9IGVsZW1lbnRzWzVdO1xuICAgICAgICBnID0gZWxlbWVudHNbNl07XG4gICAgICAgIGggPSBlbGVtZW50c1s3XTtcbiAgICAgICAgaSA9IGVsZW1lbnRzWzhdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmVsZW1lbnRzWzBdID0gYTtcbiAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBiO1xuICAgICAgdGhpcy5lbGVtZW50c1syXSA9IGM7XG4gICAgICB0aGlzLmVsZW1lbnRzWzNdID0gZDtcbiAgICAgIHRoaXMuZWxlbWVudHNbNF0gPSBlO1xuICAgICAgdGhpcy5lbGVtZW50c1s1XSA9IGY7XG4gICAgICB0aGlzLmVsZW1lbnRzWzZdID0gZztcbiAgICAgIHRoaXMuZWxlbWVudHNbN10gPSBoO1xuICAgICAgdGhpcy5lbGVtZW50c1s4XSA9IGk7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNjb3B5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENvcHkgdGhlIG1hdHJpeCBvZiBvbmUgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY29weTogZnVuY3Rpb24obSkge1xuXG4gICAgICB0aGlzLmVsZW1lbnRzWzBdID0gbS5lbGVtZW50c1swXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBtLmVsZW1lbnRzWzFdO1xuICAgICAgdGhpcy5lbGVtZW50c1syXSA9IG0uZWxlbWVudHNbMl07XG4gICAgICB0aGlzLmVsZW1lbnRzWzNdID0gbS5lbGVtZW50c1szXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbNF0gPSBtLmVsZW1lbnRzWzRdO1xuICAgICAgdGhpcy5lbGVtZW50c1s1XSA9IG0uZWxlbWVudHNbNV07XG4gICAgICB0aGlzLmVsZW1lbnRzWzZdID0gbS5lbGVtZW50c1s2XTtcbiAgICAgIHRoaXMuZWxlbWVudHNbN10gPSBtLmVsZW1lbnRzWzddO1xuICAgICAgdGhpcy5lbGVtZW50c1s4XSA9IG0uZWxlbWVudHNbOF07XG5cbiAgICAgIHRoaXMubWFudWFsID0gbS5tYW51YWw7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNpZGVudGl0eVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBUdXJuIG1hdHJpeCB0byB0aGUgaWRlbnRpdHksIGxpa2UgcmVzZXR0aW5nLlxuICAgICAqL1xuICAgIGlkZW50aXR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5lbGVtZW50c1swXSA9IE1hdHJpeC5JZGVudGl0eVswXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBNYXRyaXguSWRlbnRpdHlbMV07XG4gICAgICB0aGlzLmVsZW1lbnRzWzJdID0gTWF0cml4LklkZW50aXR5WzJdO1xuICAgICAgdGhpcy5lbGVtZW50c1szXSA9IE1hdHJpeC5JZGVudGl0eVszXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbNF0gPSBNYXRyaXguSWRlbnRpdHlbNF07XG4gICAgICB0aGlzLmVsZW1lbnRzWzVdID0gTWF0cml4LklkZW50aXR5WzVdO1xuICAgICAgdGhpcy5lbGVtZW50c1s2XSA9IE1hdHJpeC5JZGVudGl0eVs2XTtcbiAgICAgIHRoaXMuZWxlbWVudHNbN10gPSBNYXRyaXguSWRlbnRpdHlbN107XG4gICAgICB0aGlzLmVsZW1lbnRzWzhdID0gTWF0cml4LklkZW50aXR5WzhdO1xuXG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjbXVsdGlwbHlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSAtIFRoZSBzY2FsYXIgdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsdGlwbHkgYWxsIGNvbXBvbmVudHMgb2YgdGhlIG1hdHJpeCBhZ2FpbnN0IGEgc2luZ2xlIHNjYWxhciB2YWx1ZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNtdWx0aXBseVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gVGhlIHggY29tcG9uZW50IHRvIGJlIG11bHRpcGxpZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGIgLSBUaGUgeSBjb21wb25lbnQgdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyAtIFRoZSB6IGNvbXBvbmVudCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBhbGwgY29tcG9uZW50cyBvZiBhIG1hdHJpeCBhZ2FpbnN0IGEgMyBjb21wb25lbnQgdmVjdG9yLlxuICAgICAqIEBvdmVybG9hZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I211bHRpcGx5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBUaGUgdmFsdWUgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgZmlyc3Qgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIFRoZSB2YWx1ZSBhdCB0aGUgc2Vjb25kIGNvbHVtbiBhbmQgZmlyc3Qgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYyAtIFRoZSB2YWx1ZSBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCBmaXJzdCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIC0gVGhlIHZhbHVlIGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIHNlY29uZCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlIC0gVGhlIHZhbHVlIGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBzZWNvbmQgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZiAtIFRoZSB2YWx1ZSBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCBzZWNvbmQgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyAtIFRoZSB2YWx1ZSBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCB0aGlyZCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoIC0gVGhlIHZhbHVlIGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCB0aGlyZCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpIC0gVGhlIHZhbHVlIGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIHRoaXJkIHJvdyBvZiB0aGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIE11bHRpcGx5IGFsbCBjb21wb25lbnRzIG9mIGEgbWF0cml4IGFnYWluc3QgYW5vdGhlciBtYXRyaXguXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cbiAgICBtdWx0aXBseTogZnVuY3Rpb24oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSkge1xuXG4gICAgICAvLyBNdWx0aXBseSBzY2FsYXJcblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykge1xuXG4gICAgICAgIHRoaXMuZWxlbWVudHNbMF0gKj0gYTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1sxXSAqPSBhO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzJdICo9IGE7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbM10gKj0gYTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1s0XSAqPSBhO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzVdICo9IGE7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbNl0gKj0gYTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1s3XSAqPSBhO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzhdICo9IGE7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGQgPT09ICd1bmRlZmluZWQnKSB7IC8vIE11bHRpcGx5IFZlY3RvclxuXG4gICAgICAgIHZhciB4LCB5LCB6O1xuICAgICAgICBhID0gYSB8fCAwO1xuICAgICAgICBiID0gYiB8fCAwO1xuICAgICAgICBjID0gYyB8fCAwO1xuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcblxuICAgICAgICAvLyBHbyBkb3duIHJvd3MgZmlyc3RcbiAgICAgICAgLy8gYSwgZCwgZywgYiwgZSwgaCwgYywgZiwgaVxuXG4gICAgICAgIHggPSBlWzBdICogYSArIGVbMV0gKiBiICsgZVsyXSAqIGM7XG4gICAgICAgIHkgPSBlWzNdICogYSArIGVbNF0gKiBiICsgZVs1XSAqIGM7XG4gICAgICAgIHogPSBlWzZdICogYSArIGVbN10gKiBiICsgZVs4XSAqIGM7XG5cbiAgICAgICAgcmV0dXJuIHsgeDogeCwgeTogeSwgejogeiB9O1xuXG4gICAgICB9XG5cbiAgICAgIC8vIE11bHRpcGxlIG1hdHJpeFxuXG4gICAgICB2YXIgQSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgQiA9IFthLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpXTtcblxuICAgICAgdmFyIEEwID0gQVswXSwgQTEgPSBBWzFdLCBBMiA9IEFbMl07XG4gICAgICB2YXIgQTMgPSBBWzNdLCBBNCA9IEFbNF0sIEE1ID0gQVs1XTtcbiAgICAgIHZhciBBNiA9IEFbNl0sIEE3ID0gQVs3XSwgQTggPSBBWzhdO1xuXG4gICAgICB2YXIgQjAgPSBCWzBdLCBCMSA9IEJbMV0sIEIyID0gQlsyXTtcbiAgICAgIHZhciBCMyA9IEJbM10sIEI0ID0gQls0XSwgQjUgPSBCWzVdO1xuICAgICAgdmFyIEI2ID0gQls2XSwgQjcgPSBCWzddLCBCOCA9IEJbOF07XG5cbiAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSBBMCAqIEIwICsgQTEgKiBCMyArIEEyICogQjY7XG4gICAgICB0aGlzLmVsZW1lbnRzWzFdID0gQTAgKiBCMSArIEExICogQjQgKyBBMiAqIEI3O1xuICAgICAgdGhpcy5lbGVtZW50c1syXSA9IEEwICogQjIgKyBBMSAqIEI1ICsgQTIgKiBCODtcblxuICAgICAgdGhpcy5lbGVtZW50c1szXSA9IEEzICogQjAgKyBBNCAqIEIzICsgQTUgKiBCNjtcbiAgICAgIHRoaXMuZWxlbWVudHNbNF0gPSBBMyAqIEIxICsgQTQgKiBCNCArIEE1ICogQjc7XG4gICAgICB0aGlzLmVsZW1lbnRzWzVdID0gQTMgKiBCMiArIEE0ICogQjUgKyBBNSAqIEI4O1xuXG4gICAgICB0aGlzLmVsZW1lbnRzWzZdID0gQTYgKiBCMCArIEE3ICogQjMgKyBBOCAqIEI2O1xuICAgICAgdGhpcy5lbGVtZW50c1s3XSA9IEE2ICogQjEgKyBBNyAqIEI0ICsgQTggKiBCNztcbiAgICAgIHRoaXMuZWxlbWVudHNbOF0gPSBBNiAqIEIyICsgQTcgKiBCNSArIEE4ICogQjg7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNpbnZlcnNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uTWF0cml4fSBbb3V0XSAtIFRoZSBvcHRpb25hbCBtYXRyaXggdG8gYXBwbHkgdGhlIGludmVyc2lvbiB0by5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhlIG1hdHJpeC4gSWYgbm8gb3B0aW9uYWwgb25lIGlzIHBhc3NlZCBhIG5ldyBtYXRyaXggaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gICAgICovXG4gICAgaW52ZXJzZTogZnVuY3Rpb24ob3V0KSB7XG5cbiAgICAgIHZhciBhID0gdGhpcy5lbGVtZW50cztcbiAgICAgIG91dCA9IG91dCB8fCBuZXcgTWF0cml4KCk7XG5cbiAgICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdO1xuICAgICAgdmFyIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV07XG4gICAgICB2YXIgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgICAgdmFyIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMTtcbiAgICAgIHZhciBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwO1xuICAgICAgdmFyIGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgdmFyIGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTtcblxuICAgICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgICAgb3V0LmVsZW1lbnRzWzBdID0gYjAxICogZGV0O1xuICAgICAgb3V0LmVsZW1lbnRzWzFdID0gKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0O1xuICAgICAgb3V0LmVsZW1lbnRzWzJdID0gKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQ7XG4gICAgICBvdXQuZWxlbWVudHNbM10gPSBiMTEgKiBkZXQ7XG4gICAgICBvdXQuZWxlbWVudHNbNF0gPSAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldDtcbiAgICAgIG91dC5lbGVtZW50c1s1XSA9ICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldDtcbiAgICAgIG91dC5lbGVtZW50c1s2XSA9IGIyMSAqIGRldDtcbiAgICAgIG91dC5lbGVtZW50c1s3XSA9ICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldDtcbiAgICAgIG91dC5lbGVtZW50c1s4XSA9IChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0O1xuXG4gICAgICByZXR1cm4gb3V0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2NhbGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgLSBUaGUgb25lIGRpbWVuc2lvbmFsIHNjYWxlIHRvIGFwcGx5IHRvIHRoZSBtYXRyaXguXG4gICAgICogQGRlc2NyaXB0aW9uIFVuaWZvcm1seSBzY2FsZSB0aGUgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNzY2FsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeCAtIFRoZSBob3Jpem9udGFsIHNjYWxlIGZhY3Rvci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3kgLSBUaGUgdmVydGljYWwgc2NhbGUgZmFjdG9yXG4gICAgICogQGRlc2NyaXB0aW9uIFNjYWxlIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaW4gdHdvIGRpbWVuc2lvbnMuXG4gICAgICovXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHN4LCBzeSkge1xuXG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAobCA8PSAxKSB7XG4gICAgICAgIHN5ID0gc3g7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHN4LCAwLCAwLCAwLCBzeSwgMCwgMCwgMCwgMSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNyb3RhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gTnVtYmVyIC0gVGhlIGFtb3VudCB0byByb3RhdGUgaW4gTnVtYmVyLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSb3RhdGUgdGhlIG1hdHJpeC5cbiAgICAgKi9cbiAgICByb3RhdGU6IGZ1bmN0aW9uKE51bWJlcikge1xuXG4gICAgICB2YXIgYyA9IGNvcyQ1KE51bWJlcik7XG4gICAgICB2YXIgcyA9IHNpbiQ1KE51bWJlcik7XG5cbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGMsIC1zLCAwLCBzLCBjLCAwLCAwLCAwLCAxKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RyYW5zbGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgdHJhbnNsYXRpb24gdmFsdWUgdG8gYXBwbHkuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgdHJhbnNsYXRpb24gdmFsdWUgdG8gYXBwbHkuXG4gICAgICogQGRlc2NyaXB0aW9uIFRyYW5zbGF0ZSB0aGUgbWF0cml4LlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24oeCwgeSkge1xuXG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseSgxLCAwLCB4LCAwLCAxLCB5LCAwLCAwLCAxKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3NrZXdYXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IE51bWJlciAtIFRoZSBhbW91bnQgdG8gc2tldyBpbiBOdW1iZXIuXG4gICAgICogQGRlc2NyaXB0aW9uIFNrZXcgdGhlIG1hdHJpeCBieSBhbiBhbmdsZSBpbiB0aGUgeCBheGlzIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBza2V3WDogZnVuY3Rpb24oTnVtYmVyKSB7XG5cbiAgICAgIHZhciBhID0gdGFuKE51bWJlcik7XG5cbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KDEsIGEsIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2tld1lcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gTnVtYmVyIC0gVGhlIGFtb3VudCB0byBza2V3IGluIE51bWJlci5cbiAgICAgKiBAZGVzY3JpcHRpb24gU2tldyB0aGUgbWF0cml4IGJ5IGFuIGFuZ2xlIGluIHRoZSB5IGF4aXMgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHNrZXdZOiBmdW5jdGlvbihOdW1iZXIpIHtcblxuICAgICAgdmFyIGEgPSB0YW4oTnVtYmVyKTtcblxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoMSwgMCwgMCwgYSwgMSwgMCwgMCwgMCwgMSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCN0b1N0cmluZ1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Z1bGxNYXRyaXg9ZmFsc2VdIC0gUmV0dXJuIHRoZSBmdWxsIDkgZWxlbWVudHMgb2YgdGhlIG1hdHJpeCBvciBqdXN0IDYgZm9yIDJEIHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggYXMgYSA2IGNvbXBvbmVudCBzdHJpbmcgc2VwYXJhdGVkIGJ5IHNwYWNlcy5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgdHJhbnNmb3JtIHN0cmluZy4gVXNlZCBmb3IgdGhlIFR3by5qcyByZW5kZXJpbmcgQVBJcy5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oZnVsbE1hdHJpeCkge1xuXG4gICAgICBhcnJheS5sZW5ndGggPSAwO1xuICAgICAgdGhpcy50b1RyYW5zZm9ybUFycmF5KGZ1bGxNYXRyaXgsIGFycmF5KTtcblxuICAgICAgcmV0dXJuIGFycmF5Lm1hcCh0b0ZpeGVkKS5qb2luKCcgJyk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCN0b1RyYW5zZm9ybUFycmF5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZnVsbE1hdHJpeD1mYWxzZV0gLSBSZXR1cm4gdGhlIGZ1bGwgOSBlbGVtZW50cyBvZiB0aGUgbWF0cml4IG9yIGp1c3QgNiBpbiB0aGUgZm9ybWF0IGZvciAyRCB0cmFuc2Zvcm1hdGlvbnMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJbXX0gW291dHB1dF0gLSBBbiBhcnJheSBlbXB0eSBvciBvdGhlcndpc2UgdG8gYXBwbHkgdGhlIHZhbHVlcyB0by5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgdHJhbnNmb3JtIGFycmF5LiBVc2VkIGZvciB0aGUgVHdvLmpzIHJlbmRlcmluZyBBUElzLlxuICAgICAqL1xuICAgIHRvVHJhbnNmb3JtQXJyYXk6IGZ1bmN0aW9uKGZ1bGxNYXRyaXgsIG91dHB1dCkge1xuXG4gICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgdmFyIGhhc091dHB1dCA9ICEhb3V0cHV0O1xuXG4gICAgICB2YXIgYSA9IGVsZW1lbnRzWzBdO1xuICAgICAgdmFyIGIgPSBlbGVtZW50c1sxXTtcbiAgICAgIHZhciBjID0gZWxlbWVudHNbMl07XG4gICAgICB2YXIgZCA9IGVsZW1lbnRzWzNdO1xuICAgICAgdmFyIGUgPSBlbGVtZW50c1s0XTtcbiAgICAgIHZhciBmID0gZWxlbWVudHNbNV07XG5cbiAgICAgIGlmIChmdWxsTWF0cml4KSB7XG5cbiAgICAgICAgdmFyIGcgPSBlbGVtZW50c1s2XTtcbiAgICAgICAgdmFyIGggPSBlbGVtZW50c1s3XTtcbiAgICAgICAgdmFyIGkgPSBlbGVtZW50c1s4XTtcblxuICAgICAgICBpZiAoaGFzT3V0cHV0KSB7XG4gICAgICAgICAgb3V0cHV0WzBdID0gYTtcbiAgICAgICAgICBvdXRwdXRbMV0gPSBkO1xuICAgICAgICAgIG91dHB1dFsyXSA9IGc7XG4gICAgICAgICAgb3V0cHV0WzNdID0gYjtcbiAgICAgICAgICBvdXRwdXRbNF0gPSBlO1xuICAgICAgICAgIG91dHB1dFs1XSA9IGg7XG4gICAgICAgICAgb3V0cHV0WzZdID0gYztcbiAgICAgICAgICBvdXRwdXRbN10gPSBmO1xuICAgICAgICAgIG91dHB1dFs4XSA9IGk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBhLCBkLCBnLCBiLCBlLCBoLCBjLCBmLCBpXG4gICAgICAgIF07XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNPdXRwdXQpIHtcbiAgICAgICAgb3V0cHV0WzBdID0gYTtcbiAgICAgICAgb3V0cHV0WzFdID0gZDtcbiAgICAgICAgb3V0cHV0WzJdID0gYjtcbiAgICAgICAgb3V0cHV0WzNdID0gZTtcbiAgICAgICAgb3V0cHV0WzRdID0gYztcbiAgICAgICAgb3V0cHV0WzVdID0gZjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1xuICAgICAgICBhLCBkLCBiLCBlLCBjLCBmICAvLyBTcGVjaWZpYyBmb3JtYXQgc2VlIExOOjE5XG4gICAgICBdO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjdG9BcnJheVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Z1bGxNYXRyaXg9ZmFsc2VdIC0gUmV0dXJuIHRoZSBmdWxsIDkgZWxlbWVudHMgb2YgdGhlIG1hdHJpeCBvciBqdXN0IDYgZm9yIDJEIHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbb3V0cHV0XSAtIEFuIGFycmF5IGVtcHR5IG9yIG90aGVyd2lzZSB0byBhcHBseSB0aGUgdmFsdWVzIHRvLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSB0cmFuc2Zvcm0gYXJyYXkuIFVzZWQgZm9yIHRoZSBUd28uanMgcmVuZGVyaW5nIEFQSXMuXG4gICAgICovXG4gICAgdG9BcnJheTogZnVuY3Rpb24oZnVsbE1hdHJpeCwgb3V0cHV0KSB7XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgaGFzT3V0cHV0ID0gISFvdXRwdXQ7XG5cbiAgICAgIHZhciBhID0gZWxlbWVudHNbMF07XG4gICAgICB2YXIgYiA9IGVsZW1lbnRzWzFdO1xuICAgICAgdmFyIGMgPSBlbGVtZW50c1syXTtcbiAgICAgIHZhciBkID0gZWxlbWVudHNbM107XG4gICAgICB2YXIgZSA9IGVsZW1lbnRzWzRdO1xuICAgICAgdmFyIGYgPSBlbGVtZW50c1s1XTtcblxuICAgICAgaWYgKGZ1bGxNYXRyaXgpIHtcblxuICAgICAgICB2YXIgZyA9IGVsZW1lbnRzWzZdO1xuICAgICAgICB2YXIgaCA9IGVsZW1lbnRzWzddO1xuICAgICAgICB2YXIgaSA9IGVsZW1lbnRzWzhdO1xuXG4gICAgICAgIGlmIChoYXNPdXRwdXQpIHtcbiAgICAgICAgICBvdXRwdXRbMF0gPSBhO1xuICAgICAgICAgIG91dHB1dFsxXSA9IGI7XG4gICAgICAgICAgb3V0cHV0WzJdID0gYztcbiAgICAgICAgICBvdXRwdXRbM10gPSBkO1xuICAgICAgICAgIG91dHB1dFs0XSA9IGU7XG4gICAgICAgICAgb3V0cHV0WzVdID0gZjtcbiAgICAgICAgICBvdXRwdXRbNl0gPSBnO1xuICAgICAgICAgIG91dHB1dFs3XSA9IGg7XG4gICAgICAgICAgb3V0cHV0WzhdID0gaTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGlcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc091dHB1dCkge1xuICAgICAgICBvdXRwdXRbMF0gPSBhO1xuICAgICAgICBvdXRwdXRbMV0gPSBiO1xuICAgICAgICBvdXRwdXRbMl0gPSBjO1xuICAgICAgICBvdXRwdXRbM10gPSBkO1xuICAgICAgICBvdXRwdXRbNF0gPSBlO1xuICAgICAgICBvdXRwdXRbNV0gPSBmO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGEsIGIsIGMsIGQsIGUsIGZcbiAgICAgIF07XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBKU09OIGNvbXBhdGlibGUgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBpbmZvcm1hdGlvbiBvZiB0aGUgbWF0cml4LlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVsZW1lbnRzOiB0aGlzLnRvQXJyYXkodHJ1ZSksXG4gICAgICAgIG1hbnVhbDogISF0aGlzLm1hbnVhbFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDbG9uZSB0aGUgY3VycmVudCBtYXRyaXguXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICByZXR1cm4gbmV3IE1hdHJpeCgpLmNvcHkodGhpcyk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5TaGFwZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLkV2ZW50c1xuICAgKiBAZGVzY3JpcHRpb24gVGhlIGZvdW5kYXRpb25hbCB0cmFuc2Zvcm1hdGlvbiBvYmplY3QgZm9yIHRoZSBUd28uanMgc2NlbmVncmFwaC5cbiAgICovXG4gIGZ1bmN0aW9uIFNoYXBlKCkge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI3JlbmRlcmVyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIE9iamVjdCBhY2Nlc3MgdG8gc3RvcmUgcmVsZXZhbnQgcmVuZGVyZXIgc3BlY2lmaWMgdmFyaWFibGVzLiBXYXJuaW5nOiBtYW5pcHVsYXRpbmcgdGhpcyBvYmplY3QgY2FuIGNyZWF0ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcy5cbiAgICAgKiBAbm90YS1iZW5lIFdpdGggdGhlIHtAbGluayBUd28uU3ZnUmVuZGVyZXJ9IHlvdSBjYW4gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIFNWRyBlbGVtZW50IGNyZWF0ZWQgdmlhIGBzaGFwZS5yZW5kZXJlci5lbGVtYC5cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ01hdHJpeCA9IFNoYXBlLkZsYWdNYXRyaXguYmluZCh0aGlzKTtcbiAgICB0aGlzLmlzU2hhcGUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI2lkXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gU2Vzc2lvbiBzcGVjaWZpYyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKiBAbm90YS1iZW5lIEluIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfSBjaGFuZ2UgdGhpcyB0byBjaGFuZ2UgdGhlIHVuZGVybHlpbmcgU1ZHIGVsZW1lbnQncyBpZCB0b28uXG4gICAgICovXG4gICAgdGhpcy5pZCA9IENvbnN0YW50cy5JZGVudGlmaWVyICsgQ29uc3RhbnRzLnVuaXF1ZUlkKCk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjY2xhc3NMaXN0XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQSBsaXN0IG9mIGNsYXNzIHN0cmluZ3Mgc3RvcmVkIGlmIGltcG9ydGVkIC8gaW50ZXJwcmV0ZWQgIGZyb20gYW4gU1ZHIGVsZW1lbnQuXG4gICAgICovXG4gICAgdGhpcy5jbGFzc0xpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNtYXRyaXhcbiAgICAgKiBAcHJvcGVydHkge1R3by5NYXRyaXh9XG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgdGhlIHNoYXBlLlxuICAgICAqIEBub3RhLWJlbmUge0BsaW5rIFR3by5TaGFwZSN0cmFuc2xhdGlvbn0sIHtAbGluayBUd28uU2hhcGUjcm90YXRpb259LCB7QGxpbmsgVHdvLlNoYXBlI3NjYWxlfSwge0BsaW5rIFR3by5TaGFwZSNza2V3WH0sIGFuZCB7QGxpbmsgVHdvLlNoYXBlI3NrZXdZfSBhcHBseSB0aGVpciB2YWx1ZXMgdG8gdGhlIG1hdHJpeCB3aGVuIGNoYW5nZWQuIFRoZSBtYXRyaXggaXMgd2hhdCBpcyBzZW50IHRvIHRoZSByZW5kZXJlciB0byBiZSBkcmF3bi5cbiAgICAgKi9cbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSN0cmFuc2xhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBUaGUgeCBhbmQgeSB2YWx1ZSBmb3Igd2hlcmUgdGhlIHNoYXBlIGlzIHBsYWNlZCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuICAgICAqL1xuICAgIHRoaXMudHJhbnNsYXRpb24gPSBuZXcgVmVjdG9yKCk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjcm90YXRpb25cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdmFsdWUgaW4gTnVtYmVyIGZvciBob3cgbXVjaCB0aGUgc2hhcGUgaXMgcm90YXRlZCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuICAgICAqL1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI3NjYWxlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHZhbHVlIGZvciBob3cgbXVjaCB0aGUgc2hhcGUgaXMgc2NhbGVkIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIHZhbHVlIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEge0BsaW5rIFR3by5WZWN0b3J9IHRvIGRvIG5vbi11bmlmb3JtIHNjYWxpbmcuIGUuZzogYHNoYXBlLnNjYWxlID0gbmV3IFR3by5WZWN0b3IoMiwgMSk7YFxuICAgICAqL1xuICAgIHRoaXMuc2NhbGUgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI3NrZXdYXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHZhbHVlIGluIE51bWJlciBmb3IgaG93IG11Y2ggdGhlIHNoYXBlIGlzIHNrZXdlZCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuICAgICAqIEBkZXNjcmlwdGlvbiBTa2V3IHRoZSBzaGFwZSBieSBhbiBhbmdsZSBpbiB0aGUgeCBheGlzIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLnNrZXdYID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNza2V3WVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB2YWx1ZSBpbiBOdW1iZXIgZm9yIGhvdyBtdWNoIHRoZSBzaGFwZSBpcyBza2V3ZWQgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cbiAgICAgKiBAZGVzY3JpcHRpb24gU2tldyB0aGUgc2hhcGUgYnkgYW4gYW5nbGUgaW4gdGhlIHkgYXhpcyBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5za2V3WSA9IDA7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFNoYXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUuRmxhZ01hdHJpeFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBVdGlsaXR5IGZ1bmN0aW9uIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBoYW5kbGVycyB0byB1cGRhdGUgdGhlIGZsYWdNYXRyaXggb2YgYSBzaGFwZS5cbiAgICAgKi9cbiAgICBGbGFnTWF0cml4OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5TaGFwZX0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uU2hhcGV9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgdmFyIHRyYW5zbGF0aW9uID0ge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNsYXRpb247XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIGlmICh0aGlzLl90cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb24udW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdNYXRyaXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbiA9IHY7XG4gICAgICAgICAgdGhpcy5fdHJhbnNsYXRpb24uYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnTWF0cml4KTtcbiAgICAgICAgICBTaGFwZS5GbGFnTWF0cml4LmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICd0cmFuc2xhdGlvbicsIHRyYW5zbGF0aW9uKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdwb3NpdGlvbicsIHRyYW5zbGF0aW9uKTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3JvdGF0aW9uJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fcm90YXRpb24gPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3NjYWxlJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnTWF0cml4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zY2FsZSA9IHY7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ01hdHJpeCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fZmxhZ1NjYWxlID0gdHJ1ZTtcblxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3NrZXdYJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9za2V3WDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fc2tld1ggPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3NrZXdZJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9za2V3WTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fc2tld1kgPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ21hdHJpeCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWF0cml4O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9tYXRyaXggPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2lkJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdmFyIGlkID0gdGhpcy5faWQ7XG4gICAgICAgICAgaWYgKHYgPT09IHRoaXMuX2lkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2lkID0gdjtcbiAgICAgICAgICB0aGlzLl9mbGFnSWQgPSB0cnVlO1xuICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucGFyZW50LmNoaWxkcmVuLmlkc1tpZF07XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5pZHNbdGhpcy5faWRdID0gdGhpcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2xhc3NOYW1lJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3NOYW1lO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgICAgdGhpcy5fZmxhZ0NsYXNzTmFtZSA9IHRoaXMuX2NsYXNzTmFtZSAhPT0gdjtcblxuICAgICAgICAgIGlmICh0aGlzLl9mbGFnQ2xhc3NOYW1lKSB7XG5cbiAgICAgICAgICAgIHZhciBwcmV2ID0gdGhpcy5fY2xhc3NOYW1lLnNwbGl0KC9cXHMrPy8pO1xuICAgICAgICAgICAgdmFyIGRlc3QgPSB2LnNwbGl0KC9cXHMrPy8pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHByZXZbaV07XG4gICAgICAgICAgICAgIHZhciBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcy5jbGFzc0xpc3QsIGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsYXNzTGlzdCA9IHRoaXMuY2xhc3NMaXN0LmNvbmNhdChkZXN0KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NsYXNzTmFtZSA9IHY7XG5cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3JlbmRlcmVyJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvYmo7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoU2hhcGUucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBTaGFwZSxcblxuICAgIC8vIEZsYWdzXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX2lkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpZCBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0lkOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI19mbGFnTWF0cml4XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtYXRyaXggbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdNYXRyaXg6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX2ZsYWdTY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUgc2NhbGUgbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdTY2FsZTogZmFsc2UsXG5cbiAgICAvLyBfZmxhZ01hc2s6IGZhbHNlLFxuICAgIC8vIF9mbGFnQ2xpcDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX2ZsYWdDbGFzc05hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjY2xhc3NOYW1lfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQ2xhc3NOYW1lOiBmYWxzZSxcblxuICAgIC8vIFVuZGVybHlpbmcgUHJvcGVydGllc1xuXG4gICAgX2lkOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfdHJhbnNsYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBUaGUgdHJhbnNsYXRpb24gdmFsdWVzIGFzIGEge0BsaW5rIFR3by5WZWN0b3J9LlxuICAgICAqL1xuICAgIF90cmFuc2xhdGlvbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfcm90YXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSByb3RhdGlvbiB2YWx1ZSBpbiBOdW1iZXIuXG4gICAgICovXG4gICAgX3JvdGF0aW9uOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI190cmFuc2xhdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIFRoZSB0cmFuc2xhdGlvbiB2YWx1ZXMgYXMgYSB7QGxpbmsgVHdvLlZlY3Rvcn0uXG4gICAgICovXG4gICAgX3NjYWxlOiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI19za2V3WFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHJvdGF0aW9uIHZhbHVlIGluIE51bWJlci5cbiAgICAgKi9cbiAgICBfc2tld1g6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX3NrZXdZXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgcm90YXRpb24gdmFsdWUgaW4gTnVtYmVyLlxuICAgICAqL1xuICAgIF9za2V3WTogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNjbGFzc05hbWVcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBBIGNsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIENTUyBzdHlsaW5nLlxuICAgICAqIEBub3RhLWJlbmUgT25seSBhdmFpbGFibGUgZm9yIHRoZSBTVkcgcmVuZGVyZXIuXG4gICAgICovXG4gICAgX2NsYXNzTmFtZTogJycsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjYWRkVG9cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gZ3JvdXAgLSBUaGUgcGFyZW50IHRoZSBzaGFwZSBhZGRzIGl0c2VsZiB0by5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBpdHNlbGYgdG8gdGhlIHNjZW5lZ3JhcGguXG4gICAgICovXG4gICAgYWRkVG86IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICBncm91cC5hZGQodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gT3B0aW9uYWwgYXJndW1lbnQgdG8gYXV0b21hdGljYWxseSBhZGQgdGhlIHNoYXBlIHRvIGEgc2NlbmVncmFwaC5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlNoYXBlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcge0BsaW5rIFR3by5TaGFwZX0gd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIGN1cnJlbnQgc2hhcGUuXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgU2hhcGUoKTtcblxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIGNsb25lLnNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIGNsb25lLnNrZXdZID0gdGhpcy5za2V3WTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZS5fdXBkYXRlKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbihidWJibGVzKSB7XG5cbiAgICAgIGlmICghdGhpcy5fbWF0cml4Lm1hbnVhbCAmJiB0aGlzLl9mbGFnTWF0cml4KSB7XG5cbiAgICAgICAgdGhpcy5fbWF0cml4XG4gICAgICAgICAgLmlkZW50aXR5KClcbiAgICAgICAgICAudHJhbnNsYXRlKHRoaXMudHJhbnNsYXRpb24ueCwgdGhpcy50cmFuc2xhdGlvbi55KTtcblxuICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fbWF0cml4LnNjYWxlKHRoaXMuX3NjYWxlLngsIHRoaXMuX3NjYWxlLnkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXRyaXguc2NhbGUodGhpcy5fc2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hdHJpeC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XG4gICAgICAgICAgdGhpcy5fbWF0cml4LnNrZXdYKHRoaXMuc2tld1gpO1xuICAgICAgICAgIHRoaXMuX21hdHJpeC5za2V3WSh0aGlzLnNrZXdZKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJ1YmJsZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Ll91cGRhdGUpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5fdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ0lkID0gdGhpcy5fZmxhZ01hdHJpeCA9IHRoaXMuX2ZsYWdTY2FsZSA9XG4gICAgICAgIHRoaXMuX2ZsYWdDbGFzc05hbWUgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgU2hhcGUuTWFrZU9ic2VydmFibGUoU2hhcGUucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLkNvbGxlY3Rpb25cbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5FdmVudHNcbiAgICogQGRlc2NyaXB0aW9uIEFuIGBBcnJheWAgbGlrZSBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGV2ZW50IHByb3BhZ2F0aW9uIG9uIGFjdGlvbnMuIGBwb3BgLCBgc2hpZnRgLCBhbmQgYHNwbGljZWAgdHJpZ2dlciBgcmVtb3ZlZGAgZXZlbnRzLiBgcHVzaGAsIGB1bnNoaWZ0YCwgYW5kIGBzcGxpY2VgIHdpdGggbW9yZSB0aGFuIDIgYXJndW1lbnRzIHRyaWdnZXIgJ2luc2VydGVkJy4gRmluYWxseSwgYHNvcnRgIGFuZCBgcmV2ZXJzZWAgdHJpZ2dlciBgb3JkZXJgIGV2ZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIENvbGxlY3Rpb24oKSB7XG5cbiAgICBBcnJheS5jYWxsKHRoaXMpO1xuXG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMF0ubGVuZ3RoID4gMCkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHNbMF0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH1cblxuICBDb2xsZWN0aW9uLnByb3RvdHlwZSA9IG5ldyBBcnJheSgpO1xuXG4gIF8uZXh0ZW5kKENvbGxlY3Rpb24ucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBDb2xsZWN0aW9uLFxuXG4gICAgcG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3BwZWQgPSBBcnJheS5wcm90b3R5cGUucG9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnJlbW92ZSwgW3BvcHBlZF0pO1xuICAgICAgcmV0dXJuIHBvcHBlZDtcbiAgICB9LFxuXG4gICAgc2hpZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNoaWZ0ZWQgPSBBcnJheS5wcm90b3R5cGUuc2hpZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMucmVtb3ZlLCBbc2hpZnRlZF0pO1xuICAgICAgcmV0dXJuIHNoaWZ0ZWQ7XG4gICAgfSxcblxuICAgIHB1c2g6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHB1c2hlZCA9IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmluc2VydCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiBwdXNoZWQ7XG4gICAgfSxcblxuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHVuc2hpZnRlZCA9IEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmluc2VydCwgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB1bnNoaWZ0ZWQ7XG4gICAgfSxcblxuICAgIHNwbGljZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3BsaWNlZCA9IEFycmF5LnByb3RvdHlwZS5zcGxpY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHZhciBpbnNlcnRlZDtcblxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5yZW1vdmUsIHNwbGljZWQpO1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgaW5zZXJ0ZWQgPSB0aGlzLnNsaWNlKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzBdICsgYXJndW1lbnRzLmxlbmd0aCAtIDIpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmluc2VydCwgaW5zZXJ0ZWQpO1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLm9yZGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGxpY2VkO1xuICAgIH0sXG5cbiAgICBzb3J0OiBmdW5jdGlvbigpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5zb3J0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLm9yZGVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXZlcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLm9yZGVyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBpbmRleE9mOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICB9KTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqIEBuYW1lIFR3by5Hcm91cC5DaGlsZHJlblxuICAgKiBAZXh0ZW5kcyBUd28uQ29sbGVjdGlvblxuICAgKiBAZGVzY3JpcHRpb24gQSBjaGlsZHJlbiBjb2xsZWN0aW9uIHdoaWNoIGlzIGFjY2VzaWJsZSBib3RoIGJ5IGluZGV4IGFuZCBieSBvYmplY3QgYGlkYC5cbiAgICovXG4gIGZ1bmN0aW9uIENoaWxkcmVuKGNoaWxkcmVuKSB7XG5cbiAgICBDb2xsZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ19ldmVudHMnLCB7XG4gICAgICB2YWx1ZSA6IHt9LFxuICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5DaGlsZHJlbiNpZHNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBNYXAgb2YgYWxsIGVsZW1lbnRzIGluIHRoZSBsaXN0IGtleWVkIGJ5IGBpZGBzLlxuICAgICAqL1xuICAgIHRoaXMuaWRzID0ge307XG5cbiAgICB0aGlzLmF0dGFjaChcbiAgICAgIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgKTtcblxuICAgIHRoaXMub24oRXZlbnRzLlR5cGVzLmluc2VydCwgdGhpcy5hdHRhY2gpO1xuICAgIHRoaXMub24oRXZlbnRzLlR5cGVzLnJlbW92ZSwgdGhpcy5kZXRhY2gpO1xuXG4gIH1cblxuICBDaGlsZHJlbi5wcm90b3R5cGUgPSBuZXcgQ29sbGVjdGlvbigpO1xuXG4gIF8uZXh0ZW5kKENoaWxkcmVuLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IENoaWxkcmVuLFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLkNoaWxkcmVuI2F0dGFjaFxuICAgICAqIEBwYXJhbSB7VHdvLlNoYXBlW119IGNoaWxkcmVuIC0gVGhlIG9iamVjdHMgd2hpY2ggZXh0ZW5kIHtAbGluayBUd28uU2hhcGV9IHRvIGJlIGFkZGVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGRzIGVsZW1lbnRzIHRvIHRoZSBgaWRzYCBtYXAuXG4gICAgICovXG4gICAgYXR0YWNoOiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLmlkKSB7XG4gICAgICAgICAgdGhpcy5pZHNbY2hpbGQuaWRdID0gY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuQ2hpbGRyZW4jZGV0YWNoXG4gICAgICogQHBhcmFtIHtUd28uU2hhcGVbXX0gY2hpbGRyZW4gLSBUaGUgb2JqZWN0cyB3aGljaCBleHRlbmQge0BsaW5rIFR3by5TaGFwZX0gdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBlbGVtZW50cyB0byB0aGUgYGlkc2AgbWFwLlxuICAgICAqL1xuICAgIGRldGFjaDogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWRzW2NoaWxkcmVuW2ldLmlkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9KTtcblxuICAvLyBDb25zdGFudHNcblxuICB2YXIgbWluJDMgPSBNYXRoLm1pbiwgbWF4JDMgPSBNYXRoLm1heDtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLkdyb3VwXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uU2hhcGVcbiAgICogQHBhcmFtIHtUd28uU2hhcGVbXX0gW2NoaWxkcmVuXSAtIEEgbGlzdCBvZiBvYmplY3RzIHRoYXQgaW5oZXJpdCB7QGxpbmsgVHdvLlNoYXBlfS4gRm9yIGluc3RhbmNlLCB0aGUgYXJyYXkgY291bGQgYmUgYSB7QGxpbmsgVHdvLlBhdGh9LCB7QGxpbmsgVHdvLlRleHR9LCBhbmQge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlfS5cbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgdGhlIHByaW1hcnkgY2xhc3MgZm9yIGdyb3VwaW5nIG9iamVjdHMgdGhhdCBhcmUgdGhlbiBkcmF3biBpbiBUd28uanMuIEluIElsbHVzdHJhdG9yIHRoaXMgaXMgYSBncm91cCwgaW4gQWZ0ZXIgRWZmZWN0cyBpdCB3b3VsZCBiZSBhIE51bGwgT2JqZWN0LiBXaGljaGV2ZXIgdGhlIGNhc2UsIHRoZSBgVHdvLkdyb3VwYCBjb250YWlucyBhIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhbmQgY29tbWFuZHMgdG8gc3R5bGUgaXRzIGNoaWxkcmVuLCBidXQgaXQgYnkgaXRzZWxmIGRvZXNuJ3QgcmVuZGVyIHRvIHRoZSBzY3JlZW4uXG4gICAqIEBub3RhLWJlbmUgVGhlIHtAbGluayBUd28jc2NlbmV9IGlzIGFuIGluc3RhbmNlIG9mIGBUd28uR3JvdXBgLlxuICAgKi9cbiAgZnVuY3Rpb24gR3JvdXAoY2hpbGRyZW4pIHtcblxuICAgIFNoYXBlLmNhbGwodGhpcywgdHJ1ZSk7XG5cbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ2dyb3VwJztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNhZGRpdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge1R3by5TaGFwZVtdfVxuICAgICAqIEBkZXNjcmlwdGlvbiBBbiBhdXRvbWF0aWNhbGx5IHVwZGF0ZWQgbGlzdCBvZiBjaGlsZHJlbiB0aGF0IG5lZWQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIHJlbmRlcmVyJ3Mgc2NlbmVncmFwaC5cbiAgICAgKi9cbiAgICB0aGlzLmFkZGl0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI3N1YnRyYWN0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlNoYXBlW119XG4gICAgICogQGRlc2NyaXB0aW9uIEFuIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBsaXN0IG9mIGNoaWxkcmVuIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkIGZyb20gdGhlIHJlbmRlcmVyJ3Mgc2NlbmVncmFwaC5cbiAgICAgKi9cbiAgICB0aGlzLnN1YnRyYWN0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2NoaWxkcmVuXG4gICAgICogQHByb3BlcnR5IHtUd28uR3JvdXAuQ2hpbGRyZW59XG4gICAgICogQGRlc2NyaXB0aW9uIEEgbGlzdCBvZiBhbGwgdGhlIGNoaWxkcmVuIGluIHRoZSBzY2VuZWdyYXBoLlxuICAgICAqIEBub3RhLWJlbmUgVGhlciBvcmRlciBvZiB0aGlzIGxpc3QgaW5kaWNhdGVzIHRoZSBvcmRlciBlYWNoIGVsZW1lbnQgaXMgcmVuZGVyZWQgdG8gdGhlIHNjcmVlbi5cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuID0gQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKEdyb3VwLCB7XG5cbiAgICBDaGlsZHJlbjogQ2hpbGRyZW4sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuSW5zZXJ0Q2hpbGRyZW5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5TaGFwZVtdfSBjaGlsZHJlbiAtIFRoZSBvYmplY3RzIHRvIGJlIGluc2VydGVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyBjaGlsZHJlbiBoYXZlIGJlZW4gYWRkZWQgdG8gYSB7QGxpbmsgVHdvLkdyb3VwfS5cbiAgICAgKi9cbiAgICBJbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVwbGFjZVBhcmVudC5jYWxsKHRoaXMsIGNoaWxkcmVuW2ldLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLlJlbW92ZUNoaWxkcmVuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uU2hhcGVbXX0gY2hpbGRyZW4gLSBUaGUgb2JqZWN0cyB0byBiZSByZW1vdmVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyBjaGlsZHJlbiBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIGEge0BsaW5rIFR3by5Hcm91cH0uXG4gICAgICovXG4gICAgUmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlcGxhY2VQYXJlbnQuY2FsbCh0aGlzLCBjaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5PcmRlckNoaWxkcmVuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IG9yZGVyIGhhcyBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLkdyb3VwfS5cbiAgICAgKi9cbiAgICBPcmRlckNoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgdGhpcy5fZmxhZ09yZGVyID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uR3JvdXB9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFtcbiAgICAgICdmaWxsJyxcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ2xpbmV3aWR0aCcsXG4gICAgICAnY2FwJyxcbiAgICAgICdqb2luJyxcbiAgICAgICdtaXRlcicsXG5cbiAgICAgICdjbG9zZWQnLFxuICAgICAgJ2N1cnZlZCcsXG4gICAgICAnYXV0b21hdGljJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5Hcm91cH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uR3JvdXB9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgdmFyIHByb3BlcnRpZXMgPSBHcm91cC5Qcm9wZXJ0aWVzO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAndmlzaWJsZScsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fZmxhZ1Zpc2libGUgPSB0aGlzLl92aXNpYmxlICE9PSB2IHx8IHRoaXMuX2ZsYWdWaXNpYmxlO1xuICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB2O1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnb3BhY2l0eScsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29wYWNpdHk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fZmxhZ09wYWNpdHkgPSB0aGlzLl9vcGFjaXR5ICE9PSB2IHx8IHRoaXMuX2ZsYWdPcGFjaXR5O1xuICAgICAgICAgIHRoaXMuX29wYWNpdHkgPSB2O1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnYmVnaW5uaW5nJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYmVnaW5uaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2ZsYWdCZWdpbm5pbmcgPSB0aGlzLl9iZWdpbm5pbmcgIT09IHYgfHwgdGhpcy5fZmxhZ0JlZ2lubmluZztcbiAgICAgICAgICB0aGlzLl9iZWdpbm5pbmcgPSB2O1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnZW5kaW5nJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW5kaW5nO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2ZsYWdFbmRpbmcgPSB0aGlzLl9lbmRpbmcgIT09IHYgfHwgdGhpcy5fZmxhZ0VuZGluZztcbiAgICAgICAgICB0aGlzLl9lbmRpbmcgPSB2O1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnbGVuZ3RoJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZmxhZ0xlbmd0aCB8fCB0aGlzLl9sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGlsZHJlbikge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgIHRoaXMuX2xlbmd0aCArPSBjaGlsZC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIFNoYXBlLk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XG4gICAgICBHcm91cC5NYWtlR2V0dGVyU2V0dGVycyhvYmplY3QsIHByb3BlcnRpZXMpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2hpbGRyZW4nLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG5cbiAgICAgICAgICB2YXIgaW5zZXJ0Q2hpbGRyZW4gPSBHcm91cC5JbnNlcnRDaGlsZHJlbi5iaW5kKHRoaXMpO1xuICAgICAgICAgIHZhciByZW1vdmVDaGlsZHJlbiA9IEdyb3VwLlJlbW92ZUNoaWxkcmVuLmJpbmQodGhpcyk7XG4gICAgICAgICAgdmFyIG9yZGVyQ2hpbGRyZW4gPSBHcm91cC5PcmRlckNoaWxkcmVuLmJpbmQodGhpcyk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLnVuYmluZCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRyZW4odGhpcy5fY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuID0gbmV3IENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5iaW5kKEV2ZW50cy5UeXBlcy5pbnNlcnQsIGluc2VydENoaWxkcmVuKTtcbiAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5iaW5kKEV2ZW50cy5UeXBlcy5yZW1vdmUsIHJlbW92ZUNoaWxkcmVuKTtcbiAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5iaW5kKEV2ZW50cy5UeXBlcy5vcmRlciwgb3JkZXJDaGlsZHJlbik7XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaW5zZXJ0Q2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnbWFzaycsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fbWFzayA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ01hc2sgPSB0cnVlO1xuICAgICAgICAgIGlmICghdi5jbGlwKSB7XG4gICAgICAgICAgICB2LmNsaXAgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuTWFrZUdldHRlclNldHRlcnNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYXBwbHkgZ2V0dGVycyBhbmQgc2V0dGVycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyAtIEEga2V5IC8gdmFsdWUgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB0byBpbmhlcml0LlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYXBwbHkgZ2V0dGVyIC8gc2V0dGVyIGxvZ2ljIG9uIGFuIGFycmF5IG9mIHByb3BlcnRpZXMuIFVzZWQgaW4ge0BsaW5rIFR3by5Hcm91cC5NYWtlT2JzZXJ2YWJsZX0uXG4gICAgICovXG4gICAgTWFrZUdldHRlclNldHRlcnM6IGZ1bmN0aW9uKGdyb3VwLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wZXJ0aWVzKSkge1xuICAgICAgICBwcm9wZXJ0aWVzID0gW3Byb3BlcnRpZXNdO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBHcm91cC5NYWtlR2V0dGVyU2V0dGVyKGdyb3VwLCBrKTtcbiAgICAgIH0pO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5NYWtlR2V0dGVyU2V0dGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IGdyb3VwIC0gVGhlIGdyb3VwIHRvIGFwcGx5IGdldHRlcnMgYW5kIHNldHRlcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIFRoZSBrZXkgd2hpY2ggd2lsbCBiZWNvbWUgYSBwcm9wZXJ0eSBvbiB0aGUgZ3JvdXAuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIG1ldGhvZCB0byBhcHBseSBnZXR0ZXIgLyBzZXR0ZXIgbG9naWMgc3BlY2lmaWMgdG8gaG93IGBUd28uR3JvdXBgcyB0cmlja2xlIGRvd24gc3R5bGVzIHRvIHRoZWlyIGNoaWxkcmVuLiBVc2VkIGluIHtAbGluayBUd28uR3JvdXAuTWFrZU9ic2VydmFibGV9LlxuICAgICAqL1xuICAgIE1ha2VHZXR0ZXJTZXR0ZXI6IGZ1bmN0aW9uKGdyb3VwLCBrZXkpIHtcblxuICAgICAgdmFyIHNlY3JldCA9ICdfJyArIGtleTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGdyb3VwLCBrZXksIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbc2VjcmV0XTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzW3NlY3JldF0gPSB2O1xuICAgICAgICAgIC8vIFRyaWNrbGUgZG93biBzdHlsZXNcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBjaGlsZFtrZXldID0gdjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoR3JvdXAucHJvdG90eXBlLCBTaGFwZS5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBHcm91cCxcblxuICAgIC8vIEZsYWdzXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbGFnXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdBZGRpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjYWRkaXRpb25zfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0FkZGl0aW9uczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdTdWJ0cmFjdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjc3VidHJhY3Rpb25zfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1N1YnRyYWN0aW9uczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdPcmRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNvcmRlcn0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdPcmRlcjogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdWaXNpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI3Zpc2libGV9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI19mbGFnT3BhY2l0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNvcGFjaXR5fSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ09wYWNpdHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdCZWdpbm5pbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjYmVnaW5uaW5nfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0JlZ2lubmluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdFbmRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjZW5kaW5nfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0VuZGluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdMZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjbGVuZ3RofSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0xlbmd0aDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdNYXNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI21hc2t9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTWFzazogZmFsc2UsXG5cbiAgICAvLyBVbmRlcmx5aW5nIFByb3BlcnRpZXNcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNmaWxsXG4gICAgICogQHByb3BlcnR5IHsoU3RyaW5nfFR3by5HcmFkaWVudHxUd28uVGV4dHVyZSl9IC0gVGhlIHZhbHVlIG9mIHdoYXQgYWxsIGNoaWxkIHNoYXBlcyBzaG91bGQgYmUgZmlsbGVkIGluIHdpdGguXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDU1MncyBjb2xvcnMgYXMgYFN0cmluZ2AuXG4gICAgICovXG4gICAgX2ZpbGw6ICcjZmZmJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNzdHJva2VcbiAgICAgKiBAcHJvcGVydHkgeyhTdHJpbmd8VHdvLkdyYWRpZW50fFR3by5UZXh0dXJlKX0gLSBUaGUgdmFsdWUgb2Ygd2hhdCBhbGwgY2hpbGQgc2hhcGVzIHNob3VsZCBiZSBvdXRsaW5lZCBpbiB3aXRoLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9jb2xvcl92YWx1ZX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ1NTJ3MgY29sb3JzIGFzIGBTdHJpbmdgLlxuICAgICAqL1xuICAgIF9zdHJva2U6ICcjMDAwJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNsaW5ld2lkdGhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdGhpY2tuZXNzIGluIHBpeGVscyBvZiB0aGUgc3Ryb2tlIGZvciBhbGwgY2hpbGQgc2hhcGVzLlxuICAgICAqL1xuICAgIF9saW5ld2lkdGg6IDEuMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNvcGFjaXR5XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIG9wYXF1ZW5lc3Mgb2YgYWxsIGNoaWxkIHNoYXBlcy5cbiAgICAgKiBAbm90YS1iZW5lIEJlY29tZXMgbXVsdGlwbGllZCBieSB0aGUgaW5kaXZpZHVhbCBjaGlsZCdzIG9wYWNpdHkgcHJvcGVydHkuXG4gICAgICovXG4gICAgX29wYWNpdHk6IDEuMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCN2aXNpYmxlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpc3BsYXkgdGhlIHBhdGggb3Igbm90LlxuICAgICAqIEBub3RhLWJlbmUgRm9yIHtAbGluayBUd28uQ2FudmFzUmVuZGVyZXJ9IGFuZCB7QGxpbmsgVHdvLldlYkdMUmVuZGVyZXJ9IHdoZW4gc2V0IHRvIGZhbHNlIGFsbCB1cGRhdGluZyBpcyBkaXNhYmxlZCBpbXByb3ZpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IHdpdGggbWFueSBvYmplY3RzIGluIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBfdmlzaWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNjYXBcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGFpbnRpbmcuaHRtbCNTdHJva2VMaW5lY2FwUHJvcGVydHl9XG4gICAgICovXG4gICAgX2NhcDogJ3JvdW5kJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNqb2luXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhaW50aW5nLmh0bWwjU3Ryb2tlTGluZWpvaW5Qcm9wZXJ0eX1cbiAgICAgKi9cbiAgICBfam9pbjogJ3JvdW5kJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNtaXRlclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1N0cm9rZU1pdGVybGltaXRQcm9wZXJ0eX1cbiAgICAgKi9cbiAgICBfbWl0ZXI6IDQsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY2xvc2VkXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBhIGZpbmFsIGxpbmUgaXMgZHJhd24gYmV0d2VlbiB0aGUgZmluYWwgcG9pbnQgaW4gdGhlIGB2ZXJ0aWNlc2AgYXJyYXkgYW5kIHRoZSBmaXJzdCBwb2ludCBvZiBhbGwgY2hpbGQgc2hhcGVzLlxuICAgICAqL1xuICAgIF9jbG9zZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY3VydmVkXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIFdoZW4gdGhlIGNoaWxkJ3MgcGF0aCBpcyBgYXV0b21hdGljID0gdHJ1ZWAgdGhpcyBib29sZWFuIGRldGVybWluZXMgd2hldGhlciB0aGUgbGluZXMgYmV0d2VlbiB0aGUgcG9pbnRzIGFyZSBjdXJ2ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIF9jdXJ2ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2F1dG9tYXRpY1xuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IFR3by5qcyBzaG91bGQgY2FsY3VsYXRlIGN1cnZlcywgbGluZXMsIGFuZCBjb21tYW5kcyBhdXRvbWF0aWNhbGx5IGZvciB5b3Ugb3IgdG8gbGV0IHRoZSBkZXZlbG9wZXIgbWFuaXB1bGF0ZSB0aGVtIGZvciB0aGVtc2VsdmVzLlxuICAgICAqL1xuICAgIF9hdXRvbWF0aWM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYmVnaW5uaW5nXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIGJldHdlZW4gemVybyBhbmQgb25lIHRvIHN0YXRlIHRoZSBiZWdpbm5pbmcgb2Ygd2hlcmUgdGhlIHBhdGggaXMgcmVuZGVyZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIHtAbGluayBUd28uR3JvdXAjYmVnaW5uaW5nfSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgdGhhdCByZXByZXNlbnRzIGF0IHdoYXQgcGVyY2VudGFnZSBpbnRvIGFsbCBjaGlsZCBzaGFwZXMgc2hvdWxkIHRoZSByZW5kZXJlciBzdGFydCBkcmF3aW5nLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBpcyBncmVhdCBmb3IgYW5pbWF0aW5nIGluIGFuZCBvdXQgc3Ryb2tlZCBwYXRocyBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBUd28uR3JvdXAjZW5kaW5nfS5cbiAgICAgKi9cbiAgICBfYmVnaW5uaW5nOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2VuZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIE51bWJlciBiZXR3ZWVuIHplcm8gYW5kIG9uZSB0byBzdGF0ZSB0aGUgZW5kaW5nIG9mIHdoZXJlIHRoZSBwYXRoIGlzIHJlbmRlcmVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiB7QGxpbmsgVHdvLkdyb3VwI2VuZGluZ30gaXMgYSBwZXJjZW50YWdlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBhdCB3aGF0IHBlcmNlbnRhZ2UgaW50byBhbGwgY2hpbGQgc2hhcGVzIHNob3VsZCB0aGUgcmVuZGVyZXIgc3RhcnQgZHJhd2luZy5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgaXMgZ3JlYXQgZm9yIGFuaW1hdGluZyBpbiBhbmQgb3V0IHN0cm9rZWQgcGF0aHMgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgVHdvLkdyb3VwI2JlZ2lubmluZ30uXG4gICAgICovXG4gICAgX2VuZGluZzogMS4wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2xlbmd0aFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzdW0gb2YgZGlzdGFuY2VzIGJldHdlZW4gYWxsIGNoaWxkIGxlbmd0aHMuXG4gICAgICovXG4gICAgX2xlbmd0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNtYXNrXG4gICAgICogQHByb3BlcnR5IHtUd28uU2hhcGV9IC0gVGhlIFR3by5qcyBvYmplY3QgdG8gY2xpcCBmcm9tIGEgZ3JvdXAncyByZW5kZXJpbmcuXG4gICAgICovXG4gICAgX21hc2s6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5Hcm91cH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uR3JvdXB9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBncm91cC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIC8vIC8qKlxuICAgICAgLy8gICogVE9ETzogR3JvdXAgaGFzIGEgZ290Y2hhIGluIHRoYXQgaXQncyBhdCB0aGUgbW9tZW50IHJlcXVpcmVkIHRvIGJlIGJvdW5kIHRvXG4gICAgICAvLyAgKiBhbiBpbnN0YW5jZSBvZiB0d28gaW4gb3JkZXIgdG8gYWRkIGVsZW1lbnRzIGNvcnJlY3RseS4gVGhpcyBuZWVkcyB0b1xuICAgICAgLy8gICogYmUgcmV0aG91Z2h0IGFuZCBmaXhlZC5cbiAgICAgIC8vICAqL1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgR3JvdXAoKTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4ubWFwKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC5jbG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIGNsb25lLmFkZChjaGlsZHJlbik7XG5cbiAgICAgIGNsb25lLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICAgIGlmICh0aGlzLm1hc2spIHtcbiAgICAgICAgY2xvbmUubWFzayA9IHRoaXMubWFzaztcbiAgICAgIH1cblxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIGNsb25lLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lLl91cGRhdGUoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHRyYW5zbGF0aW9uOiB0aGlzLnRyYW5zbGF0aW9uLnRvT2JqZWN0KCksXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgICBzY2FsZTogdGhpcy5zY2FsZSBpbnN0YW5jZW9mIFZlY3RvciA/IHRoaXMuc2NhbGUudG9PYmplY3QoKSA6IHRoaXMuc2NhbGUsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNsYXNzTmFtZSxcbiAgICAgICAgbWFzazogKHRoaXMubWFzayA/IHRoaXMubWFzay50b09iamVjdCgpIDogbnVsbClcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgcmVzdWx0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvT2JqZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaCh0aGlzLmNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCwgaSkge1xuICAgICAgICByZXN1bHQuY2hpbGRyZW5baV0gPSBjaGlsZC50b09iamVjdCgpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2Nvcm5lclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmllbnQgdGhlIGNoaWxkcmVuIG9mIHRoZSBncm91cCB0byB0aGUgdXBwZXIgbGVmdC1oYW5kIGNvcm5lciBvZiB0aGF0IGdyb3VwLlxuICAgICAqL1xuICAgIGNvcm5lcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QodHJ1ZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBjaGlsZC50cmFuc2xhdGlvbi54IC09IHJlY3QubGVmdDtcbiAgICAgICAgY2hpbGQudHJhbnNsYXRpb24ueSAtPSByZWN0LnRvcDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2NlbnRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmllbnQgdGhlIGNoaWxkcmVuIG9mIHRoZSBncm91cCB0byB0aGUgY2VudGVyIG9mIHRoYXQgZ3JvdXAuXG4gICAgICovXG4gICAgY2VudGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh0cnVlKTtcbiAgICAgIHZhciBjeCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyIC0gdGhpcy50cmFuc2xhdGlvbi54O1xuICAgICAgdmFyIGN5ID0gcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIgLSB0aGlzLnRyYW5zbGF0aW9uLnk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQuaXNTaGFwZSkge1xuICAgICAgICAgIGNoaWxkLnRyYW5zbGF0aW9uLnggLT0gY3g7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRpb24ueSAtPSBjeTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZ2V0QnlJZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZWN1cnNpdmVseSBzZWFyY2ggZm9yIGlkLiBSZXR1cm5zIHRoZSBmaXJzdCBlbGVtZW50IGZvdW5kLlxuICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGV9IC0gT3IgYG51bGxgIGlmIG5vdGhpbmcgaXMgZm91bmQuXG4gICAgICovXG4gICAgZ2V0QnlJZDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICB2YXIgZm91bmQgPSBudWxsO1xuICAgICAgZnVuY3Rpb24gc2VhcmNoKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuaWQgPT09IGlkKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm91bmQgPSBzZWFyY2gobm9kZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWFyY2godGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNnZXRCeUNsYXNzTmFtZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZWN1cnNpdmVseSBzZWFyY2ggZm9yIGNsYXNzZXMuIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICogQHJldHVybnMge1R3by5TaGFwZVtdfSAtIE9yIGVtcHR5IGFycmF5IGlmIG5vdGhpbmcgaXMgZm91bmQuXG4gICAgICovXG4gICAgZ2V0QnlDbGFzc05hbWU6IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgICAgdmFyIGZvdW5kID0gW107XG4gICAgICBmdW5jdGlvbiBzZWFyY2gobm9kZSkge1xuICAgICAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChub2RlLmNsYXNzTGlzdCwgY2xhc3NOYW1lKSA+PSAwKSB7XG4gICAgICAgICAgZm91bmQucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHNlYXJjaChjaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWFyY2godGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNnZXRCeVR5cGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVjdXJzaXZlbHkgc2VhcmNoIGZvciBjaGlsZHJlbiBvZiBhIHNwZWNpZmljIHR5cGUsIGUuZy4ge0BsaW5rIFR3by5QYXRofS4gUGFzcyBhIHJlZmVyZW5jZSB0byB0aGlzIHR5cGUgYXMgdGhlIHBhcmFtLiBSZXR1cm5zIGFuIGFycmF5IG9mIG1hdGNoaW5nIGVsZW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGVbXX0gLSBFbXB0eSBhcnJheSBpZiBub3RoaW5nIGlzIGZvdW5kLlxuICAgICAqL1xuICAgIGdldEJ5VHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgdmFyIGZvdW5kID0gW107XG4gICAgICBmdW5jdGlvbiBzZWFyY2gobm9kZSkge1xuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIHR5cGUpIHtcbiAgICAgICAgICBmb3VuZC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgc2VhcmNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2FkZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlNoYXBlW119IG9iamVjdHMgLSBBbiBhcnJheSBvZiBvYmplY3RzIHRvIGJlIGFkZGVkLiBDYW4gYmUgYWxzbyBiZSBzdXBwbGllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cy5cbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIG9iamVjdHMgdG8gdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24ob2JqZWN0cykge1xuXG4gICAgICAvLyBBbGxvdyB0byBwYXNzIG11bHRpcGxlIG9iamVjdHMgZWl0aGVyIGFzIGFycmF5IG9yIGFzIG11bHRpcGxlIGFyZ3VtZW50c1xuICAgICAgLy8gSWYgaXQncyBhbiBhcnJheSBhbHNvIGNyZWF0ZSBjb3B5IG9mIGl0IGluIGNhc2Ugd2UncmUgZ2V0dGluZyBwYXNzZWRcbiAgICAgIC8vIGEgY2hpbGRyZW5zIGFycmF5IGRpcmVjdGx5LlxuICAgICAgaWYgKCEob2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdHMgPSBvYmplY3RzLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgb2JqZWN0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG9iamVjdHNbaV07XG4gICAgICAgIGlmICghKGNoaWxkICYmIGNoaWxkLmlkKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYWRkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uU2hhcGVbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMgdG8gYmUgcmVtb3ZlZC4gQ2FuIGJlIGFsc28gcmVtb3ZlZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cy5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIG9iamVjdHMgZnJvbSB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihvYmplY3RzKSB7XG5cbiAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgZ3JhbmRwYXJlbnQgPSB0aGlzLnBhcmVudDtcblxuICAgICAgLy8gQWxsb3cgdG8gY2FsbCByZW1vdmUgd2l0aG91dCBhcmd1bWVudHNcbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRhY2ggdGhlIG9iamVjdCBmcm9tIGl0cyBvd24gcGFyZW50LlxuICAgICAgaWYgKGwgPD0gMCAmJiBncmFuZHBhcmVudCkge1xuICAgICAgICBncmFuZHBhcmVudC5yZW1vdmUodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGxvdyB0byBwYXNzIG11bHRpcGxlIG9iamVjdHMgZWl0aGVyIGFzIGFycmF5IG9yIGFzIG11bHRpcGxlIGFyZ3VtZW50c1xuICAgICAgLy8gSWYgaXQncyBhbiBhcnJheSBhbHNvIGNyZWF0ZSBjb3B5IG9mIGl0IGluIGNhc2Ugd2UncmUgZ2V0dGluZyBwYXNzZWRcbiAgICAgIC8vIGEgY2hpbGRyZW5zIGFycmF5IGRpcmVjdGx5LlxuICAgICAgaWYgKCEob2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iamVjdHMgPSBvYmplY3RzLnNsaWNlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSBvYmplY3RzW2ldO1xuICAgICAgICBpZiAoIW9iamVjdCB8fCAhdGhpcy5jaGlsZHJlbi5pZHNbb2JqZWN0LmlkXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZihvYmplY3QpO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2hhbGxvdz1mYWxzZV0gLSBEZXNjcmliZXMgd2hldGhlciB0byBjYWxjdWxhdGUgb2ZmIGxvY2FsIG1hdHJpeCBvciB3b3JsZCBtYXRyaXguXG4gICAgICogQHJldHVybnMge09iamVjdH0gLSBSZXR1cm5zIG9iamVjdCB3aXRoIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGgsIGhlaWdodCBhdHRyaWJ1dGVzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aCwgYW5kIGhlaWdodCBwYXJhbWV0ZXJzIG9mIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uKHNoYWxsb3cpIHtcbiAgICAgIHZhciByZWN0LCBtYXRyaXgsIGEsIGIsIGMsIGQsIHRjLCBsYywgcmMsIGJjO1xuXG4gICAgICAvLyBUT0RPOiBVcGRhdGUgdGhpcyB0byBub3QgX19hbHdheXNfXyB1cGRhdGUuIEp1c3Qgd2hlbiBpdCBuZWVkcyB0by5cbiAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcblxuICAgICAgLy8gVmFyaWFibGVzIG5lZWQgdG8gYmUgZGVmaW5lZCBoZXJlLCBiZWNhdXNlIG9mIG5lc3RlZCBuYXR1cmUgb2YgZ3JvdXBzLlxuICAgICAgdmFyIGxlZnQgPSBJbmZpbml0eSwgcmlnaHQgPSAtSW5maW5pdHksXG4gICAgICAgICAgdG9wID0gSW5maW5pdHksIGJvdHRvbSA9IC1JbmZpbml0eTtcblxuICAgICAgdmFyIHJlZ2V4ID0gL3RleHR1cmV8Z3JhZGllbnQvaTtcblxuICAgICAgbWF0cml4ID0gc2hhbGxvdyA/IHRoaXMuX21hdHJpeCA6IGdldENvbXB1dGVkTWF0cml4KHRoaXMpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgIGlmICghY2hpbGQudmlzaWJsZSB8fCByZWdleC50ZXN0KGNoaWxkLl9yZW5kZXJlci50eXBlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdChzaGFsbG93KTtcblxuICAgICAgICB0YyA9IHR5cGVvZiByZWN0LnRvcCAhPT0gJ251bWJlcicgfHwgXy5pc05hTihyZWN0LnRvcCkgfHwgIWlzRmluaXRlKHJlY3QudG9wKTtcbiAgICAgICAgbGMgPSB0eXBlb2YgcmVjdC5sZWZ0ICE9PSAnbnVtYmVyJyB8fCBfLmlzTmFOKHJlY3QubGVmdCkgfHwgIWlzRmluaXRlKHJlY3QubGVmdCk7XG4gICAgICAgIHJjID0gdHlwZW9mIHJlY3QucmlnaHQgIT09ICdudW1iZXInIHx8IF8uaXNOYU4ocmVjdC5yaWdodCkgfHwgIWlzRmluaXRlKHJlY3QucmlnaHQpO1xuICAgICAgICBiYyA9IHR5cGVvZiByZWN0LmJvdHRvbSAhPT0gJ251bWJlcicgfHwgXy5pc05hTihyZWN0LmJvdHRvbSkgfHwgIWlzRmluaXRlKHJlY3QuYm90dG9tKTtcblxuICAgICAgICBpZiAodGMgfHwgbGMgfHwgcmMgfHwgYmMpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRvcCA9IG1pbiQzKHJlY3QudG9wLCB0b3ApO1xuICAgICAgICBsZWZ0ID0gbWluJDMocmVjdC5sZWZ0LCBsZWZ0KTtcbiAgICAgICAgcmlnaHQgPSBtYXgkMyhyZWN0LnJpZ2h0LCByaWdodCk7XG4gICAgICAgIGJvdHRvbSA9IG1heCQzKHJlY3QuYm90dG9tLCBib3R0b20pO1xuXG4gICAgICB9XG5cbiAgICAgIGlmIChzaGFsbG93KSB7XG5cbiAgICAgICAgYSA9IG1hdHJpeC5tdWx0aXBseShsZWZ0LCB0b3AsIDEpO1xuICAgICAgICBiID0gbWF0cml4Lm11bHRpcGx5KGxlZnQsIGJvdHRvbSwgMSk7XG4gICAgICAgIGMgPSBtYXRyaXgubXVsdGlwbHkocmlnaHQsIHRvcCwgMSk7XG4gICAgICAgIGQgPSBtYXRyaXgubXVsdGlwbHkocmlnaHQsIGJvdHRvbSwgMSk7XG5cbiAgICAgICAgdG9wID0gbWluJDMoYS55LCBiLnksIGMueSwgZC55KTtcbiAgICAgICAgbGVmdCA9IG1pbiQzKGEueCwgYi54LCBjLngsIGQueCk7XG4gICAgICAgIHJpZ2h0ID0gbWF4JDMoYS54LCBiLngsIGMueCwgZC54KTtcbiAgICAgICAgYm90dG9tID0gbWF4JDMoYS55LCBiLnksIGMueSwgZC55KTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3BcbiAgICAgIH07XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI25vRmlsbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBBcHBseSBgbm9GaWxsYCBtZXRob2QgdG8gYWxsIGNoaWxkIHNoYXBlcy5cbiAgICAgKi9cbiAgICBub0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLm5vRmlsbCgpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI25vU3Ryb2tlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGx5IGBub1N0cm9rZWAgbWV0aG9kIHRvIGFsbCBjaGlsZCBzaGFwZXMuXG4gICAgICovXG4gICAgbm9TdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLm5vU3Ryb2tlKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjc3ViZGl2aWRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGx5IGBzdWJkaXZpZGVgIG1ldGhvZCB0byBhbGwgY2hpbGQgc2hhcGVzLlxuICAgICAqL1xuICAgIHN1YmRpdmlkZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBjaGlsZC5zdWJkaXZpZGUuYXBwbHkoY2hpbGQsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGksIGwsIGNoaWxkO1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ0JlZ2lubmluZyB8fCB0aGlzLl9mbGFnRW5kaW5nKSB7XG5cbiAgICAgICAgdmFyIGJlZ2lubmluZyA9IE1hdGgubWluKHRoaXMuX2JlZ2lubmluZywgdGhpcy5fZW5kaW5nKTtcbiAgICAgICAgdmFyIGVuZGluZyA9IE1hdGgubWF4KHRoaXMuX2JlZ2lubmluZywgdGhpcy5fZW5kaW5nKTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgICB2YXIgYmQgPSBiZWdpbm5pbmcgKiBsZW5ndGg7XG4gICAgICAgIHZhciBlZCA9IGVuZGluZyAqIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgIGwgPSBjaGlsZC5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAoYmQgPiBzdW0gKyBsKSB7XG4gICAgICAgICAgICBjaGlsZC5iZWdpbm5pbmcgPSAxO1xuICAgICAgICAgICAgY2hpbGQuZW5kaW5nID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkIDwgc3VtKSB7XG4gICAgICAgICAgICBjaGlsZC5iZWdpbm5pbmcgPSAwO1xuICAgICAgICAgICAgY2hpbGQuZW5kaW5nID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJkID4gc3VtICYmIGJkIDwgc3VtICsgbCkge1xuICAgICAgICAgICAgY2hpbGQuYmVnaW5uaW5nID0gKGJkIC0gc3VtKSAvIGw7XG4gICAgICAgICAgICBjaGlsZC5lbmRpbmcgPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWQgPiBzdW0gJiYgZWQgPCBzdW0gKyBsKSB7XG4gICAgICAgICAgICBjaGlsZC5iZWdpbm5pbmcgPSAwO1xuICAgICAgICAgICAgY2hpbGQuZW5kaW5nID0gKGVkIC0gc3VtKSAvIGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkLmJlZ2lubmluZyA9IDA7XG4gICAgICAgICAgICBjaGlsZC5lbmRpbmcgPSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN1bSArPSBsO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gU2hhcGUucHJvdG90eXBlLl91cGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ0FkZGl0aW9ucykge1xuICAgICAgICB0aGlzLmFkZGl0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9mbGFnQWRkaXRpb25zID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnU3VidHJhY3Rpb25zKSB7XG4gICAgICAgIHRoaXMuc3VidHJhY3Rpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2ZsYWdTdWJ0cmFjdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmxhZ09yZGVyID0gdGhpcy5fZmxhZ01hc2sgPSB0aGlzLl9mbGFnT3BhY2l0eSA9XG4gICAgICAgIHRoaXMuX2ZsYWdCZWdpbm5pbmcgPSB0aGlzLl9mbGFnRW5kaW5nID0gZmFsc2U7XG5cbiAgICAgIFNoYXBlLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgR3JvdXAuTWFrZU9ic2VydmFibGUoR3JvdXAucHJvdG90eXBlKTtcblxuICAvLyAvKipcbiAgLy8gICogSGVscGVyIGZ1bmN0aW9uIHVzZWQgdG8gc3luYyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwIHdpdGhpbiB0aGVcbiAgLy8gICogYFR3by5Hcm91cC5jaGlsZHJlbmAgb2JqZWN0LlxuICAvLyAgKlxuICAvLyAgKiBTZXQgdGhlIHBhcmVudCBvZiB0aGUgcGFzc2VkIG9iamVjdCB0byBhbm90aGVyIG9iamVjdFxuICAvLyAgKiBhbmQgdXBkYXRlcyBwYXJlbnQtY2hpbGQgcmVsYXRpb25zaGlwc1xuICAvLyAgKiBDYWxsaW5nIHdpdGggb25lIGFyZ3VtZW50cyB3aWxsIHNpbXBseSByZW1vdmUgdGhlIHBhcmVudGluZ1xuICAvLyAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZVBhcmVudChjaGlsZCwgbmV3UGFyZW50KSB7XG5cbiAgICB2YXIgcGFyZW50ID0gY2hpbGQucGFyZW50O1xuICAgIHZhciBpbmRleDtcblxuICAgIGlmIChwYXJlbnQgPT09IG5ld1BhcmVudCkge1xuICAgICAgYWRkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuY2hpbGRyZW4uaWRzW2NoaWxkLmlkXSkge1xuXG4gICAgICBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgc3BsaWNlKCk7XG5cbiAgICB9XG5cbiAgICBpZiAobmV3UGFyZW50KSB7XG4gICAgICBhZGQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzcGxpY2UoKTtcblxuICAgIGlmIChwYXJlbnQuX2ZsYWdBZGRpdGlvbnMgJiYgcGFyZW50LmFkZGl0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcmVudC5fZmxhZ0FkZGl0aW9ucyA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAocGFyZW50Ll9mbGFnU3VidHJhY3Rpb25zICYmIHBhcmVudC5zdWJ0cmFjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBwYXJlbnQuX2ZsYWdTdWJ0cmFjdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBkZWxldGUgY2hpbGQucGFyZW50O1xuXG4gICAgZnVuY3Rpb24gYWRkKCkge1xuXG4gICAgICBpZiAobmV3UGFyZW50LnN1YnRyYWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChuZXdQYXJlbnQuc3VidHJhY3Rpb25zLCBjaGlsZCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBuZXdQYXJlbnQuc3VidHJhY3Rpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5ld1BhcmVudC5hZGRpdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobmV3UGFyZW50LmFkZGl0aW9ucywgY2hpbGQpO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgbmV3UGFyZW50LmFkZGl0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnBhcmVudCA9IG5ld1BhcmVudDtcbiAgICAgIG5ld1BhcmVudC5hZGRpdGlvbnMucHVzaChjaGlsZCk7XG4gICAgICBuZXdQYXJlbnQuX2ZsYWdBZGRpdGlvbnMgPSB0cnVlO1xuXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3BsaWNlKCkge1xuXG4gICAgICBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwocGFyZW50LmFkZGl0aW9ucywgY2hpbGQpO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBwYXJlbnQuYWRkaXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuc3VidHJhY3Rpb25zLCBjaGlsZCk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgcGFyZW50LnN1YnRyYWN0aW9ucy5wdXNoKGNoaWxkKTtcbiAgICAgICAgcGFyZW50Ll9mbGFnU3VidHJhY3Rpb25zID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbiAgLy8gQ29uc3RhbnRzXG4gIHZhciBlbXB0eUFycmF5ID0gW107XG4gIHZhciBUV09fUEkkNSA9IE1hdGguUEkgKiAyLFxuICAgIG1heCQyID0gTWF0aC5tYXgsXG4gICAgbWluJDIgPSBNYXRoLm1pbixcbiAgICBhYnMgPSBNYXRoLmFicyxcbiAgICBzaW4kNCA9IE1hdGguc2luLFxuICAgIGNvcyQ0ID0gTWF0aC5jb3MsXG4gICAgYWNvcyA9IE1hdGguYWNvcyxcbiAgICBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG4gIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgbm9uLXRyYW5zZm9ybWluZyBtYXRyaXhcbiAgdmFyIGlzRGVmYXVsdE1hdHJpeCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIChtWzBdID09IDEgJiYgbVszXSA9PSAwICYmIG1bMV0gPT0gMCAmJiBtWzRdID09IDEgJiYgbVsyXSA9PSAwICYmIG1bNV0gPT0gMCk7XG4gIH07XG5cbiAgdmFyIGNhbnZhcyA9IHtcblxuICAgIGlzSGlkZGVuOiAvKHVuZGVmaW5lZHxub25lfHRyYW5zcGFyZW50KS9pLFxuXG4gICAgYWxpZ25tZW50czoge1xuICAgICAgbGVmdDogJ3N0YXJ0JyxcbiAgICAgIG1pZGRsZTogJ2NlbnRlcicsXG4gICAgICByaWdodDogJ2VuZCdcbiAgICB9LFxuXG4gICAgc2hpbTogZnVuY3Rpb24oZWxlbSwgbmFtZSkge1xuICAgICAgZWxlbS50YWdOYW1lID0gZWxlbS5ub2RlTmFtZSA9IG5hbWUgfHwgJ2NhbnZhcyc7XG4gICAgICBlbGVtLm5vZGVUeXBlID0gMTtcbiAgICAgIGVsZW0uZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICByZXR1cm4gdGhpc1twcm9wXTtcbiAgICAgIH07XG4gICAgICBlbGVtLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHByb3AsIHZhbCkge1xuICAgICAgICB0aGlzW3Byb3BdID0gdmFsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH07XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9LFxuXG4gICAgZ3JvdXA6IHtcblxuICAgICAgcmVuZGVyQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNhbnZhc1tjaGlsZC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoY2hpbGQsIHRoaXMuY3R4LCB0cnVlLCB0aGlzLmNsaXApO1xuICAgICAgfSxcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXguZWxlbWVudHM7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIub3BhY2l0eSA9IHRoaXMuX29wYWNpdHlcbiAgICAgICAgICAqIChwYXJlbnQgJiYgcGFyZW50Ll9yZW5kZXJlciA/IHBhcmVudC5fcmVuZGVyZXIub3BhY2l0eSA6IDEpO1xuXG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5fbWFzaztcbiAgICAgICAgLy8gdmFyIGNsaXAgPSB0aGlzLl9jbGlwO1xuXG4gICAgICAgIHZhciBkZWZhdWx0TWF0cml4ID0gaXNEZWZhdWx0TWF0cml4KG1hdHJpeCk7XG4gICAgICAgIHZhciBzaG91bGRJc29sYXRlID0gIWRlZmF1bHRNYXRyaXggfHwgISFtYXNrO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuY29udGV4dCkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQuY3R4ID0gY3R4O1xuICAgICAgICAvLyB0aGlzLl9yZW5kZXJlci5jb250ZXh0LmNsaXAgPSBjbGlwO1xuXG4gICAgICAgIGlmIChzaG91bGRJc29sYXRlKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBpZiAoIWRlZmF1bHRNYXRyaXgpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbM10sIG1hdHJpeFsxXSxcbiAgICAgICAgICAgICAgbWF0cml4WzRdLCBtYXRyaXhbMl0sIG1hdHJpeFs1XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICBjYW52YXNbbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwobWFzaywgY3R4LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9vcGFjaXR5ID4gMCAmJiB0aGlzLl9zY2FsZSAhPT0gMCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNhbnZhc1tjaGlsZC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoY2hpbGQsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZElzb2xhdGUpIHtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tbWVudGVkIHR3by13YXkgZnVuY3Rpb25hbGl0eSBvZiBjbGlwcyAvIG1hc2tzIHdpdGggZ3JvdXBzIGFuZFxuICAgICAgICAvLyBwb2x5Z29ucy4gVW5jb21tZW50IHdoZW4gdGhpcyBidWcgaXMgZml4ZWQ6XG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTFcblxuICAgICAgICAvLyBpZiAoY2xpcCkge1xuICAgICAgICAvLyAgIGN0eC5jbGlwKCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHBhdGg6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGZvcmNlZCwgcGFyZW50Q2xpcHBlZCkge1xuXG4gICAgICAgIHZhciBtYXRyaXgsIHN0cm9rZSwgbGluZXdpZHRoLCBmaWxsLCBvcGFjaXR5LCB2aXNpYmxlLCBjYXAsIGpvaW4sIG1pdGVyLFxuICAgICAgICAgICAgY2xvc2VkLCBjb21tYW5kcywgbGVuZ3RoLCBsYXN0LCBuZXh0LCBwcmV2LCBhLCBiLCBjLCBkLCB1eCwgdXksIHZ4LCB2eSxcbiAgICAgICAgICAgIGFyLCBibCwgYnIsIGNsLCB4LCB5LCBtYXNrLCBjbGlwLCBkZWZhdWx0TWF0cml4LCBpc09mZnNldCwgZGFzaGVzLCBwbztcblxuICAgICAgICBwbyA9ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5fcmVuZGVyZXIpXG4gICAgICAgICAgPyB0aGlzLnBhcmVudC5fcmVuZGVyZXIub3BhY2l0eSA6IDE7XG4gICAgICAgIG1hc2sgPSB0aGlzLl9tYXNrO1xuICAgICAgICBjbGlwID0gdGhpcy5fY2xpcDtcbiAgICAgICAgb3BhY2l0eSA9IHRoaXMuX29wYWNpdHkgKiAocG8gfHwgMSk7XG4gICAgICAgIHZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuXG4gICAgICAgIGlmICghZm9yY2VkICYmICghdmlzaWJsZSB8fCBjbGlwIHx8IG9wYWNpdHkgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICBtYXRyaXggPSB0aGlzLl9tYXRyaXguZWxlbWVudHM7XG4gICAgICAgIHN0cm9rZSA9IHRoaXMuX3N0cm9rZTtcbiAgICAgICAgbGluZXdpZHRoID0gdGhpcy5fbGluZXdpZHRoO1xuICAgICAgICBmaWxsID0gdGhpcy5fZmlsbDtcbiAgICAgICAgY2FwID0gdGhpcy5fY2FwO1xuICAgICAgICBqb2luID0gdGhpcy5fam9pbjtcbiAgICAgICAgbWl0ZXIgPSB0aGlzLl9taXRlcjtcbiAgICAgICAgY2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuICAgICAgICBjb21tYW5kcyA9IHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzOyAvLyBDb21tYW5kc1xuICAgICAgICBsZW5ndGggPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgICAgIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgICAgICBkZWZhdWx0TWF0cml4ID0gaXNEZWZhdWx0TWF0cml4KG1hdHJpeCk7XG4gICAgICAgIGRhc2hlcyA9IHRoaXMuZGFzaGVzO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybVxuICAgICAgICBpZiAoIWRlZmF1bHRNYXRyaXgpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbM10sIG1hdHJpeFsxXSwgbWF0cml4WzRdLCBtYXRyaXhbMl0sIG1hdHJpeFs1XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21tZW50ZWQgdHdvLXdheSBmdW5jdGlvbmFsaXR5IG9mIGNsaXBzIC8gbWFza3Mgd2l0aCBncm91cHMgYW5kXG4gICAgICAgIC8vIHBvbHlnb25zLiBVbmNvbW1lbnQgd2hlbiB0aGlzIGJ1ZyBpcyBmaXhlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MVxuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgIGNhbnZhc1ttYXNrLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChtYXNrLCBjdHgsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3R5bGVzXG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhc1tmaWxsLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChmaWxsLCBjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwuX3JlbmRlcmVyLmVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXNbc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChzdHJva2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UuX3JlbmRlcmVyLmVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbmV3aWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1pdGVyKSB7XG4gICAgICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IG1pdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoam9pbikge1xuICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gam9pbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjbG9zZWQgJiYgY2FwKSB7XG4gICAgICAgICAgICBjdHgubGluZUNhcCA9IGNhcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGFzaGVzICYmIGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaGVzLm9mZnNldCB8fCAwO1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgIGIgPSBjb21tYW5kc1tpXTtcblxuICAgICAgICAgIHggPSBiLng7XG4gICAgICAgICAgeSA9IGIueTtcblxuICAgICAgICAgIHN3aXRjaCAoYi5jb21tYW5kKSB7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuY2xvc2U6XG4gICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuYXJjOlxuXG4gICAgICAgICAgICAgIHZhciByeCA9IGIucng7XG4gICAgICAgICAgICAgIHZhciByeSA9IGIucnk7XG4gICAgICAgICAgICAgIHZhciB4QXhpc1JvdGF0aW9uID0gYi54QXhpc1JvdGF0aW9uO1xuICAgICAgICAgICAgICB2YXIgbGFyZ2VBcmNGbGFnID0gYi5sYXJnZUFyY0ZsYWc7XG4gICAgICAgICAgICAgIHZhciBzd2VlcEZsYWcgPSBiLnN3ZWVwRmxhZztcblxuICAgICAgICAgICAgICBwcmV2ID0gY2xvc2VkID8gbW9kKGkgLSAxLCBsZW5ndGgpIDogbWF4JDIoaSAtIDEsIDApO1xuICAgICAgICAgICAgICBhID0gY29tbWFuZHNbcHJldl07XG5cbiAgICAgICAgICAgICAgdmFyIGF4ID0gYS54O1xuICAgICAgICAgICAgICB2YXIgYXkgPSBhLnk7XG5cbiAgICAgICAgICAgICAgY2FudmFzLnJlbmRlclN2Z0FyY0NvbW1hbmQoY3R4LCBheCwgYXksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHhBeGlzUm90YXRpb24sIHgsIHkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5jdXJ2ZTpcblxuICAgICAgICAgICAgICBwcmV2ID0gY2xvc2VkID8gbW9kKGkgLSAxLCBsZW5ndGgpIDogTWF0aC5tYXgoaSAtIDEsIDApO1xuICAgICAgICAgICAgICBuZXh0ID0gY2xvc2VkID8gbW9kKGkgKyAxLCBsZW5ndGgpIDogTWF0aC5taW4oaSArIDEsIGxhc3QpO1xuXG4gICAgICAgICAgICAgIGEgPSBjb21tYW5kc1twcmV2XTtcbiAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW25leHRdO1xuICAgICAgICAgICAgICBhciA9IChhLmNvbnRyb2xzICYmIGEuY29udHJvbHMucmlnaHQpIHx8IFZlY3Rvci56ZXJvO1xuICAgICAgICAgICAgICBibCA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMubGVmdCkgfHwgVmVjdG9yLnplcm87XG5cbiAgICAgICAgICAgICAgaWYgKGEuX3JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgdnggPSAoYXIueCArIGEueCk7XG4gICAgICAgICAgICAgICAgdnkgPSAoYXIueSArIGEueSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdnggPSBhci54O1xuICAgICAgICAgICAgICAgIHZ5ID0gYXIueTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChiLl9yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHV4ID0gKGJsLnggKyBiLngpO1xuICAgICAgICAgICAgICAgIHV5ID0gKGJsLnkgKyBiLnkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHV4ID0gYmwueDtcbiAgICAgICAgICAgICAgICB1eSA9IGJsLnk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh2eCwgdnksIHV4LCB1eSwgeCwgeSk7XG5cbiAgICAgICAgICAgICAgaWYgKGkgPj0gbGFzdCAmJiBjbG9zZWQpIHtcblxuICAgICAgICAgICAgICAgIGMgPSBkO1xuXG4gICAgICAgICAgICAgICAgYnIgPSAoYi5jb250cm9scyAmJiBiLmNvbnRyb2xzLnJpZ2h0KSB8fCBWZWN0b3IuemVybztcbiAgICAgICAgICAgICAgICBjbCA9IChjLmNvbnRyb2xzICYmIGMuY29udHJvbHMubGVmdCkgfHwgVmVjdG9yLnplcm87XG5cbiAgICAgICAgICAgICAgICBpZiAoYi5fcmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgIHZ4ID0gKGJyLnggKyBiLngpO1xuICAgICAgICAgICAgICAgICAgdnkgPSAoYnIueSArIGIueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZ4ID0gYnIueDtcbiAgICAgICAgICAgICAgICAgIHZ5ID0gYnIueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYy5fcmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgIHV4ID0gKGNsLnggKyBjLngpO1xuICAgICAgICAgICAgICAgICAgdXkgPSAoY2wueSArIGMueSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHV4ID0gY2wueDtcbiAgICAgICAgICAgICAgICAgIHV5ID0gY2wueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4ID0gYy54O1xuICAgICAgICAgICAgICAgIHkgPSBjLnk7XG5cbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh2eCwgdnksIHV4LCB1eSwgeCwgeSk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLmxpbmU6XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLm1vdmU6XG4gICAgICAgICAgICAgIGQgPSBiO1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvb3NlIGVuZHNcblxuICAgICAgICBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbGlwICYmICFwYXJlbnRDbGlwcGVkKSB7XG4gICAgICAgICAgaWYgKCFjYW52YXMuaXNIaWRkZW4udGVzdChmaWxsKSkge1xuICAgICAgICAgICAgaXNPZmZzZXQgPSBmaWxsLl9yZW5kZXJlciAmJiBmaWxsLl9yZW5kZXJlci5vZmZzZXQ7XG4gICAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC54LCAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC55KTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKGZpbGwuX3JlbmRlcmVyLnNjYWxlLngsIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNhbnZhcy5pc0hpZGRlbi50ZXN0KHN0cm9rZSkpIHtcbiAgICAgICAgICAgIGlzT2Zmc2V0ID0gc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldDtcbiAgICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueCwgLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55KTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueCwgc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55KTtcbiAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aCAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGVmYXVsdE1hdHJpeCkge1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2xpcCAmJiAhcGFyZW50Q2xpcHBlZCkge1xuICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGFzaGVzICYmIGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGVtcHR5QXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0ZXh0OiB7XG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBmb3JjZWQsIHBhcmVudENsaXBwZWQpIHtcblxuICAgICAgICB2YXIgcG8gPSAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuX3JlbmRlcmVyKVxuICAgICAgICAgID8gdGhpcy5wYXJlbnQuX3JlbmRlcmVyLm9wYWNpdHkgOiAxO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IHRoaXMuX29wYWNpdHkgKiBwbztcbiAgICAgICAgdmFyIHZpc2libGUgPSB0aGlzLl92aXNpYmxlO1xuICAgICAgICB2YXIgbWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgIHZhciBjbGlwID0gdGhpcy5fY2xpcDtcblxuICAgICAgICBpZiAoIWZvcmNlZCAmJiAoIXZpc2libGUgfHwgY2xpcCB8fCBvcGFjaXR5ID09PSAwKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeC5lbGVtZW50cztcbiAgICAgICAgdmFyIHN0cm9rZSA9IHRoaXMuX3N0cm9rZTtcbiAgICAgICAgdmFyIGxpbmV3aWR0aCA9IHRoaXMuX2xpbmV3aWR0aDtcbiAgICAgICAgdmFyIGZpbGwgPSB0aGlzLl9maWxsO1xuICAgICAgICB2YXIgZGVjb3JhdGlvbiA9IHRoaXMuX2RlY29yYXRpb247XG4gICAgICAgIHZhciBkZWZhdWx0TWF0cml4ID0gaXNEZWZhdWx0TWF0cml4KG1hdHJpeCk7XG4gICAgICAgIHZhciBpc09mZnNldCA9IGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldFxuICAgICAgICAgICYmIHN0cm9rZS5fcmVuZGVyZXIgJiYgc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQ7XG4gICAgICAgIHZhciBkYXNoZXMgPSB0aGlzLmRhc2hlcztcbiAgICAgICAgdmFyIGFsaWdubWVudCA9IGNhbnZhcy5hbGlnbm1lbnRzW3RoaXMuX2FsaWdubWVudF0gfHwgdGhpcy5fYWxpZ25tZW50O1xuICAgICAgICB2YXIgYmFzZWxpbmUgPSB0aGlzLl9iYXNlbGluZTtcblxuICAgICAgICB2YXIgYSwgYiwgYywgZCwgZSwgc3gsIHN5LCB4MSwgeTEsIHgyLCB5MjtcblxuICAgICAgICAvLyBUcmFuc2Zvcm1cbiAgICAgICAgaWYgKCFkZWZhdWx0TWF0cml4KSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzNdLCBtYXRyaXhbMV0sIG1hdHJpeFs0XSwgbWF0cml4WzJdLCBtYXRyaXhbNV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tbWVudGVkIHR3by13YXkgZnVuY3Rpb25hbGl0eSBvZiBjbGlwcyAvIG1hc2tzIHdpdGggZ3JvdXBzIGFuZFxuICAgICAgICAvLyBwb2x5Z29ucy4gVW5jb21tZW50IHdoZW4gdGhpcyBidWcgaXMgZml4ZWQ6XG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTFcbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICBjYW52YXNbbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwobWFzaywgY3R4LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNPZmZzZXQpIHtcbiAgICAgICAgICBjdHguZm9udCA9IFt0aGlzLl9zdHlsZSwgdGhpcy5fd2VpZ2h0LCB0aGlzLl9zaXplICsgJ3B4LycgK1xuICAgICAgICAgICAgdGhpcy5fbGVhZGluZyArICdweCcsIHRoaXMuX2ZhbWlseV0uam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IGFsaWdubWVudDtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IGJhc2VsaW5lO1xuXG4gICAgICAgIC8vIFN0eWxlc1xuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXNbZmlsbC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoZmlsbCwgY3R4KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLl9yZW5kZXJlci5lZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0cm9rZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FudmFzW3N0cm9rZS5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLl9yZW5kZXJlci5lZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5ld2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5ld2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXNoZXMgJiYgZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoZXMub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsaXAgJiYgIXBhcmVudENsaXBwZWQpIHtcblxuICAgICAgICAgIGlmICghY2FudmFzLmlzSGlkZGVuLnRlc3QoZmlsbCkpIHtcblxuICAgICAgICAgICAgaWYgKGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldCkge1xuXG4gICAgICAgICAgICAgIHN4ID0gZmlsbC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgICAgc3kgPSBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xuXG4gICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoIC0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LngsXG4gICAgICAgICAgICAgICAgLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueSk7XG4gICAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuXG4gICAgICAgICAgICAgIGEgPSB0aGlzLl9zaXplIC8gZmlsbC5fcmVuZGVyZXIuc2NhbGUueTtcbiAgICAgICAgICAgICAgYiA9IHRoaXMuX2xlYWRpbmcgLyBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgICBjdHguZm9udCA9IFt0aGlzLl9zdHlsZSwgdGhpcy5fd2VpZ2h0LCBhICsgJ3B4LycsXG4gICAgICAgICAgICAgICAgYiArICdweCcsIHRoaXMuX2ZhbWlseV0uam9pbignICcpO1xuXG4gICAgICAgICAgICAgIGMgPSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLng7XG4gICAgICAgICAgICAgIGQgPSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueSAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XG5cbiAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudmFsdWUsIGMsIGQpO1xuICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy52YWx1ZSwgMCwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNhbnZhcy5pc0hpZGRlbi50ZXN0KHN0cm9rZSkpIHtcblxuICAgICAgICAgICAgaWYgKHN0cm9rZS5fcmVuZGVyZXIgJiYgc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQpIHtcblxuICAgICAgICAgICAgICBzeCA9IHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgICAgc3kgPSBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XG5cbiAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LngsXG4gICAgICAgICAgICAgICAgLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55KTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKHN4LCBzeSk7XG5cbiAgICAgICAgICAgICAgYSA9IHRoaXMuX3NpemUgLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgICAgIGIgPSB0aGlzLl9sZWFkaW5nIC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgICBjdHguZm9udCA9IFt0aGlzLl9zdHlsZSwgdGhpcy5fd2VpZ2h0LCBhICsgJ3B4LycsXG4gICAgICAgICAgICAgICAgYiArICdweCcsIHRoaXMuX2ZhbWlseV0uam9pbignICcpO1xuXG4gICAgICAgICAgICAgIGMgPSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC54IC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgICBkID0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueSAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcbiAgICAgICAgICAgICAgZSA9IGxpbmV3aWR0aCAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcblxuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gZTtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQodGhpcy52YWx1ZSwgYywgZCk7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KHRoaXMudmFsdWUsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0ZXh0LWRlY29yYXRpb25cbiAgICAgICAgaWYgKC8odW5kZXJsaW5lfHN0cmlrZXRocm91Z2gpL2kudGVzdChkZWNvcmF0aW9uKSkge1xuXG4gICAgICAgICAgdmFyIG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQodGhpcy52YWx1ZSk7XG4gICAgICAgICAgdmFyIHNjYWxhciA9IDE7XG5cbiAgICAgICAgICBzd2l0Y2ggKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVybGluZSc6XG4gICAgICAgICAgICAgIHkxID0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgICAgICAgICAgeTIgPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0cmlrZXRocm91Z2gnOlxuICAgICAgICAgICAgICB5MSA9IDA7XG4gICAgICAgICAgICAgIHkyID0gMDtcbiAgICAgICAgICAgICAgc2NhbGFyID0gMC41O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGJhc2VsaW5lKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgICB5MSArPSB0aGlzLl9zaXplICogc2NhbGFyO1xuICAgICAgICAgICAgICB5MiArPSB0aGlzLl9zaXplICogc2NhbGFyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jhc2VsaW5lJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgIHkxIC09IHRoaXMuX3NpemUgKiBzY2FsYXI7XG4gICAgICAgICAgICAgIHkyIC09IHRoaXMuX3NpemUgKiBzY2FsYXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoYWxpZ25tZW50KSB7XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3N0YXJ0JzpcbiAgICAgICAgICAgICAgeDEgPSAwO1xuICAgICAgICAgICAgICB4MiA9IG1ldHJpY3Mud2lkdGg7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAnZW5kJzpcbiAgICAgICAgICAgICAgeDEgPSAtIG1ldHJpY3Mud2lkdGg7XG4gICAgICAgICAgICAgIHgyID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB4MSA9IC0gbWV0cmljcy53aWR0aCAvIDI7XG4gICAgICAgICAgICAgIHgyID0gbWV0cmljcy53aWR0aCAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWF4KE1hdGguZmxvb3IodGhpcy5fc2l6ZSAvIDE1KSwgMSk7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZWZhdWx0TWF0cml4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IFRlc3QgZm9yIHRleHRcbiAgICAgICAgaWYgKGNsaXAgJiYgIXBhcmVudENsaXBwZWQpIHtcbiAgICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhc2hlcyAmJiBkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChlbXB0eUFycmF5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgJ2xpbmVhci1ncmFkaWVudCc6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVmZmVjdCB8fCB0aGlzLl9mbGFnRW5kUG9pbnRzIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xuXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgICAgdGhpcy5sZWZ0Ll94LCB0aGlzLmxlZnQuX3ksXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll94LCB0aGlzLnJpZ2h0Ll95XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0b3AgPSB0aGlzLnN0b3BzW2ldO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0LmFkZENvbG9yU3RvcChzdG9wLl9vZmZzZXQsIHN0b3AuX2NvbG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgJ3JhZGlhbC1ncmFkaWVudCc6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVmZmVjdCB8fCB0aGlzLl9mbGFnQ2VudGVyIHx8IHRoaXMuX2ZsYWdGb2NhbFxuICAgICAgICAgICAgfHwgdGhpcy5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9mbGFnU3RvcHMpIHtcblxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVmZmVjdCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChcbiAgICAgICAgICAgIHRoaXMuY2VudGVyLl94LCB0aGlzLmNlbnRlci5feSwgMCxcbiAgICAgICAgICAgIHRoaXMuZm9jYWwuX3gsIHRoaXMuZm9jYWwuX3ksIHRoaXMuX3JhZGl1c1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdG9wID0gdGhpcy5zdG9wc1tpXTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVmZmVjdC5hZGRDb2xvclN0b3Aoc3RvcC5fb2Zmc2V0LCBzdG9wLl9jb2xvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRleHR1cmU6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWZmZWN0IHx8ICgodGhpcy5fZmxhZ0xvYWRlZCB8fCB0aGlzLl9mbGFnSW1hZ2UgfHwgdGhpcy5fZmxhZ1ZpZGVvIHx8IHRoaXMuX2ZsYWdSZXBlYXQpICYmIHRoaXMubG9hZGVkKSkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVmZmVjdCA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRoaXMuaW1hZ2UsIHRoaXMuX3JlcGVhdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ09mZnNldCB8fCB0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdTY2FsZSkge1xuXG4gICAgICAgICAgaWYgKCEodGhpcy5fcmVuZGVyZXIub2Zmc2V0IGluc3RhbmNlb2YgVmVjdG9yKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0ID0gbmV3IFZlY3RvcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ID0gLSB0aGlzLl9vZmZzZXQueDtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueSA9IC0gdGhpcy5fb2Zmc2V0Lnk7XG5cbiAgICAgICAgICBpZiAoaW1hZ2UpIHtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnggKz0gaW1hZ2Uud2lkdGggLyAyO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKz0gaW1hZ2UuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ICo9IHRoaXMuX3NjYWxlLng7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ICo9IHRoaXMuX3NjYWxlLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NjYWxlIHx8IHRoaXMuX2ZsYWdMb2FkZWQpIHtcblxuICAgICAgICAgIGlmICghKHRoaXMuX3JlbmRlcmVyLnNjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUgPSBuZXcgVmVjdG9yKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS5jb3B5KHRoaXMuX3NjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUuc2V0KHRoaXMuX3NjYWxlLCB0aGlzLl9zY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHJlbmRlclN2Z0FyY0NvbW1hbmQ6IGZ1bmN0aW9uKGN0eCwgYXgsIGF5LCByeCwgcnksIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4QXhpc1JvdGF0aW9uLCB4LCB5KSB7XG5cbiAgICAgIHhBeGlzUm90YXRpb24gPSB4QXhpc1JvdGF0aW9uICogTWF0aC5QSSAvIDE4MDtcblxuICAgICAgLy8gRW5zdXJlIHJhZGlpIGFyZSBwb3NpdGl2ZVxuICAgICAgcnggPSBhYnMocngpO1xuICAgICAgcnkgPSBhYnMocnkpO1xuXG4gICAgICAvLyBDb21wdXRlICh4MeKAsiwgeTHigLIpXG4gICAgICB2YXIgZHgyID0gKGF4IC0geCkgLyAyLjA7XG4gICAgICB2YXIgZHkyID0gKGF5IC0geSkgLyAyLjA7XG4gICAgICB2YXIgeDFwID0gY29zJDQoeEF4aXNSb3RhdGlvbikgKiBkeDIgKyBzaW4kNCh4QXhpc1JvdGF0aW9uKSAqIGR5MjtcbiAgICAgIHZhciB5MXAgPSAtIHNpbiQ0KHhBeGlzUm90YXRpb24pICogZHgyICsgY29zJDQoeEF4aXNSb3RhdGlvbikgKiBkeTI7XG5cbiAgICAgIC8vIENvbXB1dGUgKGN44oCyLCBjeeKAsilcbiAgICAgIHZhciByeHMgPSByeCAqIHJ4O1xuICAgICAgdmFyIHJ5cyA9IHJ5ICogcnk7XG4gICAgICB2YXIgeDFwcyA9IHgxcCAqIHgxcDtcbiAgICAgIHZhciB5MXBzID0geTFwICogeTFwO1xuXG4gICAgICAvLyBFbnN1cmUgcmFkaWkgYXJlIGxhcmdlIGVub3VnaFxuICAgICAgdmFyIGNyID0geDFwcyAvIHJ4cyArIHkxcHMgLyByeXM7XG5cbiAgICAgIGlmIChjciA+IDEpIHtcblxuICAgICAgICAvLyBzY2FsZSB1cCByeCxyeSBlcXVhbGx5IHNvIGNyID09IDFcbiAgICAgICAgdmFyIHMgPSBzcXJ0KGNyKTtcbiAgICAgICAgcnggPSBzICogcng7XG4gICAgICAgIHJ5ID0gcyAqIHJ5O1xuICAgICAgICByeHMgPSByeCAqIHJ4O1xuICAgICAgICByeXMgPSByeSAqIHJ5O1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBkcSA9IChyeHMgKiB5MXBzICsgcnlzICogeDFwcyk7XG4gICAgICB2YXIgcHEgPSAocnhzICogcnlzIC0gZHEpIC8gZHE7XG4gICAgICB2YXIgcSA9IHNxcnQobWF4JDIoMCwgcHEpKTtcbiAgICAgIGlmIChsYXJnZUFyY0ZsYWcgPT09IHN3ZWVwRmxhZykgcSA9IC0gcTtcbiAgICAgIHZhciBjeHAgPSBxICogcnggKiB5MXAgLyByeTtcbiAgICAgIHZhciBjeXAgPSAtIHEgKiByeSAqIHgxcCAvIHJ4O1xuXG4gICAgICAvLyBTdGVwIDM6IENvbXB1dGUgKGN4LCBjeSkgZnJvbSAoY3jigLIsIGN54oCyKVxuICAgICAgdmFyIGN4ID0gY29zJDQoeEF4aXNSb3RhdGlvbikgKiBjeHBcbiAgICAgICAgLSBzaW4kNCh4QXhpc1JvdGF0aW9uKSAqIGN5cCArIChheCArIHgpIC8gMjtcbiAgICAgIHZhciBjeSA9IHNpbiQ0KHhBeGlzUm90YXRpb24pICogY3hwXG4gICAgICAgICsgY29zJDQoeEF4aXNSb3RhdGlvbikgKiBjeXAgKyAoYXkgKyB5KSAvIDI7XG5cbiAgICAgIC8vIFN0ZXAgNDogQ29tcHV0ZSDOuDEgYW5kIM6UzrhcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gc3ZnQW5nbGUoMSwgMCwgKHgxcCAtIGN4cCkgLyByeCwgKHkxcCAtIGN5cCkgLyByeSk7XG4gICAgICB2YXIgZGVsdGEgPSBzdmdBbmdsZSgoeDFwIC0gY3hwKSAvIHJ4LCAoeTFwIC0gY3lwKSAvIHJ5LFxuICAgICAgICAoLSB4MXAgLSBjeHApIC8gcngsICgtIHkxcCAtIGN5cCkgLyByeSkgJSBUV09fUEkkNTtcblxuICAgICAgdmFyIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIGRlbHRhO1xuXG4gICAgICB2YXIgY2xvY2t3aXNlID0gc3dlZXBGbGFnID09PSAwO1xuXG4gICAgICByZW5kZXJBcmNFc3RpbWF0ZShjdHgsIGN4LCBjeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSxcbiAgICAgICAgY2xvY2t3aXNlLCB4QXhpc1JvdGF0aW9uKTtcblxuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uQ2FudmFzUmVuZGVyZXJcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5FdmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIFRoaXMgb2JqZWN0IGlzIGluaGVyaXRlZCB3aGVuIGNvbnN0cnVjdGluZyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvfS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBbcGFyYW1ldGVycy5kb21FbGVtZW50XSAtIFRoZSBgPGNhbnZhcyAvPmAgdG8gZHJhdyB0by4gSWYgbm9uZSBnaXZlbiBhIG5ldyBvbmUgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1ldGVycy5vdmVyZHJhd10gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNhbnZhcyBzaG91bGQgY2xlYXIgdGhlIGJhY2tncm91bmQgb3Igbm90LiBEZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtZXRlcnMuc21vb3RoaW5nPXRydWVdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYW52YXMgc2hvdWxkIGFudGlhbGlhcyBkcmF3aW5nLiBTZXQgaXQgdG8gYGZhbHNlYCB3aGVuIHdvcmtpbmcgd2l0aCBwaXhlbCBhcnQuIGBmYWxzZWAgY2FuIGxlYWQgdG8gYmV0dGVyIHBlcmZvcm1hbmNlLCBzaW5jZSBpdCB3b3VsZCB1c2UgYSBjaGVhcGVyIGludGVycG9sYXRpb24gYWxnb3JpdGhtLlxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBjbGFzcyBpcyB1c2VkIGJ5IHtAbGluayBUd299IHdoZW4gY29uc3RydWN0aW5nIHdpdGggYHR5cGVgIG9mIGBUd28uVHlwZXMuY2FudmFzYC4gSXQgdGFrZXMgVHdvLmpzJyBzY2VuZWdyYXBoIGFuZCByZW5kZXJzIGl0IHRvIGEgYDxjYW52YXMgLz5gLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVuZGVyZXIkMihwYXJhbXMpIHtcblxuICAgIC8vIEl0IG1pZ2h0IG5vdCBtYWtlIGEgYmlnIGRpZmZlcmVuY2Ugb24gR1BVIGJhY2tlZCBjYW52YXNlcy5cbiAgICB2YXIgc21vb3RoaW5nID0gKHBhcmFtcy5zbW9vdGhpbmcgIT09IGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlciNkb21FbGVtZW50XG4gICAgICogQHByb3BlcnR5IHtFbGVtZW50fSAtIFRoZSBgPGNhbnZhcyAvPmAgYXNzb2NpYXRlZCB3aXRoIHRoZSBUd28uanMgc2NlbmUuXG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gcGFyYW1zLmRvbUVsZW1lbnQgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2FudmFzUmVuZGVyZXIjY3R4XG4gICAgICogQHByb3BlcnR5IHtDYW52YXMyRENvbnRleHR9IC0gQXNzb2NpYXRlZCB0d28gZGltZW5zaW9uYWwgY29udGV4dCB0byByZW5kZXIgb24gdGhlIGA8Y2FudmFzIC8+YC5cbiAgICAgKi9cbiAgICB0aGlzLmN0eCA9IHRoaXMuZG9tRWxlbWVudC5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyI292ZXJkcmF3XG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY2FudmFzIGNsZWFycyB0aGUgYmFja2dyb3VuZCBlYWNoIGRyYXcgY2FsbC5cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5vdmVyZHJhdyA9IHBhcmFtcy5vdmVyZHJhdyB8fCBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gc21vb3RoaW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlciNzY2VuZVxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLkdyb3VwfSAtIFRoZSByb290IGdyb3VwIG9mIHRoZSBzY2VuZWdyYXBoLlxuICAgICAqL1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgR3JvdXAoKTtcbiAgICB0aGlzLnNjZW5lLnBhcmVudCA9IHRoaXM7XG4gIH1cblxuXG4gIF8uZXh0ZW5kKFJlbmRlcmVyJDIsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlci5VdGlsc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIEEgbWFzc2l2ZSBvYmplY3QgZmlsbGVkIHdpdGggdXRpbGl0eSBmdW5jdGlvbnMgYW5kIHByb3BlcnRpZXMgdG8gcmVuZGVyIFR3by5qcyBvYmplY3RzIHRvIGEgYDxjYW52YXMgLz5gLlxuICAgICAqL1xuICAgIFV0aWxzOiBjYW52YXNcblxuICB9KTtcblxuICBfLmV4dGVuZChSZW5kZXJlciQyLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUmVuZGVyZXIkMixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlciNzZXRTaXplXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIHJlc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgd2lkdGggb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gLSBUaGUgbmV3IHBpeGVsIHJhdGlvIChwaXhlbCBkZW5zaXR5KSBvZiB0aGUgcmVuZGVyZXIuIERlZmF1bHRzIHRvIGNhbGN1bGF0ZSB0aGUgcGl4ZWwgZGVuc2l0eSBvZiB0aGUgdXNlcidzIHNjcmVlbi5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2hhbmdlIHRoZSBzaXplIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByYXRpbykge1xuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5yYXRpbyA9IHR5cGVvZiByYXRpbyA9PT0gJ3VuZGVmaW5lZCcgPyBnZXRSYXRpbyh0aGlzLmN0eCkgOiByYXRpbztcblxuICAgICAgdGhpcy5kb21FbGVtZW50LndpZHRoID0gd2lkdGggKiB0aGlzLnJhdGlvO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmF0aW87XG5cbiAgICAgIGlmICh0aGlzLmRvbUVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgXy5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnJlc2l6ZSwgd2lkdGgsIGhlaWdodCwgcmF0aW8pO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlciNyZW5kZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVuZGVyIHRoZSBjdXJyZW50IHNjZW5lIHRvIHRoZSBgPGNhbnZhcyAvPmAuXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGlzT25lID0gdGhpcy5yYXRpbyA9PT0gMTtcblxuICAgICAgaWYgKCFpc09uZSkge1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNjYWxlKHRoaXMucmF0aW8sIHRoaXMucmF0aW8pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3ZlcmRyYXcpIHtcbiAgICAgICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgY2FudmFzLmdyb3VwLnJlbmRlci5jYWxsKHRoaXMuc2NlbmUsIHRoaXMuY3R4KTtcblxuICAgICAgaWYgKCFpc09uZSkge1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlbmRlckFyY0VzdGltYXRlKGN0eCwgb3gsIG95LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjbG9ja3dpc2UsIHhBeGlzUm90YXRpb24pIHtcblxuICAgIHZhciBlcHNpbG9uID0gQ3VydmUuVG9sZXJhbmNlLmVwc2lsb247XG4gICAgdmFyIGRlbHRhQW5nbGUgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG4gICAgdmFyIHNhbWVQb2ludHMgPSBNYXRoLmFicyhkZWx0YUFuZ2xlKSA8IGVwc2lsb247XG5cbiAgICAvLyBlbnN1cmVzIHRoYXQgZGVsdGFBbmdsZSBpcyAwIC4uIDIgUElcbiAgICBkZWx0YUFuZ2xlID0gbW9kKGRlbHRhQW5nbGUsIFRXT19QSSQ1KTtcblxuICAgIGlmIChkZWx0YUFuZ2xlIDwgZXBzaWxvbikge1xuXG4gICAgICBpZiAoc2FtZVBvaW50cykge1xuXG4gICAgICAgIGRlbHRhQW5nbGUgPSAwO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGRlbHRhQW5nbGUgPSBUV09fUEkkNTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrd2lzZSA9PT0gdHJ1ZSAmJiAhIHNhbWVQb2ludHMpIHtcblxuICAgICAgaWYgKGRlbHRhQW5nbGUgPT09IFRXT19QSSQ1KSB7XG5cbiAgICAgICAgZGVsdGFBbmdsZSA9IC0gVFdPX1BJJDU7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSBUV09fUEkkNTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDb25zdGFudHMuUmVzb2x1dGlvbjsgaSsrKSB7XG5cbiAgICAgIHZhciB0ID0gaSAvIChDb25zdGFudHMuUmVzb2x1dGlvbiAtIDEpO1xuXG4gICAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XG4gICAgICB2YXIgeCA9IG94ICsgcnggKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgeSA9IG95ICsgcnkgKiBNYXRoLnNpbihhbmdsZSk7XG5cbiAgICAgIGlmICh4QXhpc1JvdGF0aW9uICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKHhBeGlzUm90YXRpb24pO1xuICAgICAgICB2YXIgc2luID0gTWF0aC5zaW4oeEF4aXNSb3RhdGlvbik7XG5cbiAgICAgICAgdmFyIHR4ID0geCAtIG94O1xuICAgICAgICB2YXIgdHkgPSB5IC0gb3k7XG5cbiAgICAgICAgLy8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxuICAgICAgICB4ID0gdHggKiBjb3MgLSB0eSAqIHNpbiArIG94O1xuICAgICAgICB5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIG95O1xuXG4gICAgICB9XG5cbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHN2Z0FuZ2xlKHV4LCB1eSwgdngsIHZ5KSB7XG5cbiAgICB2YXIgZG90ID0gdXggKiB2eCArIHV5ICogdnk7XG4gICAgdmFyIGxlbiA9IHNxcnQodXggKiB1eCArIHV5ICogdXkpICogIHNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuICAgIC8vIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbiwgc2xpZ2h0bHkgb3ZlciB2YWx1ZXMgYXBwZWFyXG4gICAgdmFyIGFuZyA9IGFjb3MobWF4JDIoLTEsIG1pbiQyKDEsIGRvdCAvIGxlbikpKTtcbiAgICBpZiAoKHV4ICogdnkgLSB1eSAqIHZ4KSA8IDApIHtcbiAgICAgIGFuZyA9IC0gYW5nO1xuICAgIH1cblxuICAgIHJldHVybiBhbmc7XG5cbiAgfVxuXG4gIHZhciBDYW52YXNTaGltID0ge1xuXG4gICAgSW1hZ2U6IG51bGwsXG5cbiAgICBpc0hlYWRsZXNzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5VdGlscy5zaGltXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtjYW52YXN9IGNhbnZhcyAtIFRoZSBpbnN0YW5jZWQgYENhbnZhc2Agb2JqZWN0IHByb3ZpZGVkIGJ5IGBub2RlLWNhbnZhc2AuXG4gICAgICogQHBhcmFtIHtJbWFnZX0gW0ltYWdlXSAtIFRoZSBwcm90b3R5cGljYWwgYEltYWdlYCBvYmplY3QgcHJvdmlkZWQgYnkgYG5vZGUtY2FudmFzYC4gVGhpcyBpcyBvbmx5IG5lY2Vzc2FyeSB0byBwYXNzIGlmIHlvdSdyZSBnb2luZyB0byBsb2FkIGJpdG1hcCBpbWFnZXJ5LlxuICAgICAqIEByZXR1cm5zIHtjYW52YXN9IFJldHVybnMgdGhlIGluc3RhbmNlZCBjYW52YXMgb2JqZWN0IHlvdSBwYXNzZWQgZnJvbSB3aXRoIGFkZGl0aW9uYWwgYXR0cmlidXRlcyBuZWVkZWQgZm9yIFR3by5qcy5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbWV0aG9kIGZvciBkZWZpbmluZyBhbGwgdGhlIGRlcGVuZGVuY2llcyBmcm9tIHRoZSBucG0gcGFja2FnZSBgbm9kZS1jYW52YXNgLiBTZWUgW25vZGUtY2FudmFzXShodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9ub2RlLWNhbnZhcykgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gb24gc2V0dGluZyB1cCBIVE1MNSBgPGNhbnZhcyAvPmAgZHJhd2luZyBpbiBhIG5vZGUuanMgZW52aXJvbm1lbnQuXG4gICAgICovXG4gICAgc2hpbTogZnVuY3Rpb24oY2FudmFzLCBJbWFnZSkge1xuICAgICAgUmVuZGVyZXIkMi5VdGlscy5zaGltKGNhbnZhcyk7XG4gICAgICBpZiAodHlwZW9mIEltYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBDYW52YXNTaGltLkltYWdlID0gSW1hZ2U7XG4gICAgICB9XG4gICAgICBDYW52YXNTaGltLmlzSGVhZGxlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG5cbiAgfTtcblxuICB2YXIgZG9tID0ge1xuXG4gICAgaGFzRXZlbnRMaXN0ZW5lcnM6IHR5cGVvZiByb290JDEuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJyxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBpZiAodGhpcy5oYXNFdmVudExpc3RlbmVycykge1xuICAgICAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZ1bmMsICEhYm9vbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uKGVsZW0sIGV2ZW50LCBmdW5jLCBib29sKSB7XG4gICAgICBpZiAoZG9tLmhhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcnMoZXZlbnQsIGZ1bmMsICEhYm9vbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtLmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgZnVuYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH0sXG5cbiAgICBnZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgbGFzdFRpbWUgPSAwO1xuICAgICAgdmFyIHZlbmRvcnMgPSBbJ21zJywgJ21veicsICd3ZWJraXQnLCAnbyddO1xuICAgICAgdmFyIHJlcXVlc3QgPSByb290JDEucmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBjYW5jZWw7XG5cbiAgICAgIGlmKCFyZXF1ZXN0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlcXVlc3QgPSByb290JDFbdmVuZG9yc1tpXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSB8fCByZXF1ZXN0O1xuICAgICAgICAgIGNhbmNlbCA9IHJvb3QkMVt2ZW5kb3JzW2ldICsgJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJ11cbiAgICAgICAgICAgIHx8IHJvb3QkMVt2ZW5kb3JzW2ldICsgJ0NhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZSddIHx8IGNhbmNlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0IHx8IGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XG4gICAgICAgICAgdmFyIGlkID0gcm9vdCQxLnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGNhbGxiYWNrKGN1cnJUaW1lICsgdGltZVRvQ2FsbCk7IH0sIHRpbWVUb0NhbGwpO1xuICAgICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xuICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG5cbiAgICB9XG5cbiAgfTtcblxuICB2YXIgdGVtcCA9IChyb290JDEuZG9jdW1lbnQgPyByb290JDEuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykgOiB7fSk7XG4gIHRlbXAuaWQgPSAnaGVscC10d28tbG9hZCc7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvbSwgJ3RlbXAnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKF8uaXNFbGVtZW50KHRlbXApICYmICFyb290JDEuZG9jdW1lbnQuaGVhZC5jb250YWlucyh0ZW1wKSkge1xuICAgICAgICBfLmV4dGVuZCh0ZW1wLnN0eWxlLCB7XG4gICAgICAgICAgZGlzcGxheTogJ25vbmUnXG4gICAgICAgIH0pO1xuICAgICAgICByb290JDEuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0ZW1wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZW1wO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5FcnJvclxuICAgKiBAY2xhc3NcbiAgICogQGRlc2NyaXB0aW9uIEN1c3RvbSBlcnJvciB0aHJvd2luZyBmb3IgVHdvLmpzIHNwZWNpZmljIGlkZW50aWZpY2F0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gVHdvRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubmFtZSA9ICdUd28uanMnO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH1cblxuICBUd29FcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuICBfLmV4dGVuZChUd29FcnJvci5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3RvcjogVHdvRXJyb3JcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5kZWZpbmVHZXR0ZXJTZXR0ZXJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEB0aGlzIFR3byNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gVGhlIHByb3BlcnR5IHRvIGFkZCBhbiBlbnVtZXJhYmxlIGdldHRlciAvIHNldHRlciB0by5cbiAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldHVwIHRoZSBmbGFnIGJhc2VkIGdldHRlciAvIHNldHRlciB0aGF0IG1vc3QgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBhcyBpbiBUd28uanMuXG4gICAqL1xuICB2YXIgZGVmaW5lR2V0dGVyU2V0dGVyID0gZnVuY3Rpb24ocHJvcGVydHkpIHtcblxuICAgIHZhciBvYmplY3QgPSB0aGlzO1xuICAgIHZhciBzZWNyZXQgPSAnXycgKyBwcm9wZXJ0eTtcbiAgICB2YXIgZmxhZyA9ICdfZmxhZycgKyBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tzZWNyZXRdO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICB0aGlzW3NlY3JldF0gPSB2O1xuICAgICAgICB0aGlzW2ZsYWddID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uUmVnaXN0cnlcbiAgICogQGNsYXNzXG4gICAqIEBkZXNjcmlwdGlvbiBBbiBhcmJpdHJhcnkgY2xhc3MgdG8gbWFuYWdlIGEgZGlyZWN0b3J5IG9mIHRoaW5ncy4gTWFpbmx5IHVzZWQgZm9yIGtlZXBpbmcgdGFicyBvZiB0ZXh0dXJlcyBpbiBUd28uanMuXG4gICAqL1xuICBmdW5jdGlvbiBSZWdpc3RyeSgpIHtcblxuICAgIHRoaXMubWFwID0ge307XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFJlZ2lzdHJ5LnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IFJlZ2lzdHJ5LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlZ2lzdHJ5I2FkZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIEEgdW5pcXVlIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIHZhbHVlIC0gQW55IHR5cGUgb2YgdmFyaWFibGUgdG8gYmUgcmVnaXN0ZXJlZCB0byB0aGUgZGlyZWN0b3J5LlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGRzIGFueSB2YWx1ZSB0byB0aGUgZGlyZWN0b3J5LiBBc3NpZ25lZCBieSB0aGUgYGlkYC5cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKGlkLCBvYmopIHtcbiAgICAgIHRoaXMubWFwW2lkXSA9IG9iajtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVnaXN0cnkjcmVtb3ZlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQSB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIGFueSB2YWx1ZSBmcm9tIHRoZSBkaXJlY3RvcnkgYnkgaXRzIGBpZGAuXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihpZCkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW2lkXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVnaXN0cnkjZ2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQSB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyB7P09iamVjdH0gVGhlIGFzc29jaWF0ZWQgdmFsdWUuIElmIHVuYXZhaWxhYmxlIHRoZW4gYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCBhIHJlZ2lzdGVyZWQgdmFsdWUgYnkgaXRzIGBpZGAuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHRoaXMubWFwW2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlZ2lzdHJ5I2NvbnRhaW5zXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQSB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHNlZSBpZiBhIHZhbHVlIGlzIHJlZ2lzdGVyZWQgdG8gYW4gYGlkYCBhbHJlYWR5LlxuICAgICAqL1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIGlkIGluIHRoaXMubWFwO1xuICAgIH1cblxuICB9KTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlN0b3BcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIFRoZSBvZmZzZXQgcGVyY2VudGFnZSBvZiB0aGUgc3RvcCByZXByZXNlbnRlZCBhcyBhIHplcm8tdG8tb25lIHZhbHVlLiBEZWZhdWx0IHZhbHVlIGZsaXAgZmxvcHMgZnJvbSB6ZXJvLXRvLW9uZSBhcyBuZXcgc3RvcHMgYXJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29sb3JdIC0gVGhlIGNvbG9yIG9mIHRoZSBzdG9wLiBEZWZhdWx0IHZhbHVlIGZsaXAgZmxvcHMgZnJvbSB3aGl0ZSB0byBibGFjayBhcyBuZXcgc3RvcHMgYXJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3BhY2l0eV0gLSBUaGUgb3BhY2l0eSB2YWx1ZS4gRGVmYXVsdCB2YWx1ZSBpcyAxLCBjYW5ub3QgYmUgbG93ZXIgdGhhbiAwLlxuICAgKiBAbm90YS1iZW5lIFVzZWQgc3BlY2lmaWNhbGx5IGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIFR3by5HcmFkaWVudH1zIHRvIGNvbnRyb2wgY29sb3IgZ3JhZHVhdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIFN0b3Aob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3AjcmVuZGVyZXJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gT2JqZWN0IGFjY2VzcyB0byBzdG9yZSByZWxldmFudCByZW5kZXJlciBzcGVjaWZpYyB2YXJpYWJsZXMuIFdhcm5pbmc6IG1hbmlwdWxhdGluZyB0aGlzIG9iamVjdCBjYW4gY3JlYXRlIHVuaW50ZW5kZWQgY29uc2VxdWVuY2VzLlxuICAgICAqIEBub3RhLWJlbmUgV2l0aCB0aGUge0BsaW5rIFR3by5TdmdSZW5kZXJlcn0geW91IGNhbiBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgU1ZHIGVsZW1lbnQgY3JlYXRlZCB2aWEgYHNoYXBlLnJlbmRlcmVyLmVsZW1gLlxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ3N0b3AnO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3Ajb2Zmc2V0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIG9mZnNldCBwZXJjZW50YWdlIG9mIHRoZSBzdG9wIHJlcHJlc2VudGVkIGFzIGEgemVyby10by1vbmUgdmFsdWUuXG4gICAgICovXG4gICAgdGhpcy5vZmZzZXQgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnbnVtYmVyJyA/IG9mZnNldFxuICAgICAgOiBTdG9wLkluZGV4IDw9IDAgPyAwIDogMTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdG9wI29wYWNpdHlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgYWxwaGEgcGVyY2VudGFnZSBvZiB0aGUgc3RvcCByZXByZXNlbnRlZCBhcyBhIHplcm8tdG8tb25lIHZhbHVlLlxuICAgICAqL1xuICAgIHRoaXMub3BhY2l0eSA9IHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJyA/IG9wYWNpdHkgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3AjY29sb3JcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBUaGUgY29sb3Igb2YgdGhlIHN0b3AuXG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9ICh0eXBlb2YgY29sb3IgPT09ICdzdHJpbmcnKSA/IGNvbG9yXG4gICAgICA6IFN0b3AuSW5kZXggPD0gMCA/ICcjZmZmJyA6ICcjMDAwJztcblxuICAgIFN0b3AuSW5kZXggPSAoU3RvcC5JbmRleCArIDEpICUgMjtcblxuICB9XG5cbiAgXy5leHRlbmQoU3RvcCwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3AuSW5kZXhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgY3VycmVudCBpbmRleCBiZWluZyByZWZlcmVuY2VkIGZvciBjYWxjdWxhdGluZyBhIHN0b3AncyBkZWZhdWx0IG9mZnNldCB2YWx1ZS5cbiAgICAgKi9cbiAgICBJbmRleDogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdG9wLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uU3RvcH0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogW1xuICAgICAgJ29mZnNldCcsXG4gICAgICAnb3BhY2l0eScsXG4gICAgICAnY29sb3InXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdG9wLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uU3RvcH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uU3RvcH0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICBfLmVhY2goU3RvcC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXG4gICAgICAgIHZhciBvYmplY3QgPSB0aGlzO1xuICAgICAgICB2YXIgc2VjcmV0ID0gJ18nICsgcHJvcGVydHk7XG4gICAgICAgIHZhciBmbGFnID0gJ19mbGFnJyArIHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1tzZWNyZXRdO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgICB0aGlzW3NlY3JldF0gPSB2O1xuICAgICAgICAgICAgdGhpc1tmbGFnXSA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX2ZsYWdTdG9wcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgfSwgb2JqZWN0KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3JlbmRlcmVyJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvYmo7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoU3RvcC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgY29uc3RydWN0b3I6IFN0b3AsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RvcCNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlN0b3B9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlN0b3B9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGNsb25lID0gbmV3IFN0b3AoKTtcblxuICAgICAgXy5lYWNoKFN0b3AuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgY2xvbmVbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdG9wI3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICAgIF8uZWFjaChTdG9wLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdG9wI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ09mZnNldCA9IHRoaXMuX2ZsYWdDb2xvciA9IHRoaXMuX2ZsYWdPcGFjaXR5ID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIFN0b3AuTWFrZU9ic2VydmFibGUoU3RvcC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uR3JhZGllbnRcbiAgICogQGNsYXNzXG4gICAqIEBwYXJhbSB7VHdvLlN0b3BbXX0gW3N0b3BzXSAtIEEgbGlzdCBvZiB7QGxpbmsgVHdvLlN0b3B9cyB0aGF0IGNvbnRhaW4gdGhlIGdyYWRpZW50IGZpbGwgcGF0dGVybiBmb3IgdGhlIGdyYWRpZW50LlxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgY29uc3RydWN0aW5nIGRpZmZlcmVudCB0eXBlcyBvZiBncmFkaWVudHMgd2l0aCBUd28uanMuIFRoZSB0d28gY29tbW9uIGdyYWRpZW50cyBhcmUge0BsaW5rIFR3by5MaW5lYXJHcmFkaWVudH0gYW5kIHtAbGluayBUd28uUmFkaWFsR3JhZGllbnR9LlxuICAgKi9cbiAgZnVuY3Rpb24gR3JhZGllbnQoc3RvcHMpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNyZW5kZXJlclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBPYmplY3QgYWNjZXNzIHRvIHN0b3JlIHJlbGV2YW50IHJlbmRlcmVyIHNwZWNpZmljIHZhcmlhYmxlcy4gV2FybmluZzogbWFuaXB1bGF0aW5nIHRoaXMgb2JqZWN0IGNhbiBjcmVhdGUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMuXG4gICAgICogQG5vdGEtYmVuZSBXaXRoIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfSB5b3UgY2FuIGFjY2VzcyB0aGUgdW5kZXJseWluZyBTVkcgZWxlbWVudCBjcmVhdGVkIHZpYSBgc2hhcGUucmVuZGVyZXIuZWxlbWAuXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlciA9IHt9O1xuICAgIHRoaXMuX3JlbmRlcmVyLnR5cGUgPSAnZ3JhZGllbnQnO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I2lkXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gU2Vzc2lvbiBzcGVjaWZpYyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKiBAbm90YS1iZW5lIEluIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfSBjaGFuZ2UgdGhpcyB0byBjaGFuZ2UgdGhlIHVuZGVybHlpbmcgU1ZHIGVsZW1lbnQncyBpZCB0b28uXG4gICAgICovXG4gICAgdGhpcy5pZCA9IENvbnN0YW50cy5JZGVudGlmaWVyICsgQ29uc3RhbnRzLnVuaXF1ZUlkKCk7XG4gICAgdGhpcy5jbGFzc0xpc3QgPSBbXTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdTdG9wcyA9IEdyYWRpZW50LkZsYWdTdG9wcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmJpbmRTdG9wcyA9IEdyYWRpZW50LkJpbmRTdG9wcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnVuYmluZFN0b3BzID0gR3JhZGllbnQuVW5iaW5kU3RvcHMuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNzcHJlYWRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBJbmRpY2F0ZXMgd2hhdCBoYXBwZW5zIGlmIHRoZSBncmFkaWVudCBzdGFydHMgb3IgZW5kcyBpbnNpZGUgdGhlIGJvdW5kcyBvZiB0aGUgdGFyZ2V0IHJlY3RhbmdsZS4gUG9zc2libGUgdmFsdWVzIGFyZSBgJ3BhZCdgLCBgJ3JlZmxlY3QnYCwgYW5kIGAncmVwZWF0J2AuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BzZXJ2ZXJzLmh0bWwjTGluZWFyR3JhZGllbnRFbGVtZW50U3ByZWFkTWV0aG9kQXR0cmlidXRlfSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMuc3ByZWFkID0gJ3BhZCc7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQjc3RvcHNcbiAgICAgKiBAcHJvcGVydHkge1R3by5TdG9wW119IC0gQW4gb3JkZXJlZCBsaXN0IG9mIHtAbGluayBUd28uU3RvcH1zIGZvciByZW5kZXJpbmcgdGhlIGdyYWRpZW50LlxuICAgICAqL1xuICAgIGlmIChzdG9wcykge1xuICAgICAgdGhpcy5zdG9wcyA9IHN0b3BzO1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoR3JhZGllbnQsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5TdG9wXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlN0b3B9XG4gICAgICovXG4gICAgU3RvcDogU3RvcCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLkdyYWRpZW50fS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbXG4gICAgICAnc3ByZWFkJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5HcmFkaWVudH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uR3JhZGllbnR9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgXy5lYWNoKEdyYWRpZW50LlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqZWN0KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3N0b3BzJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihzdG9wcykge1xuXG4gICAgICAgICAgdmFyIGJpbmRTdG9wcyA9IHRoaXMuX3JlbmRlcmVyLmJpbmRTdG9wcztcbiAgICAgICAgICB2YXIgdW5iaW5kU3RvcHMgPSB0aGlzLl9yZW5kZXJlci51bmJpbmRTdG9wcztcblxuICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBsaXN0ZW5lcnNcbiAgICAgICAgICBpZiAodGhpcy5fc3RvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BzXG4gICAgICAgICAgICAgIC51bmJpbmQoRXZlbnRzLlR5cGVzLmluc2VydCwgYmluZFN0b3BzKVxuICAgICAgICAgICAgICAudW5iaW5kKEV2ZW50cy5UeXBlcy5yZW1vdmUsIHVuYmluZFN0b3BzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IENvbGxlY3Rpb24gd2l0aCBjb3B5IG9mIFN0b3BzXG4gICAgICAgICAgdGhpcy5fc3RvcHMgPSBuZXcgQ29sbGVjdGlvbigoc3RvcHMgfHwgW10pLnNsaWNlKDApKTtcblxuICAgICAgICAgIC8vIExpc3RlbiBmb3IgQ29sbGVjdGlvbiBjaGFuZ2VzIGFuZCBiaW5kIC8gdW5iaW5kXG4gICAgICAgICAgdGhpcy5fc3RvcHNcbiAgICAgICAgICAgIC5iaW5kKEV2ZW50cy5UeXBlcy5pbnNlcnQsIGJpbmRTdG9wcylcbiAgICAgICAgICAgIC5iaW5kKEV2ZW50cy5UeXBlcy5yZW1vdmUsIHVuYmluZFN0b3BzKTtcblxuICAgICAgICAgIC8vIEJpbmQgSW5pdGlhbCBTdG9wc1xuICAgICAgICAgIGJpbmRTdG9wcyh0aGlzLl9zdG9wcyk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3JlbmRlcmVyJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBvYmo7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdpZCcsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2lkID0gdjtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQuRmxhZ1N0b3BzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IHN0b3BzIGhhdmUgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5HcmFkaWVudH0uXG4gICAgICovXG4gICAgRmxhZ1N0b3BzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdTdG9wcyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5CaW5kVmVydGljZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQge0BsaW5rIFR3by5HcmFkaWVudH0ga25vdyB2ZXJ0aWNlcyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEJpbmRTdG9wczogZnVuY3Rpb24oaXRlbXMpIHtcblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYSBsb3RcbiAgICAgIC8vIHdoZW4gaW1wb3J0aW5nIGEgbGFyZ2UgU1ZHXG4gICAgICB2YXIgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlKGktLSkge1xuICAgICAgICBpdGVtc1tpXS5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdTdG9wcyk7XG4gICAgICAgIGl0ZW1zW2ldLnBhcmVudCA9IHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdTdG9wcygpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5VbmJpbmRTdG9wc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLkdyYWRpZW50fSBrbm93IHZlcnRpY2VzIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFVuYmluZFN0b3BzOiBmdW5jdGlvbihpdGVtcykge1xuXG4gICAgICB2YXIgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlKGktLSkge1xuICAgICAgICBpdGVtc1tpXS51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0b3BzKTtcbiAgICAgICAgZGVsZXRlIGl0ZW1zW2ldLnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0b3BzKCk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoR3JhZGllbnQucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBHcmFkaWVudCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNfZmxhZ0lkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyYWRpZW50I2lkfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0lkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNfZmxhZ1N0b3BzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyYWRpZW50I3N0b3BzfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1N0b3BzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQjX2ZsYWdTcHJlYWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JhZGllbnQjc3ByZWFkfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1NwcmVhZDogZmFsc2UsXG5cbiAgICBfaWQ6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uR3JhZGllbnR9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkdyYWRpZW50fSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBzdG9wcyA9IHRoaXMuc3RvcHMubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgcmV0dXJuIHMuY2xvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgR3JhZGllbnQoc3RvcHMpO1xuXG4gICAgICBfLmVhY2goR3JhZGllbnQuUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgc3RvcHM6IHRoaXMuc3RvcHMubWFwKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy50b09iamVjdCgpO1xuICAgICAgICB9KVxuICAgICAgfTtcblxuICAgICAgXy5lYWNoKEdyYWRpZW50LlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdTcHJlYWQgPSB0aGlzLl9mbGFnU3RvcHMgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgR3JhZGllbnQuTWFrZU9ic2VydmFibGUoR3JhZGllbnQucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50XG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uR3JhZGllbnRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4MT0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBlbmQgcG9pbnQgb2YgdGhlIGxpbmVhciBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5MT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBlbmQgcG9pbnQgb2YgdGhlIGxpbmVhciBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4Mj0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgZW5kIHBvaW50IG9mIHRoZSBsaW5lYXIgZ3JhZGllbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeTI9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIGVuZCBwb2ludCBvZiB0aGUgbGluZWFyIGdyYWRpZW50LlxuICAgKiBAcGFyYW0ge1R3by5TdG9wW119IFtzdG9wc10gLSBBIGxpc3Qgb2Yge0BsaW5rIFR3by5TdG9wfXMgdGhhdCBjb250YWluIHRoZSBncmFkaWVudCBmaWxsIHBhdHRlcm4gZm9yIHRoZSBncmFkaWVudC5cbiAgICogQG5vdGEtYmVuZSBUaGUgbGluZWFyIGdyYWRpZW50IGxpdmVzIHdpdGhpbiB0aGUgc3BhY2Ugb2YgdGhlIHBhcmVudCBvYmplY3QncyBtYXRyaXggc3BhY2UuXG4gICAqL1xuICBmdW5jdGlvbiBMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Miwgc3RvcHMpIHtcblxuICAgIEdyYWRpZW50LmNhbGwodGhpcywgc3RvcHMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICdsaW5lYXItZ3JhZGllbnQnO1xuXG4gICAgdmFyIGZsYWdFbmRQb2ludHMgPSBMaW5lYXJHcmFkaWVudC5GbGFnRW5kUG9pbnRzLmJpbmQodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjbGVmdFxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBUaGUgeCBhbmQgeSB2YWx1ZSBmb3Igd2hlcmUgdGhlIGZpcnN0IGVuZCBwb2ludCBpcyBwbGFjZWQgb24gdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICB0aGlzLmxlZnQgPSBuZXcgVmVjdG9yKCkuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCBmbGFnRW5kUG9pbnRzKTtcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjcmlnaHRcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gVGhlIHggYW5kIHkgdmFsdWUgZm9yIHdoZXJlIHRoZSBzZWNvbmQgZW5kIHBvaW50IGlzIHBsYWNlZCBvbiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIHRoaXMucmlnaHQgPSBuZXcgVmVjdG9yKCkuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCBmbGFnRW5kUG9pbnRzKTtcblxuICAgIGlmICh0eXBlb2YgeDEgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxlZnQueCA9IHgxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHkxID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5sZWZ0LnkgPSB5MTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4MiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucmlnaHQueCA9IHgyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHkyID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5yaWdodC55ID0geTI7XG4gICAgfVxuXG4gIH1cblxuICBfLmV4dGVuZChMaW5lYXJHcmFkaWVudCwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50LlN0b3BcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3RvcH1cbiAgICAgKi9cbiAgICBTdG9wOiBTdG9wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uTGluZWFyR3JhZGllbnR9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICBHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZShvYmplY3QpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQuRmxhZ0VuZFBvaW50c1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyBlbmQgcG9pbnRzIGhhdmUgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5MaW5lYXJHcmFkaWVudH0uXG4gICAgICovXG4gICAgRmxhZ0VuZFBvaW50czogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9mbGFnRW5kUG9pbnRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoTGluZWFyR3JhZGllbnQucHJvdG90eXBlLCBHcmFkaWVudC5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBMaW5lYXJHcmFkaWVudCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudCNfZmxhZ0VuZFBvaW50c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5MaW5lYXJHcmFkaWVudCNsZWZ0fSBvciB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50I3JpZ2h0fSBjaGFuZ2VkIGFuZCBuZWVkcyB0byB1cGRhdGUuXG4gICAgICovXG4gICAgX2ZsYWdFbmRQb2ludHM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50I2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uR3JhZGllbnR9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBzdG9wcyA9IHRoaXMuc3RvcHMubWFwKGZ1bmN0aW9uKHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIHN0b3AuY2xvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgTGluZWFyR3JhZGllbnQodGhpcy5sZWZ0Ll94LCB0aGlzLmxlZnQuX3ksXG4gICAgICAgIHRoaXMucmlnaHQuX3gsIHRoaXMucmlnaHQuX3ksIHN0b3BzKTtcblxuICAgICAgXy5lYWNoKEdyYWRpZW50LlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSBHcmFkaWVudC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcblxuICAgICAgcmVzdWx0LmxlZnQgPSB0aGlzLmxlZnQudG9PYmplY3QoKTtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHRoaXMucmlnaHQudG9PYmplY3QoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ0VuZFBvaW50cyB8fCB0aGlzLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudCNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdFbmRQb2ludHMgPSBmYWxzZTtcblxuICAgICAgR3JhZGllbnQucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBMaW5lYXJHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZShMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnRcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5HcmFkaWVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgb3JpZ2luIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBvcmlnaW4gb2YgdGhlIHJhZGlhbCBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXM9MF0gLSBUaGUgcmFkaXVzIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQuXG4gICAqIEBwYXJhbSB7VHdvLlN0b3BbXX0gW3N0b3BzXSAtIEEgbGlzdCBvZiB7QGxpbmsgVHdvLlN0b3B9cyB0aGF0IGNvbnRhaW4gdGhlIGdyYWRpZW50IGZpbGwgcGF0dGVybiBmb3IgdGhlIGdyYWRpZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZvY2FsWD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBmb2NhbCBwb2ludCBvbiB0aGUgcmFkaWFsIGdyYWRpZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZvY2FsWT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmb2NhbCBwb2ludCBvbiB0aGUgcmFkaWFsIGdyYWRpZW50LlxuICAgKiBAbm90YS1iZW5lIFRoZSByYWRpYWwgZ3JhZGllbnQgbGl2ZXMgd2l0aGluIHRoZSBzcGFjZSBvZiB0aGUgcGFyZW50IG9iamVjdCdzIG1hdHJpeCBzcGFjZS5cbiAgICovXG4gIGZ1bmN0aW9uIFJhZGlhbEdyYWRpZW50KGN4LCBjeSwgciwgc3RvcHMsIGZ4LCBmeSkge1xuXG4gICAgR3JhZGllbnQuY2FsbCh0aGlzLCBzdG9wcyk7XG5cbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ3JhZGlhbC1ncmFkaWVudCc7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjY2VudGVyXG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIFRoZSB4IGFuZCB5IHZhbHVlIGZvciB3aGVyZSB0aGUgb3JpZ2luIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQgaXMuXG4gICAgICovXG4gICAgdGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yKClcbiAgICAgIC5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fZmxhZ0NlbnRlciA9IHRydWU7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgIHRoaXMucmFkaXVzID0gdHlwZW9mIHIgPT09ICdudW1iZXInID8gciA6IDIwO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50I2ZvY2FsXG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIFRoZSB4IGFuZCB5IHZhbHVlIGZvciB3aGVyZSB0aGUgZm9jYWwgcG9pbnQgb2YgdGhlIHJhZGlhbCBncmFkaWVudCBpcy5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgZWZmZWN0cyB0aGUgc3ByYXkgb3Igc3ByZWFkIG9mIHRoZSByYWRpYWwgZ3JhZGllbnQuXG4gICAgICovXG4gICAgdGhpcy5mb2NhbCA9IG5ldyBWZWN0b3IoKVxuICAgICAgLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9mbGFnRm9jYWwgPSB0cnVlO1xuICAgICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAodHlwZW9mIGN4ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jZW50ZXIueCA9IGN4O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN5ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jZW50ZXIueSA9IGN5O1xuICAgIH1cblxuICAgIHRoaXMuZm9jYWwuY29weSh0aGlzLmNlbnRlcik7XG5cbiAgICBpZiAodHlwZW9mIGZ4ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5mb2NhbC54ID0gZng7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnkgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmZvY2FsLnkgPSBmeTtcbiAgICB9XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFJhZGlhbEdyYWRpZW50LCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQuU3RvcFxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdG9wfVxuICAgICAqL1xuICAgIFN0b3A6IFN0b3AsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQuUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudH0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogW1xuICAgICAgJ3JhZGl1cydcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uUmFkaWFsR3JhZGllbnR9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50fSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgIEdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XG5cbiAgICAgIF8uZWFjaChSYWRpYWxHcmFkaWVudC5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iamVjdCk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoUmFkaWFsR3JhZGllbnQucHJvdG90eXBlLCBHcmFkaWVudC5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCNfZmxhZ1JhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudCNyYWRpdXN9IGNoYW5nZWQgYW5kIG5lZWRzIHRvIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBfZmxhZ1JhZGl1czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50I19mbGFnQ2VudGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50I2NlbnRlcn0gY2hhbmdlZCBhbmQgbmVlZHMgdG8gdXBkYXRlLlxuICAgICAqL1xuICAgIF9mbGFnQ2VudGVyOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjX2ZsYWdGb2NhbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudCNmb2NhbH0gY2hhbmdlZCBhbmQgbmVlZHMgdG8gdXBkYXRlLlxuICAgICAqL1xuICAgIF9mbGFnRm9jYWw6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50I2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uR3JhZGllbnR9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50fSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBzdG9wcyA9IHRoaXMuc3RvcHMubWFwKGZ1bmN0aW9uKHN0b3ApIHtcbiAgICAgICAgcmV0dXJuIHN0b3AuY2xvbmUoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgUmFkaWFsR3JhZGllbnQodGhpcy5jZW50ZXIuX3gsIHRoaXMuY2VudGVyLl95LFxuICAgICAgICAgIHRoaXMuX3JhZGl1cywgc3RvcHMsIHRoaXMuZm9jYWwuX3gsIHRoaXMuZm9jYWwuX3kpO1xuXG4gICAgICBfLmVhY2goR3JhZGllbnQuUHJvcGVydGllcy5jb25jYXQoUmFkaWFsR3JhZGllbnQuUHJvcGVydGllcyksIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSBHcmFkaWVudC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcblxuICAgICAgXy5lYWNoKFJhZGlhbEdyYWRpZW50LlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXN1bHQuY2VudGVyID0gdGhpcy5jZW50ZXIudG9PYmplY3QoKTtcbiAgICAgIHJlc3VsdC5mb2NhbCA9IHRoaXMuZm9jYWwudG9PYmplY3QoKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9mbGF0Q2VudGVyIHx8IHRoaXMuX2ZsYWdGb2NhbFxuICAgICAgICB8fCB0aGlzLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdSYWRpdXMgPSB0aGlzLl9mbGFnQ2VudGVyID0gdGhpcy5fZmxhZ0ZvY2FsID0gZmFsc2U7XG5cbiAgICAgIEdyYWRpZW50LnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgUmFkaWFsR3JhZGllbnQuTWFrZU9ic2VydmFibGUoUmFkaWFsR3JhZGllbnQucHJvdG90eXBlKTtcblxuICB2YXIgYW5jaG9yO1xuICB2YXIgcmVnZXgkMSA9IHtcbiAgICB2aWRlbzogL1xcLihtcDR8d2VibXxvZ2cpJC9pLFxuICAgIGltYWdlOiAvXFwuKGpwZT9nfHBuZ3xnaWZ8dGlmZnx3ZWJwKSQvaSxcbiAgICBlZmZlY3Q6IC90ZXh0dXJlfGdyYWRpZW50L2lcbiAgfTtcblxuICBpZiAocm9vdCQxLmRvY3VtZW50KSB7XG4gICAgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5UZXh0dXJlXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uU2hhcGVcbiAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEltYWdlRWxlbWVudH0gW3NyY10gLSBUaGUgVVJMIHBhdGggdG8gYW4gaW1hZ2UgZmlsZSBvciBhbiBgPGltZyAvPmAgZWxlbWVudC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIG9uY2UgdGhlIGltYWdlIGhhcyBiZWVuIGxvYWRlZC5cbiAgICogQGRlc2NyaXB0aW9uIEZ1bmRhbWVudGFsIHRvIHdvcmsgd2l0aCBiaXRtYXAgZGF0YSwgYS5rLmEuIHByZWdlbmVyYXRlZCBpbWFnZXJ5LCBpbiBUd28uanMuIFN1cHBvcnRlZCBmb3JtYXRzIGluY2x1ZGUganBnLCBwbmcsIGdpZiwgYW5kIHRpZmYuIFNlZSB7QGxpbmsgVHdvLlRleHR1cmUuUmVndWxhckV4cHJlc3Npb25zfSBmb3IgYSBmdWxsIGxpc3Qgb2Ygc3VwcG9ydGVkIGZvcm1hdHMuXG4gICAqL1xuICBmdW5jdGlvbiBUZXh0dXJlKHNyYywgY2FsbGJhY2spIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI3JlbmRlcmVyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIE9iamVjdCBhY2Nlc3MgdG8gc3RvcmUgcmVsZXZhbnQgcmVuZGVyZXIgc3BlY2lmaWMgdmFyaWFibGVzLiBXYXJuaW5nOiBtYW5pcHVsYXRpbmcgdGhpcyBvYmplY3QgY2FuIGNyZWF0ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcy5cbiAgICAgKiBAbm90YS1iZW5lIFdpdGggdGhlIHtAbGluayBUd28uU3ZnUmVuZGVyZXJ9IHlvdSBjYW4gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIFNWRyBlbGVtZW50IGNyZWF0ZWQgdmlhIGBzaGFwZS5yZW5kZXJlci5lbGVtYC5cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICd0ZXh0dXJlJztcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnT2Zmc2V0ID0gVGV4dHVyZS5GbGFnT2Zmc2V0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1NjYWxlID0gVGV4dHVyZS5GbGFnU2NhbGUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuaWQgPSBDb25zdGFudHMuSWRlbnRpZmllciArIENvbnN0YW50cy51bmlxdWVJZCgpO1xuICAgIHRoaXMuY2xhc3NMaXN0ID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNsb2FkZWRcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gU2hvcnRoYW5kIHZhbHVlIHRvIGRldGVybWluZSBpZiBpbWFnZSBoYXMgYmVlbiBsb2FkZWQgaW50byB0aGUgdGV4dHVyZS5cbiAgICAgKi9cbiAgICB0aGlzLmxvYWRlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjcmVwZWF0XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gQ1NTIHN0eWxlIGRlY2xhcmF0aW9uIHRvIHRpbGUge0BsaW5rIFR3by5QYXRofS4gVmFsaWQgdmFsdWVzIGluY2x1ZGU6IGAnbm8tcmVwZWF0J2AsIGAncmVwZWF0J2AsIGAncmVwZWF0LXgnYCwgYCdyZXBlYXQteSdgLlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2RvbS1jb250ZXh0LTJkLWNyZWF0ZXBhdHRlcm59XG4gICAgICovXG4gICAgdGhpcy5yZXBlYXQgPSAnbm8tcmVwZWF0JztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI29mZnNldFxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBBIHR3by1jb21wb25lbnQgdmVjdG9yIGRlc2NyaWJpbmcgYW55IHBpeGVsIG9mZnNldCBvZiB0aGUgdGV4dHVyZSB3aGVuIGFwcGxpZWQgdG8gYSB7QGxpbmsgVHdvLlBhdGh9LlxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcigpO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGxvYWRlZCA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51bmJpbmQoRXZlbnRzLlR5cGVzLmxvYWQsIGxvYWRlZCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5iaW5kKEV2ZW50cy5UeXBlcy5sb2FkLCBsb2FkZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI3NyY1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBVUkwgcGF0aCB0byB0aGUgaW1hZ2UgZGF0YS5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgcHJvcGVydHkgaXMgdWx0aW1hdGVseSBzZXJpYWxpemVkIGluIGEge0BsaW5rIFR3by5SZWdpc3RyeX0gdG8gY2FjaGUgcmV0cmlldmFsLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGVsZW1TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKTtcbiAgICAgIGlmIChcbiAgICAgICAgZWxlbVN0cmluZyA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8XG4gICAgICAgIGVsZW1TdHJpbmcgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScgfHxcbiAgICAgICAgZWxlbVN0cmluZyA9PT0gJ1tvYmplY3QgSFRNTFZpZGVvRWxlbWVudF0nIHx8XG4gICAgICAgIGVsZW1TdHJpbmcgPT09ICdbb2JqZWN0IEltYWdlXSdcbiAgICAgICkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgVHdvLlRleHR1cmUjaW1hZ2VcbiAgICAgICAgICogQHByb3BlcnR5IHtFbGVtZW50fSAtIFRoZSBjb3JyZXNwb25kaW5nIERPTSBFbGVtZW50IG9mIHRoZSB0ZXh0dXJlLiBDYW4gYmUgYSBgPGltZyAvPmAsIGA8Y2FudmFzIC8+YCwgb3IgYDx2aWRlbyAvPmAgZWxlbWVudC4gU2VlIHtAbGluayBUd28uVGV4dHVyZS5SZWd1bGFyRXhwcmVzc2lvbnN9IGZvciBhIGZ1bGwgbGlzdCBvZiBzdXBwb3J0ZWQgZWxlbWVudHMuXG4gICAgICAgICAqIEBub3RhLWJlbmUgSW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzIHRoaXMgaXMgYSBgQ2FudmFzLkltYWdlYCBvYmplY3QuIFNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbm9kZS1jYW52YXN9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhlYWRsZXNzIGltYWdlIG9iamVjdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmltYWdlID0gc3JjO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gIH1cblxuICBfLmV4dGVuZChUZXh0dXJlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlRleHR1cmV9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFtcbiAgICAgICdpZCcsXG4gICAgICAnc3JjJyxcbiAgICAgICdsb2FkZWQnLFxuICAgICAgJ3JlcGVhdCdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuUmVndWxhckV4cHJlc3Npb25zXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gQSBtYXAgb2YgY29tcGF0aWJsZSBET00gRWxlbWVudHMgY2F0ZWdvcml6ZWQgYnkgbWVkaWEgZm9ybWF0LlxuICAgICAqL1xuICAgIFJlZ3VsYXJFeHByZXNzaW9uczogcmVnZXgkMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLkltYWdlUmVnaXN0cnlcbiAgICAgKiBAcHJvcGVydHkge1R3by5SZWdpc3RyeX0gLSBBIGNhbm9uaWNhbCBsaXN0aW5nIG9mIGltYWdlIGRhdGEgdXNlZCBpbiBhIHNpbmdsZSBzZXNzaW9uIG9mIFR3by5qcy5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgb2JqZWN0IGlzIHVzZWQgdG8gY2FjaGUgaW1hZ2UgZGF0YSBiZXR3ZWVuIGRpZmZlcmVudCB0ZXh0dXJlcy5cbiAgICAgKi9cbiAgICBJbWFnZVJlZ2lzdHJ5OiBuZXcgUmVnaXN0cnkoKSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLmdldEFic29sdXRlVVJMXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gLSBTZXJpYWxpemVzIGEgVVJMIGFzIGFuIGFic29sdXRlIHBhdGggZm9yIGNhbm9uaWNhbCBhdHRyaWJ1dGlvbiBpbiB7QGxpbmsgVHdvLkltYWdlUmVnaXN0cnl9LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAgICogQHJldHVybnMge1N0cmluZ30gLSBUaGUgc2VyaWFsaXplZCBhYnNvbHV0ZSBwYXRoLlxuICAgICAqL1xuICAgIGdldEFic29sdXRlVVJMOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICBpZiAoIWFuY2hvcikge1xuICAgICAgICAvLyBUT0RPOiBGaXggZm9yIGhlYWRsZXNzIGVudmlyb25tZW50c1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgIH1cbiAgICAgIGFuY2hvci5ocmVmID0gcGF0aDtcbiAgICAgIHJldHVybiBhbmNob3IuaHJlZjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUubG9hZEhlYWRsZXNzQnVmZmVyXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gLSBMb2FkcyBhbiBpbWFnZSBhcyBhIGJ1ZmZlciBpbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMuXG4gICAgICogQHBhcmFtIHtUd28uVGV4dHVyZX0gdGV4dHVyZSAtIFRoZSB7QGxpbmsgVHdvLlRleHR1cmV9IHRvIGJlIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsb2FkZWQgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgdHJpZ2dlcmVkIG9uY2UgdGhlIGltYWdlIGlzIGxvYWRlZC5cbiAgICAgKiBAbm90YS1iZW5lIC0gVGhpcyBmdW5jdGlvbiB1c2VzIG5vZGUncyBgZnMucmVhZEZpbGVTeW5jYCB0byBzcG9vZiB0aGUgYDxpbWcgLz5gIGxvYWRpbmcgcHJvY2VzcyBpbiB0aGUgYnJvd3Nlci5cbiAgICAgKi9cbiAgICBsb2FkSGVhZGxlc3NCdWZmZXI6IGZ1bmN0aW9uKHRleHR1cmUsIGxvYWRlZCkge1xuXG4gICAgICB0ZXh0dXJlLmltYWdlLm9ubG9hZCA9IGxvYWRlZDtcbiAgICAgIHRleHR1cmUuaW1hZ2Uuc3JjID0gdGV4dHVyZS5zcmM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuZ2V0VGFnXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gLSBSZXRyaWV2ZXMgdGhlIHRhZyBuYW1lIG9mIGFuIGltYWdlLCB2aWRlbywgb3IgY2FudmFzIG5vZGUuXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSAtIFRoZSBpbWFnZSB0byBpbmZlciB0aGUgdGFnIG5hbWUgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIFJldHVybnMgdGhlIHRhZyBuYW1lIG9mIGFuIGltYWdlLCB2aWRlbywgb3IgY2FudmFzIG5vZGUuXG4gICAgICovXG4gICAgZ2V0VGFnOiBmdW5jdGlvbihpbWFnZSkge1xuICAgICAgcmV0dXJuIChpbWFnZSAmJiBpbWFnZS5ub2RlTmFtZSAmJiBpbWFnZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAvLyBIZWFkbGVzcyBlbnZpcm9ubWVudHNcbiAgICAgICAgfHwgJ2ltZyc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLmdldEltYWdlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gLSBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBzZXQge0BsaW5rIFR3by5UZXh0dXJlI2ltYWdlfSBwcm9wZXJ0aWVzIHdpdGggY2Fub25pbmNhbCB2ZXJzaW9ucyBzZXQgaW4ge0BsaW5rIFR3by5UZXh0dXJlLkltYWdlUmVnaXN0cnl9LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgLSBUaGUgVVJMIHBhdGggb2YgdGhlIGltYWdlLlxuICAgICAqIEByZXR1cm5zIHtIVE1MSW1hZ2VFbGVtZW50fSAtIFJldHVybnMgZWl0aGVyIGEgY2FjaGVkIHZlcnNpb24gb2YgdGhlIGltYWdlIG9yIGEgbmV3IG9uZSB0aGF0IGlzIHJlZ2lzdGVyZWQgaW4ge0BsaW5rIFR3by5UZXh0dXJlLkltYWdlUmVnaXN0cnl9LlxuICAgICAqL1xuICAgIGdldEltYWdlOiBmdW5jdGlvbihzcmMpIHtcblxuICAgICAgdmFyIGFic29sdXRlU3JjID0gVGV4dHVyZS5nZXRBYnNvbHV0ZVVSTChzcmMpO1xuXG4gICAgICBpZiAoVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmNvbnRhaW5zKGFic29sdXRlU3JjKSkge1xuICAgICAgICByZXR1cm4gVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmdldChhYnNvbHV0ZVNyYyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWFnZTtcblxuICAgICAgaWYgKENhbnZhc1NoaW0uSW1hZ2UpIHtcblxuICAgICAgICAvLyBUT0RPOiBGaXggZm9yIGhlYWRsZXNzIGVudmlyb25tZW50c1xuICAgICAgICBpbWFnZSA9IG5ldyBDYW52YXNTaGltLkltYWdlKCk7XG4gICAgICAgIFJlbmRlcmVyJDIuVXRpbHMuc2hpbShpbWFnZSwgJ2ltZycpO1xuXG4gICAgICB9IGVsc2UgaWYgKHJvb3QkMS5kb2N1bWVudCkge1xuXG4gICAgICAgIGlmIChyZWdleCQxLnZpZGVvLnRlc3QoYWJzb2x1dGVTcmMpKSB7XG4gICAgICAgICAgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd2aWRlbycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBjb25zb2xlLndhcm4oJ1R3by5qczogbm8gcHJvdG90eXBpY2FsIGltYWdlIGRlZmluZWQgZm9yIFR3by5UZXh0dXJlJyk7XG5cbiAgICAgIH1cblxuICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcblxuICAgICAgcmV0dXJuIGltYWdlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWdpc3RlclxuICAgICAqIEBpbnRlcmZhY2VcbiAgICAgKiBAZGVzY3JpcHRpb24gQSBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB0byByZWdpc3RlciBkaWZmZXJlbnQgdHlwZXMgb2YgdGV4dHVyZXMuIFVzZWQgaW50ZXJuYWxseSBieSBhIHtAbGluayBUd28uVGV4dHVyZX0uXG4gICAgICovXG4gICAgUmVnaXN0ZXI6IHtcbiAgICAgIGNhbnZhczogZnVuY3Rpb24odGV4dHVyZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGV4dHVyZS5fc3JjID0gJyMnICsgdGV4dHVyZS5pZDtcbiAgICAgICAgVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmFkZCh0ZXh0dXJlLnNyYywgdGV4dHVyZS5pbWFnZSk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaW1nOiBmdW5jdGlvbih0ZXh0dXJlLCBjYWxsYmFjaykge1xuXG4gICAgICAgIHZhciBpbWFnZSA9IHRleHR1cmUuaW1hZ2U7XG5cbiAgICAgICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoIUNhbnZhc1NoaW0uaXNIZWFkbGVzcyAmJiBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyICYmIHR5cGVvZiBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZGVkLCBmYWxzZSk7XG4gICAgICAgICAgICBpbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKCFDYW52YXNTaGltLmlzSGVhZGxlc3MgJiYgdHlwZW9mIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkZWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IFR3b0Vycm9yKCd1bmFibGUgdG8gbG9hZCAnICsgdGV4dHVyZS5zcmMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW1hZ2Uud2lkdGggPT09ICdudW1iZXInICYmIGltYWdlLndpZHRoID4gMFxuICAgICAgICAgICYmIHR5cGVvZiBpbWFnZS5oZWlnaHQgPT09ICdudW1iZXInICYmIGltYWdlLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIGxvYWRlZCgpO1xuICAgICAgICB9IGVsc2UgaWYgKCFDYW52YXNTaGltLmlzSGVhZGxlc3MgJiYgdHlwZW9mIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZGVkLCBmYWxzZSk7XG4gICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dHVyZS5fc3JjID0gVGV4dHVyZS5nZXRBYnNvbHV0ZVVSTCh0ZXh0dXJlLl9zcmMpO1xuXG4gICAgICAgIGlmICghQ2FudmFzU2hpbS5pc0hlYWRsZXNzICYmIGltYWdlICYmIGltYWdlLmdldEF0dHJpYnV0ZSgndHdvLXNyYycpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFDYW52YXNTaGltLmlzSGVhZGxlc3MpIHtcbiAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3R3by1zcmMnLCB0ZXh0dXJlLnNyYyk7XG4gICAgICAgIH1cblxuICAgICAgICBUZXh0dXJlLkltYWdlUmVnaXN0cnkuYWRkKHRleHR1cmUuc3JjLCBpbWFnZSk7XG5cbiAgICAgICAgaWYgKENhbnZhc1NoaW0uaXNIZWFkbGVzcykge1xuXG4gICAgICAgICAgVGV4dHVyZS5sb2FkSGVhZGxlc3NCdWZmZXIodGV4dHVyZSwgbG9hZGVkKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5zcmMgPSB0ZXh0dXJlLnNyYztcblxuICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICB2aWRlbzogZnVuY3Rpb24odGV4dHVyZSwgY2FsbGJhY2spIHtcblxuICAgICAgICBpZiAoQ2FudmFzU2hpbS5pc0hlYWRsZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3b0Vycm9yKCd2aWRlbyB0ZXh0dXJlcyBhcmUgbm90IGltcGxlbWVudGVkIGluIGhlYWRsZXNzIGVudmlyb25tZW50cy4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2FkZWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGxvYWRlZCwgZmFsc2UpO1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2Uud2lkdGggPSB0ZXh0dXJlLmltYWdlLnZpZGVvV2lkdGg7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXh0dXJlLmltYWdlLnZpZGVvSGVpZ2h0O1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsIGxvYWRlZCwgZmFsc2UpO1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xuICAgICAgICAgIHRocm93IG5ldyBUd29FcnJvcigndW5hYmxlIHRvIGxvYWQgJyArIHRleHR1cmUuc3JjKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0ZXh0dXJlLl9zcmMgPSBUZXh0dXJlLmdldEFic29sdXRlVVJMKHRleHR1cmUuX3NyYyk7XG5cbiAgICAgICAgaWYgKCF0ZXh0dXJlLmltYWdlLmdldEF0dHJpYnV0ZSgndHdvLXNyYycpKSB7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5zZXRBdHRyaWJ1dGUoJ3R3by1zcmMnLCB0ZXh0dXJlLnNyYyk7XG4gICAgICAgICAgVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmFkZCh0ZXh0dXJlLnNyYywgdGV4dHVyZS5pbWFnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dHVyZS5pbWFnZS5yZWFkeVN0YXRlID49IDQpIHtcbiAgICAgICAgICBsb2FkZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgbG9hZGVkLCBmYWxzZSk7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yLCBmYWxzZSk7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5zcmMgPSB0ZXh0dXJlLnNyYztcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLmxvYWQoKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLmxvYWRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHRleHR1cmUgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB0aGUgdGV4dHVyZSBpcyBsb2FkZWQuXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24odGV4dHVyZSwgY2FsbGJhY2spIHtcblxuICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcbiAgICAgIHZhciB0YWcgPSBUZXh0dXJlLmdldFRhZyhpbWFnZSk7XG5cbiAgICAgIGlmICh0ZXh0dXJlLl9mbGFnSW1hZ2UpIHtcbiAgICAgICAgaWYgKC9jYW52YXMvaS50ZXN0KHRhZykpIHtcbiAgICAgICAgICBUZXh0dXJlLlJlZ2lzdGVyLmNhbnZhcyh0ZXh0dXJlLCBjYWxsYmFjayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dHVyZS5fc3JjID0gKCFDYW52YXNTaGltLmlzSGVhZGxlc3MgJiYgaW1hZ2UuZ2V0QXR0cmlidXRlKCd0d28tc3JjJykpIHx8IGltYWdlLnNyYztcbiAgICAgICAgICBUZXh0dXJlLlJlZ2lzdGVyW3RhZ10odGV4dHVyZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0ZXh0dXJlLl9mbGFnU3JjKSB7XG4gICAgICAgIGlmICghaW1hZ2UpIHtcbiAgICAgICAgICBpbWFnZSA9IFRleHR1cmUuZ2V0SW1hZ2UodGV4dHVyZS5zcmMpO1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgfVxuICAgICAgICB0YWcgPSBUZXh0dXJlLmdldFRhZyhpbWFnZSk7XG4gICAgICAgIFRleHR1cmUuUmVnaXN0ZXJbdGFnXSh0ZXh0dXJlLCBjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuRmxhZ09mZnNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyBgb2Zmc2V0YCBoYXMgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5UZXh0dXJlfS5cbiAgICAgKi9cbiAgICBGbGFnT2Zmc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdPZmZzZXQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5GbGFnU2NhbGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgYHNjYWxlYCBoYXMgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5UZXh0dXJlfS5cbiAgICAgKi9cbiAgICBGbGFnU2NhbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ1NjYWxlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5UZXh0dXJlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCBvciBpbmhlcml0IHRoZSB7QGxpbmsgVHdvLlRleHR1cmV9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgXy5lYWNoKFRleHR1cmUuUHJvcGVydGllcywgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmplY3QpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnaW1hZ2UnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGltYWdlKSB7XG5cbiAgICAgICAgICB2YXIgdGFnID0gVGV4dHVyZS5nZXRUYWcoaW1hZ2UpO1xuICAgICAgICAgIHZhciBpbmRleDtcblxuICAgICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgICAgICBjYXNlICdjYW52YXMnOlxuICAgICAgICAgICAgICBpbmRleCA9ICcjJyArIGltYWdlLmlkO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGluZGV4ID0gaW1hZ2Uuc3JjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChUZXh0dXJlLkltYWdlUmVnaXN0cnkuY29udGFpbnMoaW5kZXgpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZSA9IFRleHR1cmUuSW1hZ2VSZWdpc3RyeS5nZXQoaW1hZ2Uuc3JjKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9mbGFnSW1hZ2UgPSB0cnVlO1xuXG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdvZmZzZXQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX29mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5fb2Zmc2V0LnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnT2Zmc2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gdjtcbiAgICAgICAgICB0aGlzLl9vZmZzZXQuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnT2Zmc2V0KTtcbiAgICAgICAgICB0aGlzLl9mbGFnT2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdzY2FsZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9zY2FsZS51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1NjYWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zY2FsZSA9IHY7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1NjYWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9mbGFnU2NhbGUgPSB0cnVlO1xuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncmVuZGVyZXInLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG9iajtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChUZXh0dXJlLnByb3RvdHlwZSwgRXZlbnRzLCBTaGFwZS5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBUZXh0dXJlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2ZsYWdJZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI2lkfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0lkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnU3JjXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjc3JjfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1NyYzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfZmxhZ0ltYWdlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjaW1hZ2V9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSW1hZ2U6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2ZsYWdWaWRlb1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI3ZpZGVvfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1ZpZGVvOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnTG9hZGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjbG9hZGVkfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0xvYWRlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfZmxhZ1JlcGVhdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI3JlcGVhdH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdSZXBlYXQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2ZsYWdPZmZzZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dHVyZSNvZmZzZXR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnT2Zmc2V0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnU2NhbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dHVyZSNzY2FsZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdTY2FsZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfaWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5UZXh0dXJlI2lkfVxuICAgICAqL1xuICAgIF9pZDogJycsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfc3JjXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uVGV4dHVyZSNzcmN9XG4gICAgICovXG4gICAgX3NyYzogJycsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfaW1hZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5UZXh0dXJlI2ltYWdlfVxuICAgICAqL1xuICAgIF9pbWFnZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19sb2FkZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5UZXh0dXJlI2xvYWRlZH1cbiAgICAgKi9cbiAgICBfbG9hZGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19yZXBlYXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5UZXh0dXJlI3JlcGVhdH1cbiAgICAgKi9cbiAgICBfcmVwZWF0OiAnbm8tcmVwZWF0JyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19zY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHR1cmUjc2NhbGV9XG4gICAgICovXG4gICAgX3NjYWxlOiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX29mZnNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHR1cmUjb2Zmc2V0fVxuICAgICAqL1xuICAgIF9vZmZzZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtUd28uVGV4dHVyZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uVGV4dHVyZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRleHR1cmUuXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNsb25lID0gbmV3IFRleHR1cmUodGhpcy5zcmMpO1xuICAgICAgY2xvbmUucmVwZWF0ID0gdGhpcy5yZXBlYXQ7XG4gICAgICBjbG9uZS5vZmZzZXQuY29weSh0aGlzLm9yaWdpbik7XG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHRleHR1cmUuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3JjOiB0aGlzLnNyYyxcbiAgICAgICAgLy8gaW1hZ2U6IHRoaXMuaW1hZ2UsXG4gICAgICAgIHJlcGVhdDogdGhpcy5yZXBlYXQsXG4gICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4udG9PYmplY3QoKSxcbiAgICAgICAgc2NhbGU6IHR5cGVvZiB0aGlzLnNjYWxlID09PSAnbnVtYmVyJyA/IHRoaXMuc2NhbGUgOiB0aGlzLnNjYWxlLnRvT2JqZWN0KClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdTcmMgfHwgdGhpcy5fZmxhZ0ltYWdlKSB7XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3JjIHx8IHRoaXMuX2ZsYWdJbWFnZSkge1xuICAgICAgICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgICAgICAgVGV4dHVyZS5sb2FkKHRoaXMsIChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICAgLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmxvYWQpO1xuICAgICAgICAgIH0pLmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnJlYWR5U3RhdGUgPj0gNCkge1xuICAgICAgICB0aGlzLl9mbGFnVmlkZW8gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdTcmMgPSB0aGlzLl9mbGFnSW1hZ2UgPSB0aGlzLl9mbGFnTG9hZGVkXG4gICAgICAgID0gdGhpcy5fZmxhZ1ZpZGVvID0gdGhpcy5fZmxhZ1NjYWxlID0gdGhpcy5fZmxhZ09mZnNldCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBUZXh0dXJlLk1ha2VPYnNlcnZhYmxlKFRleHR1cmUucHJvdG90eXBlKTtcblxuICAvLyBDb25zdGFudHNcblxuICB2YXIgbWluJDEgPSBNYXRoLm1pbiwgbWF4JDEgPSBNYXRoLm1heCxcbiAgICBjZWlsID0gTWF0aC5jZWlsLCBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5QYXRoXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uU2hhcGVcbiAgICogQHBhcmFtIHtUd28uQW5jaG9yW119IFt2ZXJ0aWNlc10gLSBBIGxpc3Qgb2Yge0BsaW5rIFR3by5BbmNob3J9cyB0aGF0IHJlcHJlc2VudCB0aGUgb3JkZXIgYW5kIGNvb3JkaW5hdGVzIHRvIGNvbnN0cnVjdCB0aGUgcmVuZGVyZWQgc2hhcGUuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2Nsb3NlZD1mYWxzZV0gLSBEZXNjcmliZXMgd2hldGhlciB0aGUgc2hhcGUgaXMgY2xvc2VkIG9yIG9wZW4uXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2N1cnZlZD1mYWxzZV0gLSBEZXNjcmliZXMgd2hldGhlciB0aGUgc2hhcGUgYXV0b21hdGljYWxseSBjYWxjdWxhdGVzIGJlemllciBoYW5kbGVzIGZvciBlYWNoIHZlcnRleC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFudWFsPWZhbHNlXSAtIERlc2NyaWJlcyB3aGV0aGVyIHRoZSBkZXZlbG9wZXIgY29udHJvbHMgaG93IHZlcnRpY2VzIGFyZSBwbG90dGVkIG9yIGlmIFR3by5qcyBhdXRvbWF0aWNhbGx5IHBsb3RzIGNvb3JkaW5hdGVzIGJhc2VkIG9uIGNsb3NlZCBhbmQgY3VydmVkIGJvb2xlYW5zLlxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyB0aGUgcHJpbWFyeSBwcmltaXRpdmUgY2xhc3MgZm9yIGNyZWF0aW5nIGFsbCBkcmF3YWJsZSBzaGFwZXMgaW4gVHdvLmpzLiBVbmxlc3Mgc3BlY2lmaWVkIG1ldGhvZHMgcmV0dXJuIHRoZWlyIGluc3RhbmNlIG9mIGBUd28uUGF0aGAgZm9yIHRoZSBwdXJwb3NlIG9mIGNoYWluaW5nLlxuICAgKi9cbiAgZnVuY3Rpb24gUGF0aCh2ZXJ0aWNlcywgY2xvc2VkLCBjdXJ2ZWQsIG1hbnVhbCkge1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLnR5cGUgPSAncGF0aCc7XG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzID0gUGF0aC5GbGFnVmVydGljZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlci5iaW5kVmVydGljZXMgPSBQYXRoLkJpbmRWZXJ0aWNlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnVuYmluZFZlcnRpY2VzID0gUGF0aC5VbmJpbmRWZXJ0aWNlcy5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ0ZpbGwgPSBQYXRoLkZsYWdGaWxsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSA9IFBhdGguRmxhZ1N0cm9rZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzID0gW107XG4gICAgdGhpcy5fcmVuZGVyZXIuY29sbGVjdGlvbiA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjY2xvc2VkXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBhIGZpbmFsIGxpbmUgaXMgZHJhd24gYmV0d2VlbiB0aGUgZmluYWwgcG9pbnQgaW4gdGhlIGB2ZXJ0aWNlc2AgYXJyYXkgYW5kIHRoZSBmaXJzdCBwb2ludC5cbiAgICAgKi9cbiAgICB0aGlzLl9jbG9zZWQgPSAhIWNsb3NlZDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2N1cnZlZFxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBXaGVuIHRoZSBwYXRoIGlzIGBhdXRvbWF0aWMgPSB0cnVlYCB0aGlzIGJvb2xlYW4gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBsaW5lcyBiZXR3ZWVuIHRoZSBwb2ludHMgYXJlIGN1cnZlZCBvciBub3QuXG4gICAgICovXG4gICAgdGhpcy5fY3VydmVkID0gISFjdXJ2ZWQ7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNiZWdpbm5pbmdcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgYmV0d2VlbiB6ZXJvIGFuZCBvbmUgdG8gc3RhdGUgdGhlIGJlZ2lubmluZyBvZiB3aGVyZSB0aGUgcGF0aCBpcyByZW5kZXJlZC5cbiAgICAgKiBAZGVzY3JpcHRpb24ge0BsaW5rIFR3by5QYXRoI2JlZ2lubmluZ30gaXMgYSBwZXJjZW50YWdlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBhdCB3aGF0IHBlcmNlbnRhZ2UgaW50byB0aGUgcGF0aCBzaG91bGQgdGhlIHJlbmRlcmVyIHN0YXJ0IGRyYXdpbmcuXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIGlzIGdyZWF0IGZvciBhbmltYXRpbmcgaW4gYW5kIG91dCBzdHJva2VkIHBhdGhzIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIFR3by5QYXRoI2VuZGluZ30uXG4gICAgICovXG4gICAgdGhpcy5iZWdpbm5pbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZW5kaW5nXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIGJldHdlZW4gemVybyBhbmQgb25lIHRvIHN0YXRlIHRoZSBlbmRpbmcgb2Ygd2hlcmUgdGhlIHBhdGggaXMgcmVuZGVyZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIHtAbGluayBUd28uUGF0aCNlbmRpbmd9IGlzIGEgcGVyY2VudGFnZSB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgYXQgd2hhdCBwZXJjZW50YWdlIGludG8gdGhlIHBhdGggc2hvdWxkIHRoZSByZW5kZXJlciBzdGFydCBkcmF3aW5nLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBpcyBncmVhdCBmb3IgYW5pbWF0aW5nIGluIGFuZCBvdXQgc3Ryb2tlZCBwYXRocyBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBUd28uUGF0aCNiZWdpbm5pbmd9LlxuICAgICAqL1xuICAgIHRoaXMuZW5kaW5nID0gMTtcblxuICAgIC8vIFN0eWxlIHByb3BlcnRpZXNcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2ZpbGxcbiAgICAgKiBAcHJvcGVydHkgeyhTdHJpbmd8VHdvLkdyYWRpZW50fFR3by5UZXh0dXJlKX0gLSBUaGUgdmFsdWUgb2Ygd2hhdCB0aGUgcGF0aCBzaG91bGQgYmUgZmlsbGVkIGluIHdpdGguXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDU1MncyBjb2xvcnMgYXMgYFN0cmluZ2AuXG4gICAgICovXG4gICAgdGhpcy5maWxsID0gJyNmZmYnO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjc3Ryb2tlXG4gICAgICogQHByb3BlcnR5IHsoU3RyaW5nfFR3by5HcmFkaWVudHxUd28uVGV4dHVyZSl9IC0gVGhlIHZhbHVlIG9mIHdoYXQgdGhlIHBhdGggc2hvdWxkIGJlIG91dGxpbmVkIGluIHdpdGguXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDU1MncyBjb2xvcnMgYXMgYFN0cmluZ2AuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2UgPSAnIzAwMCc7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNsaW5ld2lkdGhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdGhpY2tuZXNzIGluIHBpeGVscyBvZiB0aGUgc3Ryb2tlLlxuICAgICAqL1xuICAgIHRoaXMubGluZXdpZHRoID0gMS4wO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjb3BhY2l0eVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBvcGFxdWVuZXNzIG9mIHRoZSBwYXRoLlxuICAgICAqIEBub3RhLWJlbmUgQ2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBDU1MgQ29sb3JzIHRoYXQgaGF2ZSBhbiBhbHBoYSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLm9wYWNpdHkgPSAxLjA7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjbGFzc05hbWVcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBBIGNsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIENTUyBzdHlsaW5nLlxuICAgICAqIEBub3RhLWJlbmUgT25seSBhdmFpbGFibGUgZm9yIHRoZSBTVkcgcmVuZGVyZXIuXG4gICAgICovXG4gICAgdGhpcy5jbGFzc05hbWUgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI3Zpc2libGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGlzcGxheSB0aGUgcGF0aCBvciBub3QuXG4gICAgICogQG5vdGEtYmVuZSBGb3Ige0BsaW5rIFR3by5DYW52YXNSZW5kZXJlcn0gYW5kIHtAbGluayBUd28uV2ViR0xSZW5kZXJlcn0gd2hlbiBzZXQgdG8gZmFsc2UgYWxsIHVwZGF0aW5nIGlzIGRpc2FibGVkIGltcHJvdmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgd2l0aCBtYW55IG9iamVjdHMgaW4gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjYXBcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGFpbnRpbmcuaHRtbCNTdHJva2VMaW5lY2FwUHJvcGVydHl9XG4gICAgICovXG4gICAgdGhpcy5jYXAgPSAnYnV0dCc7ICAgICAgLy8gRGVmYXVsdCBvZiBBZG9iZSBJbGx1c3RyYXRvclxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjam9pblxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1N0cm9rZUxpbmVqb2luUHJvcGVydHl9XG4gICAgICovXG4gICAgdGhpcy5qb2luID0gJ21pdGVyJzsgICAgLy8gRGVmYXVsdCBvZiBBZG9iZSBJbGx1c3RyYXRvclxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjbWl0ZXJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGFpbnRpbmcuaHRtbCNTdHJva2VNaXRlcmxpbWl0UHJvcGVydHl9XG4gICAgICovXG4gICAgdGhpcy5taXRlciA9IDQ7ICAgICAgICAgLy8gRGVmYXVsdCBvZiBBZG9iZSBJbGx1c3RyYXRvclxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjdmVydGljZXNcbiAgICAgKiBAcHJvcGVydHkge1R3by5BbmNob3JbXX0gLSBBbiBvcmRlcmVkIGxpc3Qgb2YgYW5jaG9yIHBvaW50cyBmb3IgcmVuZGVyaW5nIHRoZSBwYXRoLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGxpc3Qgb2Yge0BsaW5rIFR3by5BbmNob3J9IG9iamVjdHMgdGhhdCBjb25zaXN0IG9mIHdoYXQgZm9ybSB0aGUgcGF0aCB0YWtlcy5cbiAgICAgKiBAbm90YS1iZW5lIFRoZSBhcnJheSB3aGVuIG1hbmlwdWxhdGluZyBpcyBhY3R1YWxseSBhIHtAbGluayBUd28uQ29sbGVjdGlvbn0uXG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjYXV0b21hdGljXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBvciBub3QgVHdvLmpzIHNob3VsZCBjYWxjdWxhdGUgY3VydmVzLCBsaW5lcywgYW5kIGNvbW1hbmRzIGF1dG9tYXRpY2FsbHkgZm9yIHlvdSBvciB0byBsZXQgdGhlIGRldmVsb3BlciBtYW5pcHVsYXRlIHRoZW0gZm9yIHRoZW1zZWx2ZXMuXG4gICAgICovXG4gICAgdGhpcy5hdXRvbWF0aWMgPSAhbWFudWFsO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZGFzaGVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJbXX0gLSBBcnJheSBvZiBudW1iZXJzLiBPZGQgaW5kaWNlcyByZXByZXNlbnQgZGFzaCBsZW5ndGguIEV2ZW4gaW5kaWNlcyByZXByZXNlbnQgZGFzaCBzcGFjZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQSBsaXN0IG9mIG51bWJlcnMgdGhhdCByZXByZXNlbnQgdGhlIHJlcGVhdGVkIGRhc2ggbGVuZ3RoIGFuZCBkYXNoIHNwYWNlIGFwcGxpZWQgdG8gdGhlIHN0cm9rZSBvZiB0aGUgdGV4dC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXl9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBTVkcgc3Ryb2tlLWRhc2hhcnJheSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgdGhpcy5kYXNoZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2Rhc2hlcyNvZmZzZXRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBIG51bWJlciBpbiBwaXhlbHMgdG8gb2Zmc2V0IHtAbGluayBUd28uUGF0aCNkYXNoZXN9IGRpc3BsYXkuXG4gICAgICovXG4gICAgdGhpcy5kYXNoZXMub2Zmc2V0ID0gMDtcblxuICB9XG5cbiAgXy5leHRlbmQoUGF0aCwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGguUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5QYXRofS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbXG4gICAgICAnZmlsbCcsXG4gICAgICAnc3Ryb2tlJyxcbiAgICAgICdsaW5ld2lkdGgnLFxuICAgICAgJ29wYWNpdHknLFxuICAgICAgJ3Zpc2libGUnLFxuICAgICAgJ2NhcCcsXG4gICAgICAnam9pbicsXG4gICAgICAnbWl0ZXInLFxuXG4gICAgICAnY2xvc2VkJyxcbiAgICAgICdjdXJ2ZWQnLFxuICAgICAgJ2F1dG9tYXRpYycsXG4gICAgICAnYmVnaW5uaW5nJyxcbiAgICAgICdlbmRpbmcnXG4gICAgXSxcblxuICAgIFV0aWxzOiB7XG4gICAgICBnZXRDdXJ2ZUxlbmd0aDogZ2V0Q3VydmVMZW5ndGhcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGguRmxhZ1ZlcnRpY2VzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IHZlcnRpY2VzIGhhdmUgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5QYXRofS5cbiAgICAgKi9cbiAgICBGbGFnVmVydGljZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ1ZlcnRpY2VzID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZsYWdMZW5ndGggPSB0cnVlO1xuICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgIHRoaXMucGFyZW50Ll9mbGFnTGVuZ3RoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGguQmluZFZlcnRpY2VzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHtAbGluayBUd28uUGF0aH0ga25vdyB2ZXJ0aWNlcyBoYXZlIGJlZW4gYWRkZWQgdG8gdGhlIGluc3RhbmNlLlxuICAgICAqL1xuICAgIEJpbmRWZXJ0aWNlczogZnVuY3Rpb24oaXRlbXMpIHtcblxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYSBsb3RcbiAgICAgIC8vIHdoZW4gaW1wb3J0aW5nIGEgbGFyZ2UgU1ZHXG4gICAgICB2YXIgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaXRlbXNbaV0uYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5VbmJpbmRWZXJ0aWNlc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLlBhdGh9IGtub3cgdmVydGljZXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgVW5iaW5kVmVydGljZXM6IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cbiAgICAgIHZhciBpID0gaXRlbXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpdGVtc1tpXS51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGguRmxhZ0ZpbGxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQge0BsaW5rIFR3by5QYXRofSBrbm93IHRoZSBmaWxsIGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIEZsYWdGaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdGaWxsID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGguRmxhZ0ZpbGxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQge0BsaW5rIFR3by5QYXRofSBrbm93IHRoZSBzdHJva2UgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgRmxhZ1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9mbGFnU3Ryb2tlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGguTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5QYXRofSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5QYXRofSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgIFNoYXBlLk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XG5cbiAgICAgIC8vIE9ubHkgdGhlIDcgZGVmaW5lZCBwcm9wZXJ0aWVzIGFyZSBmbGFnZ2VkIGxpa2UgdGhpcy4gVGhlIHN1YnNlcXVlbnRcbiAgICAgIC8vIHByb3BlcnRpZXMgYmVoYXZlIGRpZmZlcmVudGx5IGFuZCBuZWVkIHRvIGJlIGhhbmQgd3JpdHRlbi5cbiAgICAgIF8uZWFjaChQYXRoLlByb3BlcnRpZXMuc2xpY2UoMiwgOCksIGRlZmluZUdldHRlclNldHRlciwgb2JqZWN0KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2ZpbGwnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZmlsbCA9IGY7XG4gICAgICAgICAgdGhpcy5fZmxhZ0ZpbGwgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ0ZpbGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3N0cm9rZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFJhZGlhbEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdTdHJva2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3N0cm9rZSA9IGY7XG4gICAgICAgICAgdGhpcy5fZmxhZ1N0cm9rZSA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIFR3by5QYXRoI2xlbmd0aFxuICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHN1bSBvZiBkaXN0YW5jZXMgYmV0d2VlbiBhbGwge0BsaW5rIFR3by5QYXRoI3ZlcnRpY2VzfS5cbiAgICAgICAqL1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2xlbmd0aCcsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5fZmxhZ0xlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2xvc2VkJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2Nsb3NlZCA9ICEhdjtcbiAgICAgICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2N1cnZlZCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VydmVkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9jdXJ2ZWQgPSAhIXY7XG4gICAgICAgICAgdGhpcy5fZmxhZ1ZlcnRpY2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdhdXRvbWF0aWMnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2F1dG9tYXRpYztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgaWYgKHYgPT09IHRoaXMuX2F1dG9tYXRpYykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9hdXRvbWF0aWMgPSAhIXY7XG4gICAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuX2F1dG9tYXRpYyA/ICdpZ25vcmUnIDogJ2xpc3Rlbic7XG4gICAgICAgICAgXy5lYWNoKHRoaXMudmVydGljZXMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHZbbWV0aG9kXSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2JlZ2lubmluZycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYmVnaW5uaW5nO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9iZWdpbm5pbmcgPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdWZXJ0aWNlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnZW5kaW5nJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2VuZGluZyA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ1ZlcnRpY2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICd2ZXJ0aWNlcycsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxlY3Rpb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2ZXJ0aWNlcykge1xuXG4gICAgICAgICAgdmFyIGJpbmRWZXJ0aWNlcyA9IHRoaXMuX3JlbmRlcmVyLmJpbmRWZXJ0aWNlcztcbiAgICAgICAgICB2YXIgdW5iaW5kVmVydGljZXMgPSB0aGlzLl9yZW5kZXJlci51bmJpbmRWZXJ0aWNlcztcblxuICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBsaXN0ZW5lcnNcbiAgICAgICAgICBpZiAodGhpcy5fY29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvblxuICAgICAgICAgICAgICAudW5iaW5kKEV2ZW50cy5UeXBlcy5pbnNlcnQsIGJpbmRWZXJ0aWNlcylcbiAgICAgICAgICAgICAgLnVuYmluZChFdmVudHMuVHlwZXMucmVtb3ZlLCB1bmJpbmRWZXJ0aWNlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBDb2xsZWN0aW9uIHdpdGggY29weSBvZiB2ZXJ0aWNlc1xuICAgICAgICAgIGlmICh2ZXJ0aWNlcyBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxlY3Rpb24gPSB2ZXJ0aWNlcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IG5ldyBDb2xsZWN0aW9uKHZlcnRpY2VzIHx8IFtdKTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIC8vIExpc3RlbiBmb3IgQ29sbGVjdGlvbiBjaGFuZ2VzIGFuZCBiaW5kIC8gdW5iaW5kXG4gICAgICAgICAgdGhpcy5fY29sbGVjdGlvblxuICAgICAgICAgICAgLmJpbmQoRXZlbnRzLlR5cGVzLmluc2VydCwgYmluZFZlcnRpY2VzKVxuICAgICAgICAgICAgLmJpbmQoRXZlbnRzLlR5cGVzLnJlbW92ZSwgdW5iaW5kVmVydGljZXMpO1xuXG4gICAgICAgICAgLy8gQmluZCBJbml0aWFsIFZlcnRpY2VzXG4gICAgICAgICAgYmluZFZlcnRpY2VzKHRoaXMuX2NvbGxlY3Rpb24pO1xuXG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgVHdvLlBhdGgjbWFza1xuICAgICAgICogQHByb3BlcnR5IHtUd28uU2hhcGV9IC0gVGhlIHNoYXBlIHdob3NlIGFscGhhIHByb3BlcnR5IGJlY29tZXMgYSBjbGlwcGluZyBhcmVhIGZvciB0aGUgcGF0aC5cbiAgICAgICAqIEBub3RhLWJlbmUgVGhpcyBwcm9wZXJ0eSBpcyBjdXJyZW50bHkgbm90IHdvcmtpbmcgYmVjdWFzZSBvZiBTVkcgc3BlYyBpc3N1ZXMgZm91bmQgaGVyZSB7QGxpbmsgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MX0uXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdtYXNrJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9tYXNrID0gdjtcbiAgICAgICAgICB0aGlzLl9mbGFnTWFzayA9IHRydWU7XG4gICAgICAgICAgaWYgKCF2LmNsaXApIHtcbiAgICAgICAgICAgIHYuY2xpcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIFR3by5QYXRoI2NsaXBcbiAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBUZWxscyBUd28uanMgcmVuZGVyZXIgaWYgdGhpcyBvYmplY3QgcmVwcmVzZW50cyBhIG1hc2sgZm9yIGFub3RoZXIgb2JqZWN0IChvciBub3QpLlxuICAgICAgICovXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2xpcCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fY2xpcCA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ0NsaXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2Rhc2hlcycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGFzaGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHYub2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdi5vZmZzZXQgPSB0aGlzLl9kYXNoZXMub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2Rhc2hlcyA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFBhdGgucHJvdG90eXBlLCBTaGFwZS5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBQYXRoLFxuXG4gICAgLy8gRmxhZ3NcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZsYWdcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19mbGFnVmVydGljZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCN2ZXJ0aWNlc30gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1ZlcnRpY2VzOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdMZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNsZW5ndGh9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTGVuZ3RoOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdGaWxsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjZmlsbH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdGaWxsOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdTdHJva2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNzdHJva2V9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU3Ryb2tlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdMaW5ld2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNsaW5ld2lkdGh9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTGluZXdpZHRoOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdPcGFjaXR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjb3BhY2l0eX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdPcGFjaXR5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdWaXNpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjdmlzaWJsZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdWaXNpYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdDYXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNjYXB9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQ2FwOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdKb2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjam9pbn0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdKb2luOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdNaXRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI21pdGVyfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ01pdGVyOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdNYXNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjbWFza30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdNYXNrOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19mbGFnQ2xpcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2NsaXB9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQ2xpcDogZmFsc2UsXG5cbiAgICAvLyBVbmRlcmx5aW5nIFByb3BlcnRpZXNcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19sZW5ndGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2xlbmd0aH1cbiAgICAgKi9cbiAgICBfbGVuZ3RoOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZpbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2ZpbGx9XG4gICAgICovXG4gICAgX2ZpbGw6ICcjZmZmJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19zdHJva2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI3N0cm9rZX1cbiAgICAgKi9cbiAgICBfc3Ryb2tlOiAnIzAwMCcsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfbGluZXdpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNsaW5ld2lkdGh9XG4gICAgICovXG4gICAgX2xpbmV3aWR0aDogMS4wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX29wYWNpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI29wYWNpdHl9XG4gICAgICovXG4gICAgX29wYWNpdHk6IDEuMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI192aXNpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCN2aXNpYmxlfVxuICAgICAqL1xuICAgIF92aXNpYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2NhcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjY2FwfVxuICAgICAqL1xuICAgIF9jYXA6ICdyb3VuZCcsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfam9pblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjam9pbn1cbiAgICAgKi9cbiAgICBfam9pbjogJ3JvdW5kJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19taXRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjbWl0ZXJ9XG4gICAgICovXG4gICAgX21pdGVyOiA0LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2Nsb3NlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjY2xvc2VkfVxuICAgICAqL1xuICAgIF9jbG9zZWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfY3VydmVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNjdXJ2ZWR9XG4gICAgICovXG4gICAgX2N1cnZlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfYXV0b21hdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNhdXRvbWF0aWN9XG4gICAgICovXG4gICAgX2F1dG9tYXRpYzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19iZWdpbm5pbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2JlZ2lubmluZ31cbiAgICAgKi9cbiAgICBfYmVnaW5uaW5nOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2VuZGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjZW5kaW5nfVxuICAgICAqL1xuICAgIF9lbmRpbmc6IDEuMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19tYXNrXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNtYXNrfVxuICAgICAqL1xuICAgIF9tYXNrOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2NsaXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2NsaXB9XG4gICAgICovXG4gICAgX2NsaXA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2Rhc2hlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjZGFzaGVzfVxuICAgICAqL1xuICAgIF9kYXNoZXM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5QYXRofVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5QYXRofSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBQYXRoKCk7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBjbG9uZS52ZXJ0aWNlcy5wdXNoKHRoaXMudmVydGljZXNbal0uY2xvbmUoKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUGF0aC5Qcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0gUGF0aC5Qcm9wZXJ0aWVzW2ldO1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9XG5cbiAgICAgIGNsb25lLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgY2xvbmUuc2tld1kgPSB0aGlzLnNrZXdZO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lLl91cGRhdGUoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgdmVydGljZXM6IHRoaXMudmVydGljZXMubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4gdi50b09iamVjdCgpO1xuICAgICAgICB9KVxuICAgICAgfTtcblxuICAgICAgXy5lYWNoKFBhdGguUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJlc3VsdC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcblxuICAgICAgcmVzdWx0LnRyYW5zbGF0aW9uID0gdGhpcy50cmFuc2xhdGlvbi50b09iamVjdCgpO1xuICAgICAgcmVzdWx0LnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIHJlc3VsdC5zY2FsZSA9IHRoaXMuc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IgPyB0aGlzLnNjYWxlLnRvT2JqZWN0KCkgOiB0aGlzLnNjYWxlO1xuICAgICAgcmVzdWx0LnNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIHJlc3VsdC5za2V3WSA9IHRoaXMuc2tld1k7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgcmVzdWx0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvT2JqZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjbm9GaWxsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFNob3J0IGhhbmQgbWV0aG9kIHRvIHNldCBmaWxsIHRvIGB0cmFuc3BhcmVudGAuXG4gICAgICovXG4gICAgbm9GaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlsbCA9ICd0cmFuc3BhcmVudCc7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjbm9TdHJva2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvcnQgaGFuZCBtZXRob2QgdG8gc2V0IHN0cm9rZSB0byBgdHJhbnNwYXJlbnRgLlxuICAgICAqL1xuICAgIG5vU3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc3Ryb2tlID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2Nvcm5lclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmllbnQgdGhlIHZlcnRpY2VzIG9mIHRoZSBzaGFwZSB0byB0aGUgdXBwZXIgbGVmdC1oYW5kIGNvcm5lciBvZiB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICBjb3JuZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRydWUpO1xuICAgICAgdmFyIGh3ID0gcmVjdC53aWR0aCAvIDI7XG4gICAgICB2YXIgaGggPSByZWN0LmhlaWdodCAvIDI7XG4gICAgICB2YXIgY3ggPSByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMjtcbiAgICAgIHZhciBjeSA9IHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLyAyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuICAgICAgICB2LnggLT0gY3g7XG4gICAgICAgIHYueSAtPSBjeTtcbiAgICAgICAgdi54ICs9IGh3O1xuICAgICAgICB2LnkgKz0gaGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2NlbnRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmllbnQgdGhlIHZlcnRpY2VzIG9mIHRoZSBzaGFwZSB0byB0aGUgY2VudGVyIG9mIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIGNlbnRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QodHJ1ZSk7XG5cbiAgICAgIHZhciBjeCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyIC0gdGhpcy50cmFuc2xhdGlvbi54O1xuICAgICAgdmFyIGN5ID0gcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIgLSB0aGlzLnRyYW5zbGF0aW9uLnk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHYueCAtPSBjeDtcbiAgICAgICAgdi55IC09IGN5O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNyZW1vdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIHNlbGYgZnJvbSB0aGUgc2NlbmUgLyBwYXJlbnQuXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaGFsbG93PWZhbHNlXSAtIERlc2NyaWJlcyB3aGV0aGVyIHRvIGNhbGN1bGF0ZSBvZmYgbG9jYWwgbWF0cml4IG9yIHdvcmxkIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFJldHVybnMgb2JqZWN0IHdpdGggdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aCwgaGVpZ2h0IGF0dHJpYnV0ZXMuXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHdpZHRoLCBhbmQgaGVpZ2h0IHBhcmFtZXRlcnMgb2YgdGhlIHBhdGguXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbihzaGFsbG93KSB7XG4gICAgICB2YXIgbWF0cml4LCBib3JkZXIsIGwsIGksIHYwLCB2MSwgYzB4LCBjMHksIGMxeCwgYzF5LCBhLCBiLCBjLCBkO1xuXG4gICAgICB2YXIgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eSxcbiAgICAgICAgICB0b3AgPSBJbmZpbml0eSwgYm90dG9tID0gLUluZmluaXR5O1xuXG4gICAgICAvLyBUT0RPOiBVcGRhdGUgdGhpcyB0byBub3QgX19hbHdheXNfXyB1cGRhdGUuIEp1c3Qgd2hlbiBpdCBuZWVkcyB0by5cbiAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcblxuICAgICAgbWF0cml4ID0gc2hhbGxvdyA/IHRoaXMuX21hdHJpeCA6IGdldENvbXB1dGVkTWF0cml4KHRoaXMpO1xuXG4gICAgICBib3JkZXIgPSAodGhpcy5saW5ld2lkdGggfHwgMCkgLyAyO1xuICAgICAgbCA9IHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgaWYgKGwgPD0gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgdjEgPSB0aGlzLl9yZW5kZXJlci52ZXJ0aWNlc1tpXTtcbiAgICAgICAgLy8gSWYgaSA9IDAsIHRoZW4gdGhpcyBcIndyYXBzIGFyb3VuZFwiIHRvIHRoZSBsYXN0IHZlcnRleC4gT3RoZXJ3aXNlLCBpdCdzIHRoZSBwcmV2aW91cyB2ZXJ0ZXguXG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGZvciBoYW5kbGluZyBjeWNsaWMgcGF0aHMuXG4gICAgICAgIHYwID0gdGhpcy5fcmVuZGVyZXIudmVydGljZXNbKGkgKyBsIC0gMSkgJSBsXTtcblxuICAgICAgICBpZiAodjAuY29udHJvbHMgJiYgdjEuY29udHJvbHMpIHtcblxuICAgICAgICAgIGMweCA9IHYwLmNvbnRyb2xzLnJpZ2h0Lng7XG4gICAgICAgICAgYzB5ID0gdjAuY29udHJvbHMucmlnaHQueTtcblxuICAgICAgICAgIGlmICh2MC5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgYzB4ICs9IHYwLng7XG4gICAgICAgICAgICBjMHkgKz0gdjAueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjMXggPSB2MS5jb250cm9scy5sZWZ0Lng7XG4gICAgICAgICAgYzF5ID0gdjEuY29udHJvbHMubGVmdC55O1xuXG4gICAgICAgICAgaWYgKHYxLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICBjMXggKz0gdjEueDtcbiAgICAgICAgICAgIGMxeSArPSB2MS55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBiYiA9IGdldEN1cnZlQm91bmRpbmdCb3godjAueCwgdjAueSxcbiAgICAgICAgICAgIGMweCwgYzB5LCBjMXgsIGMxeSwgdjEueCwgdjEueSk7XG5cbiAgICAgICAgICB0b3AgPSBtaW4kMShiYi5taW4ueSAtIGJvcmRlciwgdG9wKTtcbiAgICAgICAgICBsZWZ0ID0gbWluJDEoYmIubWluLnggLSBib3JkZXIsIGxlZnQpO1xuICAgICAgICAgIHJpZ2h0ID0gbWF4JDEoYmIubWF4LnggKyBib3JkZXIsIHJpZ2h0KTtcbiAgICAgICAgICBib3R0b20gPSBtYXgkMShiYi5tYXgueSArIGJvcmRlciwgYm90dG9tKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKGkgPD0gMSkge1xuXG4gICAgICAgICAgICB0b3AgPSBtaW4kMSh2MC55IC0gYm9yZGVyLCB0b3ApO1xuICAgICAgICAgICAgbGVmdCA9IG1pbiQxKHYwLnggLSBib3JkZXIsIGxlZnQpO1xuICAgICAgICAgICAgcmlnaHQgPSBtYXgkMSh2MC54ICsgYm9yZGVyLCByaWdodCk7XG4gICAgICAgICAgICBib3R0b20gPSBtYXgkMSh2MC55ICsgYm9yZGVyLCBib3R0b20pO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9wID0gbWluJDEodjEueSAtIGJvcmRlciwgdG9wKTtcbiAgICAgICAgICBsZWZ0ID0gbWluJDEodjEueCAtIGJvcmRlciwgbGVmdCk7XG4gICAgICAgICAgcmlnaHQgPSBtYXgkMSh2MS54ICsgYm9yZGVyLCByaWdodCk7XG4gICAgICAgICAgYm90dG9tID0gbWF4JDEodjEueSArIGJvcmRlciwgYm90dG9tKTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgYSA9IG1hdHJpeC5tdWx0aXBseShsZWZ0LCB0b3AsIDEpO1xuICAgICAgYiA9IG1hdHJpeC5tdWx0aXBseShsZWZ0LCBib3R0b20sIDEpO1xuICAgICAgYyA9IG1hdHJpeC5tdWx0aXBseShyaWdodCwgdG9wLCAxKTtcbiAgICAgIGQgPSBtYXRyaXgubXVsdGlwbHkocmlnaHQsIGJvdHRvbSwgMSk7XG5cbiAgICAgIHRvcCA9IG1pbiQxKGEueSwgYi55LCBjLnksIGQueSk7XG4gICAgICBsZWZ0ID0gbWluJDEoYS54LCBiLngsIGMueCwgZC54KTtcbiAgICAgIHJpZ2h0ID0gbWF4JDEoYS54LCBiLngsIGMueCwgZC54KTtcbiAgICAgIGJvdHRvbSA9IG1heCQxKGEueSwgYi55LCBjLnksIGQueSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNnZXRQb2ludEF0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSB0IC0gUGVyY2VudGFnZSB2YWx1ZSBkZXNjcmliaW5nIHdoZXJlIG9uIHRoZSBUd28uUGF0aCB0byBlc3RpbWF0ZSBhbmQgYXNzaWduIGNvb3JkaW5hdGUgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gW29iaj11bmRlZmluZWRdIC0gT2JqZWN0IHRvIGFwcGx5IGNhbGN1bGF0ZWQgeCwgeSB0by4gSWYgbm9uZSBhdmFpbGFibGUgcmV0dXJucyBuZXcgT2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIEdpdmVuIGEgZmxvYXQgYHRgIGZyb20gMCB0byAxLCByZXR1cm4gYSBwb2ludCBvciBhc3NpZ24gYSBwYXNzZWQgYG9iamAncyBjb29yZGluYXRlcyB0byB0aGF0IHBlcmNlbnRhZ2Ugb24gdGhpcyBUd28uUGF0aCdzIGN1cnZlLlxuICAgICAqL1xuICAgIGdldFBvaW50QXQ6IGZ1bmN0aW9uKHQsIG9iaikge1xuXG4gICAgICB2YXIgaWEsIGliLCByZXN1bHQ7XG4gICAgICB2YXIgeCwgeDEsIHgyLCB4MywgeDQsIHksIHkxLCB5MiwgeTMsIHk0LCBsZWZ0LCByaWdodDtcbiAgICAgIHZhciB0YXJnZXQgPSB0aGlzLmxlbmd0aCAqIE1hdGgubWluKE1hdGgubWF4KHQsIDApLCAxKTtcbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgIHZhciBsYXN0ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgdmFyIGEgPSBudWxsO1xuICAgICAgdmFyIGIgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2xlbmd0aHMubGVuZ3RoLCBzdW0gPSAwOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgICAgaWYgKHN1bSArIHRoaXMuX2xlbmd0aHNbaV0gPj0gdGFyZ2V0KSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICBpYSA9IG1vZChpLCBsZW5ndGgpO1xuICAgICAgICAgICAgaWIgPSBtb2QoaSAtIDEsIGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICBpYSA9IGliO1xuICAgICAgICAgICAgICBpYiA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlhID0gaTtcbiAgICAgICAgICAgIGliID0gTWF0aC5taW4oTWF0aC5tYXgoaSAtIDEsIDApLCBsYXN0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gdGhpcy52ZXJ0aWNlc1tpYV07XG4gICAgICAgICAgYiA9IHRoaXMudmVydGljZXNbaWJdO1xuICAgICAgICAgIHRhcmdldCAtPSBzdW07XG4gICAgICAgICAgaWYgKHRoaXMuX2xlbmd0aHNbaV0gIT09IDApIHtcbiAgICAgICAgICAgIHQgPSB0YXJnZXQgLyB0aGlzLl9sZW5ndGhzW2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICB9XG5cbiAgICAgICAgc3VtICs9IHRoaXMuX2xlbmd0aHNbaV07XG5cbiAgICAgIH1cblxuICAgICAgaWYgKGEgPT09IG51bGwgfHwgYiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfSBlbHNlIGlmICghYikge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cblxuICAgICAgcmlnaHQgPSBiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQ7XG4gICAgICBsZWZ0ID0gYS5jb250cm9scyAmJiBhLmNvbnRyb2xzLmxlZnQ7XG5cbiAgICAgIHgxID0gYi54O1xuICAgICAgeTEgPSBiLnk7XG4gICAgICB4MiA9IChyaWdodCB8fCBiKS54O1xuICAgICAgeTIgPSAocmlnaHQgfHwgYikueTtcbiAgICAgIHgzID0gKGxlZnQgfHwgYSkueDtcbiAgICAgIHkzID0gKGxlZnQgfHwgYSkueTtcbiAgICAgIHg0ID0gYS54O1xuICAgICAgeTQgPSBhLnk7XG5cbiAgICAgIGlmIChyaWdodCAmJiBiLnJlbGF0aXZlKSB7XG4gICAgICAgIHgyICs9IGIueDtcbiAgICAgICAgeTIgKz0gYi55O1xuICAgICAgfVxuXG4gICAgICBpZiAobGVmdCAmJiBhLnJlbGF0aXZlKSB7XG4gICAgICAgIHgzICs9IGEueDtcbiAgICAgICAgeTMgKz0gYS55O1xuICAgICAgfVxuXG4gICAgICB4ID0gZ2V0Q29tcG9uZW50T25DdWJpY0Jlemllcih0LCB4MSwgeDIsIHgzLCB4NCk7XG4gICAgICB5ID0gZ2V0Q29tcG9uZW50T25DdWJpY0Jlemllcih0LCB5MSwgeTIsIHkzLCB5NCk7XG5cbiAgICAgIC8vIEhpZ2hlciBvcmRlciBwb2ludHMgZm9yIGNvbnRyb2wgY2FsY3VsYXRpb24uXG4gICAgICB2YXIgdDF4ID0gbGVycCh4MSwgeDIsIHQpO1xuICAgICAgdmFyIHQxeSA9IGxlcnAoeTEsIHkyLCB0KTtcbiAgICAgIHZhciB0MnggPSBsZXJwKHgyLCB4MywgdCk7XG4gICAgICB2YXIgdDJ5ID0gbGVycCh5MiwgeTMsIHQpO1xuICAgICAgdmFyIHQzeCA9IGxlcnAoeDMsIHg0LCB0KTtcbiAgICAgIHZhciB0M3kgPSBsZXJwKHkzLCB5NCwgdCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcmV0dXJuZWQgcG9pbnRzIGNvbnRyb2wgcG9pbnRzLlxuICAgICAgdmFyIGJyeCA9IGxlcnAodDF4LCB0MngsIHQpO1xuICAgICAgdmFyIGJyeSA9IGxlcnAodDF5LCB0MnksIHQpO1xuICAgICAgdmFyIGFseCA9IGxlcnAodDJ4LCB0M3gsIHQpO1xuICAgICAgdmFyIGFseSA9IGxlcnAodDJ5LCB0M3ksIHQpO1xuXG4gICAgICBpZiAoXy5pc09iamVjdChvYmopKSB7XG5cbiAgICAgICAgb2JqLnggPSB4O1xuICAgICAgICBvYmoueSA9IHk7XG5cbiAgICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iai5jb250cm9scykpIHtcbiAgICAgICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKG9iaik7XG4gICAgICAgIH1cblxuICAgICAgICBvYmouY29udHJvbHMubGVmdC54ID0gYnJ4O1xuICAgICAgICBvYmouY29udHJvbHMubGVmdC55ID0gYnJ5O1xuICAgICAgICBvYmouY29udHJvbHMucmlnaHQueCA9IGFseDtcbiAgICAgICAgb2JqLmNvbnRyb2xzLnJpZ2h0LnkgPSBhbHk7XG5cbiAgICAgICAgaWYgKCF0eXBlb2Ygb2JqLnJlbGF0aXZlID09PSAnYm9vbGVhbicgfHwgb2JqLnJlbGF0aXZlKSB7XG4gICAgICAgICAgb2JqLmNvbnRyb2xzLmxlZnQueCAtPSB4O1xuICAgICAgICAgIG9iai5jb250cm9scy5sZWZ0LnkgLT0geTtcbiAgICAgICAgICBvYmouY29udHJvbHMucmlnaHQueCAtPSB4O1xuICAgICAgICAgIG9iai5jb250cm9scy5yaWdodC55IC09IHk7XG4gICAgICAgIH1cblxuICAgICAgICBvYmoudCA9IHQ7XG5cbiAgICAgICAgcmV0dXJuIG9iajtcblxuICAgICAgfVxuXG4gICAgICByZXN1bHQgPSBuZXcgQW5jaG9yKFxuICAgICAgICB4LCB5LCBicnggLSB4LCBicnkgLSB5LCBhbHggLSB4LCBhbHkgLSB5LFxuICAgICAgICB0aGlzLl9jdXJ2ZWQgPyBDb21tYW5kcy5jdXJ2ZSA6IENvbW1hbmRzLmxpbmVcbiAgICAgICk7XG5cbiAgICAgIHJlc3VsdC50ID0gdDtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNwbG90XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEJhc2VkIG9uIGNsb3NlZCAvIGN1cnZlZCBhbmQgc29ydGluZyBvZiB2ZXJ0aWNlcyBwbG90IHdoZXJlIGFsbCBwb2ludHMgc2hvdWxkIGJlIGFuZCB3aGVyZSB0aGUgcmVzcGVjdGl2ZSBoYW5kbGVzIHNob3VsZCBiZSB0b28uXG4gICAgICogQG5vdGEtYmVuZSBXaGlsZSB0aGlzIG1ldGhvZCBpcyBwdWJsaWMgaXQgaXMgaW50ZXJuYWxseSBjYWxsZWQgYnkge0BsaW5rIFR3by5QYXRoI191cGRhdGV9IHdoZW4gYGF1dG9tYXRpYyA9IHRydWVgLlxuICAgICAqL1xuICAgIHBsb3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5jdXJ2ZWQpIHtcbiAgICAgICAgZ2V0Q3VydmVGcm9tUG9pbnRzKHRoaXMuX2NvbGxlY3Rpb24sIHRoaXMuY2xvc2VkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29sbGVjdGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9jb2xsZWN0aW9uW2ldLmNvbW1hbmQgPSBpID09PSAwID8gQ29tbWFuZHMubW92ZSA6IENvbW1hbmRzLmxpbmU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI3N1YmRpdmlkZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCAtIEhvdyBtYW55IHRpbWVzIHRvIHJlY3Vyc2Ugc3ViZGl2aXNpb25zLlxuICAgICAqIEBkZXNjcmlwdGlvbiBJbnNlcnQgYSB7QGxpbmsgVHdvLkFuY2hvcn0gYXQgdGhlIG1pZHBvaW50IGJldHdlZW4gZXZlcnkgaXRlbSBpbiB7QGxpbmsgVHdvLlBhdGgjdmVydGljZXN9LlxuICAgICAqL1xuICAgIHN1YmRpdmlkZTogZnVuY3Rpb24obGltaXQpIHtcbiAgICAgIC8vVE9ETzogRFJZbmVzcyAoZnVuY3Rpb24gYmVsb3cpXG4gICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgdmFyIGxhc3QgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYiA9IHRoaXMudmVydGljZXNbbGFzdF07XG4gICAgICB2YXIgY2xvc2VkID0gdGhpcy5fY2xvc2VkIHx8IHRoaXMudmVydGljZXNbbGFzdF0uX2NvbW1hbmQgPT09IENvbW1hbmRzLmNsb3NlO1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgXy5lYWNoKHRoaXMudmVydGljZXMsIGZ1bmN0aW9uKGEsIGkpIHtcblxuICAgICAgICBpZiAoaSA8PSAwICYmICFjbG9zZWQpIHtcbiAgICAgICAgICBiID0gYTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYS5jb21tYW5kID09PSBDb21tYW5kcy5tb3ZlKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcihiLngsIGIueSkpO1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZlcnRzID0gZ2V0U3ViZGl2aXNpb25zKGEsIGIsIGxpbWl0KTtcbiAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdCh2ZXJ0cyk7XG5cbiAgICAgICAgLy8gQXNzaWduIGNvbW1hbmRzIHRvIGFsbCB0aGUgdmVydHNcbiAgICAgICAgXy5lYWNoKHZlcnRzLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICAgICAgaWYgKGkgPD0gMCAmJiBiLmNvbW1hbmQgPT09IENvbW1hbmRzLm1vdmUpIHtcbiAgICAgICAgICAgIHYuY29tbWFuZCA9IENvbW1hbmRzLm1vdmU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHYuY29tbWFuZCA9IENvbW1hbmRzLmxpbmU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoaSA+PSBsYXN0KSB7XG5cbiAgICAgICAgICAvLyBUT0RPOiBBZGQgY2hlY2sgaWYgdGhlIHR3byB2ZWN0b3JzIGluIHF1ZXN0aW9uIGFyZSB0aGUgc2FtZSB2YWx1ZXMuXG4gICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCAmJiB0aGlzLl9hdXRvbWF0aWMpIHtcblxuICAgICAgICAgICAgYiA9IGE7XG5cbiAgICAgICAgICAgIHZlcnRzID0gZ2V0U3ViZGl2aXNpb25zKGEsIGIsIGxpbWl0KTtcbiAgICAgICAgICAgIHBvaW50cyA9IHBvaW50cy5jb25jYXQodmVydHMpO1xuXG4gICAgICAgICAgICAvLyBBc3NpZ24gY29tbWFuZHMgdG8gYWxsIHRoZSB2ZXJ0c1xuICAgICAgICAgICAgXy5lYWNoKHZlcnRzLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICAgICAgICAgIGlmIChpIDw9IDAgJiYgYi5jb21tYW5kID09PSBDb21tYW5kcy5tb3ZlKSB7XG4gICAgICAgICAgICAgICAgdi5jb21tYW5kID0gQ29tbWFuZHMubW92ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2LmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xvc2VkKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChuZXcgQW5jaG9yKGEueCwgYS55KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5jb21tYW5kID0gY2xvc2VkXG4gICAgICAgICAgICA/IENvbW1hbmRzLmNsb3NlIDogQ29tbWFuZHMubGluZTtcblxuICAgICAgICB9XG5cbiAgICAgICAgYiA9IGE7XG5cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICB0aGlzLl9hdXRvbWF0aWMgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2N1cnZlZCA9IGZhbHNlO1xuICAgICAgdGhpcy52ZXJ0aWNlcyA9IHBvaW50cztcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX3VwZGF0ZUxlbmd0aFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdD1dIC1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIC0gSWYgc2V0IHRvIGB0cnVlYCB0aGVuIHRoZSBwYXRoIGlzbid0IHVwZGF0ZWQgYmVmb3JlIGNhbGN1bGF0aW9uLiBVc2VmdWwgZm9yIGludGVybmFsIHVzZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVjYWxjdWxhdGUgdGhlIHtAbGluayBUd28uUGF0aCNsZW5ndGh9IHZhbHVlLlxuICAgICAqL1xuICAgIF91cGRhdGVMZW5ndGg6IGZ1bmN0aW9uKGxpbWl0LCBzaWxlbnQpIHtcbiAgICAgIC8vVE9ETzogRFJZbmVzcyAoZnVuY3Rpb24gYWJvdmUpXG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuICAgICAgdmFyIGIgPSB0aGlzLnZlcnRpY2VzW2xhc3RdO1xuICAgICAgdmFyIGNsb3NlZCA9IGZhbHNlOy8vdGhpcy5fY2xvc2VkIHx8IHRoaXMudmVydGljZXNbbGFzdF0uX2NvbW1hbmQgPT09IENvbW1hbmRzLmNsb3NlO1xuICAgICAgdmFyIHN1bSA9IDA7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fbGVuZ3RocyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RocyA9IFtdO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2godGhpcy52ZXJ0aWNlcywgZnVuY3Rpb24oYSwgaSkge1xuXG4gICAgICAgIGlmICgoaSA8PSAwICYmICFjbG9zZWQpIHx8IGEuY29tbWFuZCA9PT0gQ29tbWFuZHMubW92ZSkge1xuICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgIHRoaXMuX2xlbmd0aHNbaV0gPSAwO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xlbmd0aHNbaV0gPSBnZXRDdXJ2ZUxlbmd0aChhLCBiLCBsaW1pdCk7XG4gICAgICAgIHN1bSArPSB0aGlzLl9sZW5ndGhzW2ldO1xuXG4gICAgICAgIGlmIChpID49IGxhc3QgJiYgY2xvc2VkKSB7XG5cbiAgICAgICAgICBiID0gdGhpcy52ZXJ0aWNlc1soaSArIDEpICUgbGVuZ3RoXTtcblxuICAgICAgICAgIHRoaXMuX2xlbmd0aHNbaSArIDFdID0gZ2V0Q3VydmVMZW5ndGgoYSwgYiwgbGltaXQpO1xuICAgICAgICAgIHN1bSArPSB0aGlzLl9sZW5ndGhzW2kgKyAxXTtcblxuICAgICAgICB9XG5cbiAgICAgICAgYiA9IGE7XG5cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICB0aGlzLl9sZW5ndGggPSBzdW07XG4gICAgICB0aGlzLl9mbGFnTGVuZ3RoID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcykge1xuXG4gICAgICAgIGlmICh0aGlzLl9hdXRvbWF0aWMpIHtcbiAgICAgICAgICB0aGlzLnBsb3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlTGVuZ3RoKHVuZGVmaW5lZCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbCA9IHRoaXMuX2NvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICB2YXIgY2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuXG4gICAgICAgIHZhciBiZWdpbm5pbmcgPSBNYXRoLm1pbih0aGlzLl9iZWdpbm5pbmcsIHRoaXMuX2VuZGluZyk7XG4gICAgICAgIHZhciBlbmRpbmcgPSBNYXRoLm1heCh0aGlzLl9iZWdpbm5pbmcsIHRoaXMuX2VuZGluZyk7XG5cbiAgICAgICAgdmFyIGJpZCA9IGdldElkQnlMZW5ndGgodGhpcywgYmVnaW5uaW5nICogdGhpcy5fbGVuZ3RoKTtcbiAgICAgICAgdmFyIGVpZCA9IGdldElkQnlMZW5ndGgodGhpcywgZW5kaW5nICogdGhpcy5fbGVuZ3RoKTtcblxuICAgICAgICB2YXIgbG93ID0gY2VpbChiaWQpO1xuICAgICAgICB2YXIgaGlnaCA9IGZsb29yKGVpZCk7XG5cbiAgICAgICAgdmFyIGxlZnQsIHJpZ2h0LCBwcmV2LCBuZXh0LCB2O1xuXG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uLmxlbmd0aCA8PSBpKSB7XG4gICAgICAgICAgICAvLyBFeHBlY3RlZCB0byBiZSBgcmVsYXRpdmVgIGFuY2hvciBwb2ludHMuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uLnB1c2gobmV3IEFuY2hvcigpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA+IGhpZ2ggJiYgIXJpZ2h0KSB7XG5cbiAgICAgICAgICAgIHYgPSB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uW2ldO1xuICAgICAgICAgICAgdi5jb3B5KHRoaXMuX2NvbGxlY3Rpb25baV0pO1xuICAgICAgICAgICAgdGhpcy5nZXRQb2ludEF0KGVuZGluZywgdik7XG4gICAgICAgICAgICB2LmNvbW1hbmQgPSB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uW2ldLmNvbW1hbmQ7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci52ZXJ0aWNlcy5wdXNoKHYpO1xuXG4gICAgICAgICAgICByaWdodCA9IHY7XG4gICAgICAgICAgICBwcmV2ID0gdGhpcy5fY29sbGVjdGlvbltpIC0gMV07XG5cbiAgICAgICAgICAgIC8vIFByb2plY3QgY29udHJvbCBvdmVyIHRoZSBwZXJjZW50YWdlIGB0YFxuICAgICAgICAgICAgLy8gb2YgdGhlIGluLWJldHdlZW4gcG9pbnRcbiAgICAgICAgICAgIGlmIChwcmV2ICYmIHByZXYuY29udHJvbHMpIHtcblxuICAgICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuY29sbGVjdGlvbltpIC0gMV0uY29udHJvbHMucmlnaHRcbiAgICAgICAgICAgICAgICAuY2xlYXIoKVxuICAgICAgICAgICAgICAgIC5sZXJwKHByZXYuY29udHJvbHMucmlnaHQsIHYudCk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaSA+PSBsb3cgJiYgaSA8PSBoaWdoKSB7XG5cbiAgICAgICAgICAgIHYgPSB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uW2ldXG4gICAgICAgICAgICAgIC5jb3B5KHRoaXMuX2NvbGxlY3Rpb25baV0pO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIudmVydGljZXMucHVzaCh2KTtcblxuICAgICAgICAgICAgaWYgKGkgPT09IGhpZ2ggJiYgY29udGFpbnModGhpcywgZW5kaW5nKSkge1xuICAgICAgICAgICAgICByaWdodCA9IHY7XG4gICAgICAgICAgICAgIGlmICghY2xvc2VkICYmIHJpZ2h0LmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgcmlnaHQuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBsb3cgJiYgY29udGFpbnModGhpcywgYmVnaW5uaW5nKSkge1xuICAgICAgICAgICAgICBsZWZ0ID0gdjtcbiAgICAgICAgICAgICAgbGVmdC5jb21tYW5kID0gQ29tbWFuZHMubW92ZTtcbiAgICAgICAgICAgICAgaWYgKCFjbG9zZWQgJiYgbGVmdC5jb250cm9scykge1xuICAgICAgICAgICAgICAgIGxlZnQuY29udHJvbHMubGVmdC5jbGVhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFByZXBlbmQgdGhlIHRyaW1tZWQgcG9pbnQgaWYgbmVjZXNzYXJ5LlxuICAgICAgICBpZiAobG93ID4gMCAmJiAhbGVmdCkge1xuXG4gICAgICAgICAgaSA9IGxvdyAtIDE7XG5cbiAgICAgICAgICB2ID0gdGhpcy5fcmVuZGVyZXIuY29sbGVjdGlvbltpXTtcbiAgICAgICAgICB2LmNvcHkodGhpcy5fY29sbGVjdGlvbltpXSk7XG4gICAgICAgICAgdGhpcy5nZXRQb2ludEF0KGJlZ2lubmluZywgdik7XG4gICAgICAgICAgdi5jb21tYW5kID0gQ29tbWFuZHMubW92ZTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci52ZXJ0aWNlcy51bnNoaWZ0KHYpO1xuXG4gICAgICAgICAgbGVmdCA9IHY7XG4gICAgICAgICAgbmV4dCA9IHRoaXMuX2NvbGxlY3Rpb25baSArIDFdO1xuXG4gICAgICAgICAgLy8gUHJvamVjdCBjb250cm9sIG92ZXIgdGhlIHBlcmNlbnRhZ2UgYHRgXG4gICAgICAgICAgLy8gb2YgdGhlIGluLWJldHdlZW4gcG9pbnRcbiAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0LmNvbnRyb2xzKSB7XG5cbiAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uW2kgKyAxXS5jb250cm9scy5sZWZ0XG4gICAgICAgICAgICAgIC5jb3B5KG5leHQuY29udHJvbHMubGVmdClcbiAgICAgICAgICAgICAgLmxlcnAoVmVjdG9yLnplcm8sIHYudCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIFNoYXBlLnByb3RvdHlwZS5fdXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1ZlcnRpY2VzID0gIHRoaXMuX2ZsYWdGaWxsID0gIHRoaXMuX2ZsYWdTdHJva2UgPVxuICAgICAgICAgIHRoaXMuX2ZsYWdMaW5ld2lkdGggPSB0aGlzLl9mbGFnT3BhY2l0eSA9IHRoaXMuX2ZsYWdWaXNpYmxlID1cbiAgICAgICAgICB0aGlzLl9mbGFnQ2FwID0gdGhpcy5fZmxhZ0pvaW4gPSB0aGlzLl9mbGFnTWl0ZXIgPVxuICAgICAgICAgIHRoaXMuX2ZsYWdDbGlwID0gZmFsc2U7XG5cbiAgICAgIFNoYXBlLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgUGF0aC5NYWtlT2JzZXJ2YWJsZShQYXRoLnByb3RvdHlwZSk7XG5cbiAgICAvLyBVdGlsaXR5IGZ1bmN0aW9uc1xuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHBhdGgsIHQpIHtcblxuICAgIGlmICh0ID09PSAwIHx8IHQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBsZW5ndGggPSBwYXRoLl9sZW5ndGg7XG4gICAgdmFyIHRhcmdldCA9IGxlbmd0aCAqIHQ7XG4gICAgdmFyIGVsYXBzZWQgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLl9sZW5ndGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlzdCA9IHBhdGguX2xlbmd0aHNbaV07XG4gICAgICBpZiAoZWxhcHNlZCA+PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldCAtIGVsYXBzZWQgPj0gMDtcbiAgICAgIH1cbiAgICAgIGVsYXBzZWQgKz0gZGlzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1R3by5QYXRofSBwYXRoIC0gVGhlIHBhdGggdG8gYW5hbHl6ZSBhZ2FpbnN0LlxuICAgKiBAcGFyYW0ge051bWJlcn0gdGFyZ2V0IC0gVGhlIHRhcmdldCBsZW5ndGggYXQgd2hpY2ggdG8gZmluZCBhbiBhbmNob3IuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gdGhlIGlkIG9mIGFuIGFuY2hvciBiYXNlZCBvbiBhIHRhcmdldCBsZW5ndGguXG4gICAqL1xuICBmdW5jdGlvbiBnZXRJZEJ5TGVuZ3RoKHBhdGgsIHRhcmdldCkge1xuXG4gICAgdmFyIHRvdGFsID0gcGF0aC5fbGVuZ3RoO1xuXG4gICAgaWYgKHRhcmdldCA8PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKHRhcmdldCA+PSB0b3RhbCkge1xuICAgICAgcmV0dXJuIHBhdGguX2xlbmd0aHMubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc3VtID0gMDsgaSA8IHBhdGguX2xlbmd0aHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgaWYgKHN1bSArIHBhdGguX2xlbmd0aHNbaV0gPj0gdGFyZ2V0KSB7XG4gICAgICAgIHRhcmdldCAtPSBzdW07XG4gICAgICAgIHJldHVybiBNYXRoLm1heChpIC0gMSwgMCkgKyB0YXJnZXQgLyBwYXRoLl9sZW5ndGhzW2ldO1xuICAgICAgfVxuXG4gICAgICBzdW0gKz0gcGF0aC5fbGVuZ3Roc1tpXTtcblxuICAgIH1cblxuICAgIHJldHVybiAtIDE7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEN1cnZlTGVuZ3RoKGEsIGIsIGxpbWl0KSB7XG4gICAgLy8gVE9ETzogRFJZbmVzc1xuICAgIHZhciB4MSwgeDIsIHgzLCB4NCwgeTEsIHkyLCB5MywgeTQ7XG5cbiAgICB2YXIgcmlnaHQgPSBiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQ7XG4gICAgdmFyIGxlZnQgPSBhLmNvbnRyb2xzICYmIGEuY29udHJvbHMubGVmdDtcblxuICAgIHgxID0gYi54O1xuICAgIHkxID0gYi55O1xuICAgIHgyID0gKHJpZ2h0IHx8IGIpLng7XG4gICAgeTIgPSAocmlnaHQgfHwgYikueTtcbiAgICB4MyA9IChsZWZ0IHx8IGEpLng7XG4gICAgeTMgPSAobGVmdCB8fCBhKS55O1xuICAgIHg0ID0gYS54O1xuICAgIHk0ID0gYS55O1xuXG4gICAgaWYgKHJpZ2h0ICYmIGIuX3JlbGF0aXZlKSB7XG4gICAgICB4MiArPSBiLng7XG4gICAgICB5MiArPSBiLnk7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQgJiYgYS5fcmVsYXRpdmUpIHtcbiAgICAgIHgzICs9IGEueDtcbiAgICAgIHkzICs9IGEueTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0Q3VydmVMZW5ndGgkMSh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGxpbWl0KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0U3ViZGl2aXNpb25zKGEsIGIsIGxpbWl0KSB7XG4gICAgLy8gVE9ETzogRFJZbmVzc1xuICAgIHZhciB4MSwgeDIsIHgzLCB4NCwgeTEsIHkyLCB5MywgeTQ7XG5cbiAgICB2YXIgcmlnaHQgPSBiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQ7XG4gICAgdmFyIGxlZnQgPSBhLmNvbnRyb2xzICYmIGEuY29udHJvbHMubGVmdDtcblxuICAgIHgxID0gYi54O1xuICAgIHkxID0gYi55O1xuICAgIHgyID0gKHJpZ2h0IHx8IGIpLng7XG4gICAgeTIgPSAocmlnaHQgfHwgYikueTtcbiAgICB4MyA9IChsZWZ0IHx8IGEpLng7XG4gICAgeTMgPSAobGVmdCB8fCBhKS55O1xuICAgIHg0ID0gYS54O1xuICAgIHk0ID0gYS55O1xuXG4gICAgaWYgKHJpZ2h0ICYmIGIuX3JlbGF0aXZlKSB7XG4gICAgICB4MiArPSBiLng7XG4gICAgICB5MiArPSBiLnk7XG4gICAgfVxuXG4gICAgaWYgKGxlZnQgJiYgYS5fcmVsYXRpdmUpIHtcbiAgICAgIHgzICs9IGEueDtcbiAgICAgIHkzICs9IGEueTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3ViZGl2aWRlKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGltaXQpO1xuXG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgVHdvLlJlY3RhbmdsZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt3aWR0aF0gLSBUaGUgd2lkdGggdmFsdWUgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHRdIC0gVGhlIHdpZHRoIHZhbHVlIG9mIHRoZSByZWN0YW5nbGUuXG4gICAqL1xuICBmdW5jdGlvbiBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgUGF0aC5jYWxsKHRoaXMsIFtcbiAgICAgIG5ldyBBbmNob3IoKSxcbiAgICAgIG5ldyBBbmNob3IoKSxcbiAgICAgIG5ldyBBbmNob3IoKSxcbiAgICAgIG5ldyBBbmNob3IoKVxuICAgICAgLy8gbmV3IEFuY2hvcigpIC8vIFRPRE86IEZpZ3VyZSBvdXQgaG93IHRvIGhhbmRsZSB0aGlzIGZvciBgYmVnaW5uaW5nYCAvIGBlbmRpbmdgIGFuaW1hdGlvbnNcbiAgICBdLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI3dpZHRoXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIHdpZHRoIG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICovXG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjaGVpZ2h0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNvcmlnaW5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBIHR3by1jb21wb25lbnQgdmVjdG9yIGRlc2NyaWJpbmcgdGhlIG9yaWdpbiBvZmZzZXQgdG8gZHJhdyB0aGUgcmVjdGFuZ2xlLiBEZWZhdWx0IGlzIGAwLCAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG5ldyBWZWN0b3IoKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldCh4LCB5KTtcblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gIH1cblxuICBfLmV4dGVuZChSZWN0YW5nbGUsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUuUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5SZWN0YW5nbGV9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFsnd2lkdGgnLCAnaGVpZ2h0J10sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uUmVjdGFuZ2xlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5SZWN0YW5nbGV9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgUGF0aC5NYWtlT2JzZXJ2YWJsZShvYmplY3QpO1xuICAgICAgXy5lYWNoKFJlY3RhbmdsZS5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iamVjdCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdvcmlnaW4nLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX29yaWdpbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX29yaWdpbikge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2luLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9vcmlnaW4gPSB2O1xuICAgICAgICAgIHRoaXMuX29yaWdpbi5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdWZXJ0aWNlcyk7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFJlY3RhbmdsZS5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUmVjdGFuZ2xlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNfZmxhZ1dpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJlY3RhbmdsZSN3aWR0aH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdXaWR0aDogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI19mbGFnSGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJlY3RhbmdsZSNoZWlnaHR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSGVpZ2h0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNfd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5SZWN0YW5nbGUjd2lkdGh9XG4gICAgICovXG4gICAgX3dpZHRoOiAwLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjX2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlJlY3RhbmdsZSNoZWlnaHR9XG4gICAgICovXG4gICAgX2hlaWdodDogMCxcblxuICAgIF9vcmlnaW46IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcyB8fCB0aGlzLl9mbGFnV2lkdGggfHwgdGhpcy5fZmxhZ0hlaWdodCkge1xuXG4gICAgICAgIHZhciB4ciA9IHRoaXMuX3dpZHRoIC8gMjtcbiAgICAgICAgdmFyIHlyID0gdGhpcy5faGVpZ2h0IC8gMjtcblxuICAgICAgICBpZiAoIXRoaXMuX2Nsb3NlZCAmJiB0aGlzLnZlcnRpY2VzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgICAgIHRoaXMudmVydGljZXMucHVzaChuZXcgQW5jaG9yKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52ZXJ0aWNlc1swXS5zZXQoLXhyLCAteXIpLmFkZCh0aGlzLl9vcmlnaW4pLmNvbW1hbmQgPSBDb21tYW5kcy5tb3ZlO1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzFdLnNldCh4ciwgLXlyKS5hZGQodGhpcy5fb3JpZ2luKS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1syXS5zZXQoeHIsIHlyKS5hZGQodGhpcy5fb3JpZ2luKS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcbiAgICAgICAgdGhpcy52ZXJ0aWNlc1szXS5zZXQoLXhyLCB5cikuYWRkKHRoaXMuX29yaWdpbikuY29tbWFuZCA9IENvbW1hbmRzLmxpbmU7XG4gICAgICAgIC8vIEZZSTogVHdvLlNwcml0ZSBhbmQgVHdvLkltYWdlU2VxdWVuY2UgaGF2ZSA0IHZlcnRzXG4gICAgICAgIGlmICh0aGlzLnZlcnRpY2VzWzRdKSB7XG4gICAgICAgICAgdGhpcy52ZXJ0aWNlc1s0XS5zZXQoLXhyLCAteXIpLmFkZCh0aGlzLl9vcmlnaW4pLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1dpZHRoID0gdGhpcy5fZmxhZ0hlaWdodCA9IGZhbHNlO1xuICAgICAgUGF0aC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5SZWN0YW5nbGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlJlY3RhbmdsZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIGNsb25lLnNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIGNsb25lLnNrZXdZID0gdGhpcy5za2V3WTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaChQYXRoLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gUGF0aC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcbiAgICAgIG9iamVjdC53aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICBvYmplY3QuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICBvYmplY3Qub3JpZ2luID0gdGhpcy5vcmlnaW4udG9PYmplY3QoKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgUmVjdGFuZ2xlLk1ha2VPYnNlcnZhYmxlKFJlY3RhbmdsZS5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uU3ByaXRlXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uUmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB7U3RyaW5nfFR3by5UZXh0dXJlfSBbcGF0aF0gLSBUaGUgVVJMIHBhdGggb3Ige0BsaW5rIFR3by5UZXh0dXJlfSB0byBiZSB1c2VkIGFzIHRoZSBiaXRtYXAgZGF0YSBkaXNwbGF5ZWQgb24gdGhlIHNwcml0ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtveD0wXSAtIFRoZSBpbml0aWFsIGB4YCBwb3NpdGlvbiBvZiB0aGUgVHdvLlNwcml0ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtveT0wXSAtIFRoZSBpbml0aWFsIGB5YCBwb3NpdGlvbiBvZiB0aGUgVHdvLlNwcml0ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2xzPTFdIC0gVGhlIG51bWJlciBvZiBjb2x1bW5zIHRoZSBzcHJpdGUgY29udGFpbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcm93cz0xXSAtIFRoZSBudW1iZXIgb2Ygcm93cyB0aGUgc3ByaXRlIGNvbnRhaW5zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyYW1lUmF0ZT0wXSAtIFRoZSBmcmFtZSByYXRlIGF0IHdoaWNoIHRoZSBwYXJ0aXRpb25zIG9mIHRoZSBpbWFnZSBzaG91bGQgcGxheWJhY2sgYXQuXG4gICAqIEBkZXNjcmlwdGlvbiBBIGNvbnZlbmllbnQgcGFja2FnZSB0byBkaXNwbGF5IHN0aWxsIG9yIGFuaW1hdGVkIGltYWdlcyB0aHJvdWdoIGEgdGlsZWQgaW1hZ2Ugc291cmNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgcHJpbmNpcGFscyBvZiBhbmltYXRlZCBpbWFnZXJ5IHRocm91Z2ggdGlsaW5nIHNlZSBbVGV4dHVyZSBBdGxhc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVGV4dHVyZV9hdGxhcykgb24gV2lraXBlZGlhLlxuICAgKi9cbiAgZnVuY3Rpb24gU3ByaXRlKHBhdGgsIG94LCBveSwgY29scywgcm93cywgZnJhbWVSYXRlKSB7XG5cbiAgICAvLyBOb3QgdXNpbmcgZGVmYXVsdCBjb25zdHJ1Y3RvciBvZiBSZWN0YW5nbGUgZHVlIHRvIG9kZCBgYmVnaW5uaW5nYCAvIGBlbmRpbmdgIGJlaGF2aW9yLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjEvdHdvLmpzL2lzc3Vlcy8zODNcbiAgICBQYXRoLmNhbGwodGhpcywgW1xuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpXG4gICAgXSwgdHJ1ZSk7XG5cbiAgICB0aGlzLm5vU3Ryb2tlKCk7XG4gICAgdGhpcy5ub0ZpbGwoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjdGV4dHVyZVxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlRleHR1cmV9IC0gVGhlIHRleHR1cmUgdG8gYmUgdXNlZCBhcyBiaXRtYXAgZGF0YSB0byBkaXNwbGF5IGltYWdlIGluIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgIHRoaXMudGV4dHVyZSA9IHBhdGg7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKHBhdGgpO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ2luID0gbmV3IFZlY3RvcigpO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgdGhpcy50cmFuc2xhdGlvbi5zZXQob3ggfHwgMCwgb3kgfHwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI2NvbHVtbnNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdG8gc3BsaXQgdGhlIHRleHR1cmUgaW50by4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgY29scyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNyb3dzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIG51bWJlciBvZiByb3dzIHRvIHNwbGl0IHRoZSB0ZXh0dXJlIGludG8uIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHJvd3MgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjZnJhbWVSYXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIG51bWJlciBvZiBmcmFtZXMgdG8gYW5pbWF0ZSBhZ2FpbnN0IHBlciBzZWNvbmQuIERlZmF1bHRzIHRvIGAwYCBmb3Igbm9uLWFuaW1hdGVkIHNwcml0ZXMuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBmcmFtZVJhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmZyYW1lUmF0ZSA9IGZyYW1lUmF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI2luZGV4XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHRpbGUgb2YgdGhlIHNwcml0ZSB0byBkaXNwbGF5LiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IDA7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFNwcml0ZSwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZS5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlNwcml0ZX0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogW1xuICAgICAgJ3RleHR1cmUnLCAnY29sdW1ucycsICdyb3dzJywgJ2ZyYW1lUmF0ZScsICdpbmRleCdcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZS5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlNwcml0ZX0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgb3IgaW5oZXJpdCB0aGUge0BsaW5rIFR3by5TcHJpdGV9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmopIHtcblxuICAgICAgUmVjdGFuZ2xlLk1ha2VPYnNlcnZhYmxlKG9iaik7XG4gICAgICBfLmVhY2goU3ByaXRlLlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqKTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChTcHJpdGUucHJvdG90eXBlLCBSZWN0YW5nbGUucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU3ByaXRlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmxhZ1RleHR1cmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlI3RleHR1cmV9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnVGV4dHVyZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19mbGFnQ29sdW1uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TcHJpdGUjY29sdW1uc30gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0NvbHVtbnM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmxhZ1Jvd3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlI3Jvd3N9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdSb3dzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2ZsYWdGcmFtZVJhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlI2ZsYWdGcmFtZVJhdGV9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnRnJhbWVSYXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2ZsYWdJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TcHJpdGUjaW5kZXh9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIGZsYWdJbmRleDogZmFsc2UsXG5cbiAgICAvLyBQcml2YXRlIHZhcmlhYmxlc1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfYW1vdW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgb2YgZnJhbWVzIGZvciBhIGdpdmVuIHtAbGluayBUd28uU3ByaXRlfS5cbiAgICAgKi9cbiAgICBfYW1vdW50OiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZHVyYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYSB7QGxpbmsgVHdvLlNwcml0ZX0uXG4gICAgICovXG4gICAgX2R1cmF0aW9uOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfc3RhcnRUaW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge01pbGxpc2Vjb25kc30gLSBFcG9jaCB0aW1lIGluIG1pbGxpc2Vjb25kcyBvZiB3aGVuIHRoZSB7QGxpbmsgVHdvLlNwcml0ZX0gc3RhcnRlZC5cbiAgICAgKi9cbiAgICBfc3RhcnRUaW1lOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfcGxheWluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpY3RhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlfSBpcyBhbmltYXRpbmcgb3Igbm90LlxuICAgICAqL1xuICAgIF9wbGF5aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2ZpcnN0RnJhbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBmcmFtZSB0aGUge0BsaW5rIFR3by5TcHJpdGV9IHNob3VsZCBzdGFydCB3aXRoLlxuICAgICAqL1xuICAgIF9maXJzdEZyYW1lOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfbGFzdEZyYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgZnJhbWUgdGhlIHtAbGluayBUd28uU3ByaXRlfSBzaG91bGQgZW5kIHdpdGguXG4gICAgICovXG4gICAgX2xhc3RGcmFtZTogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX3BsYXlpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEaWN0YXRlcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlNwcml0ZX0gc2hvdWxkIGxvb3Agb3Igbm90LlxuICAgICAqL1xuICAgIF9sb29wOiB0cnVlLFxuXG4gICAgLy8gRXhwb3NlZCB0aHJvdWdoIGdldHRlci1zZXR0ZXJcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX3RleHR1cmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TcHJpdGUjdGV4dHVyZX1cbiAgICAgKi9cbiAgICBfdGV4dHVyZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2NvbHVtbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TcHJpdGUjY29sdW1uc31cbiAgICAgKi9cbiAgICBfY29sdW1uczogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX3Jvd3NcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TcHJpdGUjcm93c31cbiAgICAgKi9cbiAgICBfcm93czogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2ZyYW1lUmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlNwcml0ZSNmcmFtZVJhdGV9XG4gICAgICovXG4gICAgX2ZyYW1lUmF0ZTogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2luZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgY3VycmVudCBmcmFtZSB0aGUge0BsaW5rIFR3by5TcHJpdGV9IGlzIGN1cnJlbnRseSBkaXNwbGF5aW5nLlxuICAgICAqL1xuICAgIF9pbmRleDogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX29yaWdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlNwcml0ZSNvcmlnaW59XG4gICAgICovXG4gICAgX29yaWdpbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjcGxheVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZmlyc3RGcmFtZT0wXSAtIFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdG8gc3RhcnQgdGhlIGFuaW1hdGlvbiB3aXRoLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbbGFzdEZyYW1lXSAtIFRoZSBpbmRleCBvZiB0aGUgZnJhbWUgdG8gZW5kIHRoZSBhbmltYXRpb24gd2l0aC4gRGVmYXVsdHMgdG8gdGhlIGxhc3QgaXRlbSBpbiB0aGUge0BsaW5rIFR3by5TcHJpdGUjdGV4dHVyZXN9LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkxhc3RGcmFtZV0gLSBPcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSB0cmlnZ2VyZWQgYWZ0ZXIgcGxheWluZyB0aGUgbGFzdCBmcmFtZS4gVGhpcyBmaXJlcyBtdWx0aXBsZSB0aW1lcyB3aGVuIHRoZSBzcHJpdGUgaXMgbG9vcGVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBJbml0aWF0ZSBhbmltYXRpb24gcGxheWJhY2sgb2YgYSB7QGxpbmsgVHdvLlNwcml0ZX0uXG4gICAgICovXG4gICAgcGxheTogZnVuY3Rpb24oZmlyc3RGcmFtZSwgbGFzdEZyYW1lLCBvbkxhc3RGcmFtZSkge1xuXG4gICAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhbWUgPSAwO1xuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5hbW91bnQgLSAxO1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gXy5wZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgaWYgKHR5cGVvZiBmaXJzdEZyYW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLl9maXJzdEZyYW1lID0gZmlyc3RGcmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGFzdEZyYW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBsYXN0RnJhbWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9uTGFzdEZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX29uTGFzdEZyYW1lID0gb25MYXN0RnJhbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5fb25MYXN0RnJhbWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbmRleCAhPT0gdGhpcy5fZmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgLT0gMTAwMCAqIE1hdGguYWJzKHRoaXMuX2luZGV4IC0gdGhpcy5fZmlyc3RGcmFtZSlcbiAgICAgICAgICAvIHRoaXMuX2ZyYW1lUmF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNwYXVzZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBIYWx0IGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uU3ByaXRlfS5cbiAgICAgKi9cbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjc3RvcFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBIYWx0IGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uU3ByaXRlfSBhbmQgc2V0IHRoZSBjdXJyZW50IGZyYW1lIGJhY2sgdG8gdGhlIGZpcnN0IGZyYW1lLlxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbmRleCA9IDA7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5TcHJpdGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlNwcml0ZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHNwcml0ZS5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBTcHJpdGUoXG4gICAgICAgIHRoaXMudGV4dHVyZSwgdGhpcy50cmFuc2xhdGlvbi54LCB0aGlzLnRyYW5zbGF0aW9uLnksXG4gICAgICAgIHRoaXMuY29sdW1ucywgdGhpcy5yb3dzLCB0aGlzLmZyYW1lUmF0ZVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMucGxheWluZykge1xuICAgICAgICBjbG9uZS5wbGF5KHRoaXMuX2ZpcnN0RnJhbWUsIHRoaXMuX2xhc3RGcmFtZSk7XG4gICAgICAgIGNsb25lLl9sb29wID0gdGhpcy5fbG9vcDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gUmVjdGFuZ2xlLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgb2JqZWN0LnRleHR1cmUgPSB0aGlzLnRleHR1cmUudG9PYmplY3QoKTtcbiAgICAgIG9iamVjdC5jb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuICAgICAgb2JqZWN0LnJvd3MgPSB0aGlzLnJvd3M7XG4gICAgICBvYmplY3QuZnJhbWVSYXRlID0gdGhpcy5mcmFtZVJhdGU7XG4gICAgICBvYmplY3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgb2JqZWN0Ll9maXJzdEZyYW1lID0gdGhpcy5fZmlyc3RGcmFtZTtcbiAgICAgIG9iamVjdC5fbGFzdEZyYW1lID0gdGhpcy5fbGFzdEZyYW1lO1xuICAgICAgb2JqZWN0Ll9sb29wID0gdGhpcy5fbG9vcDtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgZWZmZWN0ID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgIHZhciBjb2xzID0gdGhpcy5fY29sdW1ucztcbiAgICAgIHZhciByb3dzID0gdGhpcy5fcm93cztcblxuICAgICAgdmFyIHdpZHRoLCBoZWlnaHQsIGVsYXBzZWQsIGFtb3VudCwgZHVyYXRpb247XG4gICAgICB2YXIgaW5kZXgsIGl3LCBpaCwgZnJhbWVzO1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ0NvbHVtbnMgfHwgdGhpcy5fZmxhZ1Jvd3MpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gdGhpcy5fY29sdW1ucyAqIHRoaXMuX3Jvd3M7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnRnJhbWVSYXRlKSB7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMCAqIHRoaXMuX2Ftb3VudCAvIHRoaXMuX2ZyYW1lUmF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ZsYWdUZXh0dXJlKSB7XG4gICAgICAgIHRoaXMuZmlsbCA9IHRoaXMuX3RleHR1cmU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl90ZXh0dXJlLmxvYWRlZCkge1xuXG4gICAgICAgIGl3ID0gZWZmZWN0LmltYWdlLndpZHRoO1xuICAgICAgICBpaCA9IGVmZmVjdC5pbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgd2lkdGggPSBpdyAvIGNvbHM7XG4gICAgICAgIGhlaWdodCA9IGloIC8gcm93cztcbiAgICAgICAgYW1vdW50ID0gdGhpcy5fYW1vdW50O1xuXG4gICAgICAgIGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3BsYXlpbmcgJiYgdGhpcy5fZnJhbWVSYXRlID4gMCkge1xuXG4gICAgICAgICAgaWYgKF8uaXNOYU4odGhpcy5fbGFzdEZyYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gYW1vdW50IC0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBPZmZsb2FkIHBlcmYgbG9naWMgdG8gaW5zdGFuY2Ugb2YgYFR3b2AuXG4gICAgICAgICAgZWxhcHNlZCA9IF8ucGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgICAgICAgZnJhbWVzID0gdGhpcy5fbGFzdEZyYW1lICsgMTtcbiAgICAgICAgICBkdXJhdGlvbiA9IDEwMDAgKiAoZnJhbWVzIC0gdGhpcy5fZmlyc3RGcmFtZSkgLyB0aGlzLl9mcmFtZVJhdGU7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuICAgICAgICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgJSBkdXJhdGlvbjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxhcHNlZCA9IE1hdGgubWluKGVsYXBzZWQsIGR1cmF0aW9uKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmRleCA9IGxlcnAodGhpcy5fZmlyc3RGcmFtZSwgZnJhbWVzLCBlbGFwc2VkIC8gZHVyYXRpb24pO1xuICAgICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuX2luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX2xhc3RGcmFtZSAtIDEgJiYgdGhpcy5fb25MYXN0RnJhbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb25MYXN0RnJhbWUoKTsgIC8vIFNob3J0Y3V0IGZvciBjaGFpbmFibGUgc3ByaXRlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2wgPSB0aGlzLl9pbmRleCAlIGNvbHM7XG4gICAgICAgIHZhciByb3cgPSBNYXRoLmZsb29yKHRoaXMuX2luZGV4IC8gY29scyk7XG5cbiAgICAgICAgdmFyIG94ID0gLSB3aWR0aCAqIGNvbCArIChpdyAtIHdpZHRoKSAvIDI7XG4gICAgICAgIHZhciBveSA9IC0gaGVpZ2h0ICogcm93ICsgKGloIC0gaGVpZ2h0KSAvIDI7XG5cbiAgICAgICAgLy8gVE9ETzogSW1wcm92ZSBwZXJmb3JtYW5jZVxuICAgICAgICBpZiAob3ggIT09IGVmZmVjdC5vZmZzZXQueCkge1xuICAgICAgICAgIGVmZmVjdC5vZmZzZXQueCA9IG94O1xuICAgICAgICB9XG4gICAgICAgIGlmIChveSAhPT0gZWZmZWN0Lm9mZnNldC55KSB7XG4gICAgICAgICAgZWZmZWN0Lm9mZnNldC55ID0gb3k7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBSZWN0YW5nbGUucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdUZXh0dXJlID0gdGhpcy5fZmxhZ0NvbHVtbnMgPSB0aGlzLl9mbGFnUm93c1xuICAgICAgICA9IHRoaXMuX2ZsYWdGcmFtZVJhdGUgPSBmYWxzZTtcblxuICAgICAgUmVjdGFuZ2xlLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgfSk7XG5cbiAgU3ByaXRlLk1ha2VPYnNlcnZhYmxlKFNwcml0ZS5wcm90b3R5cGUpO1xuXG4gIHZhciBUV09fUEkkNCA9IE1hdGguUEkgKiAyLCBIQUxGX1BJJDIgPSBNYXRoLlBJIC8gMjtcbiAgdmFyIGNvcyQzID0gTWF0aC5jb3MsIHNpbiQzID0gTWF0aC5zaW47XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5DaXJjbGVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzPTBdIC0gVGhlIHJhZGl1cyB2YWx1ZSBvZiB0aGUgY2lyY2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Jlc29sdXRpb249NF0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBjaXJjbGUuXG4gICAqL1xuICBmdW5jdGlvbiBDaXJjbGUob3gsIG95LCByLCByZXNvbHV0aW9uKSB7XG5cbiAgICAvLyBBdCBsZWFzdCAyIHZlcnRpY2VzIGFyZSByZXF1aXJlZCBmb3IgcHJvcGVyIGNpcmNsYWdlXG4gICAgdmFyIGFtb3VudCA9IHJlc29sdXRpb24gPyBNYXRoLm1heChyZXNvbHV0aW9uLCAyKSA6IDQ7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcigwLCAwLCAwLCAwLCAwLCAwKSk7XG4gICAgfVxuXG4gICAgUGF0aC5jYWxsKHRoaXMsIHBvaW50cywgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlI3JhZGl1c1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSByYWRpdXMgb2YgdGhlIGNpcmNsZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHI7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICBpZiAodHlwZW9mIG94ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy50cmFuc2xhdGlvbi54ID0gb3g7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3kgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnkgPSBveTtcbiAgICB9XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKENpcmNsZSwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZS5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLkNpcmNsZX0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogWydyYWRpdXMnXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5DaXJjbGV9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkNpcmNsZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iaik7XG4gICAgICBfLmVhY2goQ2lyY2xlLlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqKTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChDaXJjbGUucHJvdG90eXBlLCBQYXRoLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IENpcmNsZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUjX2ZsYWdSYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uQ2lyY2xlI3JhZGl1c30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdSYWRpdXM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZSNfcmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uQ2lyY2xlI3JhZGl1c31cbiAgICAgKi9cbiAgICBfcmFkaXVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZSNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnVmVydGljZXMgfHwgdGhpcy5fZmxhZ1JhZGl1cykge1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAyKSB7XG4gICAgICAgICAgbGVuZ3RoIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2VmZmljaWVudCBmb3IgYXBwcm94aW1hdGluZyBjaXJjdWxhciBhcmNzIHdpdGggQmV6aWVyIGN1cnZlc1xuICAgICAgICB2YXIgYyA9ICg0IC8gMykgKiBNYXRoLnRhbihNYXRoLlBJIC8gKGxlbmd0aCAqIDIpKTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgdmFyIHJjID0gcmFkaXVzICogYztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgcGN0ID0gaSAvIGxlbmd0aDtcbiAgICAgICAgICB2YXIgdGhldGEgPSBwY3QgKiBUV09fUEkkNDtcblxuICAgICAgICAgIHZhciB4ID0gcmFkaXVzICogY29zJDModGhldGEpO1xuICAgICAgICAgIHZhciB5ID0gcmFkaXVzICogc2luJDModGhldGEpO1xuXG4gICAgICAgICAgdmFyIGx4ID0gcmMgKiBjb3MkMyh0aGV0YSAtIEhBTEZfUEkkMik7XG4gICAgICAgICAgdmFyIGx5ID0gcmMgKiBzaW4kMyh0aGV0YSAtIEhBTEZfUEkkMik7XG5cbiAgICAgICAgICB2YXIgcnggPSByYyAqIGNvcyQzKHRoZXRhICsgSEFMRl9QSSQyKTtcbiAgICAgICAgICB2YXIgcnkgPSByYyAqIHNpbiQzKHRoZXRhICsgSEFMRl9QSSQyKTtcblxuICAgICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgIHYuY29tbWFuZCA9IGkgPT09IDAgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMuY3VydmU7XG4gICAgICAgICAgdi5zZXQoeCwgeSk7XG4gICAgICAgICAgdi5jb250cm9scy5sZWZ0LnNldChseCwgbHkpO1xuICAgICAgICAgIHYuY29udHJvbHMucmlnaHQuc2V0KHJ4LCByeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZSNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdSYWRpdXMgPSBmYWxzZTtcblxuICAgICAgUGF0aC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uQ2lyY2xlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5DaXJjbGV9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIGNsb25lID0gbmV3IENpcmNsZSgwLCAwLCB0aGlzLnJhZGl1cywgdGhpcy52ZXJ0aWNlcy5sZW5ndGgpO1xuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgY2xvbmUuc2tld1kgPSB0aGlzLnNrZXdZO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgXy5lYWNoKFBhdGguUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICBfLmVhY2goQ2lyY2xlLlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIENpcmNsZS5NYWtlT2JzZXJ2YWJsZShDaXJjbGUucHJvdG90eXBlKTtcblxuICB2YXIgVFdPX1BJJDMgPSBNYXRoLlBJICogMiwgSEFMRl9QSSQxID0gTWF0aC5QSSAvIDI7XG4gIHZhciBjb3MkMiA9IE1hdGguY29zLCBzaW4kMiA9IE1hdGguc2luO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uRWxsaXBzZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBlbGxpcHNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3J4PTBdIC0gVGhlIHJhZGl1cyB2YWx1ZSBvZiB0aGUgZWxsaXBzZSBpbiB0aGUgeCBkaXJlY3Rpb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcnk9MF0gLSBUaGUgcmFkaXVzIHZhbHVlIG9mIHRoZSBlbGxpcHNlIGluIHRoZSB5IGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNvbHV0aW9uPTRdIC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgZWxsaXBzZS5cbiAgICovXG4gIGZ1bmN0aW9uIEVsbGlwc2Uob3gsIG95LCByeCwgcnksIHJlc29sdXRpb24pIHtcblxuICAgIGlmICh0eXBlb2YgcnkgIT09ICdudW1iZXInICYmIHR5cGVvZiByeCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJ5ID0gcng7XG4gICAgfVxuXG4gICAgLy8gQXQgbGVhc3QgMiB2ZXJ0aWNlcyBhcmUgcmVxdWlyZWQgZm9yIHByb3BlciBjaXJjbGFnZVxuICAgIHZhciBhbW91bnQgPSByZXNvbHV0aW9uID8gTWF0aC5tYXgocmVzb2x1dGlvbiwgMikgOiA0O1xuXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgIHBvaW50cy5wdXNoKG5ldyBBbmNob3IoKSk7XG4gICAgfVxuXG4gICAgUGF0aC5jYWxsKHRoaXMsIHBvaW50cywgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZSN3aWR0aFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB3aWR0aCBvZiB0aGUgZWxsaXBzZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHJ4ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy53aWR0aCA9IHJ4ICogMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZSNoZWlnaHRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgaGVpZ2h0IG9mIHRoZSBlbGxpcHNlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgcnkgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHJ5ICogMjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldChveCwgb3kpO1xuXG4gIH1cblxuICBfLmV4dGVuZChFbGxpcHNlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZS5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLkVsbGlwc2V9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFsnd2lkdGgnLCAnaGVpZ2h0J10sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZS5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkVsbGlwc2V9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkVsbGlwc2V9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmopIHtcblxuICAgICAgUGF0aC5NYWtlT2JzZXJ2YWJsZShvYmopO1xuICAgICAgXy5lYWNoKEVsbGlwc2UuUHJvcGVydGllcywgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmopO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKEVsbGlwc2UucHJvdG90eXBlLCBQYXRoLnByb3RvdHlwZSwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkVsbGlwc2UjX2ZsYWdXaWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5FbGxpcHNlI3dpZHRofSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1dpZHRoOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZSNfZmxhZ0hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5FbGxpcHNlI2hlaWdodH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdIZWlnaHQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX3dpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uRWxsaXBzZSN3aWR0aH1cbiAgICAgKi9cbiAgICBfd2lkdGg6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkVsbGlwc2UjaGVpZ2h0fVxuICAgICAqL1xuICAgIF9oZWlnaHQ6IDAsXG5cbiAgICBjb25zdHJ1Y3RvcjogRWxsaXBzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcyB8fCB0aGlzLl9mbGFnV2lkdGggfHwgdGhpcy5fZmxhZ0hlaWdodCkge1xuXG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICBpZiAoIXRoaXMuX2Nsb3NlZCAmJiBsZW5ndGggPiAyKSB7XG4gICAgICAgICAgbGVuZ3RoIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb2VmZmljaWVudCBmb3IgYXBwcm94aW1hdGluZyBjaXJjdWxhciBhcmNzIHdpdGggQmV6aWVyIGN1cnZlc1xuICAgICAgICB2YXIgYyA9ICg0IC8gMykgKiBNYXRoLnRhbihNYXRoLlBJIC8gKHRoaXMudmVydGljZXMubGVuZ3RoICogMikpO1xuICAgICAgICB2YXIgcmFkaXVzWCA9IHRoaXMuX3dpZHRoIC8gMjtcbiAgICAgICAgdmFyIHJhZGl1c1kgPSB0aGlzLl9oZWlnaHQgLyAyO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwY3QgPSBpIC8gbGVuZ3RoO1xuICAgICAgICAgIHZhciB0aGV0YSA9IHBjdCAqIFRXT19QSSQzO1xuXG4gICAgICAgICAgdmFyIHggPSByYWRpdXNYICogY29zJDIodGhldGEpO1xuICAgICAgICAgIHZhciB5ID0gcmFkaXVzWSAqIHNpbiQyKHRoZXRhKTtcblxuICAgICAgICAgIHZhciBseCA9IHJhZGl1c1ggKiBjICogY29zJDIodGhldGEgLSBIQUxGX1BJJDEpO1xuICAgICAgICAgIHZhciBseSA9IHJhZGl1c1kgKiBjICogc2luJDIodGhldGEgLSBIQUxGX1BJJDEpO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcmFkaXVzWCAqIGMgKiBjb3MkMih0aGV0YSArIEhBTEZfUEkkMSk7XG4gICAgICAgICAgdmFyIHJ5ID0gcmFkaXVzWSAqIGMgKiBzaW4kMih0aGV0YSArIEhBTEZfUEkkMSk7XG5cbiAgICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXNbaV07XG5cbiAgICAgICAgICB2LmNvbW1hbmQgPSBpID09PSAwID8gQ29tbWFuZHMubW92ZSA6IENvbW1hbmRzLmN1cnZlO1xuICAgICAgICAgIHYuc2V0KHgsIHkpO1xuICAgICAgICAgIHYuY29udHJvbHMubGVmdC5zZXQobHgsIGx5KTtcbiAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnNldChyeCwgcnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1dpZHRoID0gdGhpcy5fZmxhZ0hlaWdodCA9IGZhbHNlO1xuXG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uUG9seWdvbn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUG9seWdvbn0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICB2YXIgcnggPSB0aGlzLndpZHRoIC8gMjtcbiAgICAgIHZhciByeSA9IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICB2YXIgY2xvbmUgPSBuZXcgRWxsaXBzZSgwLCAwLCByeCwgcnksIHJlc29sdXRpb24pO1xuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgY2xvbmUuc2tld1kgPSB0aGlzLnNrZXdZO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgXy5lYWNoKFBhdGguUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gUGF0aC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcblxuICAgICAgXy5lYWNoKEVsbGlwc2UuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgRWxsaXBzZS5NYWtlT2JzZXJ2YWJsZShFbGxpcHNlLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5MaW5lXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3gxPTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGZpcnN0IHZlcnRleCBvbiB0aGUgbGluZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5MT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBmaXJzdCB2ZXJ0ZXggb24gdGhlIGxpbmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeDI9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgc2Vjb25kIHZlcnRleCBvbiB0aGUgbGluZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5Mj0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgdmVydGV4IG9uIHRoZSBsaW5lLlxuICAgKi9cbiAgZnVuY3Rpb24gTGluZSh4MSwgeTEsIHgyLCB5Mikge1xuXG4gICAgUGF0aC5jYWxsKHRoaXMsIFtcbiAgICAgICAgbmV3IEFuY2hvcih4MSwgeTEpLFxuICAgICAgICBuZXcgQW5jaG9yKHgyLCB5MilcbiAgICBdKTtcblxuICAgIHRoaXMudmVydGljZXNbMF0uY29tbWFuZCA9IENvbW1hbmRzLm1vdmU7XG4gICAgdGhpcy52ZXJ0aWNlc1sxXS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcblxuICAgIHRoaXMuYXV0b21hdGljID0gZmFsc2U7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKExpbmUucHJvdG90eXBlLCBQYXRoLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IExpbmVcblxuICB9KTtcblxuICBQYXRoLk1ha2VPYnNlcnZhYmxlKExpbmUucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoPTBdIC0gVGhlIHdpZHRoIHZhbHVlIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHQ9MF0gLSBUaGUgd2lkdGggdmFsdWUgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1cz0wXSAtIFRoZSByYWRpdXMgdmFsdWUgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Jlc29sdXRpb249MTJdIC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAqL1xuICBmdW5jdGlvbiBSb3VuZGVkUmVjdGFuZ2xlKG94LCBveSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG5cbiAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJhZGl1cyA9IE1hdGguZmxvb3IoTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAxMik7XG4gICAgfVxuXG4gICAgdmFyIGFtb3VudCA9IDEwO1xuXG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcbiAgICAgIHBvaW50cy5wdXNoKFxuICAgICAgICBuZXcgQW5jaG9yKDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgICAgICAgaSA9PT0gMCA/IENvbW1hbmRzLm1vdmUgOiBDb21tYW5kcy5jdXJ2ZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXS5jb21tYW5kID0gVHdvLkNvbW1hbmRzLmNsb3NlO1xuXG4gICAgUGF0aC5jYWxsKHRoaXMsIHBvaW50cyk7XG5cbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5hdXRvbWF0aWMgPSBmYWxzZTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdSYWRpdXMgPSBSb3VuZGVkUmVjdGFuZ2xlLkZsYWdSYWRpdXMuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3dpZHRoXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHdpZHRoIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI2hlaWdodFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBoZWlnaHQgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgaGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjcmFkaXVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIHJhZGl1cyBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiByYWRpdXMgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldChveCwgb3kpO1xuXG4gIH1cblxuICBfLmV4dGVuZChSb3VuZGVkUmVjdGFuZ2xlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZS5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGV9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFsnd2lkdGgnLCAnaGVpZ2h0J10sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZS5GbGFnUmFkaXVzXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gLSBBIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHRyaWdnZXIgdGhlIGZsYWcgZm9yIHJhZGl1cyBjaGFuZ2luZy5cbiAgICAgKi9cbiAgICBGbGFnUmFkaXVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdSYWRpdXMgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZS5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGV9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGV9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgUGF0aC5NYWtlT2JzZXJ2YWJsZShvYmplY3QpO1xuICAgICAgXy5lYWNoKFJvdW5kZWRSZWN0YW5nbGUuUHJvcGVydGllcywgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmplY3QpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncmFkaXVzJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3JhZGl1cyBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnUmFkaXVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9yYWRpdXMgPSB2O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3JhZGl1cyBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fcmFkaXVzLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1JhZGl1cyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZmxhZ1JhZGl1cyA9IHRydWU7XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoUm91bmRlZFJlY3RhbmdsZS5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUm91bmRlZFJlY3RhbmdsZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI19mbGFnV2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZSN3aWR0aH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdXaWR0aDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX2ZsYWdIZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZSNoZWlnaHR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSGVpZ2h0OiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNfZmxhZ1JhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3JhZGl1c30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdSYWRpdXM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX3dpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZSN3aWR0aH1cbiAgICAgKi9cbiAgICBfd2lkdGg6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGUjaGVpZ2h0fVxuICAgICAqL1xuICAgIF9oZWlnaHQ6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX3JhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGUjcmFkaXVzfVxuICAgICAqL1xuICAgIF9yYWRpdXM6IDEyLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ1ZlcnRpY2VzIHx8IHRoaXMuX2ZsYWdXaWR0aCB8fCB0aGlzLl9mbGFnSGVpZ2h0IHx8IHRoaXMuX2ZsYWdSYWRpdXMpIHtcblxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLl93aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuX2hlaWdodDtcblxuICAgICAgICB2YXIgcngsIHJ5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yYWRpdXMgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICByeCA9IHRoaXMuX3JhZGl1cy54O1xuICAgICAgICAgIHJ5ID0gdGhpcy5fcmFkaXVzLnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnggPSB0aGlzLl9yYWRpdXM7XG4gICAgICAgICAgcnkgPSB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdjtcbiAgICAgICAgdmFyIHcgPSB3aWR0aCAvIDI7XG4gICAgICAgIHZhciBoID0gaGVpZ2h0IC8gMjtcblxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1swXTtcbiAgICAgICAgdi54ID0gLSAodyAtIHJ4KTtcbiAgICAgICAgdi55ID0gLSBoO1xuXG4gICAgICAgIC8vIFVwcGVyIFJpZ2h0IENvcm5lclxuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzFdO1xuICAgICAgICB2LnggPSAodyAtIHJ4KTtcbiAgICAgICAgdi55ID0gLSBoO1xuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC54ID0gcng7XG4gICAgICAgIHYuY29udHJvbHMucmlnaHQueSA9IDA7XG5cbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbMl07XG4gICAgICAgIHYueCA9IHc7XG4gICAgICAgIHYueSA9IC0gKGggLSByeSk7XG4gICAgICAgIHYuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XG5cbiAgICAgICAgLy8gQm90dG9tIFJpZ2h0IENvcm5lclxuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzNdO1xuICAgICAgICB2LnggPSB3O1xuICAgICAgICB2LnkgPSAoaCAtIHJ5KTtcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XG4gICAgICAgIHYuY29udHJvbHMucmlnaHQueCA9IDA7XG4gICAgICAgIHYuY29udHJvbHMucmlnaHQueSA9IHJ5O1xuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzRdO1xuICAgICAgICB2LnggPSAodyAtIHJ4KTtcbiAgICAgICAgdi55ID0gaDtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC5jbGVhcigpO1xuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcblxuICAgICAgICAvLyBCb3R0b20gTGVmdCBDb3JuZXJcblxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1s1XTtcbiAgICAgICAgdi54ID0gLSAodyAtIHJ4KTtcbiAgICAgICAgdi55ID0gaDtcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XG4gICAgICAgIHYuY29udHJvbHMucmlnaHQueCA9IC0gcng7XG4gICAgICAgIHYuY29udHJvbHMucmlnaHQueSA9IDA7XG5cbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbNl07XG4gICAgICAgIHYueCA9IC0gdztcbiAgICAgICAgdi55ID0gKGggLSByeSk7XG4gICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XG5cbiAgICAgICAgLy8gVXBwZXIgTGVmdCBDb3JuZXJcblxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1s3XTtcbiAgICAgICAgdi54ID0gLSB3O1xuICAgICAgICB2LnkgPSAtIChoIC0gcnkpO1xuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC54ID0gMDtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC55ID0gLSByeTtcblxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1s4XTtcbiAgICAgICAgdi54ID0gLSAodyAtIHJ4KTtcbiAgICAgICAgdi55ID0gLSBoO1xuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC5jbGVhcigpO1xuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzldO1xuICAgICAgICB2LmNvcHkodGhpcy52ZXJ0aWNlc1s4XSk7XG5cbiAgICAgIH1cblxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdXaWR0aCA9IHRoaXMuX2ZsYWdIZWlnaHQgPSB0aGlzLl9mbGFnUmFkaXVzID0gZmFsc2U7XG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5Sb3VuZGVkUmVjdGFuZ2xlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICB2YXIgcmFkaXVzID0gdGhpcy5yYWRpdXM7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBSb3VuZGVkUmVjdGFuZ2xlKDAsIDAsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyk7XG5cbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICBjbG9uZS5za2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICBjbG9uZS5za2V3WSA9IHRoaXMuc2tld1k7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2goUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICBfLmVhY2goUm91bmRlZFJlY3RhbmdsZS5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgb2JqZWN0LnJhZGl1cyA9IHR5cGVvZiB0aGlzLnJhZGl1cyA9PT0gJ251bWJlcidcbiAgICAgICAgPyB0aGlzLnJhZGl1cyA6IHRoaXMucmFkaXVzLnRvT2JqZWN0KCk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgUm91bmRlZFJlY3RhbmdsZS5NYWtlT2JzZXJ2YWJsZShSb3VuZGVkUmVjdGFuZ2xlLnByb3RvdHlwZSk7XG5cbiAgdmFyIG1pbiA9IE1hdGgubWluLCBtYXggPSBNYXRoLm1heDtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlRleHRcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5TaGFwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIC0gVGhlIFN0cmluZyB0byBiZSByZW5kZXJlZCB0byB0aGUgc2NlbmUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSBwb3NpdGlvbiBpbiB0aGUgeCBkaXJlY3Rpb24gZm9yIHRoZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSBwb3NpdGlvbiBpbiB0aGUgeSBkaXJlY3Rpb24gZm9yIHRoZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSAtIEFuIG9iamVjdCB3aGVyZSBzdHlsZXMgYXJlIGFwcGxpZWQuIEF0dHJpYnV0ZSBtdXN0IGV4aXN0IGluIFR3by5UZXh0LlByb3BlcnRpZXMuXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgcHJpbWl0aXZlIGNsYXNzIGZvciBjcmVhdGluZyBkcmF3YWJsZSB0ZXh0IHRoYXQgY2FuIGJlIGFkZGVkIHRvIHRoZSBzY2VuZWdyYXBoLlxuICAgKiBAcmV0dXJucyB7VHdvLlRleHR9XG4gICAqL1xuICBmdW5jdGlvbiBUZXh0KG1lc3NhZ2UsIHgsIHksIHN0eWxlcykge1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLnR5cGUgPSAndGV4dCc7XG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ0ZpbGwgPSBUZXh0LkZsYWdGaWxsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSA9IFRleHQuRmxhZ1N0cm9rZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy52YWx1ZSA9IG1lc3NhZ2U7XG5cbiAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnggPSB4O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHkgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnkgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I2Rhc2hlc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyW119IC0gQXJyYXkgb2YgbnVtYmVycy4gT2RkIGluZGljZXMgcmVwcmVzZW50IGRhc2ggbGVuZ3RoLiBFdmVuIGluZGljZXMgcmVwcmVzZW50IGRhc2ggc3BhY2UuXG4gICAgICogQGRlc2NyaXB0aW9uIEEgbGlzdCBvZiBudW1iZXJzIHRoYXQgcmVwcmVzZW50IHRoZSByZXBlYXRlZCBkYXNoIGxlbmd0aCBhbmQgZGFzaCBzcGFjZSBhcHBsaWVkIHRvIHRoZSBzdHJva2Ugb2YgdGhlIHRleHQuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS9zdHJva2UtZGFzaGFycmF5fSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGUgU1ZHIHN0cm9rZS1kYXNoYXJyYXkgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHRoaXMuZGFzaGVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNkYXNoZXMjb2Zmc2V0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gQSBudW1iZXIgaW4gcGl4ZWxzIHRvIG9mZnNldCB7QGxpbmsgVHdvLlRleHQjZGFzaGVzfSBkaXNwbGF5LlxuICAgICAqL1xuICAgIHRoaXMuZGFzaGVzLm9mZnNldCA9IDA7XG5cbiAgICBpZiAoIV8uaXNPYmplY3Qoc3R5bGVzKSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgXy5lYWNoKFRleHQuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcblxuICAgICAgaWYgKHByb3BlcnR5IGluIHN0eWxlcykge1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHN0eWxlc1twcm9wZXJ0eV07XG4gICAgICB9XG5cbiAgICB9LCB0aGlzKTtcblxuICB9XG5cbiAgXy5leHRlbmQoVGV4dCwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQuUmF0aW9cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBcHByb3hpbWF0ZSBhc3BlY3QgcmF0aW8gb2YgYSB0eXBlZmFjZSdzIGNoYXJhY3RlciB3aWR0aCB0byBoZWlnaHQuXG4gICAgICovXG4gICAgUmF0aW86IDAuNixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0LlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uVGV4dH0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogW1xuICAgICAgJ3ZhbHVlJywgJ2ZhbWlseScsICdzaXplJywgJ2xlYWRpbmcnLCAnYWxpZ25tZW50JywgJ2xpbmV3aWR0aCcsICdzdHlsZScsXG4gICAgICAnd2VpZ2h0JywgJ2RlY29yYXRpb24nLCAnYmFzZWxpbmUnLCAnb3BhY2l0eScsICd2aXNpYmxlJywgJ2NsYXNzTmFtZScsXG4gICAgICAnZmlsbCcsICdzdHJva2UnLFxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dC5GbGFnRmlsbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyB0aGUgZmlsbCBwcm9wZXJ0eSBoYXZlIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uVGV4dH0uXG4gICAgICovXG4gICAgRmxhZ0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ0ZpbGwgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dC5GbGFnU3Ryb2tlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IHRoZSBzdHJva2UgcHJvcGVydHkgaGF2ZSBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLlRleHR9LlxuICAgICAqL1xuICAgIEZsYWdTdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ1N0cm9rZSA9IHRydWU7XG4gICAgfSxcblxuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgU2hhcGUuTWFrZU9ic2VydmFibGUob2JqZWN0KTtcblxuICAgICAgXy5lYWNoKFRleHQuUHJvcGVydGllcy5zbGljZSgwLCAxMiksIGRlZmluZUdldHRlclNldHRlciwgb2JqZWN0KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2ZpbGwnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGw7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fZmlsbCA9IGY7XG4gICAgICAgICAgdGhpcy5fZmxhZ0ZpbGwgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9maWxsLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ0ZpbGwpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3N0cm9rZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGYpIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFJhZGlhbEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdTdHJva2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3N0cm9rZSA9IGY7XG4gICAgICAgICAgdGhpcy5fZmxhZ1N0cm9rZSA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy5fc3Ryb2tlLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnbWFzaycsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fbWFzayA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ01hc2sgPSB0cnVlO1xuICAgICAgICAgIGlmICghdi5jbGlwKSB7XG4gICAgICAgICAgICB2LmNsaXAgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2NsaXAnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NsaXA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2NsaXAgPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdDbGlwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdkYXNoZXMnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Rhc2hlcztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2Lm9mZnNldCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHYub2Zmc2V0ID0gdGhpcy5fZGFzaGVzLm9mZnNldCB8fCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9kYXNoZXMgPSB2O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChUZXh0LnByb3RvdHlwZSwgU2hhcGUucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVGV4dCxcblxuICAgIC8vIEZsYWdzXG4gICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GbGFnXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ1ZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjdmFsdWV9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdWYWx1ZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnRmFtaWx5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjZmFtaWx5fSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnRmFtaWx5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdTaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjc2l6ZX0gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1NpemU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0xlYWRpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNsZWFkaW5nfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTGVhZGluZzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnQWxpZ25tZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjYWxpZ25tZW50fSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQWxpZ25tZW50OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdCYXNlbGluZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I2Jhc2VsaW5lfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQmFzZWxpbmU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ1N0eWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjc3R5bGV9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdTdHlsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnV2VpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjd2VpZ2h0fSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnV2VpZ2h0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdEZWNvcmF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjZGVjb3JhdGlvbn0gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0RlY29yYXRpb246IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0ZpbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNmaWxsfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnRmlsbDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnU3Ryb2tlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjc3Ryb2tlfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU3Ryb2tlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdMaW5ld2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNsaW5ld2lkdGh9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdMaW5ld2lkdGg6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ09wYWNpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNvcGFjaXR5fSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnT3BhY2l0eTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnQ2xhc3NOYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjY2xhc3NOYW1lfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQ2xhc3NOYW1lOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdWaXNpYmxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjdmlzaWJsZX0gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1Zpc2libGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ01hc2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNtYXNrfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ01hc2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdDbGlwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjY2xpcH0gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0NsaXA6IGZhbHNlLFxuXG4gICAgLy8gVW5kZXJseWluZyBQcm9wZXJ0aWVzXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCN2YWx1ZVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBjaGFyYWN0ZXJzIHRvIGJlIHJlbmRlcmVkIHRvIHRoZSB0aGUgc2NyZWVuLiBSZWZlcnJlZCB0byBpbiB0aGUgZG9jdW1lbnRhdGlvbiBzb21ldGltZXMgYXMgdGhlIGBtZXNzYWdlYC5cbiAgICAgKi9cbiAgICBfdmFsdWU6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjZmFtaWx5XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gVGhlIGZvbnQgZmFtaWx5IFR3by5qcyBzaG91bGQgYXR0ZW1wdCB0byByZWdzaXRlciBmb3IgcmVuZGVyaW5nLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBgJ3NhbnMtc2VyaWYnYC4gQ29tbWEgc2VwYXJhdGVkIGZvbnQgbmFtZXMgY2FuIGJlIHN1cHBsaWVkIGFzIGEgXCJzdGFja1wiLCBzaW1pbGFyIHRvIHRoZSBDU1MgaW1wbGVtZW50YXRpb24gb2YgYGZvbnQtZmFtaWx5YC5cbiAgICAgKi9cbiAgICBfZmFtaWx5OiAnc2Fucy1zZXJpZicsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNzaXplXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGZvbnQgc2l6ZSBpbiBUd28uanMgcG9pbnQgc3BhY2UuIERlZmF1bHRzIHRvIGAxM2AuXG4gICAgICovXG4gICAgX3NpemU6IDEzLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjbGVhZGluZ1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBoZWlnaHQgYmV0d2VlbiBsaW5lcyBtZWFzdXJlZCBmcm9tIGJhc2UgdG8gYmFzZSBpbiBUd28uanMgcG9pbnQgc3BhY2UuIERlZmF1bHRzIHRvIGAxN2AuXG4gICAgICovXG4gICAgX2xlYWRpbmc6IDE3LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjYWxpZ25tZW50XG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gQWxpZ25tZW50IG9mIHRleHQgaW4gcmVsYXRpb24gdG8ge0BsaW5rIFR3by5UZXh0I3RyYW5zbGF0aW9ufSdzIGNvb3JkaW5hdGVzLiBQb3NzaWJsZSB2YWx1ZXMgaW5jbHVkZSBgJ2xlZnQnYCwgYCdjZW50ZXInYCwgYCdyaWdodCdgLiBEZWZhdWx0cyB0byBgJ2NlbnRlcidgLlxuICAgICAqL1xuICAgIF9hbGlnbm1lbnQ6ICdjZW50ZXInLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjYmFzZWxpbmVcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBUaGUgdmVydGljYWwgYWxpZ21lbnQgb2YgdGhlIHRleHQgaW4gcmVsYXRpb24gdG8ge0BsaW5rIFR3by5UZXh0I3RyYW5zbGF0aW9ufSdzIGNvb3JkaW5hdGVzLiBQb3NzaWJsZSB2YWx1ZXMgaW5jbHVkZSBgJ3RvcCdgLCBgJ21pZGRsZSdgLCBgJ2JvdHRvbSdgLCBhbmQgYCdiYXNlbGluZSdgLiBEZWZhdWx0cyB0byBgJ2Jhc2VsaW5lJ2AuXG4gICAgICovXG4gICAgX2Jhc2VsaW5lOiAnbWlkZGxlJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I3N0eWxlXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gVGhlIGZvbnQncyBzdHlsZS4gUG9zc2libGUgdmFsdWVzIGluY2x1ZGUgJ2Bub3JtYWxgJywgYCdpdGFsaWMnYC4gRGVmYXVsdHMgdG8gYCdub3JtYWwnYC5cbiAgICAgKi9cbiAgICBfc3R5bGU6ICdub3JtYWwnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjd2VpZ2h0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gQSBudW1iZXIgYXQgaW50ZXJ2YWxzIG9mIDEwMCB0byBkZXNjcmliZSB0aGUgZm9udCdzIHdlaWdodC4gVGhpcyBjb21wYXRpYmlsaXR5IHZhcmllcyB3aXRoIHRoZSB0eXBlZmFjZSdzIHZhcmlhbnQgd2VpZ2h0cy4gTGFyZ2VyIHZhbHVlcyBhcmUgYm9sZGVyLiBTbWFsbGVyIHZhbHVlcyBhcmUgdGhpbm5lci4gRGVmYXVsdHMgdG8gYCc1MDAnYC5cbiAgICAgKi9cbiAgICBfd2VpZ2h0OiA1MDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNkZWNvcmF0aW9uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gU3RyaW5nIHRvIGRlbGluZWF0ZSB3aGV0aGVyIHRleHQgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoIGZvciBpbnN0YW5jZSBhbiBgJ3VuZGVybGluZSdgLiBEZWZhdWx0cyB0byBgJ25vbmUnYC5cbiAgICAgKi9cbiAgICBfZGVjb3JhdGlvbjogJ25vbmUnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjZmlsbFxuICAgICAqIEBwcm9wZXJ0eSB7KFN0cmluZ3xUd28uR3JhZGllbnR8VHdvLlRleHR1cmUpfSAtIFRoZSB2YWx1ZSBvZiB3aGF0IHRoZSB0ZXh0IG9iamVjdCBzaG91bGQgYmUgZmlsbGVkIGluIHdpdGguXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDU1MncyBjb2xvcnMgYXMgYFN0cmluZ2AuXG4gICAgICovXG4gICAgX2ZpbGw6ICcjMDAwJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I3N0cm9rZVxuICAgICAqIEBwcm9wZXJ0eSB7KFN0cmluZ3xUd28uR3JhZGllbnR8VHdvLlRleHR1cmUpfSAtIFRoZSB2YWx1ZSBvZiB3aGF0IHRoZSB0ZXh0IG9iamVjdCBzaG91bGQgYmUgZmlsbGVkIGluIHdpdGguXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDU1MncyBjb2xvcnMgYXMgYFN0cmluZ2AuXG4gICAgICovXG4gICAgX3N0cm9rZTogJ3RyYW5zcGFyZW50JyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I2xpbmV3aWR0aFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB0aGlja25lc3MgaW4gcGl4ZWxzIG9mIHRoZSBzdHJva2UuXG4gICAgICovXG4gICAgX2xpbmV3aWR0aDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I29wYWNpdHlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgb3BhcXVlbmVzcyBvZiB0aGUgdGV4dCBvYmplY3QuXG4gICAgICogQG5vdGEtYmVuZSBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIENTUyBDb2xvcnMgdGhhdCBoYXZlIGFuIGFscGhhIHZhbHVlLlxuICAgICAqL1xuICAgIF9vcGFjaXR5OiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjY2xhc3NOYW1lXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gQSBjbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50IHRvIGJlIGNvbXBhdGlibGUgd2l0aCBDU1Mgc3R5bGluZy4gT25seSBhdmFpbGFibGUgZm9yIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfS5cbiAgICAgKi9cbiAgICBfY2xhc3NOYW1lOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I3Zpc2libGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGlzcGxheSB0aGUgdGV4dCBvYmplY3Qgb3Igbm90LlxuICAgICAqIEBub3RhLWJlbmUgRm9yIHtAbGluayBUd28uQ2FudmFzUmVuZGVyZXJ9IGFuZCB7QGxpbmsgVHdvLldlYkdMUmVuZGVyZXJ9IHdoZW4gc2V0IHRvIGZhbHNlIGFsbCB1cGRhdGluZyBpcyBkaXNhYmxlZCBpbXByb3ZpbmcgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5IHdpdGggbWFueSBvYmplY3RzIGluIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBfdmlzaWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I21hc2tcbiAgICAgKiBAcHJvcGVydHkge1R3by5TaGFwZX0gLSBUaGUgc2hhcGUgd2hvc2UgYWxwaGEgcHJvcGVydHkgYmVjb21lcyBhIGNsaXBwaW5nIGFyZWEgZm9yIHRoZSB0ZXh0LlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBwcm9wZXJ0eSBpcyBjdXJyZW50bHkgbm90IHdvcmtpbmcgYmVjdWFzZSBvZiBTVkcgc3BlYyBpc3N1ZXMgZm91bmQgaGVyZSB7QGxpbmsgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MX0uXG4gICAgICovXG4gICAgX21hc2s6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNjbGlwXG4gICAgICogQHByb3BlcnR5IHtUd28uU2hhcGV9IC0gT2JqZWN0IHRvIGRlZmluZSBjbGlwcGluZyBhcmVhLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBwcm9wZXJ0eSBpcyBjdXJyZW50bHkgbm90IHdvcmtpbmcgYmVjdWFzZSBvZiBTVkcgc3BlYyBpc3N1ZXMgZm91bmQgaGVyZSB7QGxpbmsgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MX0uXG4gICAgICovXG4gICAgX2NsaXA6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2Rhc2hlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHQjZGFzaGVzfVxuICAgICAqL1xuICAgIF9kYXNoZXM6IFtdLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjcmVtb3ZlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZSBzZWxmIGZyb20gdGhlIHNjZW5lIC8gcGFyZW50LlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5UZXh0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5UZXh0fSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdGV4dCBvYmplY3QuXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgVGV4dCh0aGlzLnZhbHVlKTtcbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICAgIF8uZWFjaChUZXh0LlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIGNsb25lW3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmUuX3VwZGF0ZSgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHRleHQgb2JqZWN0LlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24udG9PYmplY3QoKSxcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIHJlc3VsdC5tYXRyaXggPSB0aGlzLm1hdHJpeC50b09iamVjdCgpO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2goVGV4dC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICByZXN1bHRbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNub0ZpbGxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvcnQgaGFuZCBtZXRob2QgdG8gc2V0IGZpbGwgdG8gYHRyYW5zcGFyZW50YC5cbiAgICAgKi9cbiAgICBub0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5maWxsID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNub1N0cm9rZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBTaG9ydCBoYW5kIG1ldGhvZCB0byBzZXQgc3Ryb2tlIHRvIGB0cmFuc3BhcmVudGAuXG4gICAgICovXG4gICAgbm9TdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJva2UgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxpbmV3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBIHNoaW0gdG8gbm90IGJyZWFrIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIGNhbGxzLlxuICAgIC8vIFRPRE86IEltcGxlbWVudCBhIHdheSB0byBjYWxjdWxhdGUgcHJvcGVyIGJvdW5kaW5nXG4gICAgLy8gYm94ZXMgb2YgYFR3by5UZXh0YC5cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I2dldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NoYWxsb3c9ZmFsc2VdIC0gRGVzY3JpYmVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIG9mZiBsb2NhbCBtYXRyaXggb3Igd29ybGQgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gUmV0dXJucyBvYmplY3Qgd2l0aCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHdpZHRoLCBoZWlnaHQgYXR0cmlidXRlcy5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGgsIGFuZCBoZWlnaHQgcGFyYW1ldGVycyBvZiB0aGUgdGV4dCBvYmplY3QuXG4gICAgICovXG4gICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbihzaGFsbG93KSB7XG5cbiAgICAgIHZhciBtYXRyaXgsIGEsIGIsIGMsIGQ7XG4gICAgICB2YXIgbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tO1xuXG4gICAgICAvLyBUT0RPOiBVcGRhdGUgdGhpcyB0byBub3QgX19hbHdheXNfXyB1cGRhdGUuIEp1c3Qgd2hlbiBpdCBuZWVkcyB0by5cbiAgICAgIHRoaXMuX3VwZGF0ZSh0cnVlKTtcblxuICAgICAgbWF0cml4ID0gc2hhbGxvdyA/IHRoaXMuX21hdHJpeCA6IGdldENvbXB1dGVkTWF0cml4KHRoaXMpO1xuXG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5sZWFkaW5nO1xuICAgICAgdmFyIHdpZHRoID0gdGhpcy52YWx1ZS5sZW5ndGggKiB0aGlzLnNpemUgKiBUZXh0LlJhdGlvO1xuICAgICAgdmFyIGJvcmRlciA9ICh0aGlzLl9saW5ld2lkdGggfHwgMCkgLyAyO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuYWxpZ25tZW50KSB7XG4gICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgIGxlZnQgPSAtIGJvcmRlcjtcbiAgICAgICAgICByaWdodCA9IHdpZHRoICsgYm9yZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgbGVmdCA9IC0gKHdpZHRoICsgYm9yZGVyKTtcbiAgICAgICAgICByaWdodCA9IGJvcmRlcjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBsZWZ0ID0gLSAod2lkdGggLyAyICsgYm9yZGVyKTtcbiAgICAgICAgICByaWdodCA9IHdpZHRoIC8gMiArIGJvcmRlcjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0aGlzLmJhc2VsaW5lKSB7XG4gICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgdG9wID0gLSBib3JkZXI7XG4gICAgICAgICAgYm90dG9tID0gaGVpZ2h0ICsgYm9yZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgIHRvcCA9IC0gKGhlaWdodCArIGJvcmRlcik7XG4gICAgICAgICAgYm90dG9tID0gYm9yZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRvcCA9IC0gKGhlaWdodCAvIDIgKyBib3JkZXIpO1xuICAgICAgICAgIGJvdHRvbSA9IGhlaWdodCAvIDIgKyBib3JkZXI7XG4gICAgICB9XG5cbiAgICAgIGEgPSBtYXRyaXgubXVsdGlwbHkobGVmdCwgdG9wLCAxKTtcbiAgICAgIGIgPSBtYXRyaXgubXVsdGlwbHkobGVmdCwgYm90dG9tLCAxKTtcbiAgICAgIGMgPSBtYXRyaXgubXVsdGlwbHkocmlnaHQsIHRvcCwgMSk7XG4gICAgICBkID0gbWF0cml4Lm11bHRpcGx5KHJpZ2h0LCBib3R0b20sIDEpO1xuXG4gICAgICB0b3AgPSBtaW4oYS55LCBiLnksIGMueSwgZC55KTtcbiAgICAgIGxlZnQgPSBtaW4oYS54LCBiLngsIGMueCwgZC54KTtcbiAgICAgIHJpZ2h0ID0gbWF4KGEueCwgYi54LCBjLngsIGQueCk7XG4gICAgICBib3R0b20gPSBtYXgoYS55LCBiLnksIGMueSwgZC55KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1ZhbHVlID0gdGhpcy5fZmxhZ0ZhbWlseSA9IHRoaXMuX2ZsYWdTaXplID1cbiAgICAgICAgdGhpcy5fZmxhZ0xlYWRpbmcgPSB0aGlzLl9mbGFnQWxpZ25tZW50ID0gdGhpcy5fZmxhZ0ZpbGwgPVxuICAgICAgICB0aGlzLl9mbGFnU3Ryb2tlID0gdGhpcy5fZmxhZ0xpbmV3aWR0aCA9IHRoaXMuX2ZsYWdPcGFjaXR5ID1cbiAgICAgICAgdGhpcy5fZmxhZ1Zpc2libGUgPSB0aGlzLl9mbGFnQ2xpcCA9IHRoaXMuX2ZsYWdEZWNvcmF0aW9uID1cbiAgICAgICAgdGhpcy5fZmxhZ0NsYXNzTmFtZSA9IHRoaXMuX2ZsYWdCYXNlbGluZSA9IHRoaXMuX2ZsYWdXZWlnaHQgPVxuICAgICAgICAgIHRoaXMuX2ZsYWdTdHlsZSA9IGZhbHNlO1xuXG4gICAgICBTaGFwZS5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIFRleHQuTWFrZU9ic2VydmFibGUoVGV4dC5wcm90b3R5cGUpO1xuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25vYnIxL3R3by5qcy9pc3N1ZXMvNTA3I2lzc3VlY29tbWVudC03NzcxNTkyMTNcbiAgdmFyIHJlZ2V4ID0ge1xuICAgIHBhdGg6IC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCspKD86W2VFXVsrLV1cXGQrKT8vZ1xuICB9O1xuXG4gIHZhciBhbGlnbm1lbnRzID0ge1xuICAgIHN0YXJ0OiAnbGVmdCcsXG4gICAgbWlkZGxlOiAnY2VudGVyJyxcbiAgICBlbmQ6ICdyaWdodCdcbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldEFsaWdubWVudFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBbGlnbm1lbnRTdHJpbmd9XG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvdGV4dC1hbmNob3J9XG4gICAqL1xuICB2YXIgZ2V0QWxpZ25tZW50ID0gZnVuY3Rpb24oYW5jaG9yKSB7XG4gICAgcmV0dXJuIGFsaWdubWVudHNbYW5jaG9yXTtcbiAgfTtcblxuICB2YXIgZ2V0QmFzZWxpbmUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIGEgPSBub2RlLmdldEF0dHJpYnV0ZSgnZG9taW5hbnQtYmFzZWxpbmUnKTtcbiAgICB2YXIgYiA9IG5vZGUuZ2V0QXR0cmlidXRlKCdhbGlnbm1lbnQtYmFzZWxpbmUnKTtcbiAgICByZXR1cm4gYSB8fCBiO1xuICB9O1xuXG4gIHZhciBnZXRUYWdOYW1lID0gZnVuY3Rpb24odGFnKSB7XG4gICAgcmV0dXJuIHRhZy5yZXBsYWNlKC9zdmc6L2lnLCAnJykudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICB2YXIgYXBwbHlUcmFuc2Zvcm1zVG9WZWN0b3IgPSBmdW5jdGlvbih0cmFuc2Zvcm1zLCB2ZWN0b3IpIHtcblxuICAgIHZlY3Rvci54ICs9IHRyYW5zZm9ybXMudHJhbnNsYXRlWDtcbiAgICB2ZWN0b3IueSArPSB0cmFuc2Zvcm1zLnRyYW5zbGF0ZVk7XG5cbiAgICB2ZWN0b3IueCAqPSB0cmFuc2Zvcm1zLnNjYWxlWDtcbiAgICB2ZWN0b3IueSAqPSB0cmFuc2Zvcm1zLnNjYWxlWTtcblxuICAgIGlmICh0cmFuc2Zvcm1zLnJvdGF0aW9uICE9PSAwKSB7XG4gICAgICAvLyBUT0RPOiBUZXN0IGZ1cnRoZXJcbiAgICAgIHZhciBsID0gdmVjdG9yLmxlbmd0aCgpO1xuICAgICAgdmVjdG9yLnggPSBsICogTWF0aC5jb3ModHJhbnNmb3Jtcy5yb3RhdGlvbik7XG4gICAgICB2ZWN0b3IueSA9IGwgKiBNYXRoLnNpbih0cmFuc2Zvcm1zLnJvdGF0aW9uKTtcbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmV4dHJhY3RDU1NUZXh0XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCAtIFRoZSBDU1MgdGV4dCBib2R5IHRvIGJlIHBhcnNlZCBhbmQgZXh0cmFjdGVkLlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3N0eWxlc10gLSBUaGUgc3R5bGVzIG9iamVjdCB0byBhcHBseSBDU1Mga2V5IHZhbHVlcyB0by5cbiAgICogQHJldHVybnMge09iamVjdH0gc3R5bGVzXG4gICAqIEBkZXNjcmlwdGlvbiBQYXJzZSBDU1MgdGV4dCBib2R5IGFuZCBhcHBseSB0aGVtIGFzIGtleSB2YWx1ZSBwYWlycyB0byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICAgKi9cbiAgdmFyIGV4dHJhY3RDU1NUZXh0ID0gZnVuY3Rpb24odGV4dCwgc3R5bGVzKSB7XG5cbiAgICB2YXIgY29tbWFuZHMsIGNvbW1hbmQsIG5hbWUsIHZhbHVlO1xuXG4gICAgaWYgKCFzdHlsZXMpIHtcbiAgICAgIHN0eWxlcyA9IHt9O1xuICAgIH1cblxuICAgIGNvbW1hbmRzID0gdGV4dC5zcGxpdCgnOycpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29tbWFuZCA9IGNvbW1hbmRzW2ldLnNwbGl0KCc6Jyk7XG4gICAgICBuYW1lID0gY29tbWFuZFswXTtcbiAgICAgIHZhbHVlID0gY29tbWFuZFsxXTtcbiAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN0eWxlc1tuYW1lXSA9IHZhbHVlLnJlcGxhY2UoL1xccy8sICcnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5nZXRTdmdTdHlsZXNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gbm9kZSAtIFRoZSBTVkcgbm9kZSB0byBwYXJzZS5cbiAgICogQHJldHVybnMge09iamVjdH0gc3R5bGVzXG4gICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIENTUyBjb21hbmRzIGZyb20gdGhlIGBzdHlsZWAgYXR0cmlidXRlIG9mIGFuIFNWRyBub2RlIGFuZCBhcHBseSB0aGVtIGFzIGtleSB2YWx1ZSBwYWlycyB0byBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICAgKi9cbiAgdmFyIGdldFN2Z1N0eWxlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgIHZhciBzdHlsZXMgPSB7fTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGdldFN2Z0F0dHJpYnV0ZXMobm9kZSk7XG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KGF0dHJpYnV0ZXMubGVuZ3RoLCBub2RlLnN0eWxlLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgIHZhciBjb21tYW5kID0gbm9kZS5zdHlsZVtpXTtcbiAgICAgIHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2ldO1xuXG4gICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICBzdHlsZXNbY29tbWFuZF0gPSBub2RlLnN0eWxlW2NvbW1hbmRdO1xuICAgICAgfVxuICAgICAgaWYgKGF0dHJpYnV0ZSkge1xuICAgICAgICBzdHlsZXNbYXR0cmlidXRlXSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGVzO1xuXG4gIH07XG5cbiAgdmFyIGdldFN2Z0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgICB2YXIgYXR0cmlidXRlcyA9IG5vZGUuZ2V0QXR0cmlidXRlTmFtZXMoKTtcblxuICAgIC8vIFJlc2VydmVkIGF0dHJpYnV0ZXMgdG8gcmVtb3ZlXG4gICAgdmFyIGtleXdvcmRzID0gWydpZCcsICdjbGFzcycsICd0cmFuc2Zvcm0nLCAneG1sbnMnLCAndmlld0JveCddO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXl3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleXdvcmQgPSBrZXl3b3Jkc1tpXTtcbiAgICAgIHZhciBpbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYXR0cmlidXRlcywga2V5d29yZCk7XG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBhdHRyaWJ1dGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmFwcGx5U3ZnVmlld0JveFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtUd28uU2hhcGV9IG5vZGUgLSBUaGUgVHdvLmpzIG9iamVjdCB0byBhcHBseSB2aWV3Ym94IG1hdHJpeCB0b1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgLSBUaGUgdmlld0JveCB2YWx1ZSBmcm9tIHRoZSBTVkcgYXR0cmlidXRlXG4gICAqIEByZXR1cm5zIHtUd28uU2hhcGV9IG5vZGVcbiAgICogQGRlc2NyaXB0aW9uIEFwcGxpZXMgdGhlIHRyYW5zZm9ybSBvZiB0aGUgU1ZHIFZpZXdib3ggb24gYSBnaXZlbiBub2RlLlxuICAgKi9cbiAgdmFyIGFwcGx5U3ZnVmlld0JveCA9IGZ1bmN0aW9uKG5vZGUsIHZhbHVlKSB7XG5cbiAgICB2YXIgZWxlbWVudHMgPSB2YWx1ZS5zcGxpdCgvXFxzLyk7XG5cbiAgICB2YXIgeCA9IHBhcnNlRmxvYXQoZWxlbWVudHNbMF0pO1xuICAgIHZhciB5ID0gcGFyc2VGbG9hdChlbGVtZW50c1sxXSk7XG4gICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChlbGVtZW50c1syXSk7XG4gICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQoZWxlbWVudHNbM10pO1xuXG4gICAgdmFyIHMgPSBNYXRoLm1pbih0aGlzLndpZHRoIC8gd2lkdGgsIHRoaXMuaGVpZ2h0IC8gaGVpZ2h0KTtcblxuICAgIG5vZGUudHJhbnNsYXRpb24ueCAtPSB4ICogcztcbiAgICBub2RlLnRyYW5zbGF0aW9uLnkgLT0geSAqIHM7XG4gICAgbm9kZS5zY2FsZSA9IHM7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuYXBwbHlTdmdBdHRyaWJ1dGVzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IG5vZGUgLSBBbiBTVkcgTm9kZSB0byBleHRyYXBvbGF0ZSBhdHRyaWJ1dGVzIGZyb20uXG4gICAqIEBwYXJhbSB7VHdvLlNoYXBlfSBlbGVtIC0gVGhlIFR3by5qcyBvYmplY3QgdG8gYXBwbHkgZXh0cmFwb2xhdGVkIGF0dHJpYnV0ZXMgdG8uXG4gICAqIEByZXR1cm5zIHtUd28uU2hhcGV9IFRoZSBUd28uanMgb2JqZWN0IHBhc3NlZCBub3cgd2l0aCBhcHBsaWVkIGF0dHJpYnV0ZXMuXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGl0ZXJhdGVzIHRocm91Z2ggYW4gU1ZHIE5vZGUncyBwcm9wZXJ0aWVzIGFuZCBzdG9yZXMgb25lcyBvZiBpbnRlcmVzdC4gSXQgdHJpZXMgdG8gcmVzb2x2ZSBzdHlsZXMgYXBwbGllZCB2aWEgQ1NTIGFzIHdlbGwuXG4gICAqIEBUT0RPIFJldmVyc2UgY2FsY3VsYXRlIHtAbGluayBUd28uR3JhZGllbnR9cyBmb3IgZmlsbCAvIHN0cm9rZSBvZiBhbnkgZ2l2ZW4gcGF0aC5cbiAgICovXG4gIHZhciBhcHBseVN2Z0F0dHJpYnV0ZXMgPSBmdW5jdGlvbihub2RlLCBlbGVtLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgIHZhciBzdHlsZXMgPSB7fSwgYXR0cmlidXRlcyA9IHt9LCBleHRyYWN0ZWQgPSB7fSwgaSwgbSwga2V5LCB2YWx1ZSwgYXR0cjtcbiAgICB2YXIgdHJhbnNmb3JtcywgeCwgeTtcbiAgICB2YXIgaWQsIHNjZW5lLCByZWYsIHRhZ05hbWU7XG5cbiAgICAvLyBOb3QgYXZhaWxhYmxlIGluIG5vbiBicm93c2VyIGVudmlyb25tZW50c1xuICAgIGlmIChyb290JDEuZ2V0Q29tcHV0ZWRTdHlsZSkge1xuICAgICAgLy8gQ29udmVydCBDU1NTdHlsZURlY2xhcmF0aW9uIHRvIGEgbm9ybWFsIG9iamVjdFxuICAgICAgdmFyIGNvbXB1dGVkU3R5bGVzID0gcm9vdCQxLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICBpID0gY29tcHV0ZWRTdHlsZXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGtleSA9IGNvbXB1dGVkU3R5bGVzW2ldO1xuICAgICAgICB2YWx1ZSA9IGNvbXB1dGVkU3R5bGVzW2tleV07XG4gICAgICAgIC8vIEdlY2tvIHJldHVybnMgdW5kZWZpbmVkIGZvciB1bnNldCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIFdlYmtpdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgc3R5bGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlcnQgTm9kZU1hcCB0byBhIG5vcm1hbCBvYmplY3RcbiAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgaWYgKC9zdHlsZS9pLnRlc3QoYXR0ci5ub2RlTmFtZSkpIHtcbiAgICAgICAgZXh0cmFjdENTU1RleHQoYXR0ci52YWx1ZSwgZXh0cmFjdGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYXR0ci5ub2RlTmFtZV0gPSBhdHRyLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldHRpbmcgdGhlIGNvcnJlY3Qgb3BhY2l0eSBpcyBhIGJpdCB0cmlja3ksIHNpbmNlIFNWRyBwYXRoIGVsZW1lbnRzIGRvbid0XG4gICAgLy8gc3VwcG9ydCBvcGFjaXR5IGFzIGFuIGF0dHJpYnV0ZSwgYnV0IHlvdSBjYW4gYXBwbHkgaXQgdmlhIENTUy5cbiAgICAvLyBTbyB3ZSB0YWtlIHRoZSBvcGFjaXR5IGFuZCBzZXQgKHN0cm9rZS9maWxsKS1vcGFjaXR5IHRvIHRoZSBzYW1lIHZhbHVlLlxuICAgIGlmICh0eXBlb2Ygc3R5bGVzLm9wYWNpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzdHlsZXNbJ3N0cm9rZS1vcGFjaXR5J10gPSBzdHlsZXMub3BhY2l0eTtcbiAgICAgIHN0eWxlc1snZmlsbC1vcGFjaXR5J10gPSBzdHlsZXMub3BhY2l0eTtcbiAgICAgIGRlbGV0ZSBzdHlsZXMub3BhY2l0eTtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSBhdHRyaWJ1dGVzIGFuZCBhcHBsaWVkIHN0eWxlcyAoYXR0cmlidXRlcyB0YWtlIHByZWNlZGVuY2UpXG4gICAgaWYgKHBhcmVudFN0eWxlcykge1xuICAgICAgXy5kZWZhdWx0cyhzdHlsZXMsIHBhcmVudFN0eWxlcyk7XG4gICAgfVxuICAgIF8uZXh0ZW5kKHN0eWxlcywgZXh0cmFjdGVkLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIFNpbWlsYXJseSB2aXNpYmlsaXR5IGlzIGluZmx1ZW5jZWQgYnkgdGhlIHZhbHVlIG9mIGJvdGggZGlzcGxheSBhbmQgdmlzaWJpbGl0eS5cbiAgICAvLyBDYWxjdWxhdGUgYSB1bmlmaWVkIHZhbHVlIGhlcmUgd2hpY2ggZGVmYXVsdHMgdG8gYHRydWVgLlxuICAgIHN0eWxlcy52aXNpYmxlID0gISh0eXBlb2Ygc3R5bGVzLmRpc3BsYXkgPT09ICd1bmRlZmluZWQnICYmIC9ub25lL2kudGVzdChzdHlsZXMuZGlzcGxheSkpXG4gICAgICB8fCAodHlwZW9mIHN0eWxlcy52aXNpYmlsaXR5ID09PSAndW5kZWZpbmVkJyAmJiAvaGlkZGVuL2kudGVzdChzdHlsZXMudmlzaWJpbGl0eSkpO1xuXG4gICAgLy8gTm93IGl0ZXJhdGUgdGhlIHdob2xlIHRoaW5nXG4gICAgZm9yIChrZXkgaW4gc3R5bGVzKSB7XG4gICAgICB2YWx1ZSA9IHN0eWxlc1trZXldO1xuXG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlICdncmFkaWVudFRyYW5zZm9ybSc6XG4gICAgICAgICAgLy8gVE9ETzogQ2hlY2sgdGhpcyBvdXQgaHR0cHM6Ly9naXRodWIuY29tL3BhcGVyanMvcGFwZXIuanMvYmxvYi9kZXZlbG9wL3NyYy9zdmcvU3ZnSW1wb3J0LmpzI0wzMTVcbiAgICAgICAgICBpZiAoL25vbmUvaS50ZXN0KHZhbHVlKSkgYnJlYWs7XG4gICAgICAgICAgbSA9IChub2RlLmdyYWRpZW50VHJhbnNmb3JtICYmIG5vZGUuZ3JhZGllbnRUcmFuc2Zvcm0uYmFzZVZhbCAmJiBub2RlLmdyYWRpZW50VHJhbnNmb3JtLmJhc2VWYWwubGVuZ3RoID4gMClcbiAgICAgICAgICAgID8gbm9kZS5ncmFkaWVudFRyYW5zZm9ybS5iYXNlVmFsWzBdLm1hdHJpeFxuICAgICAgICAgICAgOiAobm9kZS5nZXRDVE0gPyBub2RlLmdldENUTSgpIDogbnVsbCk7XG5cbiAgICAgICAgICBpZiAobSA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgICB0cmFuc2Zvcm1zID0gZGVjb21wb3NlTWF0cml4KG0pO1xuXG4gICAgICAgICAgc3dpdGNoIChlbGVtLl9yZW5kZXJlci50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdsaW5lYXItZ3JhZGllbnQnOlxuICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybXNUb1ZlY3Rvcih0cmFuc2Zvcm1zLCBlbGVtLmxlZnQpO1xuICAgICAgICAgICAgICBhcHBseVRyYW5zZm9ybXNUb1ZlY3Rvcih0cmFuc2Zvcm1zLCBlbGVtLnJpZ2h0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyYWRpYWwtZ3JhZGllbnQnOlxuICAgICAgICAgICAgICBlbGVtLmNlbnRlci54ICs9IHRyYW5zZm9ybXMudHJhbnNsYXRlWDtcbiAgICAgICAgICAgICAgZWxlbS5jZW50ZXIueSArPSB0cmFuc2Zvcm1zLnRyYW5zbGF0ZVk7XG5cbiAgICAgICAgICAgICAgZWxlbS5mb2NhbC54ICs9IHRyYW5zZm9ybXMudHJhbnNsYXRlWDtcbiAgICAgICAgICAgICAgZWxlbS5mb2NhbC55ICs9IHRyYW5zZm9ybXMudHJhbnNsYXRlWTtcblxuICAgICAgICAgICAgICBlbGVtLnJhZGl1cyAqPSBNYXRoLm1heCh0cmFuc2Zvcm1zLnNjYWxlWCwgdHJhbnNmb3Jtcy5zY2FsZVkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICAvLyBUT0RPOiBDaGVjayB0aGlzIG91dCBodHRwczovL2dpdGh1Yi5jb20vcGFwZXJqcy9wYXBlci5qcy9ibG9iL2RldmVsb3Avc3JjL3N2Zy9TdmdJbXBvcnQuanMjTDMxNVxuICAgICAgICAgIGlmICgvbm9uZS9pLnRlc3QodmFsdWUpKSBicmVhaztcbiAgICAgICAgICBtID0gKG5vZGUudHJhbnNmb3JtICYmIG5vZGUudHJhbnNmb3JtLmJhc2VWYWwgJiYgbm9kZS50cmFuc2Zvcm0uYmFzZVZhbC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgPyBub2RlLnRyYW5zZm9ybS5iYXNlVmFsWzBdLm1hdHJpeFxuICAgICAgICAgICAgOiAobm9kZS5nZXRDVE0gPyBub2RlLmdldENUTSgpIDogbnVsbCk7XG5cbiAgICAgICAgICAvLyBNaWdodCBoYXBwZW4gd2hlbiB0cmFuc2Zvcm0gc3RyaW5nIGlzIGVtcHR5IG9yIG5vdCB2YWxpZC5cbiAgICAgICAgICBpZiAobSA9PT0gbnVsbCkgYnJlYWs7XG5cbiAgICAgICAgICBpZiAoQ29uc3RhbnRzLkF1dG9DYWxjdWxhdGVJbXBvcnRlZE1hdHJpY2VzKSB7XG5cbiAgICAgICAgICAgIC8vIERlY29tcG9zZSBhbmQgaW5mZXIgVHdvLmpzIHJlbGF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHRyYW5zZm9ybXMgPSBkZWNvbXBvc2VNYXRyaXgobSk7XG5cbiAgICAgICAgICAgIGVsZW0udHJhbnNsYXRpb24uc2V0KHRyYW5zZm9ybXMudHJhbnNsYXRlWCwgdHJhbnNmb3Jtcy50cmFuc2xhdGVZKTtcbiAgICAgICAgICAgIGVsZW0ucm90YXRpb24gPSBNYXRoLlBJICogKHRyYW5zZm9ybXMucm90YXRpb24gLyAxODApO1xuICAgICAgICAgICAgZWxlbS5zY2FsZSA9IG5ldyBWZWN0b3IodHJhbnNmb3Jtcy5zY2FsZVgsIHRyYW5zZm9ybXMuc2NhbGVZKTtcblxuICAgICAgICAgICAgeCA9IHBhcnNlRmxvYXQoKHN0eWxlcy54ICsgJycpLnJlcGxhY2UoJ3B4JykpO1xuICAgICAgICAgICAgeSA9IHBhcnNlRmxvYXQoKHN0eWxlcy55ICsgJycpLnJlcGxhY2UoJ3B4JykpO1xuXG4gICAgICAgICAgICAvLyBPdmVycmlkZSBiYXNlZCBvbiBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICAgICAgZWxlbS50cmFuc2xhdGlvbi54ID0geDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHkpIHtcbiAgICAgICAgICAgICAgZWxlbS50cmFuc2xhdGlvbi55ID0geTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIEVkaXQgdGhlIHVuZGVybHlpbmcgbWF0cml4IGFuZCBkb24ndCBmb3JjZSBhbiBhdXRvIGNhbGMuXG4gICAgICAgICAgICBtID0gbm9kZS5nZXRDVE0oKTtcbiAgICAgICAgICAgIGVsZW0uX21hdHJpeC5tYW51YWwgPSB0cnVlO1xuICAgICAgICAgICAgZWxlbS5fbWF0cml4LnNldChtLmEsIG0uYiwgbS5jLCBtLmQsIG0uZSwgbS5mKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd2aWV3Qm94JzpcbiAgICAgICAgICBhcHBseVN2Z1ZpZXdCb3guY2FsbCh0aGlzLCBlbGVtLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Zpc2libGUnOlxuICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgIGVsZW0uX3Zpc2libGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtLnZpc2libGUgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Ryb2tlLWxpbmVjYXAnOlxuICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgR3JvdXApIHtcbiAgICAgICAgICAgIGVsZW0uX2NhcCA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW0uY2FwID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cm9rZS1saW5lam9pbic6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgZWxlbS5fam9pbiA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW0uam9pbiA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJva2UtbWl0ZXJsaW1pdCc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgZWxlbS5fbWl0ZXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtLm1pdGVyID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cm9rZS13aWR0aCc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgZWxlbS5fbGluZXdpZHRoID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbS5saW5ld2lkdGggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgIGNhc2UgJ3N0cm9rZS1vcGFjaXR5JzpcbiAgICAgICAgY2FzZSAnZmlsbC1vcGFjaXR5JzpcbiAgICAgICAgICAvLyBPbmx5IGFwcGx5IHN0eWxlcyB0byByZW5kZXJlZCBzaGFwZXNcbiAgICAgICAgICAvLyBpbiB0aGUgc2NlbmUuXG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgZWxlbS5fb3BhY2l0eSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW0ub3BhY2l0eSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjbGlwLXBhdGgnOlxuICAgICAgICAgIGlmICgvdXJsXFwoIy4qXFwpL2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlkID0gdmFsdWUucmVwbGFjZSgvdXJsXFwoIyguKilcXCkvaSwgJyQxJyk7XG4gICAgICAgICAgICBpZiAocmVhZC5kZWZzLmN1cnJlbnQgJiYgcmVhZC5kZWZzLmN1cnJlbnQuY29udGFpbnMoaWQpKSB7XG4gICAgICAgICAgICAgIHJlZiA9IHJlYWQuZGVmcy5jdXJyZW50LmdldChpZCk7XG4gICAgICAgICAgICAgIGlmIChyZWYgJiYgcmVmLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlZiA9IHJlZi5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgICAgIHRhZ05hbWUgPSBnZXRUYWdOYW1lKHJlZi5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgZWxlbS5tYXNrID0gcmVhZFt0YWdOYW1lXS5jYWxsKHRoaXMsIHJlZiwge30pO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoZWxlbS5fcmVuZGVyZXIudHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdwYXRoJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1hdHJpeCBoZXJlIG5lZWRzIHRvIGNoYW5nZSB0byBpbnN1cmUgdGhhdCB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGNsaXBwaW5nIGlzIGluIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3BhY2UgYXMgdGhlIGBlbGVtYC5cbiAgICAgICAgICAgICAgICAgICAgZWxlbS5wb3NpdGlvbi5hZGQoZWxlbS5tYXNrLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgZWxlbS5tYXNrLnBvc2l0aW9uLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmlsbCc6XG4gICAgICAgIGNhc2UgJ3N0cm9rZSc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAga2V5ID0gJ18nICsga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoL3VybFxcKCMuKlxcKS9pLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZCA9IHZhbHVlLnJlcGxhY2UoL3VybFxcKCMoLiopXFwpL2ksICckMScpO1xuICAgICAgICAgICAgaWYgKHJlYWQuZGVmcy5jdXJyZW50ICYmIHJlYWQuZGVmcy5jdXJyZW50LmNvbnRhaW5zKGlkKSkge1xuICAgICAgICAgICAgICByZWYgPSByZWFkLmRlZnMuY3VycmVudC5nZXQoaWQpO1xuICAgICAgICAgICAgICB0YWdOYW1lID0gZ2V0VGFnTmFtZShyZWYubm9kZU5hbWUpO1xuICAgICAgICAgICAgICByZWYgPSByZWFkW3RhZ05hbWVdLmNhbGwodGhpcywgcmVmLCB7fSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzY2VuZSA9IGdldFNjZW5lKHRoaXMpO1xuICAgICAgICAgICAgICByZWYgPSBzY2VuZS5nZXRCeUlkKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1ba2V5XSA9IHJlZjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWxlbVtrZXldID0gKC9ub25lL2kudGVzdCh2YWx1ZSkpID8gJ3RyYW5zcGFyZW50JyA6IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAgIGVsZW0uaWQgPSB2YWx1ZTtcbiAgICAgICAgICAvLyBPdmVyd3JpdHRlbiBpZCBmb3Igbm9uLWNvbmZsaWN0cyBvbiBzYW1lIHBhZ2UgU1ZHIGRvY3VtZW50c1xuICAgICAgICAgIC8vIFRPRE86IE1ha2UgdGhpcyBub24tZGVzY3J1Y3RpdmVcbiAgICAgICAgICBub2RlLmlkID0gdmFsdWUgKyAnLScgKyBDb25zdGFudHMuSWRlbnRpZmllciArICdhcHBsaWVkJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2xhc3MnOlxuICAgICAgICBjYXNlICdjbGFzc05hbWUnOlxuICAgICAgICAgIGVsZW0uY2xhc3NMaXN0ID0gdmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAneCc6XG4gICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgIHZhciBjYSA9IGVsZW0gaW5zdGFuY2VvZiBHcmFkaWVudDtcbiAgICAgICAgICB2YXIgY2IgPSBlbGVtIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnQ7XG4gICAgICAgICAgdmFyIGNjID0gZWxlbSBpbnN0YW5jZW9mIFJhZGlhbEdyYWRpZW50O1xuICAgICAgICAgIGlmIChjYSB8fCBjYiB8fCBjYykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgnW2EteiVdJCcpICYmICF2YWx1ZS5lbmRzV2l0aCgncHgnKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IFR3b0Vycm9yKFxuICAgICAgICAgICAgICAnb25seSBwaXhlbCB2YWx1ZXMgYXJlIHN1cHBvcnRlZCB3aXRoIHRoZSAnICsga2V5ICsgJyBhdHRyaWJ1dGUuJyk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW0udHJhbnNsYXRpb25ba2V5XSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb250LWZhbWlseSc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICBlbGVtLmZhbWlseSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9udC1zaXplJzpcbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgIGVsZW0uc2l6ZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9udC13ZWlnaHQnOlxuICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgZWxlbS53ZWlnaHQgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZvbnQtc3R5bGUnOlxuICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgZWxlbS5zdHlsZSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGV4dC1kZWNvcmF0aW9uJzpcbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgIGVsZW0uZGVjb3JhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGluZS1oZWlnaHQnOlxuICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgZWxlbS5sZWFkaW5nID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLnVwZGF0ZURlZnNDYWNoZVxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBub2RlIC0gVGhlIFNWRyBOb2RlIHdpdGggd2hpY2ggdG8gdXBkYXRlIHRoZSBkZWZzIGNhY2hlLlxuICAgKiBAcGFyYW0ge09iamVjdH0gT2JqZWN0IC0gVGhlIGRlZnMgY2FjaGUgdG8gYmUgdXBkYXRlZC5cbiAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZSB0aGUgY2FjaGUgb2YgY2hpbGRyZW4gb2YgPGRlZnMgLz4gdGFncy5cbiAgICovXG4gIHZhciB1cGRhdGVEZWZzQ2FjaGUgPSBmdW5jdGlvbihub2RlLCBkZWZzQ2FjaGUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBuID0gbm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgaWYgKCFuLmlkKSBjb250aW51ZTtcblxuICAgICAgdmFyIHRhZ05hbWUgPSBnZXRUYWdOYW1lKG5vZGUubm9kZU5hbWUpO1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICcjdGV4dCcpIGNvbnRpbnVlO1xuXG4gICAgICBkZWZzQ2FjaGUuYWRkKG4uaWQsIG4pO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldFNjZW5lXG4gICAqIEBwYXJhbSB7VHdvLlNoYXBlfSBub2RlIC0gVGhlIGN1cnJlbnRseSBhdmFpbGFibGUgb2JqZWN0IGluIHRoZSBzY2VuZWdyYXBoLlxuICAgKiBAcmV0dXJucyB7R3JvdXB9IC0gVGhlIGhpZ2hlc3Qgb3JkZXIge0BsaW5rIFR3by5Hcm91cH0gaW4gdGhlIHNjZW5lZ3JhcGguXG4gICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259XG4gICAqL1xuICB2YXIgZ2V0U2NlbmUgPSBmdW5jdGlvbihub2RlKSB7XG5cbiAgICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZS5zY2VuZTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMucmVhZFxuICAgKiBAcHJvcGVydHkge09iamVjdH0gcmVhZCAtIEEgbWFwIG9mIGZ1bmN0aW9ucyB0byByZWFkIGFueSBudW1iZXIgb2YgU1ZHIG5vZGUgdHlwZXMgYW5kIGNyZWF0ZSBUd28uanMgZXF1aXZhbGVudHMgb2YgdGhlbS4gUHJpbWFyaWx5IHVzZWQgYnkgdGhlIHtAbGluayBUd28jaW50ZXJwcmV0fSBtZXRob2QuXG4gICAqL1xuICB2YXIgcmVhZCA9IHtcblxuICAgIHN2ZzogZnVuY3Rpb24obm9kZSkge1xuXG4gICAgICB2YXIgZGVmcyA9IHJlYWQuZGVmcy5jdXJyZW50ID0gbmV3IFJlZ2lzdHJ5KCk7XG4gICAgICB2YXIgZWxlbWVudHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkZWZzJyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXBkYXRlRGVmc0NhY2hlKGVsZW1lbnRzW2ldLCBkZWZzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN2ZyA9IHJlYWQuZy5jYWxsKHRoaXMsIG5vZGUpO1xuICAgICAgLy8gdmFyIHZpZXdCb3ggPSBub2RlLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuXG4gICAgICBzdmcuZGVmcyA9IGRlZnM7ICAvLyBFeHBvcnQgb3V0IHRoZSA8ZGVmcyAvPiBmb3IgbGF0ZXIgdXNlXG4gICAgICAvLyBVdGlscy5hcHBseVN2Z1ZpZXdCb3goc3ZnLCB2aWV3Qm94KTtcblxuICAgICAgZGVsZXRlIHJlYWQuZGVmcy5jdXJyZW50O1xuXG4gICAgICByZXR1cm4gc3ZnO1xuXG4gICAgfSxcblxuICAgIGRlZnM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICB1c2U6IGZ1bmN0aW9uKG5vZGUsIHN0eWxlcykge1xuXG4gICAgICB2YXIgZXJyb3I7XG4gICAgICB2YXIgaHJlZiA9IG5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKTtcbiAgICAgIGlmICghaHJlZikge1xuICAgICAgICBlcnJvciA9IG5ldyBUd29FcnJvcignZW5jb3VudGVyZWQgPHVzZSAvPiB3aXRoIG5vIGhyZWYuJyk7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpZCA9IGhyZWYuc2xpY2UoMSk7XG4gICAgICBpZiAoIXJlYWQuZGVmcy5jdXJyZW50LmNvbnRhaW5zKGlkKSkge1xuICAgICAgICBlcnJvciA9IG5ldyBUd29FcnJvcihcbiAgICAgICAgICAndW5hYmxlIHRvIGZpbmQgZWxlbWVudCBmb3IgcmVmZXJlbmNlICcgKyBocmVmICsgJy4nKTtcbiAgICAgICAgY29uc29sZS53YXJuKGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRlbXBsYXRlID0gcmVhZC5kZWZzLmN1cnJlbnQuZ2V0KGlkKTtcbiAgICAgIHZhciBmdWxsTm9kZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIHZhciBvdmVyd3JpdGVBdHRycyA9IFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCcsICdocmVmJywgJ3hsaW5rOmhyZWYnXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgIHZhciBjYSA9IG92ZXJ3cml0ZUF0dHJzLmluY2x1ZGVzKGF0dHIubm9kZU5hbWUpO1xuICAgICAgICB2YXIgY2IgPSAhZnVsbE5vZGUuaGFzQXR0cmlidXRlKGF0dHIubm9kZU5hbWUpO1xuICAgICAgICBpZiAoY2EgfHwgY2IpIHtcbiAgICAgICAgICBmdWxsTm9kZS5zZXRBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSwgYXR0ci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRhZ05hbWUgPSBnZXRUYWdOYW1lKGZ1bGxOb2RlLm5vZGVOYW1lKTtcbiAgICAgIHJldHVybiByZWFkW3RhZ05hbWVdLmNhbGwodGhpcywgZnVsbE5vZGUsIHN0eWxlcyk7XG5cbiAgICB9LFxuXG4gICAgZzogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciBzdHlsZXM7XG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgZ3JvdXAsIHBhcmVudFN0eWxlcyk7XG5cbiAgICAgIHRoaXMuYWRkKGdyb3VwKTtcblxuICAgICAgLy8gU3dpdGNoZWQgdXAgb3JkZXIgdG8gaW5oZXJpdCBtb3JlIHNwZWNpZmljIHN0eWxlc1xuICAgICAgc3R5bGVzID0gZ2V0U3ZnU3R5bGVzLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbiA9IG5vZGUuY2hpbGROb2Rlc1tpXTtcbiAgICAgICAgdmFyIHRhZyA9IG4ubm9kZU5hbWU7XG4gICAgICAgIGlmICghdGFnKSByZXR1cm47XG5cbiAgICAgICAgdmFyIHRhZ05hbWUgPSBnZXRUYWdOYW1lKHRhZyk7XG5cbiAgICAgICAgaWYgKHRhZ05hbWUgaW4gcmVhZCkge1xuICAgICAgICAgIHZhciBvID0gcmVhZFt0YWdOYW1lXS5jYWxsKGdyb3VwLCBuLCBzdHlsZXMpO1xuICAgICAgICAgIGlmICghIW8gJiYgIW8ucGFyZW50KSB7XG4gICAgICAgICAgICBncm91cC5hZGQobyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBncm91cDtcblxuICAgIH0sXG5cbiAgICBwb2x5Z29uOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgICAgdmFyIHBvaW50cyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdwb2ludHMnKTtcblxuICAgICAgdmFyIHZlcnRzID0gW107XG4gICAgICBwb2ludHMucmVwbGFjZSgvKC0/W1xcZC5lRS1dKylbLHxcXHNdKC0/W1xcZC5lRS1dKykvZywgZnVuY3Rpb24obWF0Y2gsIHAxLCBwMikge1xuICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBBbmNob3IocGFyc2VGbG9hdChwMSksIHBhcnNlRmxvYXQocDIpKSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIHBvbHkgPSBuZXcgUGF0aCh2ZXJ0cywgdHJ1ZSkubm9TdHJva2UoKTtcbiAgICAgIHBvbHkuZmlsbCA9ICdibGFjayc7XG5cbiAgICAgIGFwcGx5U3ZnQXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUsIHBvbHksIHBhcmVudFN0eWxlcyk7XG5cbiAgICAgIHJldHVybiBwb2x5O1xuXG4gICAgfSxcblxuICAgIHBvbHlsaW5lOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcbiAgICAgIHZhciBwb2x5ID0gcmVhZC5wb2x5Z29uLmNhbGwodGhpcywgbm9kZSwgcGFyZW50U3R5bGVzKTtcbiAgICAgIHBvbHkuY2xvc2VkID0gZmFsc2U7XG4gICAgICByZXR1cm4gcG9seTtcbiAgICB9LFxuXG4gICAgcGF0aDogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciBwYXRoID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKTtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICAgIHZhciBjbG9zZWQgPSBmYWxzZSwgcmVsYXRpdmUgPSBmYWxzZTtcblxuICAgICAgaWYgKHBhdGgpIHtcblxuICAgICAgICAvLyBDcmVhdGUgYSBUd28uUGF0aCBmcm9tIHRoZSBwYXRocy5cblxuICAgICAgICB2YXIgY29vcmQgPSBuZXcgQW5jaG9yKCk7XG4gICAgICAgIHZhciBjb250cm9sLCBjb29yZHM7XG4gICAgICAgIHZhciBjb21tYW5kcyA9IHBhdGgubWF0Y2goL1thLWRmLXpdW15hLWRmLXpdKi9pZyk7XG4gICAgICAgIHZhciBsYXN0ID0gY29tbWFuZHMubGVuZ3RoIC0gMTtcblxuICAgICAgICAvLyBTcGxpdCB1cCBwb2x5YmV6aWVyc1xuXG4gICAgICAgIF8uZWFjaChjb21tYW5kcy5zbGljZSgwKSwgZnVuY3Rpb24oY29tbWFuZCwgaSkge1xuXG4gICAgICAgICAgdmFyIGl0ZW1zID0gY29tbWFuZC5zbGljZSgxKS50cmltKCkubWF0Y2gocmVnZXgucGF0aCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSBjb21tYW5kWzBdO1xuICAgICAgICAgIHZhciBsb3dlciA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB2YXIgYmluLCBqLCBsLCBjdCwgdGltZXMsIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGNvbW1hbmRzID0gW107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChsb3dlcikge1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICBjYXNlICd2JzpcbiAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBiaW4gPSAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICAgIGJpbiA9IDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gNCkge1xuICAgICAgICAgICAgICAgIGJpbiA9IDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDYpIHtcbiAgICAgICAgICAgICAgICBiaW4gPSA2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiA3KSB7XG4gICAgICAgICAgICAgICAgYmluID0gNztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIGhhdmUgYSBwb2x5YmV6aWVyLlxuICAgICAgICAgIGlmIChiaW4pIHtcblxuICAgICAgICAgICAgZm9yIChqID0gMCwgbCA9IGl0ZW1zLmxlbmd0aCwgdGltZXMgPSAwOyBqIDwgbDsgais9YmluKSB7XG5cbiAgICAgICAgICAgICAgY3QgPSB0eXBlO1xuICAgICAgICAgICAgICBpZiAodGltZXMgPiAwKSB7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgICBjdCA9ICdsJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlICdNJzpcbiAgICAgICAgICAgICAgICAgICAgY3QgPSAnTCc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3QgKyBpdGVtcy5zbGljZShqLCBqICsgYmluKS5qb2luKCcgJykpO1xuICAgICAgICAgICAgICB0aW1lcysrO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbW1hbmRzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShjb21tYW5kcywgcmVzdWx0KTtcblxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGNvbW1hbmRzLnB1c2goY29tbWFuZCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB2ZXJ0aWNlcyBmb3Igb3VyIFR3by5QYXRoXG5cbiAgICAgICAgXy5lYWNoKGNvbW1hbmRzLCBmdW5jdGlvbihjb21tYW5kLCBpKSB7XG5cbiAgICAgICAgICB2YXIgcmVzdWx0LCB4LCB5O1xuICAgICAgICAgIHZhciB0eXBlID0gY29tbWFuZFswXTtcbiAgICAgICAgICB2YXIgbG93ZXIgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgICAgICBjb29yZHMgPSBjb21tYW5kLnNsaWNlKDEpLnRyaW0oKS5tYXRjaChyZWdleC5wYXRoKTtcbiAgICAgICAgICByZWxhdGl2ZSA9IHR5cGUgPT09IGxvd2VyO1xuXG4gICAgICAgICAgdmFyIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgcmVmbGVjdGlvbjtcblxuICAgICAgICAgIHN3aXRjaCAobG93ZXIpIHtcblxuICAgICAgICAgICAgY2FzZSAneic6XG4gICAgICAgICAgICAgIGlmIChpID49IGxhc3QpIHtcbiAgICAgICAgICAgICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHggPSBjb29yZC54O1xuICAgICAgICAgICAgICAgIHkgPSBjb29yZC55O1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBbmNob3IoXG4gICAgICAgICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIENvbW1hbmRzLmNsb3NlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGNvb3JkIGJlIHRoZSBsYXN0IGBtYCBjb21tYW5kXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHBvaW50cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgaWYgKC9tL2kudGVzdChwb2ludC5jb21tYW5kKSkge1xuICAgICAgICAgICAgICAgICAgICBjb29yZCA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgY2FzZSAnbCc6XG5cbiAgICAgICAgICAgICAgY29udHJvbCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICB4ID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xuICAgICAgICAgICAgICB5ID0gcGFyc2VGbG9hdChjb29yZHNbMV0pO1xuXG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBbmNob3IoXG4gICAgICAgICAgICAgICAgeCwgeSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAvbS9pLnRlc3QobG93ZXIpID8gQ29tbWFuZHMubW92ZSA6IENvbW1hbmRzLmxpbmVcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkU2VsZihjb29yZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyByZXN1bHQuY29udHJvbHMubGVmdC5jb3B5KHJlc3VsdCk7XG4gICAgICAgICAgICAgIC8vIHJlc3VsdC5jb250cm9scy5yaWdodC5jb3B5KHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgY29vcmQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuXG4gICAgICAgICAgICAgIHZhciBhID0gL2gvaS50ZXN0KGxvd2VyKSA/ICd4JyA6ICd5JztcbiAgICAgICAgICAgICAgdmFyIGIgPSAveC9pLnRlc3QoYSkgPyAneScgOiAneCc7XG5cbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFuY2hvcihcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBDb21tYW5kcy5saW5lXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJlc3VsdFthXSA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcbiAgICAgICAgICAgICAgcmVzdWx0W2JdID0gY29vcmRbYl07XG5cbiAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2FdICs9IGNvb3JkW2FdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcmVzdWx0LmNvbnRyb2xzLmxlZnQuY29weShyZXN1bHQpO1xuICAgICAgICAgICAgICAvLyByZXN1bHQuY29udHJvbHMucmlnaHQuY29weShyZXN1bHQpO1xuXG4gICAgICAgICAgICAgIGNvb3JkID0gcmVzdWx0O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICBjYXNlICdzJzpcblxuICAgICAgICAgICAgICB4MSA9IGNvb3JkLng7XG4gICAgICAgICAgICAgIHkxID0gY29vcmQueTtcblxuICAgICAgICAgICAgICBpZiAoIWNvbnRyb2wpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sID0gbmV3IFZlY3RvcigpOy8vLmNvcHkoY29vcmQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKC9jL2kudGVzdChsb3dlcikpIHtcblxuICAgICAgICAgICAgICAgIHgyID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xuICAgICAgICAgICAgICAgIHkyID0gcGFyc2VGbG9hdChjb29yZHNbMV0pO1xuICAgICAgICAgICAgICAgIHgzID0gcGFyc2VGbG9hdChjb29yZHNbMl0pO1xuICAgICAgICAgICAgICAgIHkzID0gcGFyc2VGbG9hdChjb29yZHNbM10pO1xuICAgICAgICAgICAgICAgIHg0ID0gcGFyc2VGbG9hdChjb29yZHNbNF0pO1xuICAgICAgICAgICAgICAgIHk0ID0gcGFyc2VGbG9hdChjb29yZHNbNV0pO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgcmVmbGVjdGlvbiBjb250cm9sIHBvaW50IGZvciBwcm9wZXIgeDIsIHkyXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVzaW9uLlxuXG4gICAgICAgICAgICAgICAgcmVmbGVjdGlvbiA9IGdldFJlZmxlY3Rpb24oY29vcmQsIGNvbnRyb2wsIHJlbGF0aXZlKTtcblxuICAgICAgICAgICAgICAgIHgyID0gcmVmbGVjdGlvbi54O1xuICAgICAgICAgICAgICAgIHkyID0gcmVmbGVjdGlvbi55O1xuICAgICAgICAgICAgICAgIHgzID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xuICAgICAgICAgICAgICAgIHkzID0gcGFyc2VGbG9hdChjb29yZHNbMV0pO1xuICAgICAgICAgICAgICAgIHg0ID0gcGFyc2VGbG9hdChjb29yZHNbMl0pO1xuICAgICAgICAgICAgICAgIHk0ID0gcGFyc2VGbG9hdChjb29yZHNbM10pO1xuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB4MiArPSB4MTtcbiAgICAgICAgICAgICAgICB5MiArPSB5MTtcbiAgICAgICAgICAgICAgICB4MyArPSB4MTtcbiAgICAgICAgICAgICAgICB5MyArPSB5MTtcbiAgICAgICAgICAgICAgICB4NCArPSB4MTtcbiAgICAgICAgICAgICAgICB5NCArPSB5MTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghXy5pc09iamVjdChjb29yZC5jb250cm9scykpIHtcbiAgICAgICAgICAgICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKGNvb3JkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvb3JkLmNvbnRyb2xzLnJpZ2h0LnNldCh4MiAtIGNvb3JkLngsIHkyIC0gY29vcmQueSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBbmNob3IoXG4gICAgICAgICAgICAgICAgeDQsIHk0LFxuICAgICAgICAgICAgICAgIHgzIC0geDQsIHkzIC0geTQsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgQ29tbWFuZHMuY3VydmVcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBjb29yZCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHJlc3VsdC5jb250cm9scy5sZWZ0O1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIGNhc2UgJ3EnOlxuXG4gICAgICAgICAgICAgIHgxID0gY29vcmQueDtcbiAgICAgICAgICAgICAgeTEgPSBjb29yZC55O1xuXG4gICAgICAgICAgICAgIGlmICghY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBuZXcgVmVjdG9yKCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoL3EvaS50ZXN0KGxvd2VyKSkge1xuXG4gICAgICAgICAgICAgICAgeDIgPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XG4gICAgICAgICAgICAgICAgeTIgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICAgICAgeDMgPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XG4gICAgICAgICAgICAgICAgeTMgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICAgICAgeDQgPSBwYXJzZUZsb2F0KGNvb3Jkc1syXSk7XG4gICAgICAgICAgICAgICAgeTQgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHJlZmxlY3Rpb24gPSBnZXRSZWZsZWN0aW9uKGNvb3JkLCBjb250cm9sLCByZWxhdGl2ZSk7XG5cbiAgICAgICAgICAgICAgICB4MiA9IHJlZmxlY3Rpb24ueDtcbiAgICAgICAgICAgICAgICB5MiA9IHJlZmxlY3Rpb24ueTtcbiAgICAgICAgICAgICAgICB4MyA9IHJlZmxlY3Rpb24ueDtcbiAgICAgICAgICAgICAgICB5MyA9IHJlZmxlY3Rpb24ueTtcbiAgICAgICAgICAgICAgICB4NCA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcbiAgICAgICAgICAgICAgICB5NCA9IHBhcnNlRmxvYXQoY29vcmRzWzFdKTtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgeDIgKz0geDE7XG4gICAgICAgICAgICAgICAgeTIgKz0geTE7XG4gICAgICAgICAgICAgICAgeDMgKz0geDE7XG4gICAgICAgICAgICAgICAgeTMgKz0geTE7XG4gICAgICAgICAgICAgICAgeDQgKz0geDE7XG4gICAgICAgICAgICAgICAgeTQgKz0geTE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIV8uaXNPYmplY3QoY29vcmQuY29udHJvbHMpKSB7XG4gICAgICAgICAgICAgICAgQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyhjb29yZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb29yZC5jb250cm9scy5yaWdodC5zZXQoXG4gICAgICAgICAgICAgICAgKHgyIC0gY29vcmQueCkgKiAwLjMzLCAoeTIgLSBjb29yZC55KSAqIDAuMzMpO1xuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQW5jaG9yKFxuICAgICAgICAgICAgICAgIHg0LCB5NCxcbiAgICAgICAgICAgICAgICB4MyAtIHg0LCB5MyAtIHk0LFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIENvbW1hbmRzLmN1cnZlXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgY29vcmQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSByZXN1bHQuY29udHJvbHMubGVmdDtcblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnYSc6XG5cbiAgICAgICAgICAgICAgeDEgPSBjb29yZC54O1xuICAgICAgICAgICAgICB5MSA9IGNvb3JkLnk7XG5cbiAgICAgICAgICAgICAgdmFyIHJ4ID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xuICAgICAgICAgICAgICB2YXIgcnkgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICAgIHZhciB4QXhpc1JvdGF0aW9uID0gcGFyc2VGbG9hdChjb29yZHNbMl0pOy8vICogUEkgLyAxODA7XG4gICAgICAgICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XG4gICAgICAgICAgICAgIHZhciBzd2VlcEZsYWcgPSBwYXJzZUZsb2F0KGNvb3Jkc1s0XSk7XG5cbiAgICAgICAgICAgICAgeDQgPSBwYXJzZUZsb2F0KGNvb3Jkc1s1XSk7XG4gICAgICAgICAgICAgIHk0ID0gcGFyc2VGbG9hdChjb29yZHNbNl0pO1xuXG4gICAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHg0ICs9IHgxO1xuICAgICAgICAgICAgICAgIHk0ICs9IHkxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGFuY2hvciA9IG5ldyBBbmNob3IoeDQsIHk0KTtcbiAgICAgICAgICAgICAgYW5jaG9yLmNvbW1hbmQgPSBDb21tYW5kcy5hcmM7XG4gICAgICAgICAgICAgIGFuY2hvci5yeCA9IHJ4O1xuICAgICAgICAgICAgICBhbmNob3IucnkgPSByeTtcbiAgICAgICAgICAgICAgYW5jaG9yLnhBeGlzUm90YXRpb24gPSB4QXhpc1JvdGF0aW9uO1xuICAgICAgICAgICAgICBhbmNob3IubGFyZ2VBcmNGbGFnID0gbGFyZ2VBcmNGbGFnO1xuICAgICAgICAgICAgICBhbmNob3Iuc3dlZXBGbGFnID0gc3dlZXBGbGFnO1xuXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGFuY2hvcjtcblxuICAgICAgICAgICAgICBjb29yZCA9IGFuY2hvcjtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdChyZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9pbnRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgIH1cblxuICAgICAgcGF0aCA9IG5ldyBQYXRoKHBvaW50cywgY2xvc2VkLCB1bmRlZmluZWQsIHRydWUpLm5vU3Ryb2tlKCk7XG4gICAgICBwYXRoLmZpbGwgPSAnYmxhY2snO1xuXG4gICAgICB2YXIgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRydWUpO1xuXG4gICAgICAvLyBDZW50ZXIgb2JqZWN0cyB0byBzdGF5IGNvbnNpc3RlbnRcbiAgICAgIC8vIHdpdGggdGhlIHJlc3Qgb2YgdGhlIFR3by5qcyBBUEkuXG4gICAgICByZWN0LmNlbnRyb2lkID0ge1xuICAgICAgICB4OiByZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMixcbiAgICAgICAgeTogcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDJcbiAgICAgIH07XG5cbiAgICAgIF8uZWFjaChwYXRoLnZlcnRpY2VzLCBmdW5jdGlvbih2KSB7XG4gICAgICAgIHYuc3ViU2VsZihyZWN0LmNlbnRyb2lkKTtcbiAgICAgIH0pO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBwYXRoLCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICBwYXRoLnRyYW5zbGF0aW9uLmFkZFNlbGYocmVjdC5jZW50cm9pZCk7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuXG4gICAgfSxcblxuICAgIGNpcmNsZTogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnY3gnKSk7XG4gICAgICB2YXIgeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2N5JykpO1xuICAgICAgdmFyIHIgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyJykpO1xuXG4gICAgICB2YXIgY2lyY2xlID0gbmV3IENpcmNsZSgwLCAwLCByKS5ub1N0cm9rZSgpO1xuICAgICAgY2lyY2xlLmZpbGwgPSAnYmxhY2snO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBjaXJjbGUsIHBhcmVudFN0eWxlcyk7XG5cbiAgICAgIGNpcmNsZS50cmFuc2xhdGlvbi54ID0geDtcbiAgICAgIGNpcmNsZS50cmFuc2xhdGlvbi55ID0geTtcblxuICAgICAgcmV0dXJuIGNpcmNsZTtcblxuICAgIH0sXG5cbiAgICBlbGxpcHNlOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdjeCcpKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnY3knKSk7XG4gICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyeCcpKTtcbiAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyeScpKTtcblxuICAgICAgdmFyIGVsbGlwc2UgPSBuZXcgRWxsaXBzZSgwLCAwLCB3aWR0aCwgaGVpZ2h0KS5ub1N0cm9rZSgpO1xuICAgICAgZWxsaXBzZS5maWxsID0gJ2JsYWNrJztcblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgZWxsaXBzZSwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgZWxsaXBzZS50cmFuc2xhdGlvbi54ID0geDtcbiAgICAgIGVsbGlwc2UudHJhbnNsYXRpb24ueSA9IHk7XG5cbiAgICAgIHJldHVybiBlbGxpcHNlO1xuXG4gICAgfSxcblxuICAgIHJlY3Q6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuXG4gICAgICB2YXIgcnggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyeCcpKTtcbiAgICAgIHZhciByeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3J5JykpO1xuXG4gICAgICBpZiAoIV8uaXNOYU4ocngpIHx8ICFfLmlzTmFOKHJ5KSkge1xuICAgICAgICByZXR1cm4gcmVhZFsncm91bmRlZC1yZWN0J10obm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtcblxuICAgICAgdmFyIHcyID0gd2lkdGggLyAyO1xuICAgICAgdmFyIGgyID0gaGVpZ2h0IC8gMjtcblxuICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIHdpZHRoLCBoZWlnaHQpXG4gICAgICAgIC5ub1N0cm9rZSgpO1xuICAgICAgcmVjdC5maWxsID0gJ2JsYWNrJztcblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgcmVjdCwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgLy8gRm9yIHJlY3RhbmdsZXMsICh4LCB5KSBpcyB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZSByYXRoZXIgdGhhbiB0aGUgdG9wXG4gICAgICAvLyBsZWZ0IGNvcm5lci5cbiAgICAgIHJlY3QudHJhbnNsYXRpb24ueCArPSB3MjtcbiAgICAgIHJlY3QudHJhbnNsYXRpb24ueSArPSBoMjtcblxuICAgICAgcmV0dXJuIHJlY3Q7XG5cbiAgICB9LFxuXG4gICAgJ3JvdW5kZWQtcmVjdCc6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuXG4gICAgICB2YXIgcnggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyeCcpKSB8fCAwO1xuICAgICAgdmFyIHJ5ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgncnknKSkgfHwgMDtcblxuICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XG4gICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuXG4gICAgICB2YXIgdzIgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaDIgPSBoZWlnaHQgLyAyO1xuICAgICAgdmFyIHJhZGl1cyA9IG5ldyBWZWN0b3IocngsIHJ5KTtcblxuICAgICAgdmFyIHJlY3QgPSBuZXcgUm91bmRlZFJlY3RhbmdsZSgwLCAwLCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpXG4gICAgICAgIC5ub1N0cm9rZSgpO1xuICAgICAgcmVjdC5maWxsID0gJ2JsYWNrJztcblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgcmVjdCwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgLy8gRm9yIHJlY3RhbmdsZXMsICh4LCB5KSBpcyB0aGUgY2VudGVyIG9mIHRoZSBzaGFwZSByYXRoZXIgdGhhbiB0aGUgdG9wXG4gICAgICAvLyBsZWZ0IGNvcm5lci5cbiAgICAgIHJlY3QudHJhbnNsYXRpb24ueCArPSB3MjtcbiAgICAgIHJlY3QudHJhbnNsYXRpb24ueSArPSBoMjtcblxuICAgICAgcmV0dXJuIHJlY3Q7XG5cbiAgICB9LFxuXG4gICAgbGluZTogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciB4MSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3gxJykpO1xuICAgICAgdmFyIHkxID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneTEnKSk7XG4gICAgICB2YXIgeDIgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4MicpKTtcbiAgICAgIHZhciB5MiA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3kyJykpO1xuXG4gICAgICB2YXIgbGluZSA9IG5ldyBMaW5lKHgxLCB5MSwgeDIsIHkyKS5ub0ZpbGwoKTtcblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgbGluZSwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgcmV0dXJuIGxpbmU7XG5cbiAgICB9LFxuXG4gICAgbGluZWFyZ3JhZGllbnQ6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuXG4gICAgICB2YXIgeDEgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4MScpKTtcbiAgICAgIHZhciB5MSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3kxJykpO1xuICAgICAgdmFyIHgyID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneDInKSk7XG4gICAgICB2YXIgeTIgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd5MicpKTtcblxuICAgICAgdmFyIG94ID0gKHgyICsgeDEpIC8gMjtcbiAgICAgIHZhciBveSA9ICh5MiArIHkxKSAvIDI7XG5cbiAgICAgIHZhciBzdG9wcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdvZmZzZXQnKTtcbiAgICAgICAgaWYgKC8lL2lnLnRlc3Qob2Zmc2V0KSkge1xuICAgICAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0LnJlcGxhY2UoLyUvaWcsICcnKSkgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQpO1xuXG4gICAgICAgIHZhciBjb2xvciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicpO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnc3RvcC1vcGFjaXR5Jyk7XG4gICAgICAgIHZhciBzdHlsZSA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICB2YXIgbWF0Y2hlcztcbiAgICAgICAgaWYgKGNvbG9yID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IHN0eWxlID8gc3R5bGUubWF0Y2goL3N0b3AtY29sb3I6XFxzPyhbI2EtZkEtRjAtOV0qKS8pIDogZmFsc2U7XG4gICAgICAgICAgY29sb3IgPSBtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMSA/IG1hdGNoZXNbMV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3BhY2l0eSA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoZXMgPSBzdHlsZSA/IHN0eWxlLm1hdGNoKC9zdG9wLW9wYWNpdHk6XFxzPyhbMC05Li1dKikvKSA6IGZhbHNlO1xuICAgICAgICAgIG9wYWNpdHkgPSBtYXRjaGVzICYmIG1hdGNoZXMubGVuZ3RoID4gMSA/IHBhcnNlRmxvYXQobWF0Y2hlc1sxXSkgOiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wYWNpdHkgPSBwYXJzZUZsb2F0KG9wYWNpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RvcHMucHVzaChuZXcgU3RvcChvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KSk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IExpbmVhckdyYWRpZW50KHgxIC0gb3gsIHkxIC0gb3ksIHgyIC0gb3gsXG4gICAgICAgIHkyIC0gb3ksIHN0b3BzKTtcblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgZ3JhZGllbnQsIHBhcmVudFN0eWxlcyk7XG5cbiAgICAgIHJldHVybiBncmFkaWVudDtcblxuICAgIH0sXG5cbiAgICByYWRpYWxncmFkaWVudDogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciBjeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2N4JykpIHx8IDA7XG4gICAgICB2YXIgY3kgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdjeScpKSB8fCAwO1xuICAgICAgdmFyIHIgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyJykpO1xuXG4gICAgICB2YXIgZnggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdmeCcpKTtcbiAgICAgIHZhciBmeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2Z5JykpO1xuXG4gICAgICBpZiAoXy5pc05hTihmeCkpIHtcbiAgICAgICAgZnggPSBjeDtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNOYU4oZnkpKSB7XG4gICAgICAgIGZ5ID0gY3k7XG4gICAgICB9XG5cbiAgICAgIHZhciBveCA9IE1hdGguYWJzKGN4ICsgZngpIC8gMjtcbiAgICAgIHZhciBveSA9IE1hdGguYWJzKGN5ICsgZnkpIC8gMjtcblxuICAgICAgdmFyIHN0b3BzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpO1xuICAgICAgICBpZiAoLyUvaWcudGVzdChvZmZzZXQpKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQucmVwbGFjZSgvJS9pZywgJycpKSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJyk7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICAgICAgdmFyIHN0eWxlID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaGVzID0gc3R5bGUgPyBzdHlsZS5tYXRjaCgvc3RvcC1jb2xvcjpcXHM/KFsjYS1mQS1GMC05XSopLykgOiBmYWxzZTtcbiAgICAgICAgICBjb2xvciA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcGFjaXR5ID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IHN0eWxlID8gc3R5bGUubWF0Y2goL3N0b3Atb3BhY2l0eTpcXHM/KFswLTkuLV0qKS8pIDogZmFsc2U7XG4gICAgICAgICAgb3BhY2l0eSA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxID8gcGFyc2VGbG9hdChtYXRjaGVzWzFdKSA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BhY2l0eSA9IHBhcnNlRmxvYXQob3BhY2l0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdG9wcy5wdXNoKG5ldyBTdG9wKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgUmFkaWFsR3JhZGllbnQoY3ggLSBveCwgY3kgLSBveSwgcixcbiAgICAgICAgc3RvcHMsIGZ4IC0gb3gsIGZ5IC0gb3kpO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBncmFkaWVudCwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuXG4gICAgfSxcblxuICAgIHRleHQ6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuXG4gICAgICB2YXIgYWxpZ25tZW50ID0gZ2V0QWxpZ25tZW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicpKSB8fCAnbGVmdCc7XG4gICAgICB2YXIgYmFzZWxpbmUgPSBnZXRCYXNlbGluZShub2RlKSB8fCAnYmFzZWxpbmUnO1xuICAgICAgdmFyIG1lc3NhZ2UgPSBub2RlLnRleHRDb250ZW50O1xuXG4gICAgICB2YXIgdGV4dCA9IG5ldyBUZXh0KG1lc3NhZ2UpO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCB0ZXh0LCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICB0ZXh0LmFsaWdubWVudCA9IGFsaWdubWVudDtcbiAgICAgIHRleHQuYmFzZWxpbmUgPSBiYXNlbGluZTtcblxuICAgICAgcmV0dXJuIHRleHQ7XG5cbiAgICB9LFxuXG4gICAgY2xpcHBhdGg6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuICAgICAgaWYgKHJlYWQuZGVmcy5jdXJyZW50ICYmICFyZWFkLmRlZnMuY3VycmVudC5jb250YWlucyhub2RlLmlkKSkge1xuICAgICAgICByZWFkLmRlZnMuY3VycmVudC5hZGQobm9kZS5pZCwgbm9kZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgaW1hZ2U6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuXG4gICAgICB2YXIgaHJlZiA9IG5vZGUuZ2V0QXR0cmlidXRlKCdocmVmJykgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoJ3hsaW5rOmhyZWYnKTtcbiAgICAgIGlmICghaHJlZikge1xuICAgICAgICB2YXIgZXJyb3IgPSBuZXcgVHdvRXJyb3IoJ2VuY291bnRlcmVkIDxpbWFnZSAvPiB3aXRoIG5vIGhyZWYuJyk7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneCcpKSB8fCAwO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd5JykpIHx8IDA7XG4gICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG5cbiAgICAgIHZhciBzcHJpdGUgPSBuZXcgU3ByaXRlKGhyZWYsIHgsIHkpO1xuXG4gICAgICBpZiAoIV8uaXNOYU4od2lkdGgpKSB7XG4gICAgICAgIHNwcml0ZS53aWR0aCA9IHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKCFfLmlzTmFOKGhlaWdodCkpIHtcbiAgICAgICAgc3ByaXRlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgc3ByaXRlLCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICByZXR1cm4gc3ByaXRlO1xuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMueGhyXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcmV0dXJucyB7WE1MSHR0cFJlcXVlc3R9IFRoZSBjb25zdHJ1Y3RlZCBhbmQgY2FsbGVkIFhIUiByZXF1ZXN0LlxuICAgKiBAZGVzY3JpcHRpb24gQ2Fub25pY2FsIG1ldGhvZCB0byBpbml0aWF0ZSBgR0VUYCByZXF1ZXN0cyBpbiB0aGUgYnJvd3Nlci4gTWFpbmx5IHVzZWQgYnkge0BsaW5rIFR3byNsb2FkfSBtZXRob2QuXG4gICAqL1xuICBmdW5jdGlvbiB4aHIocGF0aCwgY2FsbGJhY2spIHtcblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgcGF0aCk7XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQgJiYgeGhyLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNhbGxiYWNrKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB4aHIuc2VuZCgpO1xuICAgIHJldHVybiB4aHI7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlJlY3RhbmdsZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xTdHJpbmdbXXxUd28uVGV4dHVyZXxUd28uVGV4dHVyZVtdfSBwYXRocyAtIEEgbGlzdCBvZiBVUkxzIG9yIHtAbGluayBUd28uVGV4dHVyZX1zLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW294PTBdIC0gVGhlIGluaXRpYWwgYHhgIHBvc2l0aW9uIG9mIHRoZSBUd28uSW1hZ2VTZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtveT0wXSAtIFRoZSBpbml0aWFsIGB5YCBwb3NpdGlvbiBvZiB0aGUgVHdvLkltYWdlU2VxdWVuY2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJhbWVSYXRlPTMwXSAtIFRoZSBmcmFtZSByYXRlIGF0IHdoaWNoIHRoZSBpbWFnZXMgc2hvdWxkIHBsYXliYWNrIGF0LlxuICAgKiBAZGVzY3JpcHRpb24gQSBjb252ZW5pZW50IHBhY2thZ2UgdG8gZGlzcGxheSBzdGlsbCBvciBhbmltYXRlZCBpbWFnZXMgb3JnYW5pemVkIGFzIGEgc2VyaWVzIG9mIHN0aWxsIGltYWdlcy5cbiAgICovXG4gIGZ1bmN0aW9uIEltYWdlU2VxdWVuY2UocGF0aHMsIG94LCBveSwgZnJhbWVSYXRlKSB7XG5cbiAgICAvLyBOb3QgdXNpbmcgZGVmYXVsdCBjb25zdHJ1Y3RvciBvZiBSZWN0YW5nbGUgZHVlIHRvIG9kZCBgYmVnaW5uaW5nYCAvIGBlbmRpbmdgIGJlaGF2aW9yLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjEvdHdvLmpzL2lzc3Vlcy8zODNcbiAgICBQYXRoLmNhbGwodGhpcywgW1xuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpXG4gICAgXSwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXMgPSBJbWFnZVNlcXVlbmNlLkZsYWdUZXh0dXJlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmJpbmRUZXh0dXJlcyA9IEltYWdlU2VxdWVuY2UuQmluZFRleHR1cmVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIudW5iaW5kVGV4dHVyZXMgPSBJbWFnZVNlcXVlbmNlLlVuYmluZFRleHR1cmVzLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLm5vU3Ryb2tlKCk7XG4gICAgdGhpcy5ub0ZpbGwoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI3RleHR1cmVzXG4gICAgICogQHByb3BlcnR5IHtUd28uVGV4dHVyZVtdfSAtIEEgbGlzdCBvZiB0ZXh0dXJlcyB0byBiZSB1c2VkIGFzIGZyYW1lcyBmb3IgYW5pbWF0aW5nIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxuICAgICAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KHBhdGhzKSkge1xuICAgICAgdGhpcy50ZXh0dXJlcyA9IHBhdGhzLm1hcChJbWFnZVNlcXVlbmNlLkdlbmVyYXRlVGV4dHVyZS5iaW5kKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYganVzdCBhIHNpbmdsZSBwYXRoIGNvbnZlcnQgaW50byBhIHNpbmdsZSBUd28uVGV4dHVyZVxuICAgICAgdGhpcy50ZXh0dXJlcyA9IFtJbWFnZVNlcXVlbmNlLkdlbmVyYXRlVGV4dHVyZShwYXRocyldO1xuICAgIH1cblxuICAgIHRoaXMub3JpZ2luID0gbmV3IFZlY3RvcigpO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgdGhpcy50cmFuc2xhdGlvbi5zZXQob3ggfHwgMCwgb3kgfHwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNmcmFtZVJhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgbnVtYmVyIG9mIGZyYW1lcyB0byBhbmltYXRlIGFnYWluc3QgcGVyIHNlY29uZC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGZyYW1lUmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gZnJhbWVSYXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZyYW1lUmF0ZSA9IEltYWdlU2VxdWVuY2UuRGVmYXVsdEZyYW1lUmF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNpbmRleFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCB0aWxlIG9mIHRoZSBzcHJpdGUgdG8gZGlzcGxheS4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSAwO1xuXG4gIH1cblxuICBfLmV4dGVuZChJbWFnZVNlcXVlbmNlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFtcbiAgICAgICdmcmFtZVJhdGUnLFxuICAgICAgJ2luZGV4J1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5EZWZhdWx0RnJhbWVSYXRlXG4gICAgICogQHByb3BlcnR5IFRoZSBkZWZhdWx0IGZyYW1lIHJhdGUgdGhhdCB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2UjZnJhbWVSYXRlfSBpcyBzZXQgdG8gd2hlbiBpbnN0YW50aWF0ZWQuXG4gICAgICovXG4gICAgRGVmYXVsdEZyYW1lUmF0ZTogMzAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5GbGFnVGV4dHVyZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgdGV4dHVyZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxuICAgICAqL1xuICAgIEZsYWdUZXh0dXJlczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9mbGFnVGV4dHVyZXMgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5CaW5kVGV4dHVyZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBrbm93IHRleHR1cmVzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgQmluZFRleHR1cmVzOiBmdW5jdGlvbihpdGVtcykge1xuXG4gICAgICB2YXIgaSA9IGl0ZW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaXRlbXNbaV0uYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXMoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5VbmJpbmRWZXJ0aWNlc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IGtub3cgdGV4dHVyZXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgVW5iaW5kVGV4dHVyZXM6IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cbiAgICAgIHZhciBpID0gaXRlbXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpdGVtc1tpXS51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1RleHR1cmVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1RleHR1cmVzKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCBvciBpbmhlcml0IHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmopIHtcblxuICAgICAgUmVjdGFuZ2xlLk1ha2VPYnNlcnZhYmxlKG9iaik7XG4gICAgICBfLmVhY2goSW1hZ2VTZXF1ZW5jZS5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iaik7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICd0ZXh0dXJlcycsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odGV4dHVyZXMpIHtcblxuICAgICAgICAgIHZhciBiaW5kVGV4dHVyZXMgPSB0aGlzLl9yZW5kZXJlci5iaW5kVGV4dHVyZXM7XG4gICAgICAgICAgdmFyIHVuYmluZFRleHR1cmVzID0gdGhpcy5fcmVuZGVyZXIudW5iaW5kVGV4dHVyZXM7XG5cbiAgICAgICAgICAvLyBSZW1vdmUgcHJldmlvdXMgbGlzdGVuZXJzXG4gICAgICAgICAgaWYgKHRoaXMuX3RleHR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLl90ZXh0dXJlc1xuICAgICAgICAgICAgICAudW5iaW5kKEV2ZW50cy5UeXBlcy5pbnNlcnQsIGJpbmRUZXh0dXJlcylcbiAgICAgICAgICAgICAgLnVuYmluZChFdmVudHMuVHlwZXMucmVtb3ZlLCB1bmJpbmRUZXh0dXJlcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQ3JlYXRlIG5ldyBDb2xsZWN0aW9uIHdpdGggY29weSBvZiB2ZXJ0aWNlc1xuICAgICAgICAgIHRoaXMuX3RleHR1cmVzID0gbmV3IENvbGxlY3Rpb24oKHRleHR1cmVzIHx8IFtdKS5zbGljZSgwKSk7XG5cbiAgICAgICAgICAvLyBMaXN0ZW4gZm9yIENvbGxlY3Rpb24gY2hhbmdlcyBhbmQgYmluZCAvIHVuYmluZFxuICAgICAgICAgIHRoaXMuX3RleHR1cmVzXG4gICAgICAgICAgICAuYmluZChFdmVudHMuVHlwZXMuaW5zZXJ0LCBiaW5kVGV4dHVyZXMpXG4gICAgICAgICAgICAuYmluZChFdmVudHMuVHlwZXMucmVtb3ZlLCB1bmJpbmRUZXh0dXJlcyk7XG5cbiAgICAgICAgICAvLyBCaW5kIEluaXRpYWwgVGV4dHVyZXNcbiAgICAgICAgICBiaW5kVGV4dHVyZXModGhpcy5fdGV4dHVyZXMpO1xuXG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UuR2VuZXJhdGVUZXh0dXJlXG4gICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gLSBTaG9ydGhhbmQgZnVuY3Rpb24gdG8gcHJlcGFyZSBzb3VyY2UgaW1hZ2UgbWF0ZXJpYWwgaW50byByZWFkYWJsZSBmb3JtYXQgYnkge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xUd28uVGV4dHVyZX0gdGV4dHVyZU9yU3RyaW5nIC0gVGhlIHRleHR1cmUgb3Igc3RyaW5nIHRvIGNyZWF0ZSBhIHtAbGluayBUd28uVGV4dHVyZX0gZnJvbS5cbiAgICAgKiBAZGVzY3JpcHRpb24gRnVuY3Rpb24gdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gdG8gcGFyc2UgYXJndW1lbnRzIGFuZCByZXR1cm4ge0BsaW5rIFR3by5UZXh0dXJlfXMuXG4gICAgICogQHJldHVybnMge1R3by5UZXh0dXJlfVxuICAgICAqL1xuICAgIEdlbmVyYXRlVGV4dHVyZTogZnVuY3Rpb24ob2JqKSB7XG4gICAgICBpZiAob2JqIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV3IFRleHR1cmUob2JqKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoSW1hZ2VTZXF1ZW5jZS5wcm90b3R5cGUsIFJlY3RhbmdsZS5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBJbWFnZVNlcXVlbmNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2ZsYWdUZXh0dXJlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI3RleHR1cmVzfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnVGV4dHVyZXM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2ZsYWdGcmFtZVJhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSNmcmFtZVJhdGV9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnRnJhbWVSYXRlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19mbGFnSW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSNpbmRleH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdJbmRleDogZmFsc2UsXG5cbiAgICAvLyBQcml2YXRlIHZhcmlhYmxlc1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2Ftb3VudFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIG9mIGZyYW1lcyBmb3IgYSBnaXZlbiB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxuICAgICAqL1xuICAgIF9hbW91bnQ6IDEsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfZHVyYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIE51bWJlciBvZiBtaWxsaXNlY29uZHMgYSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxuICAgICAqL1xuICAgIF9kdXJhdGlvbjogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19pbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGN1cnJlbnQgZnJhbWUgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gaXMgY3VycmVudGx5IGRpc3BsYXlpbmcuXG4gICAgICovXG4gICAgX2luZGV4OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX3N0YXJ0VGltZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtNaWxsaXNlY29uZHN9IC0gRXBvY2ggdGltZSBpbiBtaWxsaXNlY29uZHMgb2Ygd2hlbiB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBzdGFydGVkLlxuICAgICAqL1xuICAgIF9zdGFydFRpbWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfcGxheWluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpY3RhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gaXMgYW5pbWF0aW5nIG9yIG5vdC5cbiAgICAgKi9cbiAgICBfcGxheWluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfZmlyc3RGcmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGZyYW1lIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IHNob3VsZCBzdGFydCB3aXRoLlxuICAgICAqL1xuICAgIF9maXJzdEZyYW1lOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2xhc3RGcmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGZyYW1lIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IHNob3VsZCBlbmQgd2l0aC5cbiAgICAgKi9cbiAgICBfbGFzdEZyYW1lOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX3BsYXlpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEaWN0YXRlcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IHNob3VsZCBsb29wIG9yIG5vdC5cbiAgICAgKi9cbiAgICBfbG9vcDogdHJ1ZSxcblxuICAgIC8vIEV4cG9zZWQgdGhyb3VnaCBnZXR0ZXItc2V0dGVyXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfdGV4dHVyZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI3RleHR1cmVzfVxuICAgICAqL1xuICAgIF90ZXh0dXJlczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19mcmFtZVJhdGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI2ZyYW1lUmF0ZX1cbiAgICAgKi9cbiAgICBfZnJhbWVSYXRlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX29yaWdpblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2Ujb3JpZ2lufVxuICAgICAqL1xuICAgIF9vcmlnaW46IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNwbGF5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtmaXJzdEZyYW1lPTBdIC0gVGhlIGluZGV4IG9mIHRoZSBmcmFtZSB0byBzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXN0RnJhbWVdIC0gVGhlIGluZGV4IG9mIHRoZSBmcmFtZSB0byBlbmQgdGhlIGFuaW1hdGlvbiB3aXRoLiBEZWZhdWx0cyB0byB0aGUgbGFzdCBpdGVtIGluIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2UjdGV4dHVyZXN9LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvbkxhc3RGcmFtZV0gLSBPcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSB0cmlnZ2VyZWQgYWZ0ZXIgcGxheWluZyB0aGUgbGFzdCBmcmFtZS4gVGhpcyBmaXJlcyBtdWx0aXBsZSB0aW1lcyB3aGVuIHRoZSBpbWFnZSBzZXF1ZW5jZSBpcyBsb29wZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYXRlIGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXG4gICAgICovXG4gICAgcGxheTogZnVuY3Rpb24oZmlyc3RGcmFtZSwgbGFzdEZyYW1lLCBvbkxhc3RGcmFtZSkge1xuXG4gICAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhbWUgPSAwO1xuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gdGhpcy5hbW91bnQgLSAxO1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gXy5wZXJmb3JtYW5jZS5ub3coKTtcblxuICAgICAgaWYgKHR5cGVvZiBmaXJzdEZyYW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLl9maXJzdEZyYW1lID0gZmlyc3RGcmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgbGFzdEZyYW1lID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBsYXN0RnJhbWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9uTGFzdEZyYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX29uTGFzdEZyYW1lID0gb25MYXN0RnJhbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5fb25MYXN0RnJhbWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbmRleCAhPT0gdGhpcy5fZmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9zdGFydFRpbWUgLT0gMTAwMCAqIE1hdGguYWJzKHRoaXMuX2luZGV4IC0gdGhpcy5fZmlyc3RGcmFtZSlcbiAgICAgICAgICAvIHRoaXMuX2ZyYW1lUmF0ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjcGF1c2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gSGFsdCBhbmltYXRpb24gcGxheWJhY2sgb2YgYSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2Ujc3RvcFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBIYWx0IGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gYW5kIHNldCB0aGUgY3VycmVudCBmcmFtZSBiYWNrIHRvIHRoZSBmaXJzdCBmcmFtZS5cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5faW5kZXggPSB0aGlzLl9maXJzdEZyYW1lO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLkltYWdlU2VxdWVuY2V9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBpbWFnZSBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBJbWFnZVNlcXVlbmNlKHRoaXMudGV4dHVyZXMsIHRoaXMudHJhbnNsYXRpb24ueCxcbiAgICAgICAgdGhpcy50cmFuc2xhdGlvbi55LCB0aGlzLmZyYW1lUmF0ZSk7XG5cbiAgICAgIGNsb25lLl9sb29wID0gdGhpcy5fbG9vcDtcblxuICAgICAgaWYgKHRoaXMuX3BsYXlpbmcpIHtcbiAgICAgICAgY2xvbmUucGxheSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gUmVjdGFuZ2xlLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgb2JqZWN0LnRleHR1cmVzID0gdGhpcy50ZXh0dXJlcy5tYXAoZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZS50b09iamVjdCgpO1xuICAgICAgfSk7XG4gICAgICBvYmplY3QuZnJhbWVSYXRlID0gdGhpcy5mcmFtZVJhdGU7XG4gICAgICBvYmplY3QuaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgb2JqZWN0Ll9maXJzdEZyYW1lID0gdGhpcy5fZmlyc3RGcmFtZTtcbiAgICAgIG9iamVjdC5fbGFzdEZyYW1lID0gdGhpcy5fbGFzdEZyYW1lO1xuICAgICAgb2JqZWN0Ll9sb29wID0gdGhpcy5fbG9vcDtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGVmZmVjdHMgPSB0aGlzLl90ZXh0dXJlcztcbiAgICAgIHZhciB3aWR0aCwgaGVpZ2h0LCBlbGFwc2VkLCBhbW91bnQsIGR1cmF0aW9uLCB0ZXh0dXJlO1xuICAgICAgdmFyIGluZGV4LCBmcmFtZXM7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnVGV4dHVyZXMpIHtcbiAgICAgICAgdGhpcy5fYW1vdW50ID0gZWZmZWN0cy5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnRnJhbWVSYXRlKSB7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMTAwMCAqIHRoaXMuX2Ftb3VudCAvIHRoaXMuX2ZyYW1lUmF0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BsYXlpbmcgJiYgdGhpcy5fZnJhbWVSYXRlID4gMCkge1xuXG4gICAgICAgIGFtb3VudCA9IHRoaXMuX2Ftb3VudDtcblxuICAgICAgICBpZiAoXy5pc05hTih0aGlzLl9sYXN0RnJhbWUpKSB7XG4gICAgICAgICAgdGhpcy5fbGFzdEZyYW1lID0gYW1vdW50IC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IE9mZmxvYWQgcGVyZiBsb2dpYyB0byBpbnN0YW5jZSBvZiBgVHdvYC5cbiAgICAgICAgZWxhcHNlZCA9IF8ucGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgICAgIGZyYW1lcyA9IHRoaXMuX2xhc3RGcmFtZSArIDE7XG4gICAgICAgIGR1cmF0aW9uID0gMTAwMCAqIChmcmFtZXMgLSB0aGlzLl9maXJzdEZyYW1lKSAvIHRoaXMuX2ZyYW1lUmF0ZTtcblxuICAgICAgICBpZiAodGhpcy5fbG9vcCkge1xuICAgICAgICAgIGVsYXBzZWQgPSBlbGFwc2VkICUgZHVyYXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxhcHNlZCA9IE1hdGgubWluKGVsYXBzZWQsIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gbGVycCh0aGlzLl9maXJzdEZyYW1lLCBmcmFtZXMsIGVsYXBzZWQgLyBkdXJhdGlvbik7XG4gICAgICAgIGluZGV4ID0gTWF0aC5mbG9vcihpbmRleCk7XG5cbiAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLl9pbmRleCkge1xuXG4gICAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleDtcbiAgICAgICAgICB0ZXh0dXJlID0gZWZmZWN0c1t0aGlzLl9pbmRleF07XG5cbiAgICAgICAgICBpZiAodGV4dHVyZS5sb2FkZWQpIHtcblxuICAgICAgICAgICAgd2lkdGggPSB0ZXh0dXJlLmltYWdlLndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gdGV4dHVyZS5pbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5maWxsID0gdGV4dHVyZTtcblxuICAgICAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX2xhc3RGcmFtZSAtIDEgJiYgdGhpcy5fb25MYXN0RnJhbWUpIHtcbiAgICAgICAgICAgICAgdGhpcy5fb25MYXN0RnJhbWUoKTsgIC8vIFNob3J0Y3V0IGZvciBjaGFpbmFibGUgc3ByaXRlIGFuaW1hdGlvbnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fZmxhZ0luZGV4IHx8ICEodGhpcy5maWxsIGluc3RhbmNlb2YgVGV4dHVyZSkpIHtcblxuICAgICAgICB0ZXh0dXJlID0gZWZmZWN0c1t0aGlzLl9pbmRleF07XG5cbiAgICAgICAgaWYgKHRleHR1cmUubG9hZGVkKSB7XG5cbiAgICAgICAgICB3aWR0aCA9IHRleHR1cmUuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gdGV4dHVyZS5pbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgICBpZiAodGhpcy53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWxsID0gdGV4dHVyZTtcblxuICAgICAgfVxuXG4gICAgICBSZWN0YW5nbGUucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnVGV4dHVyZXMgPSB0aGlzLl9mbGFnRnJhbWVSYXRlID0gZmFsc2U7XG4gICAgICBSZWN0YW5nbGUucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBJbWFnZVNlcXVlbmNlLk1ha2VPYnNlcnZhYmxlKEltYWdlU2VxdWVuY2UucHJvdG90eXBlKTtcblxuICB2YXIgVFdPX1BJJDIgPSBNYXRoLlBJICogMiwgSEFMRl9QSSA9IE1hdGguUEkgLyAyO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudFxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGFyYyBzZWdtZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgYXJjIHNlZ21lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbaW5uZXJSYWRpdXM9MF0gLSBUaGUgaW5uZXIgcmFkaXVzIHZhbHVlIG9mIHRoZSBhcmMgc2VnbWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvdXRlclJhZGl1cz0wXSAtIFRoZSBvdXRlciByYWRpdXMgdmFsdWUgb2YgdGhlIGFyYyBzZWdtZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0QW5nbGU9MF0gLSBUaGUgc3RhcnQgYW5nbGUgb2YgdGhlIGFyYyBzZWdtZW50IGluIE51bWJlci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRBbmdsZT02LjI4MzFdIC0gVGhlIGVuZCBhbmdsZSBvZiB0aGUgYXJjIHNlZ21lbnQgaW4gTnVtYmVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Jlc29sdXRpb249MjRdIC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgYXJjIHNlZ21lbnQuXG4gICAqL1xuICBmdW5jdGlvbiBBcmNTZWdtZW50KG94LCBveSwgaXIsIG9yLCBzYSwgZWEsIHJlcykge1xuXG4gICAgdmFyIGFtb3VudCA9IHJlcyB8fCAoQ29uc3RhbnRzLlJlc29sdXRpb24gKiAzKTtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcigpKTtcbiAgICB9XG5cbiAgICBQYXRoLmNhbGwodGhpcywgcG9pbnRzLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNpbm5lclJhZGl1c1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSBpbm5lciByYWRpdXMgb2YgdGhlIGFyYyBzZWdtZW50LlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgaXIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmlubmVyUmFkaXVzID0gaXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjb3V0ZXJSYWRpdXNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBhcmMgc2VnbWVudC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIG9yID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I3N0YXJ0UmFkaXVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGFuZ2xlIG9mIG9uZSBzaWRlIGZvciB0aGUgYXJjIHNlZ21lbnQuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBzYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuc3RhcnRBbmdsZSA9IHNhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I2VuZEFuZ2xlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGFuZ2xlIG9mIHRoZSBvdGhlciBzaWRlIGZvciB0aGUgYXJjIHNlZ21lbnQuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBlYSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuZW5kQW5nbGUgPSBlYTtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIGlmICh0eXBlb2Ygb3ggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnggPSBveDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBveSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueSA9IG95O1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoQXJjU2VnbWVudCwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQuUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5BcmNTZWdtZW50fS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnLCAnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50Lk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uQXJjU2VnbWVudH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uQXJjU2VnbWVudH0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iaik7XG4gICAgICBfLmVhY2goQXJjU2VnbWVudC5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iaik7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoQXJjU2VnbWVudC5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogQXJjU2VnbWVudCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19mbGFnU3RhcnRBbmdsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5BcmNTZWdtZW50I3N0YXJ0QW5nbGV9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU3RhcnRBbmdsZTogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX2ZsYWdFbmRBbmdsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5BcmNTZWdtZW50I2VuZEFuZ2xlfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0VuZEFuZ2xlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfZmxhZ0lubmVyUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjaW5uZXJSYWRpdXN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSW5uZXJSYWRpdXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19mbGFnT3V0ZXJSYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uQXJjU2VnbWVudCNvdXRlclJhZGl1c30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdPdXRlclJhZGl1czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfc3RhcnRBbmdsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjc3RhcnRBbmdsZX1cbiAgICAgKi9cbiAgICBfc3RhcnRBbmdsZTogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfZW5kQW5nbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5BcmNTZWdtZW50I2VuZEFuZ2xlfVxuICAgICAqL1xuICAgIF9lbmRBbmdsZTogVFdPX1BJJDIsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX2lubmVyUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uQXJjU2VnbWVudCNpbm5lclJhZGl1c31cbiAgICAgKi9cbiAgICBfaW5uZXJSYWRpdXM6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX291dGVyUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uQXJjU2VnbWVudCNvdXRlclJhZGl1c31cbiAgICAgKi9cbiAgICBfb3V0ZXJSYWRpdXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnVmVydGljZXMgfHwgdGhpcy5fZmxhZ1N0YXJ0QW5nbGUgfHwgdGhpcy5fZmxhZ0VuZEFuZ2xlXG4gICAgICAgIHx8IHRoaXMuX2ZsYWdJbm5lclJhZGl1cyB8fCB0aGlzLl9mbGFnT3V0ZXJSYWRpdXMpIHtcblxuICAgICAgICB2YXIgc2EgPSB0aGlzLl9zdGFydEFuZ2xlO1xuICAgICAgICB2YXIgZWEgPSB0aGlzLl9lbmRBbmdsZTtcblxuICAgICAgICB2YXIgaXIgPSB0aGlzLl9pbm5lclJhZGl1cztcbiAgICAgICAgdmFyIG9yID0gdGhpcy5fb3V0ZXJSYWRpdXM7XG5cbiAgICAgICAgdmFyIGNvbm5lY3RlZCA9IG1vZChzYSwgVFdPX1BJJDIpID09PSBtb2QoZWEsIFRXT19QSSQyKTtcbiAgICAgICAgdmFyIHB1bmN0dXJlZCA9IGlyID4gMDtcblxuICAgICAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gKHB1bmN0dXJlZCA/IHZlcnRpY2VzLmxlbmd0aCAvIDIgOiB2ZXJ0aWNlcy5sZW5ndGgpO1xuICAgICAgICB2YXIgY29tbWFuZCwgaWQgPSAwO1xuXG4gICAgICAgIGlmIChjb25uZWN0ZWQpIHtcbiAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgfSBlbHNlIGlmICghcHVuY3R1cmVkKSB7XG4gICAgICAgICAgbGVuZ3RoIC09IDI7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT3V0ZXIgQ2lyY2xlXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGFzdCA9IGxlbmd0aCAtIDE7IGkgPCBsZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgdmFyIHBjdCA9IGkgLyBsYXN0O1xuICAgICAgICAgIHZhciB2ID0gdmVydGljZXNbaWRdO1xuICAgICAgICAgIHZhciB0aGV0YSA9IHBjdCAqIChlYSAtIHNhKSArIHNhO1xuICAgICAgICAgIHZhciBzdGVwID0gKGVhIC0gc2EpIC8gbGVuZ3RoO1xuXG4gICAgICAgICAgdmFyIHggPSBvciAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICB2YXIgeSA9IG9yICogTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBDb21tYW5kcy5tb3ZlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBDb21tYW5kcy5jdXJ2ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2LmNvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICAgIHYueCA9IHg7XG4gICAgICAgICAgdi55ID0geTtcbiAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcbiAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XG5cbiAgICAgICAgICBpZiAodi5jb21tYW5kID09PSBDb21tYW5kcy5jdXJ2ZSkge1xuICAgICAgICAgICAgdmFyIGFtcCA9IG9yICogc3RlcCAvIE1hdGguUEk7XG4gICAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQueCA9IGFtcCAqIE1hdGguY29zKHRoZXRhIC0gSEFMRl9QSSk7XG4gICAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQueSA9IGFtcCAqIE1hdGguc2luKHRoZXRhIC0gSEFMRl9QSSk7XG4gICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnggPSBhbXAgKiBNYXRoLmNvcyh0aGV0YSArIEhBTEZfUEkpO1xuICAgICAgICAgICAgdi5jb250cm9scy5yaWdodC55ID0gYW1wICogTWF0aC5zaW4odGhldGEgKyBIQUxGX1BJKTtcbiAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC5tdWx0aXBseVNjYWxhcigyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSBsYXN0KSB7XG4gICAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQubXVsdGlwbHlTY2FsYXIoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWQrKztcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHB1bmN0dXJlZCkge1xuXG4gICAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdmVydGljZXNbaWRdLmNvbW1hbmQgPSBDb21tYW5kcy5jbG9zZTtcbiAgICAgICAgICAgIGlkKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgbGFzdCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSW5uZXIgQ2lyY2xlXG4gICAgICAgICAgICovXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHBjdCA9IGkgLyBsYXN0O1xuICAgICAgICAgICAgdiA9IHZlcnRpY2VzW2lkXTtcbiAgICAgICAgICAgIHRoZXRhID0gKDEgLSBwY3QpICogKGVhIC0gc2EpICsgc2E7XG4gICAgICAgICAgICBzdGVwID0gKGVhIC0gc2EpIC8gbGVuZ3RoO1xuXG4gICAgICAgICAgICB4ID0gaXIgKiBNYXRoLmNvcyh0aGV0YSk7XG4gICAgICAgICAgICB5ID0gaXIgKiBNYXRoLnNpbih0aGV0YSk7XG4gICAgICAgICAgICBjb21tYW5kID0gQ29tbWFuZHMuY3VydmU7XG4gICAgICAgICAgICBpZiAoaSA8PSAwKSB7XG4gICAgICAgICAgICAgIGNvbW1hbmQgPSBjb25uZWN0ZWQgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMubGluZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdi5jb21tYW5kID0gY29tbWFuZDtcbiAgICAgICAgICAgIHYueCA9IHg7XG4gICAgICAgICAgICB2LnkgPSB5O1xuICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XG4gICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XG5cbiAgICAgICAgICAgIGlmICh2LmNvbW1hbmQgPT09IENvbW1hbmRzLmN1cnZlKSB7XG4gICAgICAgICAgICAgIGFtcCA9IGlyICogc3RlcCAvIE1hdGguUEk7XG4gICAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC54ID0gYW1wICogTWF0aC5jb3ModGhldGEgKyBIQUxGX1BJKTtcbiAgICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0LnkgPSBhbXAgKiBNYXRoLnNpbih0aGV0YSArIEhBTEZfUEkpO1xuICAgICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnggPSBhbXAgKiBNYXRoLmNvcyh0aGV0YSAtIEhBTEZfUEkpO1xuICAgICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnkgPSBhbXAgKiBNYXRoLnNpbih0aGV0YSAtIEhBTEZfUEkpO1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC5tdWx0aXBseVNjYWxhcigyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaSA9PT0gbGFzdCkge1xuICAgICAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQubXVsdGlwbHlTY2FsYXIoMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWQrKztcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIEZpbmFsIFBvaW50XG4gICAgICAgICAgdmVydGljZXNbaWRdLmNvcHkodmVydGljZXNbMF0pO1xuICAgICAgICAgIHZlcnRpY2VzW2lkXS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcblxuICAgICAgICB9IGVsc2UgaWYgKCFjb25uZWN0ZWQpIHtcblxuICAgICAgICAgIHZlcnRpY2VzW2lkXS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcbiAgICAgICAgICB2ZXJ0aWNlc1tpZF0ueCA9IDA7XG4gICAgICAgICAgdmVydGljZXNbaWRdLnkgPSAwO1xuICAgICAgICAgIGlkKys7XG5cbiAgICAgICAgICAvLyBGaW5hbCBQb2ludFxuICAgICAgICAgIHZlcnRpY2VzW2lkXS5jb3B5KHZlcnRpY2VzWzBdKTtcbiAgICAgICAgICB2ZXJ0aWNlc1tpZF0uY29tbWFuZCA9IENvbW1hbmRzLmxpbmU7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5fZmxhZ1N0YXJ0QW5nbGUgPSB0aGlzLl9mbGFnRW5kQW5nbGVcbiAgICAgICAgPSB0aGlzLl9mbGFnSW5uZXJSYWRpdXMgPSB0aGlzLl9mbGFnT3V0ZXJSYWRpdXMgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5BcmNTZWdtZW50fVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5BcmNTZWdtZW50fSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBpciA9IHRoaXMuaW5uZXJSYWRpdXM7XG4gICAgICB2YXIgb3IgPSB0aGlzLm91dGVyUmFkaXVzO1xuICAgICAgdmFyIHNhID0gdGhpcy5zdGFydEFuZ2xlO1xuICAgICAgdmFyIGVhID0gdGhpcy5lbmRBbmdsZTtcbiAgICAgIHZhciByZXNvbHV0aW9uID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBBcmNTZWdtZW50KDAsIDAsIGlyLCBvciwgc2EsIGVhLCByZXNvbHV0aW9uKTtcblxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIGNsb25lLnNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIGNsb25lLnNrZXdZID0gdGhpcy5za2V3WTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaChQYXRoLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIG9iamVjdCA9IFBhdGgucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgIF8uZWFjaChBcmNTZWdtZW50LlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIEFyY1NlZ21lbnQuTWFrZU9ic2VydmFibGUoQXJjU2VnbWVudC5wcm90b3R5cGUpO1xuXG4gIHZhciBUV09fUEkkMSA9IE1hdGguUEkgKiAyLCBjb3MkMSA9IE1hdGguY29zLCBzaW4kMSA9IE1hdGguc2luO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uUG9seWdvblxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBwb2x5Z29uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1cz0wXSAtIFRoZSByYWRpdXMgdmFsdWUgb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2lkZXM9MTJdIC0gVGhlIG51bWJlciBvZiB2ZXJ0aWNlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgcG9seWdvbi5cbiAgICovXG4gIGZ1bmN0aW9uIFBvbHlnb24ob3gsIG95LCByLCBzaWRlcykge1xuXG4gICAgc2lkZXMgPSBNYXRoLm1heChzaWRlcyB8fCAwLCAzKTtcblxuICAgIFBhdGguY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9tYXRpYyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgd2lkdGggb2YgdGhlIHBvbHlnb24uXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy53aWR0aCA9IHIgKiAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI2hlaWdodFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSBoZWlnaHQgb2YgdGhlIHBvbHlnb24uXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiByID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5oZWlnaHQgPSByICogMjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNzaWRlc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBhbW91bnQgb2Ygc2lkZXMgdGhlIHBvbHlvZ24gaGFzLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygc2lkZXMgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnNpZGVzID0gc2lkZXM7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICBpZiAodHlwZW9mIG94ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy50cmFuc2xhdGlvbi54ID0gb3g7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3kgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnkgPSBveTtcbiAgICB9XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFBvbHlnb24sIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uUG9seWdvbn0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogWyd3aWR0aCcsICdoZWlnaHQnLCAnc2lkZXMnXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uUG9seWdvbn0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uUG9seWdvbn0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iaik7XG4gICAgICBfLmVhY2goUG9seWdvbi5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iaik7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoUG9seWdvbi5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUG9seWdvbixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI19mbGFnV2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUG9seWdvbiN3aWR0aH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdXaWR0aDogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX2ZsYWdIZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUG9seWdvbiNoZWlnaHR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSGVpZ2h0OiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfZmxhZ1NpZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBvbHlnb24jc2lkZXN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU2lkZXM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX3dpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUG9seWdvbiN3aWR0aH1cbiAgICAgKi9cbiAgICBfd2lkdGg6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX2hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBvbHlnb24jaGVpZ2h0fVxuICAgICAqL1xuICAgIF9oZWlnaHQ6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX3NpZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUG9seWdvbiNzaWRlc31cbiAgICAgKi9cbiAgICBfc2lkZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnVmVydGljZXMgfHwgdGhpcy5fZmxhZ1dpZHRoIHx8IHRoaXMuX2ZsYWdIZWlnaHQgfHwgdGhpcy5fZmxhZ1NpZGVzKSB7XG5cbiAgICAgICAgdmFyIHNpZGVzID0gdGhpcy5fc2lkZXM7XG4gICAgICAgIHZhciBhbW91bnQgPSBzaWRlcyArIDE7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoID4gc2lkZXMpIHtcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzLnNwbGljZShzaWRlcyAtIDEsIGxlbmd0aCAtIHNpZGVzKTtcbiAgICAgICAgICBsZW5ndGggPSBzaWRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblxuICAgICAgICAgIHZhciBwY3QgPSAoaSArIDAuNSkgLyBzaWRlcztcbiAgICAgICAgICB2YXIgdGhldGEgPSBUV09fUEkkMSAqIHBjdCArIE1hdGguUEkgLyAyO1xuICAgICAgICAgIHZhciB4ID0gdGhpcy5fd2lkdGggKiBjb3MkMSh0aGV0YSkgLyAyO1xuICAgICAgICAgIHZhciB5ID0gdGhpcy5faGVpZ2h0ICogc2luJDEodGhldGEpIC8gMjtcblxuICAgICAgICAgIGlmIChpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBBbmNob3IoeCwgeSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2ldLnNldCh4LCB5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnZlcnRpY2VzW2ldLmNvbW1hbmQgPSBpID09PSAwID8gQ29tbWFuZHMubW92ZSA6IENvbW1hbmRzLmxpbmU7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1dpZHRoID0gdGhpcy5fZmxhZ0hlaWdodCA9IHRoaXMuX2ZsYWdTaWRlcyA9IGZhbHNlO1xuICAgICAgUGF0aC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uUG9seWdvbn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUG9seWdvbn0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgUG9seWdvbigwLCAwLCB0aGlzLnJhZGl1cywgdGhpcy5zaWRlcyk7XG5cbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICBjbG9uZS5za2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICBjbG9uZS5za2V3WSA9IHRoaXMuc2tld1k7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2goUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICBfLmVhY2goUG9seWdvbi5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgIH1cblxuICB9KTtcblxuICBQb2x5Z29uLk1ha2VPYnNlcnZhYmxlKFBvbHlnb24ucHJvdG90eXBlKTtcblxuICB2YXIgVFdPX1BJID0gTWF0aC5QSSAqIDIsIGNvcyA9IE1hdGguY29zLCBzaW4gPSBNYXRoLnNpbjtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlN0YXJcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzdGFyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbm5lclJhZGl1cz0wXSAtIFRoZSBpbm5lciByYWRpdXMgdmFsdWUgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3V0ZXJSYWRpdXM9MF0gLSBUaGUgb3V0ZXIgcmFkaXVzIHZhbHVlIG9mIHRoZSBzdGFyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3NpZGVzPTVdIC0gVGhlIG51bWJlciBvZiBzaWRlcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgc3Rhci5cbiAgICovXG4gIGZ1bmN0aW9uIFN0YXIob3gsIG95LCBpciwgb3IsIHNpZGVzKSB7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAzKSB7XG4gICAgICBvciA9IGlyO1xuICAgICAgaXIgPSBvciAvIDI7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzaWRlcyAhPT0gJ251bWJlcicgfHwgc2lkZXMgPD0gMCkge1xuICAgICAgc2lkZXMgPSA1O1xuICAgIH1cblxuICAgIFBhdGguY2FsbCh0aGlzKTtcbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdGhpcy5hdXRvbWF0aWMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI2lubmVyUmFkaXVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgc3Rhci5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGlyID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IGlyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI291dGVyUmFkaXVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIG91dGVyIHJhZGl1cyBvZiB0aGUgc3Rhci5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIG9yID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI3NpZGVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGFtb3VudCBvZiBzaWRlcyB0aGUgc3RhciBoYXMuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBzaWRlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuc2lkZXMgPSBzaWRlcztcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIGlmICh0eXBlb2Ygb3ggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnggPSBveDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBveSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueSA9IG95O1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoU3Rhciwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIuUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5TdGFyfS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJywgJ3NpZGVzJ10sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3Rhci5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlN0YXJ9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlN0YXJ9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmopIHtcblxuICAgICAgUGF0aC5NYWtlT2JzZXJ2YWJsZShvYmopO1xuICAgICAgXy5lYWNoKFN0YXIuUHJvcGVydGllcywgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmopO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFN0YXIucHJvdG90eXBlLCBQYXRoLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IFN0YXIsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RhciNfZmxhZ0lubmVyUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlN0YXIjaW5uZXJSYWRpdXN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSW5uZXJSYWRpdXM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI19mbGFnT3V0ZXJSYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3RhciNvdXRlclJhZGl1c30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdPdXRlclJhZGl1czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjX2ZsYWdTaWRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TdGFyI3NpZGVzfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1NpZGVzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI19pbm5lclJhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlN0YXIjaW5uZXJSYWRpdXN9XG4gICAgICovXG4gICAgX2lubmVyUmFkaXVzOiAwLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI19vdXRlclJhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlN0YXIjb3V0ZXJSYWRpdXN9XG4gICAgICovXG4gICAgX291dGVyUmFkaXVzOiAwLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI19zaWRlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlN0YXIjc2lkZXN9XG4gICAgICovXG4gICAgX3NpZGVzOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ1ZlcnRpY2VzIHx8IHRoaXMuX2ZsYWdJbm5lclJhZGl1cyB8fCB0aGlzLl9mbGFnT3V0ZXJSYWRpdXMgfHwgdGhpcy5fZmxhZ1NpZGVzKSB7XG5cbiAgICAgICAgdmFyIHNpZGVzID0gdGhpcy5fc2lkZXMgKiAyO1xuICAgICAgICB2YXIgYW1vdW50ID0gc2lkZXMgKyAxO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+IHNpZGVzKSB7XG4gICAgICAgICAgdGhpcy52ZXJ0aWNlcy5zcGxpY2Uoc2lkZXMgLSAxLCBsZW5ndGggLSBzaWRlcyk7XG4gICAgICAgICAgbGVuZ3RoID0gc2lkZXM7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cbiAgICAgICAgICB2YXIgcGN0ID0gKGkgKyAwLjUpIC8gc2lkZXM7XG4gICAgICAgICAgdmFyIHRoZXRhID0gVFdPX1BJICogcGN0O1xuICAgICAgICAgIHZhciByID0gKCEoaSAlIDIpID8gdGhpcy5faW5uZXJSYWRpdXMgOiB0aGlzLl9vdXRlclJhZGl1cykgLyAyO1xuICAgICAgICAgIHZhciB4ID0gciAqIGNvcyh0aGV0YSk7XG4gICAgICAgICAgdmFyIHkgPSByICogc2luKHRoZXRhKTtcblxuICAgICAgICAgIGlmIChpID49IGxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBBbmNob3IoeCwgeSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW2ldLnNldCh4LCB5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnZlcnRpY2VzW2ldLmNvbW1hbmQgPSBpID09PSAwID8gQ29tbWFuZHMubW92ZSA6IENvbW1hbmRzLmxpbmU7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIFBhdGgucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnSW5uZXJSYWRpdXMgPSB0aGlzLl9mbGFnT3V0ZXJSYWRpdXMgPSB0aGlzLl9mbGFnU2lkZXMgPSBmYWxzZTtcbiAgICAgIFBhdGgucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RhciNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlN0YXJ9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlN0YXJ9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIGlyID0gdGhpcy5pbm5lclJhZGl1cztcbiAgICAgIHZhciBvciA9IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgICB2YXIgc2lkZXMgPSB0aGlzLnNpZGVzO1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgU3RhcigwLCAwLCBpciwgb3IsIHNpZGVzKTtcblxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIGNsb25lLnNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIGNsb25lLnNrZXdZID0gdGhpcy5za2V3WTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaChQYXRoLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RhciN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIG9iamVjdCA9IFBhdGgucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgIF8uZWFjaChTdGFyLlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIFN0YXIuTWFrZU9ic2VydmFibGUoU3Rhci5wcm90b3R5cGUpO1xuXG4gIHZhciBzdmcgPSB7XG5cbiAgICB2ZXJzaW9uOiAxLjEsXG5cbiAgICBuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXG4gICAgYWxpZ25tZW50czoge1xuICAgICAgbGVmdDogJ3N0YXJ0JyxcbiAgICAgIGNlbnRlcjogJ21pZGRsZScsXG4gICAgICByaWdodDogJ2VuZCdcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGFuIHN2ZyBuYW1lc3BhY2VkIGVsZW1lbnQuXG4gICAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24obmFtZSwgYXR0cnMpIHtcbiAgICAgIHZhciB0YWcgPSBuYW1lO1xuICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnLm5zLCB0YWcpO1xuICAgICAgaWYgKHRhZyA9PT0gJ3N2ZycpIHtcbiAgICAgICAgYXR0cnMgPSBfLmRlZmF1bHRzKGF0dHJzIHx8IHt9LCB7XG4gICAgICAgICAgdmVyc2lvbjogc3ZnLnZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cnMgJiYgT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXMoZWxlbSwgYXR0cnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW07XG4gICAgfSxcblxuICAgIC8vIEFkZCBhdHRyaWJ1dGVzIGZyb20gYW4gc3ZnIGVsZW1lbnQuXG4gICAgc2V0QXR0cmlidXRlczogZnVuY3Rpb24oZWxlbSwgYXR0cnMpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYXR0cnMpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvaHJlZi8udGVzdChrZXlzW2ldKSkge1xuICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlTlMoc3ZnLnhsaW5rLCBrZXlzW2ldLCBhdHRyc1trZXlzW2ldXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoa2V5c1tpXSwgYXR0cnNba2V5c1tpXV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVtb3ZlIGF0dHJpYnV0ZXMgZnJvbSBhbiBzdmcgZWxlbWVudC5cbiAgICByZW1vdmVBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtLCBhdHRycykge1xuICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG4gICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVHVybiBhIHNldCBvZiB2ZXJ0aWNlcyBpbnRvIGEgc3RyaW5nIGZvciB0aGUgZCBwcm9wZXJ0eSBvZiBhIHBhdGhcbiAgICAvLyBlbGVtZW50LiBJdCBpcyBpbXBlcmF0aXZlIHRoYXQgdGhlIHN0cmluZyBjb2xsYXRpb24gaXMgYXMgZmFzdCBhc1xuICAgIC8vIHBvc3NpYmxlLCBiZWNhdXNlIHRoaXMgY2FsbCB3aWxsIGJlIGhhcHBlbmluZyBtdWx0aXBsZSB0aW1lcyBhXG4gICAgLy8gc2Vjb25kLlxuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihwb2ludHMsIGNsb3NlZCkge1xuXG4gICAgICB2YXIgbCA9IHBvaW50cy5sZW5ndGgsXG4gICAgICAgIGxhc3QgPSBsIC0gMSxcbiAgICAgICAgZCwgLy8gVGhlIGVsdXNpdmUgbGFzdCBDb21tYW5kcy5tb3ZlIHBvaW50XG4gICAgICAgIHN0cmluZyA9ICcnO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgYiA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIGNvbW1hbmQ7XG4gICAgICAgIHZhciBwcmV2ID0gY2xvc2VkID8gbW9kKGkgLSAxLCBsKSA6IE1hdGgubWF4KGkgLSAxLCAwKTtcbiAgICAgICAgdmFyIG5leHQgPSBjbG9zZWQgPyBtb2QoaSArIDEsIGwpIDogTWF0aC5taW4oaSArIDEsIGxhc3QpO1xuXG4gICAgICAgIHZhciBhID0gcG9pbnRzW3ByZXZdO1xuICAgICAgICB2YXIgYyA9IHBvaW50c1tuZXh0XTtcblxuICAgICAgICB2YXIgdngsIHZ5LCB1eCwgdXksIGFyLCBibCwgYnIsIGNsO1xuICAgICAgICB2YXIgcngsIHJ5LCB4QXhpc1JvdGF0aW9uLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZztcblxuICAgICAgICAvLyBBY2Nlc3MgeCBhbmQgeSBkaXJlY3RseSxcbiAgICAgICAgLy8gYnlwYXNzaW5nIHRoZSBnZXR0ZXJcbiAgICAgICAgdmFyIHggPSB0b0ZpeGVkKGIueCk7XG4gICAgICAgIHZhciB5ID0gdG9GaXhlZChiLnkpO1xuXG4gICAgICAgIHN3aXRjaCAoYi5jb21tYW5kKSB7XG5cbiAgICAgICAgICBjYXNlIENvbW1hbmRzLmNsb3NlOlxuICAgICAgICAgICAgY29tbWFuZCA9IENvbW1hbmRzLmNsb3NlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIENvbW1hbmRzLmFyYzpcblxuICAgICAgICAgICAgcnggPSBiLnJ4O1xuICAgICAgICAgICAgcnkgPSBiLnJ5O1xuICAgICAgICAgICAgeEF4aXNSb3RhdGlvbiA9IGIueEF4aXNSb3RhdGlvbjtcbiAgICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IGIubGFyZ2VBcmNGbGFnO1xuICAgICAgICAgICAgc3dlZXBGbGFnID0gYi5zd2VlcEZsYWc7XG5cbiAgICAgICAgICAgIGNvbW1hbmQgPSBDb21tYW5kcy5hcmMgKyAnICcgKyByeCArICcgJyArIHJ5ICsgJyAnXG4gICAgICAgICAgICAgICsgeEF4aXNSb3RhdGlvbiArICcgJyArIGxhcmdlQXJjRmxhZyArICcgJyArIHN3ZWVwRmxhZyArICcgJ1xuICAgICAgICAgICAgICArIHggKyAnICcgKyB5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIENvbW1hbmRzLmN1cnZlOlxuXG4gICAgICAgICAgICBhciA9IChhLmNvbnRyb2xzICYmIGEuY29udHJvbHMucmlnaHQpIHx8IFZlY3Rvci56ZXJvO1xuICAgICAgICAgICAgYmwgPSAoYi5jb250cm9scyAmJiBiLmNvbnRyb2xzLmxlZnQpIHx8IFZlY3Rvci56ZXJvO1xuXG4gICAgICAgICAgICBpZiAoYS5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICB2eCA9IHRvRml4ZWQoKGFyLnggKyBhLngpKTtcbiAgICAgICAgICAgICAgdnkgPSB0b0ZpeGVkKChhci55ICsgYS55KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2eCA9IHRvRml4ZWQoYXIueCk7XG4gICAgICAgICAgICAgIHZ5ID0gdG9GaXhlZChhci55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGIucmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgdXggPSB0b0ZpeGVkKChibC54ICsgYi54KSk7XG4gICAgICAgICAgICAgIHV5ID0gdG9GaXhlZCgoYmwueSArIGIueSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXggPSB0b0ZpeGVkKGJsLngpO1xuICAgICAgICAgICAgICB1eSA9IHRvRml4ZWQoYmwueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbW1hbmQgPSAoKGkgPT09IDApID8gQ29tbWFuZHMubW92ZSA6IENvbW1hbmRzLmN1cnZlKSArXG4gICAgICAgICAgICAgICcgJyArIHZ4ICsgJyAnICsgdnkgKyAnICcgKyB1eCArICcgJyArIHV5ICsgJyAnICsgeCArICcgJyArIHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQ29tbWFuZHMubW92ZTpcbiAgICAgICAgICAgIGQgPSBiO1xuICAgICAgICAgICAgY29tbWFuZCA9IENvbW1hbmRzLm1vdmUgKyAnICcgKyB4ICsgJyAnICsgeTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbW1hbmQgPSBiLmNvbW1hbmQgKyAnICcgKyB4ICsgJyAnICsgeTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGEgZmluYWwgcG9pbnQgYW5kIGNsb3NlIGl0IG9mZlxuXG4gICAgICAgIGlmIChpID49IGxhc3QgJiYgY2xvc2VkKSB7XG5cbiAgICAgICAgICBpZiAoYi5jb21tYW5kID09PSBDb21tYW5kcy5jdXJ2ZSkge1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgY2xvc2UgdG8gdGhlIG1vc3QgcHJldmlvdXMgQ29tbWFuZHMubW92ZVxuICAgICAgICAgICAgYyA9IGQ7XG5cbiAgICAgICAgICAgIGJyID0gKGIuY29udHJvbHMgJiYgYi5jb250cm9scy5yaWdodCkgfHwgYjtcbiAgICAgICAgICAgIGNsID0gKGMuY29udHJvbHMgJiYgYy5jb250cm9scy5sZWZ0KSB8fCBjO1xuXG4gICAgICAgICAgICBpZiAoYi5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICB2eCA9IHRvRml4ZWQoKGJyLnggKyBiLngpKTtcbiAgICAgICAgICAgICAgdnkgPSB0b0ZpeGVkKChici55ICsgYi55KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2eCA9IHRvRml4ZWQoYnIueCk7XG4gICAgICAgICAgICAgIHZ5ID0gdG9GaXhlZChici55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGMucmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgdXggPSB0b0ZpeGVkKChjbC54ICsgYy54KSk7XG4gICAgICAgICAgICAgIHV5ID0gdG9GaXhlZCgoY2wueSArIGMueSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdXggPSB0b0ZpeGVkKGNsLngpO1xuICAgICAgICAgICAgICB1eSA9IHRvRml4ZWQoY2wueSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHggPSB0b0ZpeGVkKGMueCk7XG4gICAgICAgICAgICB5ID0gdG9GaXhlZChjLnkpO1xuXG4gICAgICAgICAgICBjb21tYW5kICs9XG4gICAgICAgICAgICAgICcgQyAnICsgdnggKyAnICcgKyB2eSArICcgJyArIHV4ICsgJyAnICsgdXkgKyAnICcgKyB4ICsgJyAnICsgeTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChiLmNvbW1hbmQgIT09IENvbW1hbmRzLmNsb3NlKSB7XG4gICAgICAgICAgICBjb21tYW5kICs9ICcgWic7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBzdHJpbmcgKz0gY29tbWFuZCArICcgJztcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyaW5nO1xuXG4gICAgfSxcblxuICAgIGdldENsaXA6IGZ1bmN0aW9uKHNoYXBlLCBkb21FbGVtZW50KSB7XG5cbiAgICAgIHZhciBjbGlwID0gc2hhcGUuX3JlbmRlcmVyLmNsaXA7XG5cbiAgICAgIGlmICghY2xpcCkge1xuXG4gICAgICAgIGNsaXAgPSBzaGFwZS5fcmVuZGVyZXIuY2xpcCA9IHN2Zy5jcmVhdGVFbGVtZW50KCdjbGlwUGF0aCcsIHtcbiAgICAgICAgICAnY2xpcC1ydWxlJzogJ25vbnplcm8nXG4gICAgICAgIH0pO1xuICAgICAgICBkb21FbGVtZW50LmRlZnMuYXBwZW5kQ2hpbGQoY2xpcCk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsaXA7XG5cbiAgICB9LFxuXG4gICAgZ3JvdXA6IHtcblxuICAgICAgLy8gVE9ETzogQ2FuIHNwZWVkIHVwLlxuICAgICAgLy8gVE9ETzogSG93IGRvZXMgdGhpcyBlZmZlY3QgYSBmXG4gICAgICBhcHBlbmRDaGlsZDogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgICAgdmFyIGVsZW0gPSBvYmplY3QuX3JlbmRlcmVyLmVsZW07XG5cbiAgICAgICAgaWYgKCFlbGVtKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhZyA9IGVsZW0ubm9kZU5hbWU7XG5cbiAgICAgICAgaWYgKCF0YWcgfHwgLyhyYWRpYWx8bGluZWFyKWdyYWRpZW50L2kudGVzdCh0YWcpIHx8IG9iamVjdC5fY2xpcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbS5hcHBlbmRDaGlsZChlbGVtKTtcblxuICAgICAgfSxcblxuICAgICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICAgIHZhciBlbGVtID0gb2JqZWN0Ll9yZW5kZXJlci5lbGVtO1xuXG4gICAgICAgIGlmICghZWxlbSB8fCBlbGVtLnBhcmVudE5vZGUgIT0gdGhpcy5lbGVtKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhZyA9IGVsZW0ubm9kZU5hbWU7XG5cbiAgICAgICAgaWYgKCF0YWcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZlciBzdWJ0cmFjdGlvbnMgd2hpbGUgY2xpcHBpbmcuXG4gICAgICAgIGlmIChvYmplY3QuX2NsaXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmVsZW0ucmVtb3ZlQ2hpbGQoZWxlbSk7XG5cbiAgICAgIH0sXG5cbiAgICAgIG9yZGVyQ2hpbGQ6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICB0aGlzLmVsZW0uYXBwZW5kQ2hpbGQob2JqZWN0Ll9yZW5kZXJlci5lbGVtKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbmRlckNoaWxkOiBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICBzdmdbY2hpbGQuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGNoaWxkLCB0aGlzKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZG9tRWxlbWVudCkge1xuXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBoaWRkZW4gb2JqZWN0cy5cbiAgICAgICAgLy8gRG9lc24ndCByZXNldCB0aGUgZmxhZ3MsIHNvIGNoYW5nZXMgYXJlIHN0b3JlZCBhbmRcbiAgICAgICAgLy8gYXBwbGllZCBvbmNlIHRoZSBvYmplY3QgaXMgdmlzaWJsZSBhZ2FpblxuICAgICAgICBpZiAoKCF0aGlzLl92aXNpYmxlICYmICF0aGlzLl9mbGFnVmlzaWJsZSlcbiAgICAgICAgICB8fCAodGhpcy5fb3BhY2l0eSA9PT0gMCAmJiAhdGhpcy5fZmxhZ09wYWNpdHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVsZW0pIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ2cnLCB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZWxlbSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBfVXBkYXRlIHN0eWxlcyBmb3IgdGhlIDxnPlxuICAgICAgICB2YXIgZmxhZ01hdHJpeCA9IHRoaXMuX21hdHJpeC5tYW51YWwgfHwgdGhpcy5fZmxhZ01hdHJpeDtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgZG9tRWxlbWVudDogZG9tRWxlbWVudCxcbiAgICAgICAgICBlbGVtOiB0aGlzLl9yZW5kZXJlci5lbGVtXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGZsYWdNYXRyaXgpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ21hdHJpeCgnICsgdGhpcy5fbWF0cml4LnRvU3RyaW5nKCkgKyAnKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICBzdmdbY2hpbGQuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGNoaWxkLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnSWQpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLl9pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ09wYWNpdHkpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIHRoaXMuX29wYWNpdHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdWaXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCB0aGlzLl92aXNpYmxlID8gJ2lubGluZScgOiAnbm9uZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGFzc05hbWUpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB0aGlzLmNsYXNzTGlzdC5qb2luKCcgJykpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdBZGRpdGlvbnMpIHtcbiAgICAgICAgICB0aGlzLmFkZGl0aW9ucy5mb3JFYWNoKHN2Zy5ncm91cC5hcHBlbmRDaGlsZCwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1N1YnRyYWN0aW9ucykge1xuICAgICAgICAgIHRoaXMuc3VidHJhY3Rpb25zLmZvckVhY2goc3ZnLmdyb3VwLnJlbW92ZUNoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnT3JkZXIpIHtcbiAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goc3ZnLmdyb3VwLm9yZGVyQ2hpbGQsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tbWVudGVkIHR3by13YXkgZnVuY3Rpb25hbGl0eSBvZiBjbGlwcyAvIG1hc2tzIHdpdGggZ3JvdXBzIGFuZFxuICAgICAgICAvLyBwb2x5Z29ucy4gVW5jb21tZW50IHdoZW4gdGhpcyBidWcgaXMgZml4ZWQ6XG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTFcblxuICAgICAgICAvLyBpZiAodGhpcy5fZmxhZ0NsaXApIHtcblxuICAgICAgICAvLyAgIGNsaXAgPSBzdmcuZ2V0Q2xpcCh0aGlzLCBkb21FbGVtZW50KTtcbiAgICAgICAgLy8gICBlbGVtID0gdGhpcy5fcmVuZGVyZXIuZWxlbTtcblxuICAgICAgICAvLyAgIGlmICh0aGlzLl9jbGlwKSB7XG4gICAgICAgIC8vICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgLy8gICAgIGNsaXAuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xuICAgICAgICAvLyAgICAgY2xpcC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAvLyAgICAgY2xpcC5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgIC8vICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmlkKTtcbiAgICAgICAgLy8gICAgIHRoaXMucGFyZW50Ll9yZW5kZXJlci5lbGVtLmFwcGVuZENoaWxkKGVsZW0pOyAvLyBUT0RPOiBzaG91bGQgYmUgaW5zZXJ0QmVmb3JlXG4gICAgICAgIC8vICAgfVxuXG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ01hc2spIHtcbiAgICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgc3ZnW3RoaXMuX21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX21hc2ssIGRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoIycgKyB0aGlzLl9tYXNrLmlkICsgJyknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgcGF0aDoge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbUVsZW1lbnQpIHtcblxuICAgICAgICAvLyBTaG9ydGN1dCBmb3IgaGlkZGVuIG9iamVjdHMuXG4gICAgICAgIC8vIERvZXNuJ3QgcmVzZXQgdGhlIGZsYWdzLCBzbyBjaGFuZ2VzIGFyZSBzdG9yZWQgYW5kXG4gICAgICAgIC8vIGFwcGxpZWQgb25jZSB0aGUgb2JqZWN0IGlzIHZpc2libGUgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMuX29wYWNpdHkgPT09IDAgJiYgIXRoaXMuX2ZsYWdPcGFjaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAvLyBDb2xsZWN0IGFueSBhdHRyaWJ1dGUgdGhhdCBuZWVkcyB0byBiZSBjaGFuZ2VkIGhlcmVcbiAgICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcblxuICAgICAgICB2YXIgZmxhZ01hdHJpeCA9IHRoaXMuX21hdHJpeC5tYW51YWwgfHwgdGhpcy5fZmxhZ01hdHJpeDtcblxuICAgICAgICBpZiAoZmxhZ01hdHJpeCkge1xuICAgICAgICAgIGNoYW5nZWQudHJhbnNmb3JtID0gJ21hdHJpeCgnICsgdGhpcy5fbWF0cml4LnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0lkKSB7XG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcykge1xuICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHN2Zy50b1N0cmluZyh0aGlzLl9yZW5kZXJlci52ZXJ0aWNlcywgdGhpcy5fY2xvc2VkKTtcbiAgICAgICAgICBjaGFuZ2VkLmQgPSB2ZXJ0aWNlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuX3JlbmRlcmVyKSB7XG4gICAgICAgICAgdGhpcy5fZmlsbC5fdXBkYXRlKCk7XG4gICAgICAgICAgc3ZnW3RoaXMuX2ZpbGwuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX2ZpbGwsIGRvbUVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdGaWxsKSB7XG4gICAgICAgICAgY2hhbmdlZC5maWxsID0gdGhpcy5fZmlsbCAmJiB0aGlzLl9maWxsLmlkXG4gICAgICAgICAgICA/ICd1cmwoIycgKyB0aGlzLl9maWxsLmlkICsgJyknIDogdGhpcy5fZmlsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9zdHJva2UgJiYgdGhpcy5fc3Ryb2tlLl9yZW5kZXJlcikge1xuICAgICAgICAgIHRoaXMuX3N0cm9rZS5fdXBkYXRlKCk7XG4gICAgICAgICAgc3ZnW3RoaXMuX3N0cm9rZS5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fc3Ryb2tlLCBkb21FbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3Ryb2tlKSB7XG4gICAgICAgICAgY2hhbmdlZC5zdHJva2UgPSB0aGlzLl9zdHJva2UgJiYgdGhpcy5fc3Ryb2tlLmlkXG4gICAgICAgICAgICA/ICd1cmwoIycgKyB0aGlzLl9zdHJva2UuaWQgKyAnKScgOiB0aGlzLl9zdHJva2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0xpbmV3aWR0aCkge1xuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS13aWR0aCddID0gdGhpcy5fbGluZXdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPcGFjaXR5KSB7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLW9wYWNpdHknXSA9IHRoaXMuX29wYWNpdHk7XG4gICAgICAgICAgY2hhbmdlZFsnZmlsbC1vcGFjaXR5J10gPSB0aGlzLl9vcGFjaXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGFzc05hbWUpIHtcbiAgICAgICAgICBjaGFuZ2VkWydjbGFzcyddID0gdGhpcy5jbGFzc0xpc3Quam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdWaXNpYmxlKSB7XG4gICAgICAgICAgY2hhbmdlZC52aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDYXApIHtcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2UtbGluZWNhcCddID0gdGhpcy5fY2FwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdKb2luKSB7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWxpbmVqb2luJ10gPSB0aGlzLl9qb2luO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdNaXRlcikge1xuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS1taXRlcmxpbWl0J10gPSB0aGlzLl9taXRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmRhc2hlcyAmJiB0aGlzLmRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWRhc2hhcnJheSddID0gdGhpcy5kYXNoZXMuam9pbignICcpO1xuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS1kYXNob2Zmc2V0J10gPSB0aGlzLmRhc2hlcy5vZmZzZXQgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGF0dGFjaGVkIERPTSBlbGVtZW50IHlldCxcbiAgICAgICAgLy8gY3JlYXRlIGl0IHdpdGggYWxsIG5lY2Vzc2FyeSBhdHRyaWJ1dGVzLlxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVsZW0pIHtcblxuICAgICAgICAgIGNoYW5nZWQuaWQgPSB0aGlzLl9pZDtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBjaGFuZ2VkKTtcbiAgICAgICAgICBkb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0pO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBhcHBseSBhbGwgcGVuZGluZyBhdHRyaWJ1dGVzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NsaXApIHtcblxuICAgICAgICAgIHZhciBjbGlwID0gc3ZnLmdldENsaXAodGhpcywgZG9tRWxlbWVudCk7XG4gICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLl9yZW5kZXJlci5lbGVtO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2NsaXApIHtcbiAgICAgICAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgY2xpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5pZCk7XG4gICAgICAgICAgICBjbGlwLmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbGlwLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3JlbmRlcmVyLmVsZW0uYXBwZW5kQ2hpbGQoZWxlbSk7IC8vIFRPRE86IHNob3VsZCBiZSBpbnNlcnRCZWZvcmVcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbW1lbnRlZCB0d28td2F5IGZ1bmN0aW9uYWxpdHkgb2YgY2xpcHMgLyBtYXNrcyB3aXRoIGdyb3VwcyBhbmRcbiAgICAgICAgLy8gcG9seWdvbnMuIFVuY29tbWVudCB3aGVuIHRoaXMgYnVnIGlzIGZpeGVkOlxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzcwOTUxXG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdNYXNrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgICAgIHN2Z1t0aGlzLl9tYXNrLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbCh0aGlzLl9tYXNrLCBkb21FbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCMnICsgdGhpcy5fbWFzay5pZCArICcpJyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0ucmVtb3ZlQXR0cmlidXRlKCdjbGlwLXBhdGgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRleHQ6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihkb21FbGVtZW50KSB7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcblxuICAgICAgICB2YXIgZmxhZ01hdHJpeCA9IHRoaXMuX21hdHJpeC5tYW51YWwgfHwgdGhpcy5fZmxhZ01hdHJpeDtcblxuICAgICAgICBpZiAoZmxhZ01hdHJpeCkge1xuICAgICAgICAgIGNoYW5nZWQudHJhbnNmb3JtID0gJ21hdHJpeCgnICsgdGhpcy5fbWF0cml4LnRvU3RyaW5nKCkgKyAnKSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0lkKSB7XG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdGYW1pbHkpIHtcbiAgICAgICAgICBjaGFuZ2VkWydmb250LWZhbWlseSddID0gdGhpcy5fZmFtaWx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnU2l6ZSkge1xuICAgICAgICAgIGNoYW5nZWRbJ2ZvbnQtc2l6ZSddID0gdGhpcy5fc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0xlYWRpbmcpIHtcbiAgICAgICAgICBjaGFuZ2VkWydsaW5lLWhlaWdodCddID0gdGhpcy5fbGVhZGluZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0FsaWdubWVudCkge1xuICAgICAgICAgIGNoYW5nZWRbJ3RleHQtYW5jaG9yJ10gPSBzdmcuYWxpZ25tZW50c1t0aGlzLl9hbGlnbm1lbnRdIHx8IHRoaXMuX2FsaWdubWVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0Jhc2VsaW5lKSB7XG4gICAgICAgICAgY2hhbmdlZFsnYWxpZ25tZW50LWJhc2VsaW5lJ10gPSBjaGFuZ2VkWydkb21pbmFudC1iYXNlbGluZSddID0gdGhpcy5fYmFzZWxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdHlsZSkge1xuICAgICAgICAgIGNoYW5nZWRbJ2ZvbnQtc3R5bGUnXSA9IHRoaXMuX3N0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnV2VpZ2h0KSB7XG4gICAgICAgICAgY2hhbmdlZFsnZm9udC13ZWlnaHQnXSA9IHRoaXMuX3dlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0RlY29yYXRpb24pIHtcbiAgICAgICAgICBjaGFuZ2VkWyd0ZXh0LWRlY29yYXRpb24nXSA9IHRoaXMuX2RlY29yYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZpbGwgJiYgdGhpcy5fZmlsbC5fcmVuZGVyZXIpIHtcbiAgICAgICAgICB0aGlzLl9maWxsLl91cGRhdGUoKTtcbiAgICAgICAgICBzdmdbdGhpcy5fZmlsbC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fZmlsbCwgZG9tRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdGaWxsKSB7XG4gICAgICAgICAgY2hhbmdlZC5maWxsID0gdGhpcy5fZmlsbCAmJiB0aGlzLl9maWxsLmlkXG4gICAgICAgICAgICA/ICd1cmwoIycgKyB0aGlzLl9maWxsLmlkICsgJyknIDogdGhpcy5fZmlsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICYmIHRoaXMuX3N0cm9rZS5fcmVuZGVyZXIpIHtcbiAgICAgICAgICB0aGlzLl9zdHJva2UuX3VwZGF0ZSgpO1xuICAgICAgICAgIHN2Z1t0aGlzLl9zdHJva2UuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX3N0cm9rZSwgZG9tRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdHJva2UpIHtcbiAgICAgICAgICBjaGFuZ2VkLnN0cm9rZSA9IHRoaXMuX3N0cm9rZSAmJiB0aGlzLl9zdHJva2UuaWRcbiAgICAgICAgICAgID8gJ3VybCgjJyArIHRoaXMuX3N0cm9rZS5pZCArICcpJyA6IHRoaXMuX3N0cm9rZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0xpbmV3aWR0aCkge1xuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS13aWR0aCddID0gdGhpcy5fbGluZXdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnT3BhY2l0eSkge1xuICAgICAgICAgIGNoYW5nZWQub3BhY2l0eSA9IHRoaXMuX29wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGFzc05hbWUpIHtcbiAgICAgICAgICBjaGFuZ2VkWydjbGFzcyddID0gdGhpcy5jbGFzc0xpc3Quam9pbignICcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnVmlzaWJsZSkge1xuICAgICAgICAgIGNoYW5nZWQudmlzaWJpbGl0eSA9IHRoaXMuX3Zpc2libGUgPyAndmlzaWJsZScgOiAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXNoZXMgJiYgdGhpcy5kYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS1kYXNoYXJyYXknXSA9IHRoaXMuZGFzaGVzLmpvaW4oJyAnKTtcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2UtZGFzaG9mZnNldCddID0gdGhpcy5kYXNoZXMub2Zmc2V0IHx8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVsZW0pIHtcblxuICAgICAgICAgIGNoYW5nZWQuaWQgPSB0aGlzLl9pZDtcblxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgndGV4dCcsIGNoYW5nZWQpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnQ2xpcCkge1xuXG4gICAgICAgICAgdmFyIGNsaXAgPSBzdmcuZ2V0Q2xpcCh0aGlzLCBkb21FbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuX3JlbmRlcmVyLmVsZW07XG5cbiAgICAgICAgICBpZiAodGhpcy5fY2xpcCkge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICBjbGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIGNsaXAuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsaXAucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5fcmVuZGVyZXIuZWxlbS5hcHBlbmRDaGlsZChlbGVtKTsgLy8gVE9ETzogc2hvdWxkIGJlIGluc2VydEJlZm9yZVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tbWVudGVkIHR3by13YXkgZnVuY3Rpb25hbGl0eSBvZiBjbGlwcyAvIG1hc2tzIHdpdGggZ3JvdXBzIGFuZFxuICAgICAgICAvLyBwb2x5Z29ucy4gVW5jb21tZW50IHdoZW4gdGhpcyBidWcgaXMgZml4ZWQ6XG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTFcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ01hc2spIHtcbiAgICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgc3ZnW3RoaXMuX21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX21hc2ssIGRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoIycgKyB0aGlzLl9tYXNrLmlkICsgJyknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnVmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnRleHRDb250ZW50ID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgICdsaW5lYXItZ3JhZGllbnQnOiB7XG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZG9tRWxlbWVudCwgc2lsZW50KSB7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFuZ2VkID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdJZCkge1xuICAgICAgICAgIGNoYW5nZWQuaWQgPSB0aGlzLl9pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnRW5kUG9pbnRzKSB7XG4gICAgICAgICAgY2hhbmdlZC54MSA9IHRoaXMubGVmdC5feDtcbiAgICAgICAgICBjaGFuZ2VkLnkxID0gdGhpcy5sZWZ0Ll95O1xuICAgICAgICAgIGNoYW5nZWQueDIgPSB0aGlzLnJpZ2h0Ll94O1xuICAgICAgICAgIGNoYW5nZWQueTIgPSB0aGlzLnJpZ2h0Ll95O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTcHJlYWQpIHtcbiAgICAgICAgICBjaGFuZ2VkLnNwcmVhZE1ldGhvZCA9IHRoaXMuX3NwcmVhZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGF0dGFjaGVkIERPTSBlbGVtZW50IHlldCxcbiAgICAgICAgLy8gY3JlYXRlIGl0IHdpdGggYWxsIG5lY2Vzc2FyeSBhdHRyaWJ1dGVzLlxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVsZW0pIHtcblxuICAgICAgICAgIGNoYW5nZWQuaWQgPSB0aGlzLl9pZDtcbiAgICAgICAgICBjaGFuZ2VkLmdyYWRpZW50VW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgnbGluZWFyR3JhZGllbnQnLCBjaGFuZ2VkKTtcbiAgICAgICAgICBkb21FbGVtZW50LmRlZnMuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZWxlbSk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGx5IGFsbCBwZW5kaW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVzKHRoaXMuX3JlbmRlcmVyLmVsZW0sIGNoYW5nZWQpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1N0b3BzKSB7XG5cbiAgICAgICAgICB2YXIgbGVuZ3RoQ2hhbmdlZCA9IHRoaXMuX3JlbmRlcmVyLmVsZW0uY2hpbGROb2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICE9PSB0aGlzLnN0b3BzLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChsZW5ndGhDaGFuZ2VkKSB7XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5fcmVuZGVyZXIuZWxlbS5sYXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5yZW1vdmVDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtLmxhc3RDaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHZhciBzdG9wID0gdGhpcy5zdG9wc1tpXTtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHt9O1xuXG4gICAgICAgICAgICBpZiAoc3RvcC5fZmxhZ09mZnNldCkge1xuICAgICAgICAgICAgICBhdHRycy5vZmZzZXQgPSAxMDAgKiBzdG9wLl9vZmZzZXQgKyAnJSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RvcC5fZmxhZ0NvbG9yKSB7XG4gICAgICAgICAgICAgIGF0dHJzWydzdG9wLWNvbG9yJ10gPSBzdG9wLl9jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9wLl9mbGFnT3BhY2l0eSkge1xuICAgICAgICAgICAgICBhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBzdG9wLl9vcGFjaXR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0b3AuX3JlbmRlcmVyLmVsZW0pIHtcbiAgICAgICAgICAgICAgc3RvcC5fcmVuZGVyZXIuZWxlbSA9IHN2Zy5jcmVhdGVFbGVtZW50KCdzdG9wJywgYXR0cnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXMoc3RvcC5fcmVuZGVyZXIuZWxlbSwgYXR0cnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGVuZ3RoQ2hhbmdlZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLmFwcGVuZENoaWxkKHN0b3AuX3JlbmRlcmVyLmVsZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcC5mbGFnUmVzZXQoKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAncmFkaWFsLWdyYWRpZW50Jzoge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbUVsZW1lbnQsIHNpbGVudCkge1xuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhbmdlZCA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnSWQpIHtcbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5faWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NlbnRlcikge1xuICAgICAgICAgIGNoYW5nZWQuY3ggPSB0aGlzLmNlbnRlci5feDtcbiAgICAgICAgICBjaGFuZ2VkLmN5ID0gdGhpcy5jZW50ZXIuX3k7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdGb2NhbCkge1xuICAgICAgICAgIGNoYW5nZWQuZnggPSB0aGlzLmZvY2FsLl94O1xuICAgICAgICAgIGNoYW5nZWQuZnkgPSB0aGlzLmZvY2FsLl95O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdSYWRpdXMpIHtcbiAgICAgICAgICBjaGFuZ2VkLnIgPSB0aGlzLl9yYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NwcmVhZCkge1xuICAgICAgICAgIGNoYW5nZWQuc3ByZWFkTWV0aG9kID0gdGhpcy5fc3ByZWFkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYXR0YWNoZWQgRE9NIGVsZW1lbnQgeWV0LFxuICAgICAgICAvLyBjcmVhdGUgaXQgd2l0aCBhbGwgbmVjZXNzYXJ5IGF0dHJpYnV0ZXMuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWxlbSkge1xuXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuICAgICAgICAgIGNoYW5nZWQuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbSA9IHN2Zy5jcmVhdGVFbGVtZW50KCdyYWRpYWxHcmFkaWVudCcsIGNoYW5nZWQpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtKTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgYXBwbHkgYWxsIHBlbmRpbmcgYXR0cmlidXRlc1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3RvcHMpIHtcblxuICAgICAgICAgIHZhciBsZW5ndGhDaGFuZ2VkID0gdGhpcy5fcmVuZGVyZXIuZWxlbS5jaGlsZE5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgIT09IHRoaXMuc3RvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aENoYW5nZWQpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9yZW5kZXJlci5lbGVtLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnJlbW92ZUNoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0ubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHN0b3AgPSB0aGlzLnN0b3BzW2ldO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG5cbiAgICAgICAgICAgIGlmIChzdG9wLl9mbGFnT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGF0dHJzLm9mZnNldCA9IDEwMCAqIHN0b3AuX29mZnNldCArICclJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9wLl9mbGFnQ29sb3IpIHtcbiAgICAgICAgICAgICAgYXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3AuX2NvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3AuX2ZsYWdPcGFjaXR5KSB7XG4gICAgICAgICAgICAgIGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IHN0b3AuX29wYWNpdHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3RvcC5fcmVuZGVyZXIuZWxlbSkge1xuICAgICAgICAgICAgICBzdG9wLl9yZW5kZXJlci5lbGVtID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ3N0b3AnLCBhdHRycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyhzdG9wLl9yZW5kZXJlci5lbGVtLCBhdHRycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGhDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uYXBwZW5kQ2hpbGQoc3RvcC5fcmVuZGVyZXIuZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wLmZsYWdSZXNldCgpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRleHR1cmU6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihkb21FbGVtZW50LCBzaWxlbnQpIHtcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnSWQpIHtcbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5faWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0xvYWRlZCAmJiB0aGlzLmxvYWRlZCkge1xuXG4gICAgICAgICAgc3dpdGNoIChpbWFnZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG5cbiAgICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICAgIHN0eWxlcy5ocmVmID0gc3R5bGVzWyd4bGluazpocmVmJ10gPSBpbWFnZS50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ltZyc6XG4gICAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICAgIHN0eWxlcy5ocmVmID0gc3R5bGVzWyd4bGluazpocmVmJ10gPSB0aGlzLnNyYztcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnT2Zmc2V0IHx8IHRoaXMuX2ZsYWdMb2FkZWQgfHwgdGhpcy5fZmxhZ1NjYWxlKSB7XG5cbiAgICAgICAgICBjaGFuZ2VkLnggPSB0aGlzLl9vZmZzZXQueDtcbiAgICAgICAgICBjaGFuZ2VkLnkgPSB0aGlzLl9vZmZzZXQueTtcblxuICAgICAgICAgIGlmIChpbWFnZSkge1xuXG4gICAgICAgICAgICBjaGFuZ2VkLnggLT0gaW1hZ2Uud2lkdGggLyAyO1xuICAgICAgICAgICAgY2hhbmdlZC55IC09IGltYWdlLmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgICBjaGFuZ2VkLnggKj0gdGhpcy5fc2NhbGUueDtcbiAgICAgICAgICAgICAgY2hhbmdlZC55ICo9IHRoaXMuX3NjYWxlLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGFuZ2VkLnggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICAgIGNoYW5nZWQueSAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZC54ID4gMCkge1xuICAgICAgICAgICAgY2hhbmdlZC54ICo9IC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYW5nZWQueSA+IDApIHtcbiAgICAgICAgICAgIGNoYW5nZWQueSAqPSAtIDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NjYWxlIHx8IHRoaXMuX2ZsYWdMb2FkZWQgfHwgdGhpcy5fZmxhZ1JlcGVhdCkge1xuXG4gICAgICAgICAgY2hhbmdlZC53aWR0aCA9IDA7XG4gICAgICAgICAgY2hhbmdlZC5oZWlnaHQgPSAwO1xuXG4gICAgICAgICAgaWYgKGltYWdlKSB7XG5cbiAgICAgICAgICAgIHN0eWxlcy53aWR0aCA9IGNoYW5nZWQud2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgICAgIHN0eWxlcy5oZWlnaHQgPSBjaGFuZ2VkLmhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICAgICAgLy8gVE9ETzogSGFjayAvIEJhbmQtYWlkXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3JlcGVhdCkge1xuICAgICAgICAgICAgICBjYXNlICduby1yZXBlYXQnOlxuICAgICAgICAgICAgICAgIGNoYW5nZWQud2lkdGggKz0gMTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VkLmhlaWdodCArPSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZC53aWR0aCAqPSB0aGlzLl9zY2FsZS54O1xuICAgICAgICAgICAgICBjaGFuZ2VkLmhlaWdodCAqPSB0aGlzLl9zY2FsZS55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hhbmdlZC53aWR0aCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgICAgY2hhbmdlZC5oZWlnaHQgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NjYWxlIHx8IHRoaXMuX2ZsYWdMb2FkZWQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmltYWdlKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5pbWFnZSA9IHN2Zy5jcmVhdGVFbGVtZW50KCdpbWFnZScsIHN0eWxlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVzKHRoaXMuX3JlbmRlcmVyLmltYWdlLCBzdHlsZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWxlbSkge1xuXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuICAgICAgICAgIGNoYW5nZWQucGF0dGVyblVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJztcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ3BhdHRlcm4nLCBjaGFuZ2VkKTtcbiAgICAgICAgICBkb21FbGVtZW50LmRlZnMuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZWxlbSk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChPYmplY3Qua2V5cyhjaGFuZ2VkKS5sZW5ndGggIT09IDApIHtcblxuICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVzKHRoaXMuX3JlbmRlcmVyLmVsZW0sIGNoYW5nZWQpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyZXIuZWxlbSAmJiB0aGlzLl9yZW5kZXJlci5pbWFnZSAmJiAhdGhpcy5fcmVuZGVyZXIuYXBwZW5kZWQpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmltYWdlKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5hcHBlbmRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5TVkdSZW5kZXJlclxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLkV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gVGhpcyBvYmplY3QgaXMgaW5oZXJpdGVkIHdoZW4gY29uc3RydWN0aW5nIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd299LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtwYXJhbWV0ZXJzLmRvbUVsZW1lbnRdIC0gVGhlIGA8c3ZnIC8+YCB0byBkcmF3IHRvLiBJZiBub25lIGdpdmVuIGEgbmV3IG9uZSB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBjbGFzcyBpcyB1c2VkIGJ5IHtAbGluayBUd299IHdoZW4gY29uc3RydWN0aW5nIHdpdGggYHR5cGVgIG9mIGBUd28uVHlwZXMuc3ZnYCAodGhlIGRlZmF1bHQgdHlwZSkuIEl0IHRha2VzIFR3by5qcycgc2NlbmVncmFwaCBhbmQgcmVuZGVycyBpdCB0byBhIGA8c3ZnIC8+YC5cbiAgICovXG4gIGZ1bmN0aW9uIFJlbmRlcmVyJDEocGFyYW1zKSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU1ZHUmVuZGVyZXIjZG9tRWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gLSBUaGUgYDxzdmcgLz5gIGFzc29jaWF0ZWQgd2l0aCB0aGUgVHdvLmpzIHNjZW5lLlxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IHBhcmFtcy5kb21FbGVtZW50IHx8IHN2Zy5jcmVhdGVFbGVtZW50KCdzdmcnKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TVkdSZW5kZXJlciNzY2VuZVxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLkdyb3VwfSAtIFRoZSByb290IGdyb3VwIG9mIHRoZSBzY2VuZWdyYXBoLlxuICAgICAqL1xuICAgIHRoaXMuc2NlbmUgPSBuZXcgR3JvdXAoKTtcbiAgICB0aGlzLnNjZW5lLnBhcmVudCA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU1ZHUmVuZGVyZXIjZGVmc1xuICAgICAqIEBwcm9wZXJ0eSB7U3ZnRGVmaW50aW9uc0VsZW1lbnR9IC0gVGhlIGA8ZGVmcyAvPmAgdG8gYXBwbHkgZ3JhZGllbnRzLCBwYXR0ZXJucywgYW5kIGJpdG1hcCBpbWFnZXJ5LlxuICAgICAqL1xuICAgIHRoaXMuZGVmcyA9IHN2Zy5jcmVhdGVFbGVtZW50KCdkZWZzJyk7XG4gICAgdGhpcy5kb21FbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZGVmcyk7XG4gICAgdGhpcy5kb21FbGVtZW50LmRlZnMgPSB0aGlzLmRlZnM7XG4gICAgdGhpcy5kb21FbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFJlbmRlcmVyJDEsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TVkdSZW5kZXJlci5VdGlsc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIEEgbWFzc2l2ZSBvYmplY3QgZmlsbGVkIHdpdGggdXRpbGl0eSBmdW5jdGlvbnMgYW5kIHByb3BlcnRpZXMgdG8gcmVuZGVyIFR3by5qcyBvYmplY3RzIHRvIGEgYDxzdmcgLz5gLlxuICAgICAqL1xuICAgIFV0aWxzOiBzdmdcblxuICB9KTtcblxuICBfLmV4dGVuZChSZW5kZXJlciQxLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUmVuZGVyZXIkMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TVkdSZW5kZXJlciNzZXRTaXplXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSByZW5kZXJlci5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2hhbmdlIHRoZSBzaXplIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKiBAbm90YS1iZW5lIFRyaWdnZXJzIGEgYFR3by5FdmVudHMucmVzaXplYC5cbiAgICAgKi9cbiAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICBzdmcuc2V0QXR0cmlidXRlcyh0aGlzLmRvbUVsZW1lbnQsIHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnJlc2l6ZSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyI3JlbmRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgdG8gdGhlIGA8c3ZnIC8+YC5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBzdmcuZ3JvdXAucmVuZGVyLmNhbGwodGhpcy5zY2VuZSwgdGhpcy5kb21FbGVtZW50KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gQ29uc3RhbnRzXG5cbiAgdmFyIG11bHRpcGx5TWF0cml4ID0gTWF0cml4Lk11bHRpcGx5LFxuICAgIGlkZW50aXR5ID0gWzEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDFdLFxuICAgIHRyYW5zZm9ybWF0aW9uID0gbmV3IE51bUFycmF5KDkpLFxuICAgIENhbnZhc1V0aWxzID0gUmVuZGVyZXIkMi5VdGlscztcblxuICB2YXIgd2ViZ2wgPSB7XG5cbiAgICBpc0hpZGRlbjogLyh1bmRlZmluZWR8bm9uZXx0cmFuc3BhcmVudCkvaSxcblxuICAgIGNhbnZhczogKHJvb3QkMS5kb2N1bWVudCA/IHJvb3QkMS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IHsgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7fSB9KSxcblxuICAgIGFsaWdubWVudHM6IHtcbiAgICAgIGxlZnQ6ICdzdGFydCcsXG4gICAgICBtaWRkbGU6ICdjZW50ZXInLFxuICAgICAgcmlnaHQ6ICdlbmQnXG4gICAgfSxcblxuICAgIG1hdHJpeDogbmV3IE1hdHJpeCgpLFxuXG4gICAgZ3JvdXA6IHtcblxuICAgICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkLCBnbCkge1xuICAgICAgICBpZiAoY2hpbGQuY2hpbGRyZW4pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB3ZWJnbC5ncm91cC5yZW1vdmVDaGlsZChjaGlsZC5jaGlsZHJlbltpXSwgZ2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVhbGxvY2F0ZSB0ZXh0dXJlIHRvIGZyZWUgdXAgZ2wgbWVtb3J5LlxuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKGNoaWxkLl9yZW5kZXJlci50ZXh0dXJlKTtcbiAgICAgICAgZGVsZXRlIGNoaWxkLl9yZW5kZXJlci50ZXh0dXJlO1xuICAgICAgfSxcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIGZsYWdQYXJlbnRNYXRyaXggPSAocGFyZW50Ll9tYXRyaXggJiYgcGFyZW50Ll9tYXRyaXgubWFudWFsKSB8fCBwYXJlbnQuX2ZsYWdNYXRyaXg7XG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xuXG4gICAgICAgIGlmIChmbGFnUGFyZW50TWF0cml4IHx8IGZsYWdNYXRyaXgpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIubWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5tYXRyaXggPSBuZXcgTnVtQXJyYXkoOSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVkdWNlIGFtb3VudCBvZiBvYmplY3QgLyBhcnJheSBjcmVhdGlvbiAvIGRlbGV0aW9uXG4gICAgICAgICAgdGhpcy5fbWF0cml4LnRvVHJhbnNmb3JtQXJyYXkodHJ1ZSwgdHJhbnNmb3JtYXRpb24pO1xuXG4gICAgICAgICAgbXVsdGlwbHlNYXRyaXgodHJhbnNmb3JtYXRpb24sIHBhcmVudC5fcmVuZGVyZXIubWF0cml4LCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xuXG4gICAgICAgICAgaWYgKCEodGhpcy5fcmVuZGVyZXIuc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZSA9IG5ldyBWZWN0b3IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZS54O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSA9IHRoaXMuX3NjYWxlLnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoISgvcmVuZGVyZXIvaS50ZXN0KHBhcmVudC5fcmVuZGVyZXIudHlwZSkpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ICo9IHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgKj0gcGFyZW50Ll9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbGFnUGFyZW50TWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLl9mbGFnTWF0cml4ID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG5cbiAgICAgICAgICAvLyBTdGVuY2lsIGF3YXkgZXZlcnl0aGluZyB0aGF0IGlzbid0IHJlbmRlcmVkIGJ5IHRoZSBtYXNrXG4gICAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbiAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywgMSwgMCk7XG4gICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLlJFUExBQ0UpO1xuICAgICAgICAgIC8vIERvbid0IGRyYXcgdGhlIGVsZW1lbnQgb250byB0aGUgY2FudmFzLCBvbmx5IG9udG8gdGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgIHdlYmdsW3RoaXMuX21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX21hc2ssIGdsLCBwcm9ncmFtLCB0aGlzKTtcblxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAxLCAweGZmKTtcbiAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9mbGFnT3BhY2l0eSA9IHBhcmVudC5fZmxhZ09wYWNpdHkgfHwgdGhpcy5fZmxhZ09wYWNpdHk7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIub3BhY2l0eSA9IHRoaXMuX29wYWNpdHlcbiAgICAgICAgICAqIChwYXJlbnQgJiYgcGFyZW50Ll9yZW5kZXJlciA/IHBhcmVudC5fcmVuZGVyZXIub3BhY2l0eSA6IDEpO1xuXG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAodGhpcy5fZmxhZ1N1YnRyYWN0aW9ucykge1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnN1YnRyYWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgd2ViZ2wuZ3JvdXAucmVtb3ZlQ2hpbGQodGhpcy5zdWJ0cmFjdGlvbnNbaV0sIGdsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgd2ViZ2xbY2hpbGQuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGNoaWxkLCBnbCwgcHJvZ3JhbSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgcGF0aDoge1xuXG4gICAgICB1cGRhdGVDYW52YXM6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgICB2YXIgbmV4dCwgcHJldiwgYSwgYywgdXgsIHV5LCB2eCwgdnksIGFyLCBibCwgYnIsIGNsLCB4LCB5O1xuICAgICAgICB2YXIgaXNPZmZzZXQ7XG5cbiAgICAgICAgdmFyIGNvbW1hbmRzID0gZWxlbS5fcmVuZGVyZXIudmVydGljZXM7XG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgICAgIC8vIFN0eWxlc1xuICAgICAgICB2YXIgc2NhbGUgPSBlbGVtLl9yZW5kZXJlci5zY2FsZTtcbiAgICAgICAgdmFyIHN0cm9rZSA9IGVsZW0uX3N0cm9rZTtcbiAgICAgICAgdmFyIGxpbmV3aWR0aCA9IGVsZW0uX2xpbmV3aWR0aDtcbiAgICAgICAgdmFyIGZpbGwgPSBlbGVtLl9maWxsO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IGVsZW0uX3JlbmRlcmVyLm9wYWNpdHkgfHwgZWxlbS5fb3BhY2l0eTtcbiAgICAgICAgdmFyIGNhcCA9IGVsZW0uX2NhcDtcbiAgICAgICAgdmFyIGpvaW4gPSBlbGVtLl9qb2luO1xuICAgICAgICB2YXIgbWl0ZXIgPSBlbGVtLl9taXRlcjtcbiAgICAgICAgdmFyIGNsb3NlZCA9IGVsZW0uX2Nsb3NlZDtcbiAgICAgICAgdmFyIGRhc2hlcyA9IGVsZW0uZGFzaGVzO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdCA9IGxlbmd0aCAtIDE7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGVsZW0uX3JlbmRlcmVyLnJlY3Qud2lkdGggKiBzY2FsZS54KSwgMSk7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoZWxlbS5fcmVuZGVyZXIucmVjdC5oZWlnaHQgKiBzY2FsZS55KSwgMSk7XG5cbiAgICAgICAgdmFyIGNlbnRyb2lkID0gZWxlbS5fcmVuZGVyZXIucmVjdC5jZW50cm9pZDtcbiAgICAgICAgdmFyIGN4ID0gY2VudHJvaWQueDtcbiAgICAgICAgdmFyIGN5ID0gY2VudHJvaWQueTtcblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xbZmlsbC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoZmlsbCwgY3R4LCBlbGVtKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLl9yZW5kZXJlci5lZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0cm9rZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xbc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChzdHJva2UsIGN0eCwgZWxlbSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UuX3JlbmRlcmVyLmVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbmV3aWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1pdGVyKSB7XG4gICAgICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IG1pdGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoam9pbikge1xuICAgICAgICAgICAgY3R4LmxpbmVKb2luID0gam9pbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjbG9zZWQgJiYgY2FwKSB7XG4gICAgICAgICAgICBjdHgubGluZUNhcCA9IGNhcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGFzaGVzICYmIGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaGVzLm9mZnNldCB8fCAwO1xuICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZS54LCBzY2FsZS55KTtcblxuICAgICAgICBjdHgudHJhbnNsYXRlKGN4LCBjeSk7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICB2YXIgYiA9IGNvbW1hbmRzW2ldO1xuXG4gICAgICAgICAgeCA9IGIueDtcbiAgICAgICAgICB5ID0gYi55O1xuXG4gICAgICAgICAgc3dpdGNoIChiLmNvbW1hbmQpIHtcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5jbG9zZTpcbiAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5hcmM6XG5cbiAgICAgICAgICAgICAgdmFyIHJ4ID0gYi5yeDtcbiAgICAgICAgICAgICAgdmFyIHJ5ID0gYi5yeTtcbiAgICAgICAgICAgICAgdmFyIHhBeGlzUm90YXRpb24gPSBiLnhBeGlzUm90YXRpb247XG4gICAgICAgICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBiLmxhcmdlQXJjRmxhZztcbiAgICAgICAgICAgICAgdmFyIHN3ZWVwRmxhZyA9IGIuc3dlZXBGbGFnO1xuXG4gICAgICAgICAgICAgIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGxlbmd0aCkgOiBNYXRoLm1heChpIC0gMSwgMCk7XG4gICAgICAgICAgICAgIGEgPSBjb21tYW5kc1twcmV2XTtcblxuICAgICAgICAgICAgICB2YXIgYXggPSBhLng7XG4gICAgICAgICAgICAgIHZhciBheSA9IGEueTtcblxuICAgICAgICAgICAgICBDYW52YXNVdGlscy5yZW5kZXJTdmdBcmNDb21tYW5kKGN0eCwgYXgsIGF5LCByeCwgcnksIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnLCB4QXhpc1JvdGF0aW9uLCB4LCB5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuY3VydmU6XG5cbiAgICAgICAgICAgICAgcHJldiA9IGNsb3NlZCA/IG1vZChpIC0gMSwgbGVuZ3RoKSA6IE1hdGgubWF4KGkgLSAxLCAwKTtcbiAgICAgICAgICAgICAgbmV4dCA9IGNsb3NlZCA/IG1vZChpICsgMSwgbGVuZ3RoKSA6IE1hdGgubWluKGkgKyAxLCBsYXN0KTtcblxuICAgICAgICAgICAgICBhID0gY29tbWFuZHNbcHJldl07XG4gICAgICAgICAgICAgIGMgPSBjb21tYW5kc1tuZXh0XTtcbiAgICAgICAgICAgICAgYXIgPSAoYS5jb250cm9scyAmJiBhLmNvbnRyb2xzLnJpZ2h0KSB8fCBWZWN0b3IuemVybztcbiAgICAgICAgICAgICAgYmwgPSAoYi5jb250cm9scyAmJiBiLmNvbnRyb2xzLmxlZnQpIHx8IFZlY3Rvci56ZXJvO1xuXG4gICAgICAgICAgICAgIGlmIChhLl9yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZ4ID0gYXIueCArIGEueDtcbiAgICAgICAgICAgICAgICB2eSA9IGFyLnkgKyBhLnk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdnggPSBhci54O1xuICAgICAgICAgICAgICAgIHZ5ID0gYXIueTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChiLl9yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHV4ID0gYmwueCArIGIueDtcbiAgICAgICAgICAgICAgICB1eSA9IGJsLnkgKyBiLnk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXggPSBibC54O1xuICAgICAgICAgICAgICAgIHV5ID0gYmwueTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZ4LCB2eSwgdXgsIHV5LCB4LCB5KTtcblxuICAgICAgICAgICAgICBpZiAoaSA+PSBsYXN0ICYmIGNsb3NlZCkge1xuXG4gICAgICAgICAgICAgICAgYyA9IGQ7XG5cbiAgICAgICAgICAgICAgICBiciA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQpIHx8IFZlY3Rvci56ZXJvO1xuICAgICAgICAgICAgICAgIGNsID0gKGMuY29udHJvbHMgJiYgYy5jb250cm9scy5sZWZ0KSB8fCBWZWN0b3IuemVybztcblxuICAgICAgICAgICAgICAgIGlmIChiLl9yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgdnggPSBici54ICsgYi54O1xuICAgICAgICAgICAgICAgICAgdnkgPSBici55ICsgYi55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2eCA9IGJyLng7XG4gICAgICAgICAgICAgICAgICB2eSA9IGJyLnk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGMuX3JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICB1eCA9IGNsLnggKyBjLng7XG4gICAgICAgICAgICAgICAgICB1eSA9IGNsLnkgKyBjLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHV4ID0gY2wueDtcbiAgICAgICAgICAgICAgICAgIHV5ID0gY2wueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB4ID0gYy54O1xuICAgICAgICAgICAgICAgIHkgPSBjLnk7XG5cbiAgICAgICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh2eCwgdnksIHV4LCB1eSwgeCwgeSk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLmxpbmU6XG4gICAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLm1vdmU6XG4gICAgICAgICAgICAgIGQgPSBiO1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vc2UgZW5kc1xuXG4gICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdlYmdsLmlzSGlkZGVuLnRlc3QoZmlsbCkpIHtcbiAgICAgICAgICBpc09mZnNldCA9IGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldDtcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC54LCAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC55KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShmaWxsLl9yZW5kZXJlci5zY2FsZS54LCBmaWxsLl9yZW5kZXJlci5zY2FsZS55KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3ZWJnbC5pc0hpZGRlbi50ZXN0KHN0cm9rZSkpIHtcbiAgICAgICAgICBpc09mZnNldCA9IHN0cm9rZS5fcmVuZGVyZXIgJiYgc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQ7XG4gICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC54LCAtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LnkpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueCwgc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55KTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5ld2lkdGggLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLng7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgfSxcblxuICAgICAgLy8gUmV0dXJucyB0aGUgcmVjdCBvZiBhIHNldCBvZiB2ZXJ0cy4gVHlwaWNhbGx5IHRha2VzIHZlcnRpY2VzIHRoYXQgYXJlXG4gICAgICAvLyBcImNlbnRlcmVkXCIgYXJvdW5kIDAgYW5kIHJldHVybnMgdGhlbSB0byBiZSBhbmNob3JlZCB1cHBlci1sZWZ0LlxuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbih2ZXJ0aWNlcywgYm9yZGVyLCByZWN0KSB7XG5cbiAgICAgICAgdmFyIGxlZnQgPSBJbmZpbml0eSwgcmlnaHQgPSAtSW5maW5pdHksXG4gICAgICAgICAgICB0b3AgPSBJbmZpbml0eSwgYm90dG9tID0gLUluZmluaXR5LFxuICAgICAgICAgICAgd2lkdGgsIGhlaWdodDtcblxuICAgICAgICB2ZXJ0aWNlcy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICAgIHZhciB4ID0gdi54LCB5ID0gdi55LCBjb250cm9scyA9IHYuY29udHJvbHM7XG4gICAgICAgICAgdmFyIGEsIGIsIGMsIGQsIGNsLCBjcjtcblxuICAgICAgICAgIHRvcCA9IE1hdGgubWluKHksIHRvcCk7XG4gICAgICAgICAgbGVmdCA9IE1hdGgubWluKHgsIGxlZnQpO1xuICAgICAgICAgIHJpZ2h0ID0gTWF0aC5tYXgoeCwgcmlnaHQpO1xuICAgICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJvdHRvbSk7XG5cbiAgICAgICAgICBpZiAoIXYuY29udHJvbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbCA9IGNvbnRyb2xzLmxlZnQ7XG4gICAgICAgICAgY3IgPSBjb250cm9scy5yaWdodDtcblxuICAgICAgICAgIGlmICghY2wgfHwgIWNyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYSA9IHYuX3JlbGF0aXZlID8gY2wueCArIHggOiBjbC54O1xuICAgICAgICAgIGIgPSB2Ll9yZWxhdGl2ZSA/IGNsLnkgKyB5IDogY2wueTtcbiAgICAgICAgICBjID0gdi5fcmVsYXRpdmUgPyBjci54ICsgeCA6IGNyLng7XG4gICAgICAgICAgZCA9IHYuX3JlbGF0aXZlID8gY3IueSArIHkgOiBjci55O1xuXG4gICAgICAgICAgaWYgKCFhIHx8ICFiIHx8ICFjIHx8ICFkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9wID0gTWF0aC5taW4oYiwgZCwgdG9wKTtcbiAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4oYSwgYywgbGVmdCk7XG4gICAgICAgICAgcmlnaHQgPSBNYXRoLm1heChhLCBjLCByaWdodCk7XG4gICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoYiwgZCwgYm90dG9tKTtcblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBFeHBhbmQgYm9yZGVyc1xuXG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRvcCAtPSBib3JkZXI7XG4gICAgICAgICAgbGVmdCAtPSBib3JkZXI7XG4gICAgICAgICAgcmlnaHQgKz0gYm9yZGVyO1xuICAgICAgICAgIGJvdHRvbSArPSBib3JkZXI7XG4gICAgICAgIH1cblxuICAgICAgICB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICAgICAgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuXG4gICAgICAgIHJlY3QudG9wID0gdG9wO1xuICAgICAgICByZWN0LmxlZnQgPSBsZWZ0O1xuICAgICAgICByZWN0LnJpZ2h0ID0gcmlnaHQ7XG4gICAgICAgIHJlY3QuYm90dG9tID0gYm90dG9tO1xuICAgICAgICByZWN0LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlY3QuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIGlmICghcmVjdC5jZW50cm9pZCkge1xuICAgICAgICAgIHJlY3QuY2VudHJvaWQgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3QuY2VudHJvaWQueCA9IC0gbGVmdDtcbiAgICAgICAgcmVjdC5jZW50cm9pZC55ID0gLSB0b3A7XG5cbiAgICAgIH0sXG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZ2wsIHByb2dyYW0sIGZvcmNlZFBhcmVudCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSB8fCAhdGhpcy5fb3BhY2l0eSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHdoYXQgY2hhbmdlZFxuXG4gICAgICAgIHZhciBwYXJlbnQgPSBmb3JjZWRQYXJlbnQgfHwgdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBmbGFnUGFyZW50TWF0cml4ID0gcGFyZW50Ll9tYXRyaXgubWFudWFsIHx8IHBhcmVudC5fZmxhZ01hdHJpeDtcbiAgICAgICAgdmFyIGZsYWdNYXRyaXggPSB0aGlzLl9tYXRyaXgubWFudWFsIHx8IHRoaXMuX2ZsYWdNYXRyaXg7XG4gICAgICAgIHZhciBwYXJlbnRDaGFuZ2VkID0gdGhpcy5fcmVuZGVyZXIucGFyZW50ICE9PSBwYXJlbnQ7XG4gICAgICAgIHZhciBmbGFnVGV4dHVyZSA9IHRoaXMuX2ZsYWdWZXJ0aWNlcyB8fCB0aGlzLl9mbGFnRmlsbFxuICAgICAgICAgIHx8ICh0aGlzLl9maWxsIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnQgJiYgKHRoaXMuX2ZpbGwuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fZmlsbC5fZmxhZ1N0b3BzIHx8IHRoaXMuX2ZpbGwuX2ZsYWdFbmRQb2ludHMpKVxuICAgICAgICAgIHx8ICh0aGlzLl9maWxsIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnQgJiYgKHRoaXMuX2ZpbGwuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fZmlsbC5fZmxhZ1N0b3BzIHx8IHRoaXMuX2ZpbGwuX2ZsYWdSYWRpdXMgfHwgdGhpcy5fZmlsbC5fZmxhZ0NlbnRlciB8fCB0aGlzLl9maWxsLl9mbGFnRm9jYWwpKVxuICAgICAgICAgIHx8ICh0aGlzLl9maWxsIGluc3RhbmNlb2YgVGV4dHVyZSAmJiAodGhpcy5fZmlsbC5fZmxhZ0xvYWRlZCAmJiB0aGlzLl9maWxsLmxvYWRlZCB8fCB0aGlzLl9maWxsLl9mbGFnSW1hZ2UgfHwgdGhpcy5fZmlsbC5fZmxhZ1ZpZGVvIHx8IHRoaXMuX2ZpbGwuX2ZsYWdSZXBlYXQgfHwgdGhpcy5fZmlsbC5fZmxhZ09mZnNldCB8fCB0aGlzLl9maWxsLl9mbGFnU2NhbGUpKVxuICAgICAgICAgIHx8ICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBMaW5lYXJHcmFkaWVudCAmJiAodGhpcy5fc3Ryb2tlLl9mbGFnU3ByZWFkIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ1N0b3BzIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ0VuZFBvaW50cykpXG4gICAgICAgICAgfHwgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFJhZGlhbEdyYWRpZW50ICYmICh0aGlzLl9zdHJva2UuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnU3RvcHMgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnUmFkaXVzIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ0NlbnRlciB8fCB0aGlzLl9zdHJva2UuX2ZsYWdGb2NhbCkpXG4gICAgICAgICAgfHwgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFRleHR1cmUgJiYgKHRoaXMuX3N0cm9rZS5fZmxhZ0xvYWRlZCAmJiB0aGlzLl9zdHJva2UubG9hZGVkIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ0ltYWdlIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ1ZpZGVvIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ1JlcGVhdCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdPZmZzZXQgfHwgdGhpcy5fZmlsbC5fZmxhZ1NjYWxlKSlcbiAgICAgICAgICB8fCB0aGlzLl9mbGFnU3Ryb2tlIHx8IHRoaXMuX2ZsYWdMaW5ld2lkdGggfHwgdGhpcy5fZmxhZ09wYWNpdHlcbiAgICAgICAgICB8fCBwYXJlbnQuX2ZsYWdPcGFjaXR5IHx8IHRoaXMuX2ZsYWdWaXNpYmxlIHx8IHRoaXMuX2ZsYWdDYXBcbiAgICAgICAgICB8fCB0aGlzLl9mbGFnSm9pbiB8fCB0aGlzLl9mbGFnTWl0ZXIgfHwgdGhpcy5fZmxhZ1NjYWxlXG4gICAgICAgICAgfHwgKHRoaXMuZGFzaGVzICYmIHRoaXMuZGFzaGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgfHwgIXRoaXMuX3JlbmRlcmVyLnRleHR1cmU7XG5cbiAgICAgICAgaWYgKGZsYWdQYXJlbnRNYXRyaXggfHwgZmxhZ01hdHJpeCB8fCBwYXJlbnRDaGFuZ2VkKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLm1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubWF0cml4ID0gbmV3IE51bUFycmF5KDkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlZHVjZSBhbW91bnQgb2Ygb2JqZWN0IC8gYXJyYXkgY3JlYXRpb24gLyBkZWxldGlvblxuXG4gICAgICAgICAgdGhpcy5fbWF0cml4LnRvVHJhbnNmb3JtQXJyYXkodHJ1ZSwgdHJhbnNmb3JtYXRpb24pO1xuXG4gICAgICAgICAgbXVsdGlwbHlNYXRyaXgodHJhbnNmb3JtYXRpb24sIHBhcmVudC5fcmVuZGVyZXIubWF0cml4LCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xuXG4gICAgICAgICAgaWYgKCEodGhpcy5fcmVuZGVyZXIuc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZSA9IG5ldyBWZWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ID0gdGhpcy5fc2NhbGUueCAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgPSB0aGlzLl9zY2FsZS55ICogcGFyZW50Ll9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ID0gdGhpcy5fc2NhbGUgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLng7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS55ID0gdGhpcy5fc2NhbGUgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmVudENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuXG4gICAgICAgICAgLy8gU3RlbmNpbCBhd2F5IGV2ZXJ5dGhpbmcgdGhhdCBpc24ndCByZW5kZXJlZCBieSB0aGUgbWFza1xuICAgICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsIDEsIDApO1xuICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5SRVBMQUNFKTtcbiAgICAgICAgICAvLyBEb24ndCBkcmF3IHRoZSBlbGVtZW50IG9udG8gdGhlIGNhbnZhcywgb25seSBvbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgICB3ZWJnbFt0aGlzLl9tYXNrLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbCh0aGlzLl9tYXNrLCBnbCwgcHJvZ3JhbSwgdGhpcyk7XG5cbiAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMSwgMHhmZik7XG4gICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLktFRVApO1xuICAgICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdUZXh0dXJlKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLnJlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlY3QgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSAqIHBhcmVudC5fcmVuZGVyZXIub3BhY2l0eTtcblxuICAgICAgICAgIHdlYmdsLnBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzLCB0aGlzLl9saW5ld2lkdGgsIHRoaXMuX3JlbmRlcmVyLnJlY3QpO1xuXG4gICAgICAgICAgd2ViZ2wudXBkYXRlVGV4dHVyZS5jYWxsKHdlYmdsLCBnbCwgdGhpcyk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIGNoaWxkIFR3byBlbGVtZW50cyBvbiB0aGUgZmlsbCBhbmRcbiAgICAgICAgICAvLyBzdHJva2UgcHJvcGVydGllcy5cbiAgICAgICAgICBpZiAodGhpcy5fZmlsbCAmJiB0aGlzLl9maWxsLl91cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwuX3VwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICYmIHRoaXMuX3N0cm9rZS5fdXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UuX3VwZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NsaXAgJiYgIWZvcmNlZFBhcmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgVGV4dHVyZVxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9yZW5kZXJlci50ZXh0dXJlKTtcblxuICAgICAgICAvLyBEcmF3IFJlY3RcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZW5kZXJlci5yZWN0O1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHByb2dyYW0ubWF0cml4LCBmYWxzZSwgdGhpcy5fcmVuZGVyZXIubWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTRmKHByb2dyYW0ucmVjdCwgcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b20pO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRleHQ6IHtcblxuICAgICAgdXBkYXRlQ2FudmFzOiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICAgICAgLy8gU3R5bGVzXG4gICAgICAgIHZhciBzY2FsZSA9IGVsZW0uX3JlbmRlcmVyLnNjYWxlO1xuICAgICAgICB2YXIgc3Ryb2tlID0gZWxlbS5fc3Ryb2tlO1xuICAgICAgICB2YXIgbGluZXdpZHRoID0gZWxlbS5fbGluZXdpZHRoICogc2NhbGU7XG4gICAgICAgIHZhciBmaWxsID0gZWxlbS5fZmlsbDtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBlbGVtLl9yZW5kZXJlci5vcGFjaXR5IHx8IGVsZW0uX29wYWNpdHk7XG4gICAgICAgIHZhciBkYXNoZXMgPSBlbGVtLmRhc2hlcztcbiAgICAgICAgdmFyIGRlY29yYXRpb24gPSBlbGVtLl9kZWNvcmF0aW9uO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChlbGVtLl9yZW5kZXJlci5yZWN0LndpZHRoICogc2NhbGUueCksIDEpO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKGVsZW0uX3JlbmRlcmVyLnJlY3QuaGVpZ2h0ICogc2NhbGUueSksIDEpO1xuXG4gICAgICAgIHZhciBjZW50cm9pZCA9IGVsZW0uX3JlbmRlcmVyLnJlY3QuY2VudHJvaWQ7XG4gICAgICAgIHZhciBjeCA9IGNlbnRyb2lkLng7XG4gICAgICAgIHZhciBjeSA9IGNlbnRyb2lkLnk7XG5cbiAgICAgICAgdmFyIGEsIGIsIGMsIGQsIGUsIHN4LCBzeSwgeDEsIHkxLCB4MiwgeTI7XG4gICAgICAgIHZhciBpc09mZnNldCA9IGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldFxuICAgICAgICAgICYmIHN0cm9rZS5fcmVuZGVyZXIgJiYgc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQ7XG5cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmICghaXNPZmZzZXQpIHtcbiAgICAgICAgICBjdHguZm9udCA9IFtlbGVtLl9zdHlsZSwgZWxlbS5fd2VpZ2h0LCBlbGVtLl9zaXplICsgJ3B4LycgK1xuICAgICAgICAgICAgZWxlbS5fbGVhZGluZyArICdweCcsIGVsZW0uX2ZhbWlseV0uam9pbignICcpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG5cbiAgICAgICAgLy8gU3R5bGVzXG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlYmdsW2ZpbGwuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGZpbGwsIGN0eCwgZWxlbSk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC5fcmVuZGVyZXIuZWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdHJva2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlYmdsW3N0cm9rZS5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoc3Ryb2tlLCBjdHgsIGVsZW0pO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLl9yZW5kZXJlci5lZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5ld2lkdGgpIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5ld2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXNoZXMgJiYgZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoZXMub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoc2NhbGUueCwgc2NhbGUueSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcblxuICAgICAgICBpZiAoIXdlYmdsLmlzSGlkZGVuLnRlc3QoZmlsbCkpIHtcblxuICAgICAgICAgIGlmIChmaWxsLl9yZW5kZXJlciAmJiBmaWxsLl9yZW5kZXJlci5vZmZzZXQpIHtcblxuICAgICAgICAgICAgc3ggPSBmaWxsLl9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgc3kgPSBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xuXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSggLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCxcbiAgICAgICAgICAgICAgLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueSk7XG4gICAgICAgICAgICBjdHguc2NhbGUoc3gsIHN5KTtcblxuICAgICAgICAgICAgYSA9IGVsZW0uX3NpemUgLyBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgYiA9IGVsZW0uX2xlYWRpbmcgLyBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBbZWxlbS5fc3R5bGUsIGVsZW0uX3dlaWdodCwgYSArICdweC8nLFxuICAgICAgICAgICAgICBiICsgJ3B4JywgZWxlbS5fZmFtaWx5XS5qb2luKCcgJyk7XG5cbiAgICAgICAgICAgIGMgPSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLng7XG4gICAgICAgICAgICBkID0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LnkgLyBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xuXG4gICAgICAgICAgICBjdHguZmlsbFRleHQoZWxlbS52YWx1ZSwgYywgZCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChlbGVtLnZhbHVlLCAwLCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd2ViZ2wuaXNIaWRkZW4udGVzdChzdHJva2UpKSB7XG5cbiAgICAgICAgICBpZiAoc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldCkge1xuXG4gICAgICAgICAgICBzeCA9IHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIHN5ID0gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xuXG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LngsXG4gICAgICAgICAgICAgIC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueSk7XG4gICAgICAgICAgICBjdHguc2NhbGUoc3gsIHN5KTtcblxuICAgICAgICAgICAgYSA9IGVsZW0uX3NpemUgLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgICBiID0gZWxlbS5fbGVhZGluZyAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcbiAgICAgICAgICAgIGN0eC5mb250ID0gW2VsZW0uX3N0eWxlLCBlbGVtLl93ZWlnaHQsIGEgKyAncHgvJyxcbiAgICAgICAgICAgICAgYiArICdweCcsIGVsZW0uX2ZhbWlseV0uam9pbignICcpO1xuXG4gICAgICAgICAgICBjID0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueCAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIGQgPSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55IC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgZSA9IGxpbmV3aWR0aCAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcblxuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGU7XG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dChlbGVtLnZhbHVlLCBjLCBkKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQoZWxlbS52YWx1ZSwgMCwgMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgdGV4dC1kZWNvcmF0aW9uXG4gICAgICAgIGlmICgvKHVuZGVybGluZXxzdHJpa2V0aHJvdWdoKS9pLnRlc3QoZGVjb3JhdGlvbikpIHtcblxuICAgICAgICAgIHZhciBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KGVsZW0udmFsdWUpO1xuXG4gICAgICAgICAgc3dpdGNoIChkZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd1bmRlcmxpbmUnOlxuICAgICAgICAgICAgICB5MSA9IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICAgICAgICAgIHkyID0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzdHJpa2V0aHJvdWdoJzpcbiAgICAgICAgICAgICAgeTEgPSAwO1xuICAgICAgICAgICAgICB5MiA9IDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgxID0gLSBtZXRyaWNzLndpZHRoIC8gMjtcbiAgICAgICAgICB4MiA9IG1ldHJpY3Mud2lkdGggLyAyO1xuXG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWF4KE1hdGguZmxvb3IoZWxlbS5fc2l6ZSAvIDE1KSwgMSk7XG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4MiwgeTIpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgfSxcblxuICAgICAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0OiBmdW5jdGlvbihlbGVtLCByZWN0KSB7XG5cbiAgICAgICAgdmFyIGN0eCA9IHdlYmdsLmN0eDtcblxuICAgICAgICBjdHguZm9udCA9IFtlbGVtLl9zdHlsZSwgZWxlbS5fd2VpZ2h0LCBlbGVtLl9zaXplICsgJ3B4LycgK1xuICAgICAgICAgIGVsZW0uX2xlYWRpbmcgKyAncHgnLCBlbGVtLl9mYW1pbHldLmpvaW4oJyAnKTtcblxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBlbGVtLl9iYXNlbGluZTtcblxuICAgICAgICAvLyBUT0RPOiBFc3RpbWF0ZSB0aGlzIGJldHRlclxuICAgICAgICB2YXIgd2lkdGggPSBjdHgubWVhc3VyZVRleHQoZWxlbS5fdmFsdWUpLndpZHRoICogMS4yNTtcbiAgICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGVsZW0uX3NpemUsIGVsZW0uX2xlYWRpbmcpICogMS4yNTtcblxuICAgICAgICBpZiAodGhpcy5fbGluZXdpZHRoICYmICF3ZWJnbC5pc0hpZGRlbi50ZXN0KHRoaXMuX3N0cm9rZSkpIHtcbiAgICAgICAgICB3aWR0aCArPSB0aGlzLl9saW5ld2lkdGggKiAyO1xuICAgICAgICAgIGhlaWdodCArPSB0aGlzLl9saW5ld2lkdGggKiAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHcgPSB3aWR0aCAvIDI7XG4gICAgICAgIHZhciBoID0gaGVpZ2h0IC8gMjtcblxuICAgICAgICBzd2l0Y2ggKHdlYmdsLmFsaWdubWVudHNbZWxlbS5fYWxpZ25tZW50XSB8fCBlbGVtLl9hbGlnbm1lbnQpIHtcblxuICAgICAgICAgIGNhc2Ugd2ViZ2wuYWxpZ25tZW50cy5sZWZ0OlxuICAgICAgICAgICAgcmVjdC5sZWZ0ID0gMDtcbiAgICAgICAgICAgIHJlY3QucmlnaHQgPSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2Ugd2ViZ2wuYWxpZ25tZW50cy5yaWdodDpcbiAgICAgICAgICAgIHJlY3QubGVmdCA9IC0gd2lkdGg7XG4gICAgICAgICAgICByZWN0LnJpZ2h0ID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWN0LmxlZnQgPSAtIHc7XG4gICAgICAgICAgICByZWN0LnJpZ2h0ID0gdztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE86IEdyYWRpZW50cyBhcmVuJ3QgaW5oZXJpdGVkLi4uXG4gICAgICAgIHN3aXRjaCAoZWxlbS5fYmFzZWxpbmUpIHtcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgcmVjdC50b3AgPSAtIGhlaWdodDtcbiAgICAgICAgICAgIHJlY3QuYm90dG9tID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICByZWN0LnRvcCA9IDA7XG4gICAgICAgICAgICByZWN0LmJvdHRvbSA9IGhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZWN0LnRvcCA9IC0gaDtcbiAgICAgICAgICAgIHJlY3QuYm90dG9tID0gaDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFyZWN0LmNlbnRyb2lkKSB7XG4gICAgICAgICAgcmVjdC5jZW50cm9pZCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzpcbiAgICAgICAgcmVjdC5jZW50cm9pZC54ID0gdztcbiAgICAgICAgcmVjdC5jZW50cm9pZC55ID0gaDtcblxuICAgICAgfSxcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZm9yY2VkUGFyZW50KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aXNpYmxlIHx8ICF0aGlzLl9vcGFjaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgd2hhdCBjaGFuZ2VkXG5cbiAgICAgICAgdmFyIHBhcmVudCA9IGZvcmNlZFBhcmVudCB8fCB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIGZsYWdQYXJlbnRNYXRyaXggPSBwYXJlbnQuX21hdHJpeC5tYW51YWwgfHwgcGFyZW50Ll9mbGFnTWF0cml4O1xuICAgICAgICB2YXIgZmxhZ01hdHJpeCA9IHRoaXMuX21hdHJpeC5tYW51YWwgfHwgdGhpcy5fZmxhZ01hdHJpeDtcbiAgICAgICAgdmFyIHBhcmVudENoYW5nZWQgPSB0aGlzLl9yZW5kZXJlci5wYXJlbnQgIT09IHBhcmVudDtcbiAgICAgICAgdmFyIGZsYWdUZXh0dXJlID0gdGhpcy5fZmxhZ1ZlcnRpY2VzIHx8IHRoaXMuX2ZsYWdGaWxsXG4gICAgICAgICAgfHwgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBMaW5lYXJHcmFkaWVudCAmJiAodGhpcy5fZmlsbC5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9maWxsLl9mbGFnU3RvcHMgfHwgdGhpcy5fZmlsbC5fZmxhZ0VuZFBvaW50cykpXG4gICAgICAgICAgfHwgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudCAmJiAodGhpcy5fZmlsbC5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9maWxsLl9mbGFnU3RvcHMgfHwgdGhpcy5fZmlsbC5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9maWxsLl9mbGFnQ2VudGVyIHx8IHRoaXMuX2ZpbGwuX2ZsYWdGb2NhbCkpXG4gICAgICAgICAgfHwgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUZXh0dXJlICYmICh0aGlzLl9maWxsLl9mbGFnTG9hZGVkICYmIHRoaXMuX2ZpbGwubG9hZGVkIHx8IHRoaXMuX2ZpbGwuX2ZsYWdJbWFnZSB8fCB0aGlzLl9maWxsLl9mbGFnVmlkZW8gfHwgdGhpcy5fZmlsbC5fZmxhZ1JlcGVhdCB8fCB0aGlzLl9maWxsLl9mbGFnT2Zmc2V0IHx8IHRoaXMuX2ZpbGwuX2ZsYWdTY2FsZSkpXG4gICAgICAgICAgfHwgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50ICYmICh0aGlzLl9zdHJva2UuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnU3RvcHMgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnRW5kUG9pbnRzKSlcbiAgICAgICAgICB8fCAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnQgJiYgKHRoaXMuX3N0cm9rZS5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdTdG9wcyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdSYWRpdXMgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnQ2VudGVyIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ0ZvY2FsKSlcbiAgICAgICAgICB8fCAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVGV4dHVyZSAmJiAodGhpcy5fc3Ryb2tlLl9mbGFnTG9hZGVkICYmIHRoaXMuX3N0cm9rZS5sb2FkZWQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnSW1hZ2UgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnVmlkZW8gfHwgdGhpcy5fc3Ryb2tlLl9mbGFnUmVwZWF0IHx8IHRoaXMuX3N0cm9rZS5fZmxhZ09mZnNldCB8fCB0aGlzLl9maWxsLl9mbGFnU2NhbGUpKVxuICAgICAgICAgIHx8IHRoaXMuX2ZsYWdTdHJva2UgfHwgdGhpcy5fZmxhZ0xpbmV3aWR0aCB8fCB0aGlzLl9mbGFnT3BhY2l0eVxuICAgICAgICAgIHx8IHBhcmVudC5fZmxhZ09wYWNpdHkgfHwgdGhpcy5fZmxhZ1Zpc2libGUgfHwgdGhpcy5fZmxhZ1NjYWxlXG4gICAgICAgICAgfHwgdGhpcy5fZmxhZ1ZhbHVlIHx8IHRoaXMuX2ZsYWdGYW1pbHkgfHwgdGhpcy5fZmxhZ1NpemVcbiAgICAgICAgICB8fCB0aGlzLl9mbGFnTGVhZGluZyB8fCB0aGlzLl9mbGFnQWxpZ25tZW50IHx8IHRoaXMuX2ZsYWdCYXNlbGluZVxuICAgICAgICAgIHx8IHRoaXMuX2ZsYWdTdHlsZSB8fCB0aGlzLl9mbGFnV2VpZ2h0IHx8IHRoaXMuX2ZsYWdEZWNvcmF0aW9uXG4gICAgICAgICAgfHwgKHRoaXMuZGFzaGVzICYmIHRoaXMuZGFzaGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgfHwgIXRoaXMuX3JlbmRlcmVyLnRleHR1cmU7XG5cbiAgICAgICAgaWYgKGZsYWdQYXJlbnRNYXRyaXggfHwgZmxhZ01hdHJpeCB8fCBwYXJlbnRDaGFuZ2VkKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLm1hdHJpeCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIubWF0cml4ID0gbmV3IE51bUFycmF5KDkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlZHVjZSBhbW91bnQgb2Ygb2JqZWN0IC8gYXJyYXkgY3JlYXRpb24gLyBkZWxldGlvblxuXG4gICAgICAgICAgdGhpcy5fbWF0cml4LnRvVHJhbnNmb3JtQXJyYXkodHJ1ZSwgdHJhbnNmb3JtYXRpb24pO1xuXG4gICAgICAgICAgbXVsdGlwbHlNYXRyaXgodHJhbnNmb3JtYXRpb24sIHBhcmVudC5fcmVuZGVyZXIubWF0cml4LCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xuXG4gICAgICAgICAgaWYgKCEodGhpcy5fcmVuZGVyZXIuc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZSA9IG5ldyBWZWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ID0gdGhpcy5fc2NhbGUueCAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgPSB0aGlzLl9zY2FsZS55ICogcGFyZW50Ll9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS54ID0gdGhpcy5fc2NhbGUgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLng7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS55ID0gdGhpcy5fc2NhbGUgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHBhcmVudENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuXG4gICAgICAgICAgLy8gU3RlbmNpbCBhd2F5IGV2ZXJ5dGhpbmcgdGhhdCBpc24ndCByZW5kZXJlZCBieSB0aGUgbWFza1xuICAgICAgICAgIGdsLmNsZWFyKGdsLlNURU5DSUxfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgZ2wuZW5hYmxlKGdsLlNURU5DSUxfVEVTVCk7XG5cbiAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5BTFdBWVMsIDEsIDApO1xuICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5SRVBMQUNFKTtcbiAgICAgICAgICAvLyBEb24ndCBkcmF3IHRoZSBlbGVtZW50IG9udG8gdGhlIGNhbnZhcywgb25seSBvbnRvIHRoZSBzdGVuY2lsIGJ1ZmZlclxuICAgICAgICAgIGdsLmNvbG9yTWFzayhmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSk7XG5cbiAgICAgICAgICB3ZWJnbFt0aGlzLl9tYXNrLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbCh0aGlzLl9tYXNrLCBnbCwgcHJvZ3JhbSwgdGhpcyk7XG5cbiAgICAgICAgICBnbC5zdGVuY2lsRnVuYyhnbC5FUVVBTCwgMSwgMHhmZik7XG4gICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLktFRVApO1xuICAgICAgICAgIGdsLmNvbG9yTWFzayh0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdUZXh0dXJlKSB7XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLnJlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnJlY3QgPSB7fTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSAqIHBhcmVudC5fcmVuZGVyZXIub3BhY2l0eTtcblxuICAgICAgICAgIHdlYmdsLnRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRoaXMsIHRoaXMuX3JlbmRlcmVyLnJlY3QpO1xuXG4gICAgICAgICAgd2ViZ2wudXBkYXRlVGV4dHVyZS5jYWxsKHdlYmdsLCBnbCwgdGhpcyk7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIFdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIGNoaWxkIFR3byBlbGVtZW50cyBvbiB0aGUgZmlsbCBhbmRcbiAgICAgICAgICAvLyBzdHJva2UgcHJvcGVydGllcy5cbiAgICAgICAgICBpZiAodGhpcy5fZmlsbCAmJiB0aGlzLl9maWxsLl91cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwuX3VwZGF0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc3Ryb2tlICYmIHRoaXMuX3N0cm9rZS5fdXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UuX3VwZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NsaXAgJiYgIWZvcmNlZFBhcmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgVGV4dHVyZVxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9yZW5kZXJlci50ZXh0dXJlKTtcblxuICAgICAgICAvLyBEcmF3IFJlY3RcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLl9yZW5kZXJlci5yZWN0O1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHByb2dyYW0ubWF0cml4LCBmYWxzZSwgdGhpcy5fcmVuZGVyZXIubWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTRmKHByb2dyYW0ucmVjdCwgcmVjdC5sZWZ0LCByZWN0LnRvcCwgcmVjdC5yaWdodCwgcmVjdC5ib3R0b20pO1xuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgICdsaW5lYXItZ3JhZGllbnQnOiB7XG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBlbGVtKSB7XG5cbiAgICAgICAgaWYgKCFjdHguY2FudmFzLmdldENvbnRleHQoJzJkJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3JlbmRlcmVyLmVmZmVjdCB8fCB0aGlzLl9mbGFnRW5kUG9pbnRzIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xuXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KFxuICAgICAgICAgICAgdGhpcy5sZWZ0Ll94LCB0aGlzLmxlZnQuX3ksXG4gICAgICAgICAgICB0aGlzLnJpZ2h0Ll94LCB0aGlzLnJpZ2h0Ll95XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0b3AgPSB0aGlzLnN0b3BzW2ldO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0LmFkZENvbG9yU3RvcChzdG9wLl9vZmZzZXQsIHN0b3AuX2NvbG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgJ3JhZGlhbC1ncmFkaWVudCc6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGVsZW0pIHtcblxuICAgICAgICBpZiAoIWN0eC5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWZmZWN0IHx8IHRoaXMuX2ZsYWdDZW50ZXIgfHwgdGhpcy5fZmxhZ0ZvY2FsXG4gICAgICAgICAgICB8fCB0aGlzLl9mbGFnUmFkaXVzIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xuXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgICAgdGhpcy5jZW50ZXIuX3gsIHRoaXMuY2VudGVyLl95LCAwLFxuICAgICAgICAgICAgdGhpcy5mb2NhbC5feCwgdGhpcy5mb2NhbC5feSwgdGhpcy5fcmFkaXVzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0b3AgPSB0aGlzLnN0b3BzW2ldO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0LmFkZENvbG9yU3RvcChzdG9wLl9vZmZzZXQsIHN0b3AuX2NvbG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGV4dHVyZToge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCwgZWxlbSkge1xuXG4gICAgICAgIGlmICghY3R4LmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5pbWFnZTtcblxuICAgICAgICBpZiAoKCh0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdJbWFnZSB8fCB0aGlzLl9mbGFnVmlkZW8gfHwgdGhpcy5fZmxhZ1JlcGVhdCkgJiYgdGhpcy5sb2FkZWQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0ID0gY3R4LmNyZWF0ZVBhdHRlcm4oaW1hZ2UsIHRoaXMuX3JlcGVhdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3JlbmRlcmVyLmVmZmVjdCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPZmZzZXQgfHwgdGhpcy5fZmxhZ0xvYWRlZCB8fCB0aGlzLl9mbGFnU2NhbGUpIHtcblxuICAgICAgICAgIGlmICghKHRoaXMuX3JlbmRlcmVyLm9mZnNldCBpbnN0YW5jZW9mIFZlY3RvcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldCA9IG5ldyBWZWN0b3IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueCA9IC0gdGhpcy5fb2Zmc2V0Lng7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgPSAtIHRoaXMuX29mZnNldC55O1xuXG4gICAgICAgICAgaWYgKGltYWdlKSB7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ICs9IGltYWdlLndpZHRoIC8gMjtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ICs9IGltYWdlLmhlaWdodCAvIDI7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueCAqPSB0aGlzLl9zY2FsZS54O1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueSAqPSB0aGlzLl9zY2FsZS55O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnggKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTY2FsZSB8fCB0aGlzLl9mbGFnTG9hZGVkKSB7XG5cbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5zY2FsZSBpbnN0YW5jZW9mIFZlY3RvcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlID0gbmV3IFZlY3RvcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUuY29weSh0aGlzLl9zY2FsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnNldCh0aGlzLl9zY2FsZSwgdGhpcy5fc2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICB1cGRhdGVUZXh0dXJlOiBmdW5jdGlvbihnbCwgZWxlbSkge1xuXG4gICAgICB0aGlzW2VsZW0uX3JlbmRlcmVyLnR5cGVdLnVwZGF0ZUNhbnZhcy5jYWxsKHdlYmdsLCBlbGVtKTtcblxuICAgICAgaWYgKCFlbGVtLl9yZW5kZXJlci50ZXh0dXJlKSB7XG4gICAgICAgIGVsZW0uX3JlbmRlcmVyLnRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICB9XG5cbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGVsZW0uX3JlbmRlcmVyLnRleHR1cmUpO1xuXG4gICAgICAvLyBTZXQgdGhlIHBhcmFtZXRlcnMgc28gd2UgY2FuIHJlbmRlciBhbnkgc2l6ZSBpbWFnZS5cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgIC8vIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgLy8gZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xuICAgICAgLy8gZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMud2lkdGggPD0gMCB8fCB0aGlzLmNhbnZhcy5oZWlnaHQgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFVwbG9hZCB0aGUgaW1hZ2UgaW50byB0aGUgdGV4dHVyZS5cbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5jYW52YXMpO1xuXG4gICAgfSxcblxuICAgIHByb2dyYW06IHtcblxuICAgICAgY3JlYXRlOiBmdW5jdGlvbihnbCwgc2hhZGVycykge1xuICAgICAgICB2YXIgcHJvZ3JhbSwgbGlua2VkLCBlcnJvcjtcbiAgICAgICAgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgXy5lYWNoKHNoYWRlcnMsIGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBsaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcbiAgICAgICAgaWYgKCFsaW5rZWQpIHtcbiAgICAgICAgICBlcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgICAgICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3b0Vycm9yKCd1bmFibGUgdG8gbGluayBwcm9ncmFtOiAnICsgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBzaGFkZXJzOiB7XG5cbiAgICAgIGNyZWF0ZTogZnVuY3Rpb24oZ2wsIHNvdXJjZSwgdHlwZSkge1xuICAgICAgICB2YXIgc2hhZGVyLCBjb21waWxlZCwgZXJyb3I7XG4gICAgICAgIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbFt0eXBlXSk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAgICAgICBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcbiAgICAgICAgaWYgKCFjb21waWxlZCkge1xuICAgICAgICAgIGVycm9yID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgICAgICAgIHRocm93IG5ldyBUd29FcnJvcigndW5hYmxlIHRvIGNvbXBpbGUgc2hhZGVyICcgKyBzaGFkZXIgKyAnOiAnICsgZXJyb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcblxuICAgICAgfSxcblxuICAgICAgdHlwZXM6IHtcbiAgICAgICAgdmVydGV4OiAnVkVSVEVYX1NIQURFUicsXG4gICAgICAgIGZyYWdtZW50OiAnRlJBR01FTlRfU0hBREVSJ1xuICAgICAgfSxcblxuICAgICAgdmVydGV4OiBbXG4gICAgICAgICdwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDsnLFxuICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnLFxuICAgICAgICAnJyxcbiAgICAgICAgJ3VuaWZvcm0gbWF0MyB1X21hdHJpeDsnLFxuICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnLFxuICAgICAgICAndW5pZm9ybSB2ZWM0IHVfcmVjdDsnLFxuICAgICAgICAnJyxcbiAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleHR1cmVDb29yZHM7JyxcbiAgICAgICAgJycsXG4gICAgICAgICd2b2lkIG1haW4oKSB7JyxcbiAgICAgICAgJyAgIHZlYzIgcmVjdENvb3JkcyA9IChhX3Bvc2l0aW9uICogKHVfcmVjdC56dyAtIHVfcmVjdC54eSkpICsgdV9yZWN0Lnh5OycsXG4gICAgICAgICcgICB2ZWMyIHByb2plY3RlZCA9ICh1X21hdHJpeCAqIHZlYzMocmVjdENvb3JkcywgMS4wKSkueHk7JyxcbiAgICAgICAgJyAgIHZlYzIgbm9ybWFsID0gcHJvamVjdGVkIC8gdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICcgICB2ZWMyIGNsaXBzcGFjZSA9IChub3JtYWwgKiAyLjApIC0gMS4wOycsXG4gICAgICAgICcnLFxuICAgICAgICAnICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBzcGFjZSAqIHZlYzIoMS4wLCAtMS4wKSwgMC4wLCAxLjApOycsXG4gICAgICAgICcgICB2X3RleHR1cmVDb29yZHMgPSBhX3Bvc2l0aW9uOycsXG4gICAgICAgICd9J1xuICAgICAgXS5qb2luKCdcXG4nKSxcblxuICAgICAgZnJhZ21lbnQ6IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICcnLFxuICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTsnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkczsnLFxuICAgICAgICAnJyxcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAnICB2ZWM0IHRleGVsID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4dHVyZUNvb3Jkcyk7JyxcbiAgICAgICAgJyAgaWYgKHRleGVsLmEgPT0gMC4wKSB7JyxcbiAgICAgICAgJyAgICBkaXNjYXJkOycsXG4gICAgICAgICcgIH0nLFxuICAgICAgICAnICBnbF9GcmFnQ29sb3IgPSB0ZXhlbDsnLFxuICAgICAgICAnfSdcbiAgICAgIF0uam9pbignXFxuJylcblxuICAgIH0sXG5cbiAgICBUZXh0dXJlUmVnaXN0cnk6IG5ldyBSZWdpc3RyeSgpXG5cbiAgfTtcblxuICB3ZWJnbC5jdHggPSB3ZWJnbC5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXJcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5FdmVudHNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbWV0ZXJzXSAtIFRoaXMgb2JqZWN0IGlzIGluaGVyaXRlZCB3aGVuIGNvbnN0cnVjdGluZyBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvfS5cbiAgICogQHBhcmFtIHtFbGVtZW50fSBbcGFyYW1ldGVycy5kb21FbGVtZW50XSAtIFRoZSBgPGNhbnZhcyAvPmAgdG8gZHJhdyB0by4gSWYgbm9uZSBnaXZlbiBhIG5ldyBvbmUgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gW3BhcmFtZXRlcnMub2Zmc2NyZWVuRWxlbWVudF0gLSBUaGUgb2Zmc2NyZWVuIHR3byBkaW1lbnNpb25hbCBgPGNhbnZhcyAvPmAgdG8gcmVuZGVyIGVhY2ggZWxlbWVudCBvbiBXZWJHTCB0ZXh0dXJlIHVwZGF0ZXMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3BhcmFtZXRlcnMuYW50aWFsaWFzXSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBjbGVhciByZW5kZXIgd2l0aCBhbnRpYWxpYXMgb24uXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGNsYXNzIGlzIHVzZWQgYnkge0BsaW5rIFR3b30gd2hlbiBjb25zdHJ1Y3Rpbmcgd2l0aCBgdHlwZWAgb2YgYFR3by5UeXBlcy53ZWJnbGAuIEl0IHRha2VzIFR3by5qcycgc2NlbmVncmFwaCBhbmQgcmVuZGVycyBpdCB0byBhIGA8Y2FudmFzIC8+YCB0aHJvdWdoIHRoZSBXZWJHTCBhcGkuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL3NwZWNzL2xhdGVzdC8xLjAvfVxuICAgKi9cbiAgZnVuY3Rpb24gUmVuZGVyZXIocGFyYW1zKSB7XG5cbiAgICB2YXIgZ2wsIHZzLCBmcztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyI2RvbUVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IC0gVGhlIGA8Y2FudmFzIC8+YCBhc3NvY2lhdGVkIHdpdGggdGhlIFR3by5qcyBzY2VuZS5cbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBwYXJhbXMuZG9tRWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zLm9mZnNjcmVlbkVsZW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB3ZWJnbC5jYW52YXMgPSBwYXJhbXMub2Zmc2NyZWVuRWxlbWVudDtcbiAgICAgIHdlYmdsLmN0eCA9IHdlYmdsLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyI3NjZW5lXG4gICAgICogQHByb3BlcnR5IHtUd28uR3JvdXB9IC0gVGhlIHJvb3QgZ3JvdXAgb2YgdGhlIHNjZW5lZ3JhcGguXG4gICAgICovXG4gICAgdGhpcy5zY2VuZSA9IG5ldyBHcm91cCgpO1xuICAgIHRoaXMuc2NlbmUucGFyZW50ID0gdGhpcztcblxuICAgIHRoaXMuX3JlbmRlcmVyID0ge1xuICAgICAgdHlwZTogJ3JlbmRlcmVyJyxcbiAgICAgIG1hdHJpeDogbmV3IE51bUFycmF5KGlkZW50aXR5KSxcbiAgICAgIHNjYWxlOiAxLFxuICAgICAgb3BhY2l0eTogMVxuICAgIH07XG4gICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG5cbiAgICAvLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL2dhbWUvd2ViZ2wtYW5kLWFscGhhL1xuICAgIC8vIGh0dHA6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvbGF0ZXN0LyM1LjJcbiAgICBwYXJhbXMgPSBfLmRlZmF1bHRzKHBhcmFtcyB8fCB7fSwge1xuICAgICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICAgIGFscGhhOiB0cnVlLFxuICAgICAgcHJlbXVsdGlwbGllZEFscGhhOiB0cnVlLFxuICAgICAgc3RlbmNpbDogdHJ1ZSxcbiAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSxcbiAgICAgIG92ZXJkcmF3OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjb3ZlcmRyYXdcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYW52YXMgY2xlYXJzIHRoZSBiYWNrZ3JvdW5kIGVhY2ggZHJhdyBjYWxsLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJkcmF3ID0gcGFyYW1zLm92ZXJkcmF3O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjY3R4XG4gICAgICogQHByb3BlcnR5IHtXZWJHTENvbnRleHR9IC0gQXNzb2NpYXRlZCB0d28gZGltZW5zaW9uYWwgY29udGV4dCB0byByZW5kZXIgb24gdGhlIGA8Y2FudmFzIC8+YC5cbiAgICAgKi9cbiAgICBnbCA9IHRoaXMuY3R4ID0gdGhpcy5kb21FbGVtZW50LmdldENvbnRleHQoJ3dlYmdsJywgcGFyYW1zKSB8fFxuICAgICAgdGhpcy5kb21FbGVtZW50LmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHBhcmFtcyk7XG5cbiAgICBpZiAoIXRoaXMuY3R4KSB7XG4gICAgICB0aHJvdyBuZXcgVHdvRXJyb3IoXG4gICAgICAgICd1bmFibGUgdG8gY3JlYXRlIGEgd2ViZ2wgY29udGV4dC4gVHJ5IHVzaW5nIGFub3RoZXIgcmVuZGVyZXIuJyk7XG4gICAgfVxuXG4gICAgLy8gQ29tcGlsZSBCYXNlIFNoYWRlcnMgdG8gZHJhdyBpbiBwaXhlbCBzcGFjZS5cbiAgICB2cyA9IHdlYmdsLnNoYWRlcnMuY3JlYXRlKFxuICAgICAgZ2wsIHdlYmdsLnNoYWRlcnMudmVydGV4LCB3ZWJnbC5zaGFkZXJzLnR5cGVzLnZlcnRleCk7XG4gICAgZnMgPSB3ZWJnbC5zaGFkZXJzLmNyZWF0ZShcbiAgICAgIGdsLCB3ZWJnbC5zaGFkZXJzLmZyYWdtZW50LCB3ZWJnbC5zaGFkZXJzLnR5cGVzLmZyYWdtZW50KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyI3Byb2dyYW1cbiAgICAgKiBAcHJvcGVydHkge1dlYkdMUHJvZ3JhbX0gLSBBc3NvY2lhdGVkIFdlYkdMIHByb2dyYW0gdG8gcmVuZGVyIGFsbCBlbGVtZW50cyBmcm9tIHRoZSBzY2VuZWdyYXBoLlxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IHdlYmdsLnByb2dyYW0uY3JlYXRlKGdsLCBbdnMsIGZzXSk7XG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xuXG4gICAgLy8gQ3JlYXRlIGFuZCBiaW5kIHRoZSBkcmF3aW5nIGJ1ZmZlclxuXG4gICAgLy8gbG9vayB1cCB3aGVyZSB0aGUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ28uXG4gICAgdGhpcy5wcm9ncmFtLnBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xuICAgIHRoaXMucHJvZ3JhbS5tYXRyaXggPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCAndV9tYXRyaXgnKTtcbiAgICB0aGlzLnByb2dyYW0ucmVjdCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICd1X3JlY3QnKTtcblxuICAgIC8vIEJpbmQgdGhlIHZlcnRleCBidWZmZXJcbiAgICB2YXIgcG9zaXRpb25CdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb25CdWZmZXIpO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5wcm9ncmFtLnBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMucHJvZ3JhbS5wb3NpdGlvbik7XG4gICAgZ2wuYnVmZmVyRGF0YShcbiAgICAgIGdsLkFSUkFZX0JVRkZFUixcbiAgICAgIG5ldyBOdW1BcnJheShbXG4gICAgICAgIDAsIDAsXG4gICAgICAgIDEsIDAsXG4gICAgICAgIDAsIDEsXG4gICAgICAgIDAsIDEsXG4gICAgICAgIDEsIDAsXG4gICAgICAgIDEsIDFcbiAgICAgIF0pLFxuICAgICAgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgLy8gU2V0dXAgc29tZSBpbml0aWFsIHN0YXRlbWVudHMgb2YgdGhlIGdsIGNvbnRleHRcbiAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcblxuICAgIGdsLmJsZW5kRXF1YXRpb24oZ2wuRlVOQ19BREQpO1xuICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICB9XG5cbiAgXy5leHRlbmQoUmVuZGVyZXIsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyLlV0aWxzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gQSBtYXNzaXZlIG9iamVjdCBmaWxsZWQgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllcyB0byByZW5kZXIgVHdvLmpzIG9iamVjdHMgdG8gYSBgPGNhbnZhcyAvPmAgdGhyb3VnaCB0aGUgV2ViR0wgQVBJLlxuICAgICAqL1xuICAgIFV0aWxzOiB3ZWJnbFxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFJlbmRlcmVyLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUmVuZGVyZXIsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uV2ViR0xSZW5kZXJlciNzZXRTaXplXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIHJlc2l6ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgd2lkdGggb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHQgLSBUaGUgbmV3IGhlaWdodCBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYXRpb10gLSBUaGUgbmV3IHBpeGVsIHJhdGlvIChwaXhlbCBkZW5zaXR5KSBvZiB0aGUgcmVuZGVyZXIuIERlZmF1bHRzIHRvIGNhbGN1bGF0ZSB0aGUgcGl4ZWwgZGVuc2l0eSBvZiB0aGUgdXNlcidzIHNjcmVlbi5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2hhbmdlIHRoZSBzaXplIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBzZXRTaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCByYXRpbykge1xuXG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgdGhpcy5yYXRpbyA9IHR5cGVvZiByYXRpbyA9PT0gJ3VuZGVmaW5lZCcgPyBnZXRSYXRpbyh0aGlzLmN0eCkgOiByYXRpbztcblxuICAgICAgdGhpcy5kb21FbGVtZW50LndpZHRoID0gd2lkdGggKiB0aGlzLnJhdGlvO1xuICAgICAgdGhpcy5kb21FbGVtZW50LmhlaWdodCA9IGhlaWdodCAqIHRoaXMucmF0aW87XG5cbiAgICAgIGlmIChfLmlzT2JqZWN0KHRoaXMuZG9tRWxlbWVudC5zdHlsZSkpIHtcbiAgICAgICAgXy5leHRlbmQodGhpcy5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICAgICAgd2lkdGg6IHdpZHRoICsgJ3B4JyxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCArICdweCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBmb3IgdGhpcy5zdGFnZSBwYXJlbnQgc2NhbGluZyB0byBhY2NvdW50IGZvciBIRFBJXG4gICAgICB0aGlzLl9yZW5kZXJlci5tYXRyaXhbMF0gPSB0aGlzLl9yZW5kZXJlci5tYXRyaXhbNF0gPSB0aGlzLl9yZW5kZXJlci5zY2FsZSA9IHRoaXMucmF0aW87XG5cbiAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xuXG4gICAgICB0aGlzLmN0eC52aWV3cG9ydCgwLCAwLCB3aWR0aCAqIHRoaXMucmF0aW8sIGhlaWdodCAqIHRoaXMucmF0aW8pO1xuXG4gICAgICB2YXIgcmVzb2x1dGlvbkxvY2F0aW9uID0gdGhpcy5jdHguZ2V0VW5pZm9ybUxvY2F0aW9uKFxuICAgICAgICB0aGlzLnByb2dyYW0sICd1X3Jlc29sdXRpb24nKTtcbiAgICAgIHRoaXMuY3R4LnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHdpZHRoICogdGhpcy5yYXRpbywgaGVpZ2h0ICogdGhpcy5yYXRpbyk7XG5cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnJlc2l6ZSwgd2lkdGgsIGhlaWdodCwgcmF0aW8pO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyI3JlbmRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgdG8gdGhlIGA8Y2FudmFzIC8+YC5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgZ2wgPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKCF0aGlzLm92ZXJkcmF3KSB7XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgfVxuXG4gICAgICB3ZWJnbC5ncm91cC5yZW5kZXIuY2FsbCh0aGlzLnNjZW5lLCBnbCwgdGhpcy5wcm9ncmFtKTtcbiAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVXRpbHNcblxuICAvKipcbiAgICogQG5hbWUgVHdvXG4gICAqIEBjbGFzc1xuICAgKiBAZ2xvYmFsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mdWxsc2NyZWVuPWZhbHNlXSAtIFNldCB0byBgdHJ1ZWAgdG8gYXV0b21hdGljYWxseSBtYWtlIHRoZSBzdGFnZSBhZGFwdCB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGFyZW50IGRvY3VtZW50LiBUaGlzIHBhcmFtZXRlciBvdmVycmlkZXMgYHdpZHRoYCBhbmQgYGhlaWdodGAgcGFyYW1ldGVycyBpZiBzZXQgdG8gYHRydWVgLiBUaGlzIG92ZXJyaWRlcyBgb3B0aW9ucy5maXR0ZWRgIGFzIHdlbGwuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZml0dGVkPWZhbHNlXSA9IFNldCB0byBgdHJ1ZWAgdG8gYXV0b21hdGljYWxseSBtYWtlIHRoZSBzdGFnZSBhZGFwdCB0byB0aGUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgcGFyZW50IGVsZW1lbnQuIFRoaXMgcGFyYW1ldGVyIG92ZXJyaWRlcyBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwYXJhbWV0ZXJzIGlmIHNldCB0byBgdHJ1ZWAuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy53aWR0aD02NDBdIC0gVGhlIHdpZHRoIG9mIHRoZSBzdGFnZSBvbiBjb25zdHJ1Y3Rpb24uIFRoaXMgY2FuIGJlIHNldCBhdCBhIGxhdGVyIHRpbWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5oZWlnaHQ9NDgwXSAtIFRoZSBoZWlnaHQgb2YgdGhlIHN0YWdlIG9uIGNvbnN0cnVjdGlvbi4gVGhpcyBjYW4gYmUgc2V0IGF0IGEgbGF0ZXIgdGltZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGU9VHdvLlR5cGVzLnN2Z10gLSBUaGUgdHlwZSBvZiByZW5kZXJlciB0byBzZXR1cCBkcmF3aW5nIHdpdGguIFNlZSB7QGxpbmsgVHdvLlR5cGVzfSBmb3IgYXZhaWxhYmxlIG9wdGlvbnMuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b3N0YXJ0PWZhbHNlXSAtIFNldCB0byBgdHJ1ZWAgdG8gYWRkIHRoZSBpbnN0YW5jZSB0byBkcmF3IG9uIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLiBUaGlzIGlzIGEgY29udmVuaWVudCBzdWJzdGl0dXRlIGZvciB7QGxpbmsgVHdvI3BsYXl9LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtvcHRpb25zLmRvbUVsZW1lbnRdIC0gVGhlIGNhbnZhcyBvciBTVkcgZWxlbWVudCB0byBkcmF3IGludG8uIFRoaXMgb3ZlcnJpZGVzIHRoZSBgb3B0aW9ucy50eXBlYCBhcmd1bWVudC5cbiAgICogQGRlc2NyaXB0aW9uIFRoZSBlbnRyeXBvaW50IGZvciBUd28uanMuIEluc3RhbnRpYXRlIGEgYG5ldyBUd29gIGluIG9yZGVyIHRvIHNldHVwIGEgc2NlbmUgdG8gcmVuZGVyIHRvLiBgVHdvYCBpcyBhbHNvIHRoZSBwdWJsaWNseSBhY2Nlc3NpYmxlIG5hbWVzcGFjZSB0aGF0IGFsbCBvdGhlciBzdWItY2xhc3NlcywgZnVuY3Rpb25zLCBhbmQgdXRpbGl0aWVzIGF0dGFjaCB0by5cbiAgICovXG4gIGZ1bmN0aW9uIFR3byhvcHRpb25zKSB7XG5cbiAgICAvLyBEZXRlcm1pbmUgd2hhdCBSZW5kZXJlciB0byB1c2UgYW5kIHNldHVwIGEgc2NlbmUuXG5cbiAgICB2YXIgcGFyYW1zID0gXy5kZWZhdWx0cyhvcHRpb25zIHx8IHt9LCB7XG4gICAgICBmdWxsc2NyZWVuOiBmYWxzZSxcbiAgICAgIGZpdHRlZDogZmFsc2UsXG4gICAgICB3aWR0aDogNjQwLFxuICAgICAgaGVpZ2h0OiA0ODAsXG4gICAgICB0eXBlOiBUd28uVHlwZXMuc3ZnLFxuICAgICAgYXV0b3N0YXJ0OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgXy5lYWNoKHBhcmFtcywgZnVuY3Rpb24odiwgaykge1xuICAgICAgaWYgKC9mdWxsc2NyZWVuL2kudGVzdChrKSB8fCAvYXV0b3N0YXJ0L2kudGVzdChrKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzW2tdID0gdjtcbiAgICB9LCB0aGlzKTtcblxuICAgIC8vIFNwZWNpZmllZCBkb21FbGVtZW50IG92ZXJyaWRlcyB0eXBlIGRlY2xhcmF0aW9uIG9ubHkgaWYgdGhlIGVsZW1lbnQgZG9lcyBub3Qgc3VwcG9ydCBkZWNsYXJlZCByZW5kZXJlciB0eXBlLlxuICAgIGlmIChfLmlzRWxlbWVudChwYXJhbXMuZG9tRWxlbWVudCkpIHtcbiAgICAgIHZhciB0YWdOYW1lID0gcGFyYW1zLmRvbUVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgLy8gVE9ETzogUmVjb25zaWRlciB0aGlzIGlmIHN0YXRlbWVudCdzIGxvZ2ljLlxuICAgICAgaWYgKCEvXihDYW52YXNSZW5kZXJlci1jYW52YXN8V2ViR0xSZW5kZXJlci1jYW52YXN8U1ZHUmVuZGVyZXItc3ZnKSQvLnRlc3QodGhpcy50eXBlKyctJyt0YWdOYW1lKSkge1xuICAgICAgICB0aGlzLnR5cGUgPSBUd28uVHlwZXNbdGFnTmFtZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlciA9IG5ldyBUd29bdGhpcy50eXBlXSh0aGlzKTtcbiAgICB0aGlzLnNldFBsYXlpbmcocGFyYW1zLmF1dG9zdGFydCk7XG4gICAgdGhpcy5mcmFtZUNvdW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNmaXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gSWYgYG9wdGlvbnMuZnVsbHNjcmVlbmAgb3IgYG9wdGlvbnMuZml0dGVkYCBpbiBjb25zdHJ1Y3Rpb24gY3JlYXRlIHRoaXMgZnVuY3Rpb24uIEl0IHNldHMgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIG9mIHRoZSBpbnN0YW5jZSB0byBpdHMgcmVzcGVjdGl2ZSBwYXJlbnQgYHdpbmRvd2Agb3IgYGVsZW1lbnRgIGRlcGVuZGluZyBvbiB0aGUgYG9wdGlvbnNgIHBhc3NlZC5cbiAgICAgKi9cbiAgICBpZiAocGFyYW1zLmZ1bGxzY3JlZW4pIHtcblxuICAgICAgdGhpcy5maXQgPSBmaXRUb1dpbmRvdy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5maXQuZG9tRWxlbWVudCA9IHdpbmRvdztcbiAgICAgIHRoaXMuZml0LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIF8uZXh0ZW5kKGRvY3VtZW50LmJvZHkuc3R5bGUsIHtcbiAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCdcbiAgICAgIH0pO1xuICAgICAgXy5leHRlbmQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaycsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgcG9zaXRpb246ICdmaXhlZCdcbiAgICAgIH0pO1xuICAgICAgZG9tLmJpbmQodGhpcy5maXQuZG9tRWxlbWVudCwgJ3Jlc2l6ZScsIHRoaXMuZml0KTtcbiAgICAgIHRoaXMuZml0KCk7XG5cbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5maXR0ZWQpIHtcblxuICAgICAgdGhpcy5maXQgPSBmaXRUb1BhcmVudC5iaW5kKHRoaXMpO1xuICAgICAgXy5leHRlbmQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50LnN0eWxlLCB7XG4gICAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmICghXy5pc0VsZW1lbnQocGFyYW1zLmRvbUVsZW1lbnQpKSB7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZShwYXJhbXMud2lkdGgsIHBhcmFtcy5oZWlnaHQsIHRoaXMucmF0aW8pO1xuICAgICAgdGhpcy53aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcblxuICAgIH1cblxuICAgIHRoaXMucmVuZGVyZXIuYmluZChFdmVudHMuVHlwZXMucmVzaXplLCB1cGRhdGVEaW1lbnNpb25zLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2NlbmUgPSB0aGlzLnJlbmRlcmVyLnNjZW5lO1xuXG4gICAgVHdvLkluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgIGlmIChwYXJhbXMuYXV0b3N0YXJ0KSB7XG4gICAgICByYWYuaW5pdCgpO1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoVHdvLCBDb25zdGFudHMpO1xuXG4gIF8uZXh0ZW5kKFR3by5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgY29uc3RydWN0b3I6IFR3byxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byN0eXBlXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHdoaWNoIHR5cGUgb2YgcmVuZGVyZXIgdGhlIGluc3RhbmNlIGhhcyBpbnN0YW50aWF0ZWQuXG4gICAgICovXG4gICAgdHlwZTogJycsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jcmVuZGVyZXJcbiAgICAgKiBAcHJvcGVydHkgeyhUd28uU1ZHUmVuZGVyZXJ8VHdvLkNhbnZhc1JlbmRlcmVyfFR3by5XZWJHTFJlbmRlcmVyKX0gLSBUaGUgaW5zdGFudGlhdGVkIHJlbmRlcmluZyBjbGFzcyBmb3IgdGhlIGluc3RhbmNlLiBGb3IgYSBsaXN0IG9mIHBvc3NpYmxlIHJlbmRlcmluZyB0eXBlcyBjaGVjayBvdXQgVHdvLlR5cGVzLlxuICAgICAqL1xuICAgIHJlbmRlcmVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI3NjZW5lXG4gICAgICogQHByb3BlcnR5IHtUd28uR3JvdXB9IC0gVGhlIGJhc2UgbGV2ZWwge0BsaW5rIFR3by5Hcm91cH0gd2hpY2ggaG91c2VzIGFsbCBvYmplY3RzIGZvciB0aGUgaW5zdGFuY2UuIEJlY2F1c2UgaXQgaXMgYSB7QGxpbmsgVHdvLkdyb3VwfSB0cmFuc2Zvcm1hdGlvbnMgY2FuIGJlIGFwcGxpZWQgdG8gaXQgdGhhdCB3aWxsIGFmZmVjdCBhbGwgb2JqZWN0cyBpbiB0aGUgaW5zdGFuY2UuIFRoaXMgaXMgaGFuZHkgYXMgYSBtYWtlc2hpZnQgaW52ZXJ0ZWQgY2FtZXJhLlxuICAgICAqL1xuICAgIHNjZW5lOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI3dpZHRoXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHdpZHRoIG9mIHRoZSBpbnN0YW5jZSdzIGRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIHdpZHRoOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI2hlaWdodFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBoZWlnaHQgb2YgdGhlIGluc3RhbmNlJ3MgZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgaGVpZ2h0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI2ZyYW1lQ291bnRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBbiBpbnRlZ2VyIHJlcHJlc2VudGluZyBob3cgbWFueSBmcmFtZXMgaGF2ZSBlbGFwc2VkLlxuICAgICAqL1xuICAgIGZyYW1lQ291bnQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jdGltZURlbHRhXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gQSBudW1iZXIgcmVwcmVzZW50aW5nIGhvdyBtdWNoIHRpbWUgaGFzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgZnJhbWUgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqL1xuICAgIHRpbWVEZWx0YTogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNwbGF5aW5nXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIEEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBvciBub3QgdGhlIGluc3RhbmNlIGlzIGJlaW5nIHVwZGF0ZWQgdGhyb3VnaCB0aGUgYXV0b21hdGljIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgLlxuICAgICAqL1xuICAgIHBsYXlpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI2FwcGVuZFRvXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtIC0gVGhlIERPTSBlbGVtZW50IHRvIGFwcGVuZCB0aGUgVHdvLmpzIHN0YWdlIHRvLlxuICAgICAqIEBkZXNjcmlwdGlvbiBTaG9ydGhhbmQgbWV0aG9kIHRvIGFwcGVuZCB5b3VyIGluc3RhbmNlIG9mIFR3by5qcyB0byB0aGUgYGRvY3VtZW50YC5cbiAgICAgKi9cbiAgICBhcHBlbmRUbzogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICBlbGVtLmFwcGVuZENoaWxkKHRoaXMucmVuZGVyZXIuZG9tRWxlbWVudCk7XG5cbiAgICAgIGlmICh0aGlzLmZpdCkge1xuICAgICAgICBpZiAodGhpcy5maXQuZG9tRWxlbWVudCAhPT0gd2luZG93KSB7XG4gICAgICAgICAgdGhpcy5maXQuZG9tRWxlbWVudCA9IGVsZW07XG4gICAgICAgICAgdGhpcy5maXQuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jcGxheVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBUd28uRXZlbnRzLlR5cGVzLnBsYXkgZXZlbnRcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbCB0byBzdGFydCBhbiBpbnRlcm5hbCBhbmltYXRpb24gbG9vcC5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgZnVuY3Rpb24gaW5pdGlhdGVzIGEgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgbG9vcC5cbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICAgIHJhZi5pbml0KCk7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5wbGF5KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jcGF1c2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgVHdvLkV2ZW50cy5UeXBlcy5wYXVzZSBldmVudFxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIHN0b3AgdGhlIGludGVybmFsIGFuaW1hdGlvbiBsb29wIGZvciBhIHNwZWNpZmljIGluc3RhbmNlIG9mIFR3by5qcy5cbiAgICAgKi9cbiAgICBwYXVzZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMucGF1c2UpO1xuXG4gICAgfSxcblxuICAgIHNldFBsYXlpbmc6IGZ1bmN0aW9uKHApIHtcbiAgICAgIHRoaXMucGxheWluZyA9IHA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNyZWxlYXNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBvYmplY3QgcGFzc2VkIGZvciBldmVudCBkZWFsbG9jYXRpb24uXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbGVhc2UgYW4gYXJiaXRyYXJ5IGNsYXNzJyBldmVudHMgZnJvbSB0aGUgVHdvLmpzIGNvcnB1cyBhbmQgcmVjdXJzZSB0aHJvdWdoIGl0cyBjaGlsZHJlbiBhbmQgb3IgdmVydGljZXMuXG4gICAgICovXG4gICAgcmVsZWFzZTogZnVuY3Rpb24ob2JqKSB7XG5cbiAgICAgIHZhciBpLCB2LCBjaGlsZDtcblxuICAgICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG9iai51bmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2JqLnVuYmluZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob2JqLnZlcnRpY2VzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnZlcnRpY2VzLnVuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9iai52ZXJ0aWNlcy51bmJpbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdiA9IG9iai52ZXJ0aWNlc1tpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHYudW5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2LnVuYmluZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob2JqLmNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjaGlsZCA9IG9iai5jaGlsZHJlbltpXTtcbiAgICAgICAgICB0aGlzLnJlbGVhc2UoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmo7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBUd28uRXZlbnRzLlR5cGVzLnVwZGF0ZSBldmVudFxuICAgICAqIEBkZXNjcmlwdGlvbiBVcGRhdGUgcG9zaXRpb25zIGFuZCBjYWxjdWxhdGlvbnMgaW4gb25lIHBhc3MgYmVmb3JlIHJlbmRlcmluZy4gVGhlbiByZW5kZXIgdG8gdGhlIGNhbnZhcy5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgaWYgdXNpbmcge0BsaW5rIFR3byNwbGF5fSBvciB0aGUgYGF1dG9zdGFydGAgcGFyYW1ldGVyIGluIGNvbnN0cnVjdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgYW5pbWF0ZWQgPSAhIXRoaXMuX2xhc3RGcmFtZTtcbiAgICAgIHZhciBub3cgPSBfLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBpZiAoYW5pbWF0ZWQpIHtcbiAgICAgICAgdGhpcy50aW1lRGVsdGEgPSBwYXJzZUZsb2F0KChub3cgLSB0aGlzLl9sYXN0RnJhbWUpLnRvRml4ZWQoMykpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGFzdEZyYW1lID0gbm93O1xuXG4gICAgICBpZiAodGhpcy5maXQgJiYgdGhpcy5maXQuZG9tRWxlbWVudCAmJiAhdGhpcy5maXQuYXR0YWNoZWQpIHtcbiAgICAgICAgICBkb20uYmluZCh0aGlzLmZpdC5kb21FbGVtZW50LCAncmVzaXplJywgdGhpcy5maXQpO1xuICAgICAgICAgIHRoaXMuZml0LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmZpdCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0O1xuICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcblxuICAgICAgLy8gVXBkYXRlIHdpZHRoIC8gaGVpZ2h0IGZvciB0aGUgcmVuZGVyZXJcbiAgICAgIGlmICh3aWR0aCAhPT0gcmVuZGVyZXIud2lkdGggfHwgaGVpZ2h0ICE9PSByZW5kZXJlci5oZWlnaHQpIHtcbiAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCB0aGlzLnJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy51cGRhdGUsIHRoaXMuZnJhbWVDb3VudCwgdGhpcy50aW1lRGVsdGEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXIoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jcmVuZGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIHJlbmRlclxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgYWxsIGRyYXdhYmxlIGFuZCB2aXNpYmxlIG9iamVjdHMgb2YgdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMucmVuZGVyZXIucmVuZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5yZW5kZXIsIHRoaXMuZnJhbWVDb3VudCsrKTtcblxuICAgIH0sXG5cbiAgICAvLyBDb252ZW5pZW5jZSBNZXRob2RzXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jYWRkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoVHdvLlNoYXBlW118Li4uVHdvLlNoYXBlKX0gW29iamVjdHNdIC0gQW4gYXJyYXkgb2YgVHdvLmpzIG9iamVjdHMuIEFsdGVybmF0aXZlbHkgY2FuIGFkZCBvYmplY3RzIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBIHNob3J0aGFuZCBtZXRob2QgdG8gYWRkIHNwZWNpZmljIFR3by5qcyBvYmplY3RzIHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG8pIHtcblxuICAgICAgdmFyIG9iamVjdHMgPSBvO1xuICAgICAgaWYgKCEob2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5hZGQob2JqZWN0cyk7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jcmVtb3ZlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoVHdvLlNoYXBlW118Li4uVHdvLlNoYXBlKX0gW29iamVjdHNdIC0gQW4gYXJyYXkgb2YgVHdvLmpzIG9iamVjdHMuXG4gICAgICogQGRlc2NyaXB0aW9uIEEgc2hvcnRoYW5kIG1ldGhvZCB0byByZW1vdmUgc3BlY2lmaWMgVHdvLmpzIG9iamVjdHMgZnJvbSB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihvKSB7XG5cbiAgICAgIHZhciBvYmplY3RzID0gbztcbiAgICAgIGlmICghKG9iamVjdHMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgb2JqZWN0cyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKG9iamVjdHMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jY2xlYXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhbGwgb2JqZWN0cyBmcm9tIHRoZSBpbnN0YW5jZSdzIHNjZW5lLiBJZiB5b3UgaW50ZW5kIHRvIGhhdmUgdGhlIGJyb3dzZXIgZ2FyYmFnZSBjb2xsZWN0IHRoaXMsIGRvbid0IGZvcmdldCB0byBkZWxldGUgdGhlIHJlZmVyZW5jZXMgaW4geW91ciBhcHBsaWNhdGlvbiBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy5zY2VuZS5jaGlsZHJlbik7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZUxpbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICAgKiBAcmV0dXJucyB7VHdvLkxpbmV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgbGluZSBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgbWFrZUxpbmU6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG5cbiAgICAgIHZhciBsaW5lID0gbmV3IExpbmUoeDEsIHkxLCB4MiwgeTIpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQobGluZSk7XG5cbiAgICAgIHJldHVybiBsaW5lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlQXJyb3dcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICAgKiBAcmV0dXJucyB7VHdvLlBhdGh9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgYXJyb3cgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VBcnJvdzogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIsIHNpemUpIHtcblxuICAgICAgdmFyIGhlYWRsZW4gPSB0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicgPyBzaXplIDogMTA7XG5cbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeTIgLSB5MSwgeDIgLSB4MSk7XG5cbiAgICAgIHZhciB2ZXJ0aWNlcyA9IFtcblxuICAgICAgICBuZXcgQW5jaG9yKHgxLCB5MSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBDb21tYW5kcy5tb3ZlKSxcbiAgICAgICAgbmV3IEFuY2hvcih4MiwgeTIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgQ29tbWFuZHMubGluZSksXG4gICAgICAgIG5ldyBBbmNob3IoXG4gICAgICAgICAgeDIgLSBoZWFkbGVuICogTWF0aC5jb3MoYW5nbGUgLSBNYXRoLlBJIC8gNCksXG4gICAgICAgICAgeTIgLSBoZWFkbGVuICogTWF0aC5zaW4oYW5nbGUgLSBNYXRoLlBJIC8gNCksXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBDb21tYW5kcy5saW5lXG4gICAgICAgICksXG5cbiAgICAgICAgbmV3IEFuY2hvcih4MiwgeTIsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgQ29tbWFuZHMubW92ZSksXG4gICAgICAgIG5ldyBBbmNob3IoXG4gICAgICAgICAgeDIgLSBoZWFkbGVuICogTWF0aC5jb3MoYW5nbGUgKyBNYXRoLlBJIC8gNCksXG4gICAgICAgICAgeTIgLSBoZWFkbGVuICogTWF0aC5zaW4oYW5nbGUgKyBNYXRoLlBJIC8gNCksXG4gICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBDb21tYW5kcy5saW5lXG4gICAgICAgIClcblxuICAgICAgXTtcblxuICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aCh2ZXJ0aWNlcywgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIHBhdGgubm9GaWxsKCk7XG4gICAgICBwYXRoLmNhcCA9ICdyb3VuZCc7XG4gICAgICBwYXRoLmpvaW4gPSAncm91bmQnO1xuXG4gICAgICB0aGlzLnNjZW5lLmFkZChwYXRoKTtcblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlUmVjdGFuZ2xlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcmV0dXJucyB7VHdvLlJlY3RhbmdsZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyByZWN0YW5nbGUgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VSZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgdmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQocmVjdCk7XG5cbiAgICAgIHJldHVybiByZWN0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlUm91bmRlZFJlY3RhbmdsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzXG4gICAgICogQHJldHVybnMge1R3by5SZWN0YW5nbGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgcm91bmRlZCByZWN0YW5nbGUgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VSb3VuZGVkUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzaWRlcykge1xuXG4gICAgICB2YXIgcmVjdCA9IG5ldyBSb3VuZGVkUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIHNpZGVzKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKHJlY3QpO1xuXG4gICAgICByZXR1cm4gcmVjdDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZUNpcmNsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNvbHV0aW9uPTRdXG4gICAgICogQHJldHVybnMge1R3by5DaXJjbGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgY2lyY2xlIGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBtYWtlQ2lyY2xlOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHJlc29sdXRpb24pIHtcblxuICAgICAgdmFyIGNpcmNsZSA9IG5ldyBDaXJjbGUoeCwgeSwgcmFkaXVzLCByZXNvbHV0aW9uKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGNpcmNsZSk7XG5cbiAgICAgIHJldHVybiBjaXJjbGU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VFbGxpcHNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByeFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByeVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj00XVxuICAgICAqIEByZXR1cm5zIHtUd28uRWxsaXBzZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBlbGxpcHNlIGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBtYWtlRWxsaXBzZTogZnVuY3Rpb24oeCwgeSwgcngsIHJ5LCByZXNvbHV0aW9uKSB7XG5cbiAgICAgIHZhciBlbGxpcHNlID0gbmV3IEVsbGlwc2UoeCwgeSwgcngsIHJ5LCByZXNvbHV0aW9uKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGVsbGlwc2UpO1xuXG4gICAgICByZXR1cm4gZWxsaXBzZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZVN0YXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG91dGVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlubmVyUmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzXG4gICAgICogQHJldHVybnMge1R3by5TdGFyfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIHN0YXIgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VTdGFyOiBmdW5jdGlvbihveCwgb3ksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgc2lkZXMpIHtcblxuICAgICAgdmFyIHN0YXIgPSBuZXcgU3RhcihveCwgb3ksIG91dGVyUmFkaXVzLCBpbm5lclJhZGl1cywgc2lkZXMpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQoc3Rhcik7XG5cbiAgICAgIHJldHVybiBzdGFyO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlQ3VydmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5BbmNob3JbXX0gW3BvaW50c10gLSBBbiBhcnJheSBvZiB7QGxpbmsgVHdvLkFuY2hvcn0gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7Li4uTnVtYmVyfSAtIEFsdGVybmF0aXZlbHkgeW91IGNhbiBwYXNzIGFsdGVybmF0aW5nIGB4YCAvIGB5YCBjb29yZGluYXRlIHZhbHVlcyBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cy4gVGhlc2Ugd2lsbCBiZSBjb21iaW5lZCBpbnRvIHtAbGluayBUd28uQW5jaG9yfXMgZm9yIHVzZSBpbiB0aGUgcGF0aC5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlBhdGh9IC0gV2hlcmUgYHBhdGguY3VydmVkYCBpcyBzZXQgdG8gYHRydWVgLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIHBhdGggdGhhdCBpcyBjdXJ2ZWQgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqIEBub3RhLWJlbmUgSW4gZWl0aGVyIGNhc2Ugb2YgcGFzc2luZyBhbiBhcnJheSBvciBwYXNzaW5nIG51bWJlcmVkIGFyZ3VtZW50cyB0aGUgbGFzdCBhcmd1bWVudCBpcyBhbiBvcHRpb25hbCBgQm9vbGVhbmAgdGhhdCBkZWZpbmVzIHdoZXRoZXIgdGhlIHBhdGggc2hvdWxkIGJlIG9wZW4gb3IgY2xvc2VkLlxuICAgICAqL1xuICAgIG1ha2VDdXJ2ZTogZnVuY3Rpb24ocCkge1xuXG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IHA7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocCkpIHtcbiAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSs9Mikge1xuICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgeSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcih4LCB5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3QgPSBhcmd1bWVudHNbbCAtIDFdO1xuICAgICAgdmFyIGN1cnZlID0gbmV3IFBhdGgocG9pbnRzLCAhKHR5cGVvZiBsYXN0ID09PSAnYm9vbGVhbicgPyBsYXN0IDogdW5kZWZpbmVkKSwgdHJ1ZSk7XG4gICAgICB2YXIgcmVjdCA9IGN1cnZlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY3VydmUuY2VudGVyKCkudHJhbnNsYXRpb25cbiAgICAgICAgLnNldChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIpO1xuXG4gICAgICB0aGlzLnNjZW5lLmFkZChjdXJ2ZSk7XG5cbiAgICAgIHJldHVybiBjdXJ2ZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZVBvbHlnb25cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzaWRlc1xuICAgICAqIEByZXR1cm5zIHtUd28uUG9seWdvbn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBwb2x5Z29uIGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBtYWtlUG9seWdvbjogZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzaWRlcykge1xuXG4gICAgICB2YXIgcG9seSA9IG5ldyBQb2x5Z29uKHgsIHksIHJhZGl1cywgc2lkZXMpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQocG9seSk7XG5cbiAgICAgIHJldHVybiBwb2x5O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlQXJjU2VnbWVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRBbmdsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRBbmdsZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj1Ud28uUmVzb2x1dGlvbl0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHRoYXQgc2hvdWxkIGNvbXByaXNlIHRoZSBhcmMgc2VnbWVudC5cbiAgICAgKi9cbiAgICBtYWtlQXJjU2VnbWVudDogZnVuY3Rpb24ob3gsIG95LCBpciwgb3IsIHNhLCBlYSwgcmVzKSB7XG4gICAgICB2YXIgYXJjU2VnbWVudCA9IG5ldyBBcmNTZWdtZW50KG94LCBveSwgaXIsIG9yLCBzYSwgZWEsIHJlcyk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChhcmNTZWdtZW50KTtcbiAgICAgIHJldHVybiBhcmNTZWdtZW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZVBhdGhcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5BbmNob3JbXX0gW3BvaW50c10gLSBBbiBhcnJheSBvZiB7QGxpbmsgVHdvLkFuY2hvcn0gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7Li4uTnVtYmVyfSAtIEFsdGVybmF0aXZlbHkgeW91IGNhbiBwYXNzIGFsdGVybmF0aW5nIGB4YCAvIGB5YCBjb29yZGluYXRlIHZhbHVlcyBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cy4gVGhlc2Ugd2lsbCBiZSBjb21iaW5lZCBpbnRvIHtAbGluayBUd28uQW5jaG9yfXMgZm9yIHVzZSBpbiB0aGUgcGF0aC5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlBhdGh9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgcGF0aCBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXG4gICAgICogQG5vdGEtYmVuZSBJbiBlaXRoZXIgY2FzZSBvZiBwYXNzaW5nIGFuIGFycmF5IG9yIHBhc3NpbmcgbnVtYmVyZWQgYXJndW1lbnRzIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIGBCb29sZWFuYCB0aGF0IGRlZmluZXMgd2hldGhlciB0aGUgcGF0aCBzaG91bGQgYmUgb3BlbiBvciBjbG9zZWQuXG4gICAgICovXG4gICAgbWFrZVBhdGg6IGZ1bmN0aW9uKHApIHtcblxuICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoLCBwb2ludHMgPSBwO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHApKSB7XG4gICAgICAgIHBvaW50cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrPTIpIHtcbiAgICAgICAgICB2YXIgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHkgPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBBbmNob3IoeCwgeSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0ID0gYXJndW1lbnRzW2wgLSAxXTtcbiAgICAgIHZhciBwYXRoID0gbmV3IFBhdGgocG9pbnRzLCAhKHR5cGVvZiBsYXN0ID09PSAnYm9vbGVhbicgPyBsYXN0IDogdW5kZWZpbmVkKSk7XG4gICAgICB2YXIgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAodHlwZW9mIHJlY3QudG9wID09PSAnbnVtYmVyJyAgICYmIHR5cGVvZiByZWN0LmxlZnQgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgdHlwZW9mIHJlY3QucmlnaHQgPT09ICdudW1iZXInICYmIHR5cGVvZiByZWN0LmJvdHRvbSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGF0aC5jZW50ZXIoKS50cmFuc2xhdGlvblxuICAgICAgICAgIC5zZXQocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIsIHJlY3QudG9wICsgcmVjdC5oZWlnaHQgLyAyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5hZGQocGF0aCk7XG5cbiAgICAgIHJldHVybiBwYXRoO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlVGV4dFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSAtIEFuIG9iamVjdCB0byBkZXNjcmliZSBhbnkgb2YgdGhlIHtAbGluayBUd28uVGV4dC5Qcm9wZXJ0aWVzfSBpbmNsdWRpbmcgYGZpbGxgLCBgc3Ryb2tlYCwgYGxpbmV3aWR0aGAsIGBmYW1pbHlgLCBgYWxpZ25tZW50YCwgYGxlYWRpbmdgLCBgb3BhY2l0eWAsIGV0Yy4uXG4gICAgICogQHJldHVybnMge1R3by5UZXh0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIHRleHQgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBtYWtlVGV4dDogZnVuY3Rpb24obWVzc2FnZSwgeCwgeSwgc3R5bGVzKSB7XG4gICAgICB2YXIgdGV4dCA9IG5ldyBUZXh0KG1lc3NhZ2UsIHgsIHksIHN0eWxlcyk7XG4gICAgICB0aGlzLmFkZCh0ZXh0KTtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZUxpbmVhckdyYWRpZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHgxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkxXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHgyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHkyXG4gICAgICogQHBhcmFtIHsuLi5Ud28uU3RvcH0gc3RvcHMgLSBBbnkgbnVtYmVyIG9mIGNvbG9yIHN0b3BzIHNvbWV0aW1lcyByZWZmZXJlZCB0byBhcyByYW1wIHN0b3BzLiBJZiBub25lIGFyZSBzdXBwbGllZCB0aGVuIHRoZSBkZWZhdWx0IGJsYWNrLXRvLXdoaXRlIHR3byBzdG9wIGdyYWRpZW50IGlzIGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge1R3by5MaW5lYXJHcmFkaWVudH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBsaW5lYXIgZ3JhZGllbnQgYW5kIGFkcyBpdCB0byB0aGUgc2NlbmUuIEluIHRoZSBjYXNlIG9mIGFuIGVmZmVjdCBpdCdzIGFkZGVkIHRvIGFuIGludmlzaWJsZSBcImRlZmluaXRpb25zXCIgZ3JvdXAuXG4gICAgICovXG4gICAgbWFrZUxpbmVhckdyYWRpZW50OiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiAvKiBzdG9wcyAqLykge1xuXG4gICAgICB2YXIgc3RvcHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDQpO1xuICAgICAgdmFyIGdyYWRpZW50ID0gbmV3IExpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyLCBzdG9wcyk7XG5cbiAgICAgIHRoaXMuYWRkKGdyYWRpZW50KTtcblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlUmFkaWFsR3JhZGllbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHsuLi5Ud28uU3RvcH0gc3RvcHMgLSBBbnkgbnVtYmVyIG9mIGNvbG9yIHN0b3BzIHNvbWV0aW1lcyByZWZmZXJlZCB0byBhcyByYW1wIHN0b3BzLiBJZiBub25lIGFyZSBzdXBwbGllZCB0aGVuIHRoZSBkZWZhdWx0IGJsYWNrLXRvLXdoaXRlIHR3byBzdG9wIGdyYWRpZW50IGlzIGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge1R3by5SYWRpYWxHcmFkaWVudH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBsaW5lYXItZ3JhZGllbnQgb2JqZWN0IGFuZCBhZHMgaXQgdG8gdGhlIHNjZW5lLiBJbiB0aGUgY2FzZSBvZiBhbiBlZmZlY3QgaXQncyBhZGRlZCB0byBhbiBpbnZpc2libGUgXCJkZWZpbml0aW9uc1wiIGdyb3VwLlxuICAgICAqL1xuICAgIG1ha2VSYWRpYWxHcmFkaWVudDogZnVuY3Rpb24oeDEsIHkxLCByIC8qIHN0b3BzICovKSB7XG5cbiAgICAgIHZhciBzdG9wcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgUmFkaWFsR3JhZGllbnQoeDEsIHkxLCByLCBzdG9wcyk7XG5cbiAgICAgIHRoaXMuYWRkKGdyYWRpZW50KTtcblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlU3ByaXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfFR3by5UZXh0dXJlKX0gcGF0aE9yVGV4dHVyZSAtIFRoZSBVUkwgcGF0aCB0byBhbiBpbWFnZSBvciBhbiBhbHJlYWR5IGNyZWF0ZWQge0BsaW5rIFR3by5UZXh0dXJlfS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2x1bW5zPTFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyb3dzPTFdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmFtZVJhdGU9MF1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFthdXRvc3RhcnQ9ZmFsc2VdXG4gICAgICogQHJldHVybnMge1R3by5TcHJpdGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgc3ByaXRlIG9iamVjdCBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuIFNwcml0ZXMgY2FuIGJlIHVzZWQgZm9yIHN0aWxsIGltYWdlcyBhcyB3ZWxsIGFzIGFuaW1hdGlvbnMuXG4gICAgICovXG4gICAgbWFrZVNwcml0ZTogZnVuY3Rpb24ocGF0aCwgeCwgeSwgY29scywgcm93cywgZnJhbWVSYXRlLCBhdXRvc3RhcnQpIHtcblxuICAgICAgdmFyIHNwcml0ZSA9IG5ldyBTcHJpdGUocGF0aCwgeCwgeSwgY29scywgcm93cywgZnJhbWVSYXRlKTtcbiAgICAgIGlmIChhdXRvc3RhcnQpIHtcbiAgICAgICAgc3ByaXRlLnBsYXkoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkKHNwcml0ZSk7XG5cbiAgICAgIHJldHVybiBzcHJpdGU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VJbWFnZVNlcXVlbmNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoU3RyaW5nW118VHdvLlRleHR1cmVbXSl9IHBhdGhzT3JUZXh0dXJlcyAtIEFuIGFycmF5IG9mIHBhdGhzIG9yIG9mIHtAbGluayBUd28uVGV4dHVyZXN9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyYW1lUmF0ZT0wXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2F1dG9zdGFydD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7VHdvLkltYWdlU2VxdWVuY2V9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgaW1hZ2Ugc2VxdWVuY2Ugb2JqZWN0IGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBtYWtlSW1hZ2VTZXF1ZW5jZTogZnVuY3Rpb24ocGF0aHMsIHgsIHksIGZyYW1lUmF0ZSwgYXV0b3N0YXJ0KSB7XG5cbiAgICAgIHZhciBpbWFnZVNlcXVlbmNlID0gbmV3IEltYWdlU2VxdWVuY2UocGF0aHMsIHgsIHksIGZyYW1lUmF0ZSk7XG4gICAgICBpZiAoYXV0b3N0YXJ0KSB7XG4gICAgICAgIGltYWdlU2VxdWVuY2UucGxheSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGQoaW1hZ2VTZXF1ZW5jZSk7XG5cbiAgICAgIHJldHVybiBpbWFnZVNlcXVlbmNlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlVGV4dHVyZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7KFN0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fEhUTUxWaWRlb0VsZW1lbnQpfSBbcGF0aE9yU291cmNlXSAtIFRoZSBVUkwgcGF0aCB0byBhbiBpbWFnZSBvciBhIERPTSBpbWFnZS1saWtlIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbiB0aGUgaW1hZ2UgaXMgbG9hZGVkLlxuICAgICAqIEByZXR1cm5zIHtUd28uVGV4dHVyZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyB0ZXh0dXJlIG9iamVjdC5cbiAgICAgKi9cbiAgICBtYWtlVGV4dHVyZTogZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcblxuICAgICAgdmFyIHRleHR1cmUgPSBuZXcgVGV4dHVyZShwYXRoLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGV4dHVyZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZUdyb3VwXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoVHdvLlNoYXBlW118Li4uVHdvLlNoYXBlKX0gW29iamVjdHNdIC0gVHdvLmpzIG9iamVjdHMgdG8gYmUgYWRkZWQgdG8gdGhlIGdyb3VwIGluIHRoZSBmb3JtIG9mIGFuIGFycmF5IG9yIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqIEByZXR1cm5zIHtUd28uR3JvdXB9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgZ3JvdXAgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBtYWtlR3JvdXA6IGZ1bmN0aW9uKG8pIHtcblxuICAgICAgdmFyIG9iamVjdHMgPSBvO1xuICAgICAgaWYgKCEob2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGdyb3VwID0gbmV3IEdyb3VwKCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChncm91cCk7XG4gICAgICBncm91cC5hZGQob2JqZWN0cyk7XG5cbiAgICAgIHJldHVybiBncm91cDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jaW50ZXJwcmV0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBTVkdFbGVtZW50IC0gVGhlIFNWRyBub2RlIHRvIGJlIHBhcnNlZC5cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHNoYWxsb3cgLSBEb24ndCBjcmVhdGUgYSB0b3AtbW9zdCBncm91cCBidXQgYXBwZW5kIGFsbCBjb250ZW50IGRpcmVjdGx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWRkIOKAkyBBdXRvbWF0aWNhbGx5IGFkZCB0aGUgcmVjb25zdHJ1Y3RlZCBTVkcgbm9kZSB0byBzY2VuZS5cbiAgICAgKiBAcmV0dXJucyB7VHdvLkdyb3VwfVxuICAgICAqIEBkZXNjcmlwdGlvbiBJbnRlcnByZXQgYW4gU1ZHIE5vZGUgYW5kIGFkZCBpdCB0byB0aGlzIGluc3RhbmNlJ3Mgc2NlbmUuIFRoZSBkaXN0aW5jdGlvbiBzaG91bGQgYmUgbWFkZSB0aGF0IHRoaXMgZG9lc24ndCBgaW1wb3J0YCBzdmcncywgaXQgc29sZWx5IGludGVycHJldHMgdGhlbSBpbnRvIHNvbWV0aGluZyBjb21wYXRpYmxlIGZvciBUd28uanMgLSB0aGlzIGlzIHNsaWdodGx5IGRpZmZlcmVudCB0aGFuIGEgZGlyZWN0IHRyYW5zY3JpcHRpb24uXG4gICAgICovXG4gICAgaW50ZXJwcmV0OiBmdW5jdGlvbihTVkdFbGVtZW50LCBzaGFsbG93LCBhZGQpIHtcblxuICAgICAgdmFyIHRhZyA9IFNWR0VsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBhZGQgPSAodHlwZW9mIGFkZCAhPT0gJ3VuZGVmaW5lZCcpID8gYWRkIDogdHJ1ZTtcblxuICAgICAgaWYgKCEodGFnIGluIHJlYWQpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IHJlYWRbdGFnXS5jYWxsKHRoaXMsIFNWR0VsZW1lbnQpO1xuXG4gICAgICBpZiAoYWRkKSB7XG4gICAgICAgIHRoaXMuYWRkKHNoYWxsb3cgJiYgbm9kZSBpbnN0YW5jZW9mIEdyb3VwID8gbm9kZS5jaGlsZHJlbiA6IG5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnBhcmVudCkge1xuICAgICAgICAvLyBSZW1vdmUgYGdgIHRhZ3MgdGhhdCBoYXZlIGJlZW4gYWRkZWQgdG8gc2NlbmVncmFwaCAvIERPTVxuICAgICAgICAvLyBpbiBvcmRlciB0byBiZSBjb21wYXRpYmxlIHdpdGggYGdldEJ5SWRgIG1ldGhvZHMuXG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBub2RlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNsb2FkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd8U1ZHRWxlbWVudH0gcGF0aE9yU1ZHQ29udGVudCAtIFRoZSBVUkwgcGF0aCBvZiBhbiBTVkcgZmlsZSBvciBhbiBTVkcgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwgb25jZSBsb2FkaW5nIGhhcyBjb21wbGV0ZWQuXG4gICAgICogQHJldHVybnMge1R3by5Hcm91cH1cbiAgICAgKiBAZGVzY3JpcHRpb24gTG9hZCBhbiBTVkcgZmlsZSBvciBTVkcgdGV4dCBhbmQgaW50ZXJwcmV0IGl0IGludG8gVHdvLmpzIGxlZ2libGUgb2JqZWN0cy5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbih0ZXh0LCBjYWxsYmFjaykge1xuXG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICAgIHZhciBlbGVtLCBpLCBqLCBjaGlsZDtcblxuICAgICAgdmFyIGF0dGFjaCA9IChmdW5jdGlvbihkYXRhKSB7XG5cbiAgICAgICAgZG9tLnRlbXAuaW5uZXJIVE1MID0gZGF0YTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZG9tLnRlbXAuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlbGVtID0gZG9tLnRlbXAuY2hpbGRyZW5baV07XG4gICAgICAgICAgaWYgKC9zdmcvaS50ZXN0KGVsZW0ubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICBjaGlsZCA9IHRoaXMuaW50ZXJwcmV0KGVsZW0pO1xuICAgICAgICAgICAgLy8gVHdvLlV0aWxzLmFwcGx5U3ZnVmlld0JveC5jYWxsKHRoaXMsIGdyb3VwLCBlbGVtLmdldEF0dHJpYnV0ZSgndmlld0JveCcpKTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjaGlsZC5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICBncm91cC5hZGQoY2hpbGQuY2hpbGRyZW5bal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncm91cC5hZGQodGhpcy5pbnRlcnByZXQoZWxlbSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgc3ZnID0gZG9tLnRlbXAuY2hpbGRyZW4ubGVuZ3RoIDw9IDFcbiAgICAgICAgICAgID8gZG9tLnRlbXAuY2hpbGRyZW5bMF0gOiBkb20udGVtcC5jaGlsZHJlbjtcbiAgICAgICAgICBjYWxsYmFjayhncm91cCwgc3ZnKTtcbiAgICAgICAgfVxuXG4gICAgICB9KS5iaW5kKHRoaXMpO1xuXG4gICAgICBpZiAoLy4qXFwuc3ZnL2lnLnRlc3QodGV4dCkpIHtcblxuICAgICAgICB4aHIodGV4dCwgYXR0YWNoKTtcblxuICAgICAgICByZXR1cm4gZ3JvdXA7XG5cbiAgICAgIH1cblxuICAgICAgYXR0YWNoKHRleHQpO1xuXG4gICAgICByZXR1cm4gZ3JvdXA7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZml0VG9XaW5kb3coKSB7XG5cbiAgICB2YXIgd3IgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCA9IHdyLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCA9IHdyLmhlaWdodDtcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCB0aGlzLnJhdGlvKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZml0VG9QYXJlbnQoKSB7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5yZW5kZXJlci5kb21FbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgIGNvbnNvbGUud2FybignVHdvLmpzOiBBdHRlbXB0aW5nIHRvIGZpdCB0byBwYXJlbnQsIGJ1dCBubyBwYXJlbnQgZm91bmQuJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB3ciA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggPSB3ci53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgPSB3ci5oZWlnaHQ7XG5cbiAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCwgdGhpcy5yYXRpbyk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZURpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnJlc2l6ZSwgd2lkdGgsIGhlaWdodCk7XG4gIH1cblxuICAvLyBSZXF1ZXN0IEFuaW1hdGlvbiBGcmFtZVxuXG4gIHZhciByYWYgPSBkb20uZ2V0UmVxdWVzdEFuaW1hdGlvbkZyYW1lKCk7XG5cbiAgZnVuY3Rpb24gbG9vcCgpIHtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVHdvLkluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHQgPSBUd28uSW5zdGFuY2VzW2ldO1xuICAgICAgaWYgKHQucGxheWluZykge1xuICAgICAgICB0LnVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFR3by5uZXh0RnJhbWVJRCA9IHJhZihsb29wKTtcblxuICB9XG5cbiAgcmFmLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBsb29wKCk7XG4gICAgcmFmLmluaXQgPSBmdW5jdGlvbigpIHt9O1xuICB9O1xuXG4gIF8uZXh0ZW5kKFR3bywge1xuICAgIEFuY2hvcjogQW5jaG9yLFxuICAgIENvbGxlY3Rpb246IENvbGxlY3Rpb24sXG4gICAgRXZlbnRzOiBFdmVudHMsXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIE1hdHJpeDogTWF0cml4LFxuICAgIFBhdGg6IFBhdGgsXG4gICAgUmVnaXN0cnk6IFJlZ2lzdHJ5LFxuICAgIFNoYXBlOiBTaGFwZSxcbiAgICBUZXh0OiBUZXh0LFxuICAgIFZlY3RvcjogVmVjdG9yLFxuXG4gICAgR3JhZGllbnQ6IEdyYWRpZW50LFxuICAgIEltYWdlU2VxdWVuY2U6IEltYWdlU2VxdWVuY2UsXG4gICAgTGluZWFyR3JhZGllbnQ6IExpbmVhckdyYWRpZW50LFxuICAgIFJhZGlhbEdyYWRpZW50OiBSYWRpYWxHcmFkaWVudCxcbiAgICBTcHJpdGU6IFNwcml0ZSxcbiAgICBTdG9wOiBTdG9wLFxuICAgIFRleHR1cmU6IFRleHR1cmUsXG5cbiAgICBBcmNTZWdtZW50OiBBcmNTZWdtZW50LFxuICAgIENpcmNsZTogQ2lyY2xlLFxuICAgIEVsbGlwc2U6IEVsbGlwc2UsXG4gICAgTGluZTogTGluZSxcbiAgICBQb2x5Z29uOiBQb2x5Z29uLFxuICAgIFJlY3RhbmdsZTogUmVjdGFuZ2xlLFxuICAgIFJvdW5kZWRSZWN0YW5nbGU6IFJvdW5kZWRSZWN0YW5nbGUsXG4gICAgU3RhcjogU3RhcixcblxuICAgIENhbnZhc1JlbmRlcmVyOiBSZW5kZXJlciQyLFxuICAgIFNWR1JlbmRlcmVyOiBSZW5kZXJlciQxLFxuICAgIFdlYkdMUmVuZGVyZXI6IFJlbmRlcmVyLFxuXG4gICAgQ29tbWFuZHM6IENvbW1hbmRzLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlV0aWxzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gQSBtYXNzaXZlIG9iamVjdCBmaWxsZWQgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBVdGlsczogXy5leHRlbmQoe1xuXG4gICAgICBFcnJvcjogVHdvRXJyb3IsXG4gICAgICBnZXRSYXRpbzogZ2V0UmF0aW8sXG4gICAgICBkZWZpbmVHZXR0ZXJTZXR0ZXI6IGRlZmluZUdldHRlclNldHRlcixcbiAgICAgIHJlYWQ6IHJlYWQsXG4gICAgICB4aHI6IHhoclxuXG4gICAgfSwgXywgQ2FudmFzU2hpbSwgQ3VydmVzLCBtYXRoKVxuXG4gIH0pO1xuXG4gIHJldHVybiBUd287XG5cbn0pKSk7XG4iLCJcbmdsb2JhbC5DQU5WQVNfU0tFVENIX0RFRkFVTFRfU1RPUkFHRV9LRVkgPSBcIkQ6XFxcXE1hbnVlbFxcXFxjYW52YXMtc2tldGNoXFxcXGV4YW1wbGVzXFxcXGFuaW1hdGVkLXR3by1vdmVyZHJhdy5qc1wiO1xuIl19
