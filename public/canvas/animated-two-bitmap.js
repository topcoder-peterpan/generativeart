(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

// Mark output/export as enabled for the client API scripts.
window['canvas-sketch-cli'] = window['canvas-sketch-cli'] || {};
window['canvas-sketch-cli'].output = true;

},{}],2:[function(require,module,exports){
"use strict";

const NAMESPACE = 'canvas-sketch-cli'; // Grab the CLI namespace

window[NAMESPACE] = window[NAMESPACE] || {};

if (!window[NAMESPACE].initialized) {
  initialize();
}

function initialize() {
  // Awaiting enable/disable event
  window[NAMESPACE].liveReloadEnabled = undefined;
  window[NAMESPACE].initialized = true;
  const defaultPostOptions = {
    method: 'POST',
    cache: 'no-cache',
    credentials: 'same-origin'
  }; // File saving utility

  window[NAMESPACE].saveBlob = (blob, opts) => {
    opts = opts || {};
    const form = new window.FormData();
    form.append('file', blob, opts.filename);
    return window.fetch('/canvas-sketch-cli/saveBlob', Object.assign({}, defaultPostOptions, {
      body: form
    })).then(res => {
      if (res.status === 200) {
        return res.json();
      } else {
        return res.text().then(text => {
          throw new Error(text);
        });
      }
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn(`There was a problem exporting ${opts.filename}`);
      console.error(err);
      return undefined;
    });
  };

  const stream = (url, opts) => {
    opts = opts || {};
    return window.fetch(url, Object.assign({}, defaultPostOptions, {
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        save: opts.save,
        encoding: opts.encoding,
        timeStamp: opts.timeStamp,
        fps: opts.fps,
        filename: opts.filename
      })
    })).then(res => {
      if (res.status === 200) {
        return res.json();
      } else {
        return res.text().then(text => {
          throw new Error(text);
        });
      }
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn(`There was a problem starting the stream export`);
      console.error(err);
      return undefined;
    });
  }; // File streaming utility


  window[NAMESPACE].streamStart = opts => {
    return stream('/canvas-sketch-cli/stream-start', opts);
  };

  window[NAMESPACE].streamEnd = opts => {
    return stream('/canvas-sketch-cli/stream-end', opts);
  }; // git commit utility


  window[NAMESPACE].commit = () => {
    return window.fetch('/canvas-sketch-cli/commit', defaultPostOptions).then(resp => resp.json()).then(result => {
      if (result.error) {
        if (result.error.toLowerCase().includes('not a git repository')) {
          console.warn(`Warning: ${result.error}`);
          return null;
        } else {
          throw new Error(result.error);
        }
      } // Notify user of changes


      console.log(result.changed ? `[git] ${result.hash} Committed changes` : `[git] ${result.hash} Nothing changed`);
      return result.hash;
    }).catch(err => {
      // Some issue, just bail out and return nil hash
      console.warn('Could not commit changes and fetch hash');
      console.error(err);
      return undefined;
    });
  };

  if ('budo-livereload' in window) {
    const client = window['budo-livereload'];
    client.listen(data => {
      if (data.event === 'hot-reload') {
        setupLiveReload(data.enabled);
      }
    }); // On first load, check to see if we should setup live reload or not

    if (window[NAMESPACE].hot) {
      setupLiveReload(true);
    } else {
      setupLiveReload(false);
    }
  }
}

function setupLiveReload(isEnabled) {
  const previousState = window[NAMESPACE].liveReloadEnabled;

  if (typeof previousState !== 'undefined' && isEnabled !== previousState) {
    // We need to reload the page to ensure the new sketch function is
    // named for hot reloading, and/or cleaned up after hot reloading is disabled
    window.location.reload(true);
    return;
  }

  if (isEnabled === window[NAMESPACE].liveReloadEnabled) {
    // No change in state
    return;
  } // Mark new state


  window[NAMESPACE].liveReloadEnabled = isEnabled;

  if (isEnabled) {
    if ('budo-livereload' in window) {
      console.log(`%c[canvas-sketch-cli]%c âœ¨ Hot Reload Enabled`, 'color: #8e8e8e;', 'color: initial;');
      const client = window['budo-livereload'];
      client.listen(onClientData);
    }
  }
}

function onClientData(data) {
  const client = window['budo-livereload'];
  if (!client) return;

  if (data.event === 'eval') {
    if (!data.error) {
      client.clearError();
    }

    try {
      eval(data.code);
      if (!data.error) console.log(`%c[canvas-sketch-cli]%c âœ¨ Hot Reloaded`, 'color: #8e8e8e;', 'color: initial;');
    } catch (err) {
      console.error(`%c[canvas-sketch-cli]%c ðŸš¨ Hot Reload error`, 'color: #8e8e8e;', 'color: initial;');
      client.showError(err.toString()); // This will also load up the problematic script so that stack traces with
      // source maps is visible

      const scriptElement = document.createElement('script');

      scriptElement.onload = () => {
        document.body.removeChild(scriptElement);
      };

      scriptElement.src = data.src;
      document.body.appendChild(scriptElement);
    }
  }
}

},{}],3:[function(require,module,exports){
const canvasSketch = require('canvas-sketch');
const load = require('load-asset');

// Import Two.js - make sure to have greater than v0.7.0-alpha.1
// because previous versions don't support module loading or headless environments
const Two = require('two.js');

const settings = {
  dimensions: [ 2048, 2048 ],
  // Make the loop animated
  animate: true
};

const sketch = async ({ canvas }) => {
  // Create the instance of Two.js
  const two = new Two({ domElement: canvas });

  // Generate the image and wait for load to finish before
  // moving forward with rendering.
  const image = await load('assets/baboon.jpg');

  // Get the dimensions of the baboon image
  const imageWidth = image.width;
  const imageHeight = image.height;

  // How many strips will there be?
  const amount = 25;
  // The height of each strip we will create
  const stripHeight = Math.ceil(imageHeight / amount);

  for (let i = 0; i < amount; i++) {
    let pct = i / (amount - 1);
    let y = imageHeight * (pct - 0.5);
    // Create a rectangle strip that represents a slice of the image
    let sprite = new Two.Rectangle(0, y, imageWidth, stripHeight);

    // Set the fill of the strip to be a texture
    sprite.fill = new Two.Texture(image);
    // Make the texture repeat in the x direction
    sprite.fill.repeat = 'repeat-x';
    // Offset the image's y position so that when all strips line up
    // they roughly create the reference image in full
    sprite.fill.offset.y = imageHeight * ((1 - pct) - 0.5);
    // Set the stroke to be the fill ensuring that there isn't any
    // leftover white space between the strips
    sprite.stroke = sprite.fill;

    // Add the sprite to the scene
    two.add(sprite);
  }

  return {
    resize ({ pixelRatio, width, height }) {
      // Update width and height of Two.js scene based on
      // canvas-sketch auto changing viewport parameters
      two.width = width;
      two.height = height;
      two.ratio = pixelRatio;

      // This needs to be passed down to the renderer's width and height as well
      two.renderer.width = two.width;
      two.renderer.height = two.height;

      // Position scene to be at the center of the canvas
      two.scene.translation.set(two.width / 2, two.height / 2);

      // Scale the scene to fit the canvas
      two.scene.scale = two.width / imageWidth;
    },
    render ({ time }) {
      // Define the speed at which the offset smear occurs
      const speed = (1 + Math.sin(time * 5)) / 2;

      for (let i = 0; i < amount; i++) {
        const sprite = two.scene.children[i];
        // The normalized value of the strip's index
        const pct = i / amount;

        // Set the repeated image offset
        sprite.fill.offset.x += speed * Math.sin(pct * Math.PI * 3);
      }

      // Update two.js via the `render` method - *not* the `update` method.
      two.render();
    }
  };
};

canvasSketch(sketch, settings);

},{"canvas-sketch":6,"load-asset":10,"two.js":17}],4:[function(require,module,exports){
// sourced from:
// http://www.leanbackplayer.com/test/h5mt.html
// https://github.com/broofa/node-mime/blob/master/types.json
var mimeTypes = require('./mime-types.json')

var mimeLookup = {}
Object.keys(mimeTypes).forEach(function (key) {
  var extensions = mimeTypes[key]
  extensions.forEach(function (ext) {
    mimeLookup[ext] = key
  })
})

module.exports = function lookup (ext) {
  if (!ext) throw new TypeError('must specify extension string')
  if (ext.indexOf('.') === 0) {
    ext = ext.substring(1)
  }
  return mimeLookup[ext.toLowerCase()]
}

},{"./mime-types.json":5}],5:[function(require,module,exports){
module.exports={
  "audio/midi": ["mid", "midi", "kar", "rmi"],
  "audio/mp4": ["mp4a", "m4a"],
  "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"],
  "audio/ogg": ["oga", "ogg", "spx"],
  "audio/webm": ["weba"],
  "audio/x-matroska": ["mka"],
  "audio/x-mpegurl": ["m3u"],
  "audio/wav": ["wav"],
  "video/3gpp": ["3gp"],
  "video/3gpp2": ["3g2"],
  "video/mp4": ["mp4", "mp4v", "mpg4"],
  "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"],
  "video/ogg": ["ogv"],
  "video/quicktime": ["qt", "mov"],
  "video/webm": ["webm"],
  "video/x-f4v": ["f4v"],
  "video/x-fli": ["fli"],
  "video/x-flv": ["flv"],
  "video/x-m4v": ["m4v"],
  "video/x-matroska": ["mkv", "mk3d", "mks"]
}
},{}],6:[function(require,module,exports){
(function (global){(function (){
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.canvasSketch = factory());
}(this, (function () {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}

			// Detect buggy property enumeration order in older V8 versions.

			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}

			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}

			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}

	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;

		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);

			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}

			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}

		return to;
	};

	var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var browser =
	  commonjsGlobal.performance &&
	  commonjsGlobal.performance.now ? function now() {
	    return performance.now()
	  } : Date.now || function now() {
	    return +new Date
	  };

	var isPromise_1 = isPromise;

	function isPromise(obj) {
	  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
	}

	var isDom = isNode;

	function isNode (val) {
	  return (!val || typeof val !== 'object')
	    ? false
	    : (typeof window === 'object' && typeof window.Node === 'object')
	      ? (val instanceof window.Node)
	      : (typeof val.nodeType === 'number') &&
	        (typeof val.nodeName === 'string')
	}

	function getClientAPI() {
	    return typeof window !== 'undefined' && window['canvas-sketch-cli'];
	}

	function defined() {
	    var arguments$1 = arguments;

	    for (var i = 0;i < arguments.length; i++) {
	        if (arguments$1[i] != null) {
	            return arguments$1[i];
	        }
	    }
	    return undefined;
	}

	function isBrowser() {
	    return typeof document !== 'undefined';
	}

	function isWebGLContext(ctx) {
	    return typeof ctx.clear === 'function' && typeof ctx.clearColor === 'function' && typeof ctx.bufferData === 'function';
	}

	function isCanvas(element) {
	    return isDom(element) && /canvas/i.test(element.nodeName) && typeof element.getContext === 'function';
	}

	var keys = createCommonjsModule(function (module, exports) {
	exports = module.exports = typeof Object.keys === 'function'
	  ? Object.keys : shim;

	exports.shim = shim;
	function shim (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	});
	var keys_1 = keys.shim;

	var is_arguments = createCommonjsModule(function (module, exports) {
	var supportsArgumentsClass = (function(){
	  return Object.prototype.toString.call(arguments)
	})() == '[object Arguments]';

	exports = module.exports = supportsArgumentsClass ? supported : unsupported;

	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	exports.unsupported = unsupported;
	function unsupported(object){
	  return object &&
	    typeof object == 'object' &&
	    typeof object.length == 'number' &&
	    Object.prototype.hasOwnProperty.call(object, 'callee') &&
	    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
	    false;
	}});
	var is_arguments_1 = is_arguments.supported;
	var is_arguments_2 = is_arguments.unsupported;

	var deepEqual_1 = createCommonjsModule(function (module) {
	var pSlice = Array.prototype.slice;



	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;

	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();

	  // 7.3. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
	    return opts.strict ? actual === expected : actual == expected;

	  // 7.4. For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};

	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}

	function isBuffer (x) {
	  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}

	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
	    return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (is_arguments(a)) {
	    if (!is_arguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = keys(a),
	        kb = keys(b);
	  } catch (e) {//happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return typeof a === typeof b;
	}
	});

	var dateformat = createCommonjsModule(function (module, exports) {
	/*
	 * Date Format 1.2.3
	 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
	 * MIT license
	 *
	 * Includes enhancements by Scott Trenda <scott.trenda.net>
	 * and Kris Kowal <cixar.com/~kris.kowal/>
	 *
	 * Accepts a date, a mask, or a date and a mask.
	 * Returns a formatted version of the given date.
	 * The date defaults to the current date/time.
	 * The mask defaults to dateFormat.masks.default.
	 */

	(function(global) {

	  var dateFormat = (function() {
	      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|"[^"]*"|'[^']*'/g;
	      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
	      var timezoneClip = /[^-+\dA-Z]/g;
	  
	      // Regexes and supporting functions are cached through closure
	      return function (date, mask, utc, gmt) {
	  
	        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
	        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
	          mask = date;
	          date = undefined;
	        }
	  
	        date = date || new Date;
	  
	        if(!(date instanceof Date)) {
	          date = new Date(date);
	        }
	  
	        if (isNaN(date)) {
	          throw TypeError('Invalid date');
	        }
	  
	        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
	  
	        // Allow setting the utc/gmt argument via the mask
	        var maskSlice = mask.slice(0, 4);
	        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
	          mask = mask.slice(4);
	          utc = true;
	          if (maskSlice === 'GMT:') {
	            gmt = true;
	          }
	        }
	  
	        var _ = utc ? 'getUTC' : 'get';
	        var d = date[_ + 'Date']();
	        var D = date[_ + 'Day']();
	        var m = date[_ + 'Month']();
	        var y = date[_ + 'FullYear']();
	        var H = date[_ + 'Hours']();
	        var M = date[_ + 'Minutes']();
	        var s = date[_ + 'Seconds']();
	        var L = date[_ + 'Milliseconds']();
	        var o = utc ? 0 : date.getTimezoneOffset();
	        var W = getWeek(date);
	        var N = getDayOfWeek(date);
	        var flags = {
	          d:    d,
	          dd:   pad(d),
	          ddd:  dateFormat.i18n.dayNames[D],
	          dddd: dateFormat.i18n.dayNames[D + 7],
	          m:    m + 1,
	          mm:   pad(m + 1),
	          mmm:  dateFormat.i18n.monthNames[m],
	          mmmm: dateFormat.i18n.monthNames[m + 12],
	          yy:   String(y).slice(2),
	          yyyy: y,
	          h:    H % 12 || 12,
	          hh:   pad(H % 12 || 12),
	          H:    H,
	          HH:   pad(H),
	          M:    M,
	          MM:   pad(M),
	          s:    s,
	          ss:   pad(s),
	          l:    pad(L, 3),
	          L:    pad(Math.round(L / 10)),
	          t:    H < 12 ? dateFormat.i18n.timeNames[0] : dateFormat.i18n.timeNames[1],
	          tt:   H < 12 ? dateFormat.i18n.timeNames[2] : dateFormat.i18n.timeNames[3],
	          T:    H < 12 ? dateFormat.i18n.timeNames[4] : dateFormat.i18n.timeNames[5],
	          TT:   H < 12 ? dateFormat.i18n.timeNames[6] : dateFormat.i18n.timeNames[7],
	          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
	          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
	          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
	          W:    W,
	          N:    N
	        };
	  
	        return mask.replace(token, function (match) {
	          if (match in flags) {
	            return flags[match];
	          }
	          return match.slice(1, match.length - 1);
	        });
	      };
	    })();

	  dateFormat.masks = {
	    'default':               'ddd mmm dd yyyy HH:MM:ss',
	    'shortDate':             'm/d/yy',
	    'mediumDate':            'mmm d, yyyy',
	    'longDate':              'mmmm d, yyyy',
	    'fullDate':              'dddd, mmmm d, yyyy',
	    'shortTime':             'h:MM TT',
	    'mediumTime':            'h:MM:ss TT',
	    'longTime':              'h:MM:ss TT Z',
	    'isoDate':               'yyyy-mm-dd',
	    'isoTime':               'HH:MM:ss',
	    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
	    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
	    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
	  };

	  // Internationalization strings
	  dateFormat.i18n = {
	    dayNames: [
	      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
	      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
	    ],
	    monthNames: [
	      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
	      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
	    ],
	    timeNames: [
	      'a', 'p', 'am', 'pm', 'A', 'P', 'AM', 'PM'
	    ]
	  };

	function pad(val, len) {
	  val = String(val);
	  len = len || 2;
	  while (val.length < len) {
	    val = '0' + val;
	  }
	  return val;
	}

	/**
	 * Get the ISO 8601 week number
	 * Based on comments from
	 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
	 *
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getWeek(date) {
	  // Remove time components of date
	  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

	  // Change date to Thursday same week
	  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

	  // Take January 4th as it is always in week 1 (see ISO 8601)
	  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

	  // Change date to Thursday same week
	  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

	  // Check if daylight-saving-time-switch occurred and correct for it
	  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
	  targetThursday.setHours(targetThursday.getHours() - ds);

	  // Number of weeks between target Thursday and first Thursday
	  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
	  return 1 + Math.floor(weekDiff);
	}

	/**
	 * Get ISO-8601 numeric representation of the day of the week
	 * 1 (for Monday) through 7 (for Sunday)
	 * 
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getDayOfWeek(date) {
	  var dow = date.getDay();
	  if(dow === 0) {
	    dow = 7;
	  }
	  return dow;
	}

	/**
	 * kind-of shortcut
	 * @param  {*} val
	 * @return {String}
	 */
	function kindOf(val) {
	  if (val === null) {
	    return 'null';
	  }

	  if (val === undefined) {
	    return 'undefined';
	  }

	  if (typeof val !== 'object') {
	    return typeof val;
	  }

	  if (Array.isArray(val)) {
	    return 'array';
	  }

	  return {}.toString.call(val)
	    .slice(8, -1).toLowerCase();
	}


	  if (typeof undefined === 'function' && undefined.amd) {
	    undefined(function () {
	      return dateFormat;
	    });
	  } else {
	    module.exports = dateFormat;
	  }
	})(commonjsGlobal);
	});

	/*!
	 * repeat-string <https://github.com/jonschlinkert/repeat-string>
	 *
	 * Copyright (c) 2014-2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	/**
	 * Results cache
	 */

	var res = '';
	var cache;

	/**
	 * Expose `repeat`
	 */

	var repeatString = repeat;

	/**
	 * Repeat the given `string` the specified `number`
	 * of times.
	 *
	 * **Example:**
	 *
	 * ```js
	 * var repeat = require('repeat-string');
	 * repeat('A', 5);
	 * //=> AAAAA
	 * ```
	 *
	 * @param {String} `string` The string to repeat
	 * @param {Number} `number` The number of times to repeat the string
	 * @return {String} Repeated string
	 * @api public
	 */

	function repeat(str, num) {
	  if (typeof str !== 'string') {
	    throw new TypeError('expected a string');
	  }

	  // cover common, quick use cases
	  if (num === 1) return str;
	  if (num === 2) return str + str;

	  var max = str.length * num;
	  if (cache !== str || typeof cache === 'undefined') {
	    cache = str;
	    res = '';
	  } else if (res.length >= max) {
	    return res.substr(0, max);
	  }

	  while (max > res.length && num > 1) {
	    if (num & 1) {
	      res += str;
	    }

	    num >>= 1;
	    str += str;
	  }

	  res += str;
	  res = res.substr(0, max);
	  return res;
	}

	var padLeft = function padLeft(str, num, ch) {
	  str = str.toString();

	  if (typeof num === 'undefined') {
	    return str;
	  }

	  if (ch === 0) {
	    ch = '0';
	  } else if (ch) {
	    ch = ch.toString();
	  } else {
	    ch = ' ';
	  }

	  return repeatString(ch, num - str.length) + str;
	};

	var noop = function () {};
	var link;
	var defaultExts = {
	    extension: '',
	    prefix: '',
	    suffix: ''
	};
	var supportedEncodings = ['image/png','image/jpeg','image/webp'];
	function stream(isStart, opts) {
	    if ( opts === void 0 ) opts = {};

	    return new Promise(function (resolve, reject) {
	        opts = objectAssign({}, defaultExts, opts);
	        var filename = resolveFilename(Object.assign({}, opts, {
	            extension: '',
	            frame: undefined
	        }));
	        var func = isStart ? 'streamStart' : 'streamEnd';
	        var client = getClientAPI();
	        if (client && client.output && typeof client[func] === 'function') {
	            return client[func](objectAssign({}, opts, {
	                filename: filename
	            })).then(function (ev) { return resolve(ev); });
	        } else {
	            return resolve({
	                filename: filename,
	                client: false
	            });
	        }
	    });
	}

	function streamStart(opts) {
	    if ( opts === void 0 ) opts = {};

	    return stream(true, opts);
	}

	function streamEnd(opts) {
	    if ( opts === void 0 ) opts = {};

	    return stream(false, opts);
	}

	function exportCanvas(canvas, opt) {
	    if ( opt === void 0 ) opt = {};

	    var encoding = opt.encoding || 'image/png';
	    if (!supportedEncodings.includes(encoding)) 
	        { throw new Error(("Invalid canvas encoding " + encoding)); }
	    var extension = (encoding.split('/')[1] || '').replace(/jpeg/i, 'jpg');
	    if (extension) 
	        { extension = ("." + extension).toLowerCase(); }
	    return {
	        extension: extension,
	        type: encoding,
	        dataURL: canvas.toDataURL(encoding, opt.encodingQuality)
	    };
	}

	function createBlobFromDataURL(dataURL) {
	    return new Promise(function (resolve) {
	        var splitIndex = dataURL.indexOf(',');
	        if (splitIndex === -1) {
	            resolve(new window.Blob());
	            return;
	        }
	        var base64 = dataURL.slice(splitIndex + 1);
	        var byteString = window.atob(base64);
	        var type = dataURL.slice(0, splitIndex);
	        var mimeMatch = /data:([^;]+)/.exec(type);
	        var mime = (mimeMatch ? mimeMatch[1] : '') || undefined;
	        var ab = new ArrayBuffer(byteString.length);
	        var ia = new Uint8Array(ab);
	        for (var i = 0;i < byteString.length; i++) {
	            ia[i] = byteString.charCodeAt(i);
	        }
	        resolve(new window.Blob([ab], {
	            type: mime
	        }));
	    });
	}

	function saveDataURL(dataURL, opts) {
	    if ( opts === void 0 ) opts = {};

	    return createBlobFromDataURL(dataURL).then(function (blob) { return saveBlob(blob, opts); });
	}

	function saveBlob(blob, opts) {
	    if ( opts === void 0 ) opts = {};

	    return new Promise(function (resolve) {
	        opts = objectAssign({}, defaultExts, opts);
	        var filename = opts.filename;
	        var client = getClientAPI();
	        if (client && typeof client.saveBlob === 'function' && client.output) {
	            return client.saveBlob(blob, objectAssign({}, opts, {
	                filename: filename
	            })).then(function (ev) { return resolve(ev); });
	        } else {
	            if (!link) {
	                link = document.createElement('a');
	                link.style.visibility = 'hidden';
	                link.target = '_blank';
	            }
	            link.download = filename;
	            link.href = window.URL.createObjectURL(blob);
	            document.body.appendChild(link);
	            link.onclick = (function () {
	                link.onclick = noop;
	                setTimeout(function () {
	                    window.URL.revokeObjectURL(blob);
	                    if (link.parentElement) 
	                        { link.parentElement.removeChild(link); }
	                    link.removeAttribute('href');
	                    resolve({
	                        filename: filename,
	                        client: false
	                    });
	                });
	            });
	            link.click();
	        }
	    });
	}

	function saveFile(data, opts) {
	    if ( opts === void 0 ) opts = {};

	    var parts = Array.isArray(data) ? data : [data];
	    var blob = new window.Blob(parts, {
	        type: opts.type || ''
	    });
	    return saveBlob(blob, opts);
	}

	function getTimeStamp() {
	    var dateFormatStr = "yyyy.mm.dd-HH.MM.ss";
	    return dateformat(new Date(), dateFormatStr);
	}

	function resolveFilename(opt) {
	    if ( opt === void 0 ) opt = {};

	    opt = objectAssign({}, opt);
	    if (typeof opt.file === 'function') {
	        return opt.file(opt);
	    } else if (opt.file) {
	        return opt.file;
	    }
	    var frame = null;
	    var extension = '';
	    if (typeof opt.extension === 'string') 
	        { extension = opt.extension; }
	    if (typeof opt.frame === 'number') {
	        var totalFrames;
	        if (typeof opt.totalFrames === 'number') {
	            totalFrames = opt.totalFrames;
	        } else {
	            totalFrames = Math.max(10000, opt.frame);
	        }
	        frame = padLeft(String(opt.frame), String(totalFrames).length, '0');
	    }
	    var layerStr = isFinite(opt.totalLayers) && isFinite(opt.layer) && opt.totalLayers > 1 ? ("" + (opt.layer)) : '';
	    if (frame != null) {
	        return [layerStr,frame].filter(Boolean).join('-') + extension;
	    } else {
	        var defaultFileName = opt.timeStamp;
	        return [opt.prefix,opt.name || defaultFileName,layerStr,opt.hash,opt.suffix].filter(Boolean).join('-') + extension;
	    }
	}

	var commonTypos = {
	    dimension: 'dimensions',
	    animated: 'animate',
	    animating: 'animate',
	    unit: 'units',
	    P5: 'p5',
	    pixellated: 'pixelated',
	    looping: 'loop',
	    pixelPerInch: 'pixels'
	};
	var allKeys = ['dimensions','units','pixelsPerInch','orientation','scaleToFit',
	    'scaleToView','bleed','pixelRatio','exportPixelRatio','maxPixelRatio','scaleContext',
	    'resizeCanvas','styleCanvas','canvas','context','attributes','parent','file',
	    'name','prefix','suffix','animate','playing','loop','duration','totalFrames',
	    'fps','playbackRate','timeScale','frame','time','flush','pixelated','hotkeys',
	    'p5','id','scaleToFitPadding','data','params','encoding','encodingQuality'];
	var checkSettings = function (settings) {
	    var keys = Object.keys(settings);
	    keys.forEach(function (key) {
	        if (key in commonTypos) {
	            var actual = commonTypos[key];
	            console.warn(("[canvas-sketch] Could not recognize the setting \"" + key + "\", did you mean \"" + actual + "\"?"));
	        } else if (!allKeys.includes(key)) {
	            console.warn(("[canvas-sketch] Could not recognize the setting \"" + key + "\""));
	        }
	    });
	};

	function keyboardShortcuts (opt) {
	    if ( opt === void 0 ) opt = {};

	    var handler = function (ev) {
	        if (!opt.enabled()) 
	            { return; }
	        var client = getClientAPI();
	        if (ev.keyCode === 83 && !ev.altKey && (ev.metaKey || ev.ctrlKey)) {
	            ev.preventDefault();
	            opt.save(ev);
	        } else if (ev.keyCode === 32) {
	            opt.togglePlay(ev);
	        } else if (client && !ev.altKey && ev.keyCode === 75 && (ev.metaKey || ev.ctrlKey)) {
	            ev.preventDefault();
	            opt.commit(ev);
	        }
	    };
	    var attach = function () {
	        window.addEventListener('keydown', handler);
	    };
	    var detach = function () {
	        window.removeEventListener('keydown', handler);
	    };
	    return {
	        attach: attach,
	        detach: detach
	    };
	}

	var defaultUnits = 'mm';
	var data = [['postcard',101.6,152.4],['poster-small',280,430],['poster',460,610],
	    ['poster-large',610,910],['business-card',50.8,88.9],['2r',64,89],['3r',89,127],
	    ['4r',102,152],['5r',127,178],['6r',152,203],['8r',203,254],['10r',254,305],['11r',
	    279,356],['12r',305,381],['a0',841,1189],['a1',594,841],['a2',420,594],['a3',
	    297,420],['a4',210,297],['a5',148,210],['a6',105,148],['a7',74,105],['a8',52,
	    74],['a9',37,52],['a10',26,37],['2a0',1189,1682],['4a0',1682,2378],['b0',1000,
	    1414],['b1',707,1000],['b1+',720,1020],['b2',500,707],['b2+',520,720],['b3',353,
	    500],['b4',250,353],['b5',176,250],['b6',125,176],['b7',88,125],['b8',62,88],
	    ['b9',44,62],['b10',31,44],['b11',22,32],['b12',16,22],['c0',917,1297],['c1',
	    648,917],['c2',458,648],['c3',324,458],['c4',229,324],['c5',162,229],['c6',114,
	    162],['c7',81,114],['c8',57,81],['c9',40,57],['c10',28,40],['c11',22,32],['c12',
	    16,22],['half-letter',5.5,8.5,'in'],['letter',8.5,11,'in'],['legal',8.5,14,'in'],
	    ['junior-legal',5,8,'in'],['ledger',11,17,'in'],['tabloid',11,17,'in'],['ansi-a',
	    8.5,11.0,'in'],['ansi-b',11.0,17.0,'in'],['ansi-c',17.0,22.0,'in'],['ansi-d',
	    22.0,34.0,'in'],['ansi-e',34.0,44.0,'in'],['arch-a',9,12,'in'],['arch-b',12,18,
	    'in'],['arch-c',18,24,'in'],['arch-d',24,36,'in'],['arch-e',36,48,'in'],['arch-e1',
	    30,42,'in'],['arch-e2',26,38,'in'],['arch-e3',27,39,'in']];
	var paperSizes = data.reduce(function (dict, preset) {
	    var item = {
	        units: preset[3] || defaultUnits,
	        dimensions: [preset[1],preset[2]]
	    };
	    dict[preset[0]] = item;
	    dict[preset[0].replace(/-/g, ' ')] = item;
	    return dict;
	}, {})

	var defined$1 = function () {
	    for (var i = 0; i < arguments.length; i++) {
	        if (arguments[i] !== undefined) return arguments[i];
	    }
	};

	var units = [ 'mm', 'cm', 'm', 'pc', 'pt', 'in', 'ft', 'px' ];

	var conversions = {
	  // metric
	  m: {
	    system: 'metric',
	    factor: 1
	  },
	  cm: {
	    system: 'metric',
	    factor: 1 / 100
	  },
	  mm: {
	    system: 'metric',
	    factor: 1 / 1000
	  },
	  // imperial
	  pt: {
	    system: 'imperial',
	    factor: 1 / 72
	  },
	  pc: {
	    system: 'imperial',
	    factor: 1 / 6
	  },
	  in: {
	    system: 'imperial',
	    factor: 1
	  },
	  ft: {
	    system: 'imperial',
	    factor: 12
	  }
	};

	const anchors = {
	  metric: {
	    unit: 'm',
	    ratio: 1 / 0.0254
	  },
	  imperial: {
	    unit: 'in',
	    ratio: 0.0254
	  }
	};

	function round (value, decimals) {
	  return Number(Math.round(value + 'e' + decimals) + 'e-' + decimals);
	}

	function convertDistance (value, fromUnit, toUnit, opts) {
	  if (typeof value !== 'number' || !isFinite(value)) throw new Error('Value must be a finite number');
	  if (!fromUnit || !toUnit) throw new Error('Must specify from and to units');

	  opts = opts || {};
	  var pixelsPerInch = defined$1(opts.pixelsPerInch, 96);
	  var precision = opts.precision;
	  var roundPixel = opts.roundPixel !== false;

	  fromUnit = fromUnit.toLowerCase();
	  toUnit = toUnit.toLowerCase();

	  if (units.indexOf(fromUnit) === -1) throw new Error('Invalid from unit "' + fromUnit + '", must be one of: ' + units.join(', '));
	  if (units.indexOf(toUnit) === -1) throw new Error('Invalid from unit "' + toUnit + '", must be one of: ' + units.join(', '));

	  if (fromUnit === toUnit) {
	    // We don't need to convert from A to B since they are the same already
	    return value;
	  }

	  var toFactor = 1;
	  var fromFactor = 1;
	  var isToPixel = false;

	  if (fromUnit === 'px') {
	    fromFactor = 1 / pixelsPerInch;
	    fromUnit = 'in';
	  }
	  if (toUnit === 'px') {
	    isToPixel = true;
	    toFactor = pixelsPerInch;
	    toUnit = 'in';
	  }

	  var fromUnitData = conversions[fromUnit];
	  var toUnitData = conversions[toUnit];

	  // source to anchor inside source's system
	  var anchor = value * fromUnitData.factor * fromFactor;

	  // if systems differ, convert one to another
	  if (fromUnitData.system !== toUnitData.system) {
	    // regular 'm' to 'in' and so forth
	    anchor *= anchors[fromUnitData.system].ratio;
	  }

	  var result = anchor / toUnitData.factor * toFactor;
	  if (isToPixel && roundPixel) {
	    result = Math.round(result);
	  } else if (typeof precision === 'number' && isFinite(precision)) {
	    result = round(result, precision);
	  }
	  return result;
	}

	var convertLength = convertDistance;
	var units_1 = units;
	convertLength.units = units_1;

	function getDimensionsFromPreset(dimensions, unitsTo, pixelsPerInch) {
	    if ( unitsTo === void 0 ) unitsTo = 'px';
	    if ( pixelsPerInch === void 0 ) pixelsPerInch = 72;

	    if (typeof dimensions === 'string') {
	        var key = dimensions.toLowerCase();
	        if (!(key in paperSizes)) {
	            throw new Error(("The dimension preset \"" + dimensions + "\" is not supported or could not be found; try using a4, a3, postcard, letter, etc."));
	        }
	        var preset = paperSizes[key];
	        return preset.dimensions.map(function (d) { return convertDistance$1(d, preset.units, unitsTo, pixelsPerInch); });
	    } else {
	        return dimensions;
	    }
	}

	function convertDistance$1(dimension, unitsFrom, unitsTo, pixelsPerInch) {
	    if ( unitsFrom === void 0 ) unitsFrom = 'px';
	    if ( unitsTo === void 0 ) unitsTo = 'px';
	    if ( pixelsPerInch === void 0 ) pixelsPerInch = 72;

	    return convertLength(dimension, unitsFrom, unitsTo, {
	        pixelsPerInch: pixelsPerInch,
	        precision: 4,
	        roundPixel: true
	    });
	}

	function checkIfHasDimensions(settings) {
	    if (!settings.dimensions) 
	        { return false; }
	    if (typeof settings.dimensions === 'string') 
	        { return true; }
	    if (Array.isArray(settings.dimensions) && settings.dimensions.length >= 2) 
	        { return true; }
	    return false;
	}

	function getParentSize(props, settings) {
	    if (!isBrowser()) {
	        return [300,150];
	    }
	    var element = settings.parent || window;
	    if (element === window || element === document || element === document.body) {
	        return [window.innerWidth,window.innerHeight];
	    } else {
	        var ref = element.getBoundingClientRect();
	        var width = ref.width;
	        var height = ref.height;
	        return [width,height];
	    }
	}

	function resizeCanvas(props, settings) {
	    var width, height;
	    var styleWidth, styleHeight;
	    var canvasWidth, canvasHeight;
	    var browser = isBrowser();
	    var dimensions = settings.dimensions;
	    var hasDimensions = checkIfHasDimensions(settings);
	    var exporting = props.exporting;
	    var scaleToFit = hasDimensions ? settings.scaleToFit !== false : false;
	    var scaleToView = !exporting && hasDimensions ? settings.scaleToView : true;
	    if (!browser) 
	        { scaleToFit = (scaleToView = false); }
	    var units = settings.units;
	    var pixelsPerInch = typeof settings.pixelsPerInch === 'number' && isFinite(settings.pixelsPerInch) ? settings.pixelsPerInch : 72;
	    var bleed = defined(settings.bleed, 0);
	    var devicePixelRatio = browser ? window.devicePixelRatio : 1;
	    var basePixelRatio = scaleToView ? devicePixelRatio : 1;
	    var pixelRatio, exportPixelRatio;
	    if (typeof settings.pixelRatio === 'number' && isFinite(settings.pixelRatio)) {
	        pixelRatio = settings.pixelRatio;
	        exportPixelRatio = defined(settings.exportPixelRatio, pixelRatio);
	    } else {
	        if (hasDimensions) {
	            pixelRatio = basePixelRatio;
	            exportPixelRatio = defined(settings.exportPixelRatio, 1);
	        } else {
	            pixelRatio = devicePixelRatio;
	            exportPixelRatio = defined(settings.exportPixelRatio, pixelRatio);
	        }
	    }
	    if (typeof settings.maxPixelRatio === 'number' && isFinite(settings.maxPixelRatio)) {
	        pixelRatio = Math.min(settings.maxPixelRatio, pixelRatio);
	    }
	    if (exporting) {
	        pixelRatio = exportPixelRatio;
	    }
	    var ref = getParentSize(props, settings);
	    var parentWidth = ref[0];
	    var parentHeight = ref[1];
	    var trimWidth, trimHeight;
	    if (hasDimensions) {
	        var result = getDimensionsFromPreset(dimensions, units, pixelsPerInch);
	        var highest = Math.max(result[0], result[1]);
	        var lowest = Math.min(result[0], result[1]);
	        if (settings.orientation) {
	            var landscape = settings.orientation === 'landscape';
	            width = landscape ? highest : lowest;
	            height = landscape ? lowest : highest;
	        } else {
	            width = result[0];
	            height = result[1];
	        }
	        trimWidth = width;
	        trimHeight = height;
	        width += bleed * 2;
	        height += bleed * 2;
	    } else {
	        width = parentWidth;
	        height = parentHeight;
	        trimWidth = width;
	        trimHeight = height;
	    }
	    var realWidth = width;
	    var realHeight = height;
	    if (hasDimensions && units) {
	        realWidth = convertDistance$1(width, units, 'px', pixelsPerInch);
	        realHeight = convertDistance$1(height, units, 'px', pixelsPerInch);
	    }
	    styleWidth = Math.round(realWidth);
	    styleHeight = Math.round(realHeight);
	    if (scaleToFit && !exporting && hasDimensions) {
	        var aspect = width / height;
	        var windowAspect = parentWidth / parentHeight;
	        var scaleToFitPadding = defined(settings.scaleToFitPadding, 40);
	        var maxWidth = Math.round(parentWidth - scaleToFitPadding * 2);
	        var maxHeight = Math.round(parentHeight - scaleToFitPadding * 2);
	        if (styleWidth > maxWidth || styleHeight > maxHeight) {
	            if (windowAspect > aspect) {
	                styleHeight = maxHeight;
	                styleWidth = Math.round(styleHeight * aspect);
	            } else {
	                styleWidth = maxWidth;
	                styleHeight = Math.round(styleWidth / aspect);
	            }
	        }
	    }
	    canvasWidth = scaleToView ? Math.round(pixelRatio * styleWidth) : Math.round(pixelRatio * realWidth);
	    canvasHeight = scaleToView ? Math.round(pixelRatio * styleHeight) : Math.round(pixelRatio * realHeight);
	    var viewportWidth = scaleToView ? Math.round(styleWidth) : Math.round(realWidth);
	    var viewportHeight = scaleToView ? Math.round(styleHeight) : Math.round(realHeight);
	    var scaleX = canvasWidth / width;
	    var scaleY = canvasHeight / height;
	    return {
	        bleed: bleed,
	        pixelRatio: pixelRatio,
	        width: width,
	        height: height,
	        dimensions: [width,height],
	        units: units || 'px',
	        scaleX: scaleX,
	        scaleY: scaleY,
	        pixelsPerInch: pixelsPerInch,
	        viewportWidth: viewportWidth,
	        viewportHeight: viewportHeight,
	        canvasWidth: canvasWidth,
	        canvasHeight: canvasHeight,
	        trimWidth: trimWidth,
	        trimHeight: trimHeight,
	        styleWidth: styleWidth,
	        styleHeight: styleHeight
	    };
	}

	var getCanvasContext_1 = getCanvasContext;
	function getCanvasContext (type, opts) {
	  if (typeof type !== 'string') {
	    throw new TypeError('must specify type string')
	  }

	  opts = opts || {};

	  if (typeof document === 'undefined' && !opts.canvas) {
	    return null // check for Node
	  }

	  var canvas = opts.canvas || document.createElement('canvas');
	  if (typeof opts.width === 'number') {
	    canvas.width = opts.width;
	  }
	  if (typeof opts.height === 'number') {
	    canvas.height = opts.height;
	  }

	  var attribs = opts;
	  var gl;
	  try {
	    var names = [ type ];
	    // prefix GL contexts
	    if (type.indexOf('webgl') === 0) {
	      names.push('experimental-' + type);
	    }

	    for (var i = 0; i < names.length; i++) {
	      gl = canvas.getContext(names[i], attribs);
	      if (gl) return gl
	    }
	  } catch (e) {
	    gl = null;
	  }
	  return (gl || null) // ensure null on fail
	}

	function createCanvasElement() {
	    if (!isBrowser()) {
	        throw new Error('It appears you are runing from Node.js or a non-browser environment. Try passing in an existing { canvas } interface instead.');
	    }
	    return document.createElement('canvas');
	}

	function createCanvas(settings) {
	    if ( settings === void 0 ) settings = {};

	    var context, canvas;
	    var ownsCanvas = false;
	    if (settings.canvas !== false) {
	        context = settings.context;
	        if (!context || typeof context === 'string') {
	            var newCanvas = settings.canvas;
	            if (!newCanvas) {
	                newCanvas = createCanvasElement();
	                ownsCanvas = true;
	            }
	            var type = context || '2d';
	            if (typeof newCanvas.getContext !== 'function') {
	                throw new Error("The specified { canvas } element does not have a getContext() function, maybe it is not a <canvas> tag?");
	            }
	            context = getCanvasContext_1(type, objectAssign({}, settings.attributes, {
	                canvas: newCanvas
	            }));
	            if (!context) {
	                throw new Error(("Failed at canvas.getContext('" + type + "') - the browser may not support this context, or a different context may already be in use with this canvas."));
	            }
	        }
	        canvas = context.canvas;
	        if (settings.canvas && canvas !== settings.canvas) {
	            throw new Error('The { canvas } and { context } settings must point to the same underlying canvas element');
	        }
	        if (settings.pixelated) {
	            context.imageSmoothingEnabled = false;
	            context.mozImageSmoothingEnabled = false;
	            context.oImageSmoothingEnabled = false;
	            context.webkitImageSmoothingEnabled = false;
	            context.msImageSmoothingEnabled = false;
	            canvas.style['image-rendering'] = 'pixelated';
	        }
	    }
	    return {
	        canvas: canvas,
	        context: context,
	        ownsCanvas: ownsCanvas
	    };
	}

	var SketchManager = function SketchManager() {
	    var this$1 = this;

	    this._settings = {};
	    this._props = {};
	    this._sketch = undefined;
	    this._raf = null;
	    this._recordTimeout = null;
	    this._lastRedrawResult = undefined;
	    this._isP5Resizing = false;
	    this._keyboardShortcuts = keyboardShortcuts({
	        enabled: function () { return this$1.settings.hotkeys !== false; },
	        save: function (ev) {
	            if (ev.shiftKey) {
	                if (this$1.props.recording) {
	                    this$1.endRecord();
	                    this$1.run();
	                } else 
	                    { this$1.record(); }
	            } else if (!this$1.props.recording) {
	                this$1.exportFrame();
	            }
	        },
	        togglePlay: function () {
	            if (this$1.props.playing) 
	                { this$1.pause(); }
	             else 
	                { this$1.play(); }
	        },
	        commit: function (ev) {
	            this$1.exportFrame({
	                commit: true
	            });
	        }
	    });
	    this._animateHandler = (function () { return this$1.animate(); });
	    this._resizeHandler = (function () {
	        var changed = this$1.resize();
	        if (changed) {
	            this$1.render();
	        }
	    });
	};

	var prototypeAccessors = { sketch: { configurable: true },settings: { configurable: true },props: { configurable: true } };
	prototypeAccessors.sketch.get = function () {
	    return this._sketch;
	};
	prototypeAccessors.settings.get = function () {
	    return this._settings;
	};
	prototypeAccessors.props.get = function () {
	    return this._props;
	};
	SketchManager.prototype._computePlayhead = function _computePlayhead (currentTime, duration) {
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    return hasDuration ? currentTime / duration : 0;
	};
	SketchManager.prototype._computeFrame = function _computeFrame (playhead, time, totalFrames, fps) {
	    return isFinite(totalFrames) && totalFrames > 1 ? Math.floor(playhead * (totalFrames - 1)) : Math.floor(fps * time);
	};
	SketchManager.prototype._computeCurrentFrame = function _computeCurrentFrame () {
	    return this._computeFrame(this.props.playhead, this.props.time, this.props.totalFrames, this.props.fps);
	};
	SketchManager.prototype._getSizeProps = function _getSizeProps () {
	    var props = this.props;
	    return {
	        width: props.width,
	        height: props.height,
	        pixelRatio: props.pixelRatio,
	        canvasWidth: props.canvasWidth,
	        canvasHeight: props.canvasHeight,
	        viewportWidth: props.viewportWidth,
	        viewportHeight: props.viewportHeight
	    };
	};
	SketchManager.prototype.run = function run () {
	    if (!this.sketch) 
	        { throw new Error('should wait until sketch is loaded before trying to play()'); }
	    if (this.settings.playing !== false) {
	        this.play();
	    }
	    if (typeof this.sketch.dispose === 'function') {
	        console.warn('In canvas-sketch@0.0.23 the dispose() event has been renamed to unload()');
	    }
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    this.tick();
	    this.render();
	    return this;
	};
	SketchManager.prototype._cancelTimeouts = function _cancelTimeouts () {
	    if (this._raf != null && typeof window !== 'undefined' && typeof window.cancelAnimationFrame === 'function') {
	        window.cancelAnimationFrame(this._raf);
	        this._raf = null;
	    }
	    if (this._recordTimeout != null) {
	        clearTimeout(this._recordTimeout);
	        this._recordTimeout = null;
	    }
	};
	SketchManager.prototype.play = function play () {
	    var animate = this.settings.animate;
	    if ('animation' in this.settings) {
	        animate = true;
	        console.warn('[canvas-sketch] { animation } has been renamed to { animate }');
	    }
	    if (!animate) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Using { animate } in Node.js is not yet supported');
	        return;
	    }
	    if (this.props.playing) 
	        { return; }
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    this.props.playing = true;
	    this._cancelTimeouts();
	    this._lastTime = browser();
	    this._raf = window.requestAnimationFrame(this._animateHandler);
	};
	SketchManager.prototype.pause = function pause () {
	    if (this.props.recording) 
	        { this.endRecord(); }
	    this.props.playing = false;
	    this._cancelTimeouts();
	};
	SketchManager.prototype.togglePlay = function togglePlay () {
	    if (this.props.playing) 
	        { this.pause(); }
	     else 
	        { this.play(); }
	};
	SketchManager.prototype.stop = function stop () {
	    this.pause();
	    this.props.frame = 0;
	    this.props.playhead = 0;
	    this.props.time = 0;
	    this.props.deltaTime = 0;
	    this.props.started = false;
	    this.render();
	};
	SketchManager.prototype.record = function record () {
	        var this$1 = this;

	    if (this.props.recording) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Recording from Node.js is not yet supported');
	        return;
	    }
	    this.stop();
	    this.props.playing = true;
	    this.props.recording = true;
	    var exportOpts = this._createExportOptions({
	        sequence: true
	    });
	    var frameInterval = 1 / this.props.fps;
	    this._cancelTimeouts();
	    var tick = function () {
	        if (!this$1.props.recording) 
	            { return Promise.resolve(); }
	        this$1.props.deltaTime = frameInterval;
	        this$1.tick();
	        return this$1.exportFrame(exportOpts).then(function () {
	            if (!this$1.props.recording) 
	                { return; }
	            this$1.props.deltaTime = 0;
	            this$1.props.frame++;
	            if (this$1.props.frame < this$1.props.totalFrames) {
	                this$1.props.time += frameInterval;
	                this$1.props.playhead = this$1._computePlayhead(this$1.props.time, this$1.props.duration);
	                this$1._recordTimeout = setTimeout(tick, 0);
	            } else {
	                console.log('Finished recording');
	                this$1._signalEnd();
	                this$1.endRecord();
	                this$1.stop();
	                this$1.run();
	            }
	        });
	    };
	    if (!this.props.started) {
	        this._signalBegin();
	        this.props.started = true;
	    }
	    if (this.sketch && typeof this.sketch.beginRecord === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.beginRecord(props); });
	    }
	    streamStart(exportOpts).catch(function (err) {
	        console.error(err);
	    }).then(function (response) {
	        this$1._raf = window.requestAnimationFrame(tick);
	    });
	};
	SketchManager.prototype._signalBegin = function _signalBegin () {
	        var this$1 = this;

	    if (this.sketch && typeof this.sketch.begin === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.begin(props); });
	    }
	};
	SketchManager.prototype._signalEnd = function _signalEnd () {
	        var this$1 = this;

	    if (this.sketch && typeof this.sketch.end === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.end(props); });
	    }
	};
	SketchManager.prototype.endRecord = function endRecord () {
	        var this$1 = this;

	    var wasRecording = this.props.recording;
	    this._cancelTimeouts();
	    this.props.recording = false;
	    this.props.deltaTime = 0;
	    this.props.playing = false;
	    return streamEnd().catch(function (err) {
	        console.error(err);
	    }).then(function () {
	        if (wasRecording && this$1.sketch && typeof this$1.sketch.endRecord === 'function') {
	            this$1._wrapContextScale(function (props) { return this$1.sketch.endRecord(props); });
	        }
	    });
	};
	SketchManager.prototype._createExportOptions = function _createExportOptions (opt) {
	        if ( opt === void 0 ) opt = {};

	    return {
	        sequence: opt.sequence,
	        save: opt.save,
	        fps: this.props.fps,
	        frame: opt.sequence ? this.props.frame : undefined,
	        file: this.settings.file,
	        name: this.settings.name,
	        prefix: this.settings.prefix,
	        suffix: this.settings.suffix,
	        encoding: this.settings.encoding,
	        encodingQuality: this.settings.encodingQuality,
	        timeStamp: opt.timeStamp || getTimeStamp(),
	        totalFrames: isFinite(this.props.totalFrames) ? Math.max(0, this.props.totalFrames) : 1000
	    };
	};
	SketchManager.prototype.exportFrame = function exportFrame (opt) {
	        var this$1 = this;
	        if ( opt === void 0 ) opt = {};

	    if (!this.sketch) 
	        { return Promise.all([]); }
	    if (typeof this.sketch.preExport === 'function') {
	        this.sketch.preExport();
	    }
	    var exportOpts = this._createExportOptions(opt);
	    var client = getClientAPI();
	    var p = Promise.resolve();
	    if (client && opt.commit && typeof client.commit === 'function') {
	        var commitOpts = objectAssign({}, exportOpts);
	        var hash = client.commit(commitOpts);
	        if (isPromise_1(hash)) 
	            { p = hash; }
	         else 
	            { p = Promise.resolve(hash); }
	    }
	    return p.then(function (hash) { return this$1._doExportFrame(objectAssign({}, exportOpts, {
	        hash: hash || ''
	    })); }).then(function (result) {
	        if (result.length === 1) 
	            { return result[0]; }
	         else 
	            { return result; }
	    });
	};
	SketchManager.prototype._doExportFrame = function _doExportFrame (exportOpts) {
	        var this$1 = this;
	        if ( exportOpts === void 0 ) exportOpts = {};

	    this._props.exporting = true;
	    this.resize();
	    var drawResult = this.render();
	    var canvas = this.props.canvas;
	    if (typeof drawResult === 'undefined') {
	        drawResult = [canvas];
	    }
	    drawResult = [].concat(drawResult).filter(Boolean);
	    drawResult = drawResult.map(function (result) {
	        var hasDataObject = typeof result === 'object' && result && ('data' in result || 'dataURL' in result);
	        var data = hasDataObject ? result.data : result;
	        var opts = hasDataObject ? objectAssign({}, result, {
	            data: data
	        }) : {
	            data: data
	        };
	        if (isCanvas(data)) {
	            var encoding = opts.encoding || exportOpts.encoding;
	            var encodingQuality = defined(opts.encodingQuality, exportOpts.encodingQuality, 0.95);
	            var ref = exportCanvas(data, {
	                encoding: encoding,
	                encodingQuality: encodingQuality
	            });
	                var dataURL = ref.dataURL;
	                var extension = ref.extension;
	                var type = ref.type;
	            return Object.assign(opts, {
	                dataURL: dataURL,
	                extension: extension,
	                type: type
	            });
	        } else {
	            return opts;
	        }
	    });
	    this._props.exporting = false;
	    this.resize();
	    this.render();
	    return Promise.all(drawResult.map(function (result, i, layerList) {
	        var curOpt = objectAssign({
	            extension: '',
	            prefix: '',
	            suffix: ''
	        }, exportOpts, result, {
	            layer: i,
	            totalLayers: layerList.length
	        });
	        var saveParam = exportOpts.save === false ? false : result.save;
	        curOpt.save = saveParam !== false;
	        curOpt.filename = resolveFilename(curOpt);
	        delete curOpt.encoding;
	        delete curOpt.encodingQuality;
	        for (var k in curOpt) {
	            if (typeof curOpt[k] === 'undefined') 
	                { delete curOpt[k]; }
	        }
	        var savePromise = Promise.resolve({});
	        if (curOpt.save) {
	            var data = curOpt.data;
	            if (curOpt.dataURL) {
	                var dataURL = curOpt.dataURL;
	                savePromise = saveDataURL(dataURL, curOpt);
	            } else {
	                savePromise = saveFile(data, curOpt);
	            }
	        }
	        return savePromise.then(function (saveResult) { return Object.assign({}, curOpt, saveResult); });
	    })).then(function (ev) {
	        var savedEvents = ev.filter(function (e) { return e.save; });
	        if (savedEvents.length > 0) {
	            var eventWithOutput = savedEvents.find(function (e) { return e.outputName; });
	            var isClient = savedEvents.some(function (e) { return e.client; });
	            var isStreaming = savedEvents.some(function (e) { return e.stream; });
	            var item;
	            if (savedEvents.length > 1) 
	                { item = savedEvents.length; }
	             else if (eventWithOutput) 
	                { item = (eventWithOutput.outputName) + "/" + (savedEvents[0].filename); }
	             else 
	                { item = "" + (savedEvents[0].filename); }
	            var ofSeq = '';
	            if (exportOpts.sequence) {
	                var hasTotalFrames = isFinite(this$1.props.totalFrames);
	                ofSeq = hasTotalFrames ? (" (frame " + (exportOpts.frame + 1) + " / " + (this$1.props.totalFrames) + ")") : (" (frame " + (exportOpts.frame) + ")");
	            } else if (savedEvents.length > 1) {
	                ofSeq = " files";
	            }
	            var client = isClient ? 'canvas-sketch-cli' : 'canvas-sketch';
	            var action = isStreaming ? 'Streaming into' : 'Exported';
	            console.log(("%c[" + client + "]%c " + action + " %c" + item + "%c" + ofSeq), 'color: #8e8e8e;', 'color: initial;', 'font-weight: bold;', 'font-weight: initial;');
	        }
	        if (typeof this$1.sketch.postExport === 'function') {
	            this$1.sketch.postExport();
	        }
	        return ev;
	    });
	};
	SketchManager.prototype._wrapContextScale = function _wrapContextScale (cb) {
	    this._preRender();
	    cb(this.props);
	    this._postRender();
	};
	SketchManager.prototype._preRender = function _preRender () {
	    var props = this.props;
	    if (!this.props.gl && props.context && !props.p5) {
	        props.context.save();
	        if (this.settings.scaleContext !== false) {
	            props.context.scale(props.scaleX, props.scaleY);
	        }
	    } else if (props.p5) {
	        props.p5.scale(props.scaleX / props.pixelRatio, props.scaleY / props.pixelRatio);
	    }
	};
	SketchManager.prototype._postRender = function _postRender () {
	    var props = this.props;
	    if (!this.props.gl && props.context && !props.p5) {
	        props.context.restore();
	    }
	    if (props.gl && this.settings.flush !== false && !props.p5) {
	        props.gl.flush();
	    }
	};
	SketchManager.prototype.tick = function tick () {
	    if (this.sketch && typeof this.sketch.tick === 'function') {
	        this._preRender();
	        this.sketch.tick(this.props);
	        this._postRender();
	    }
	};
	SketchManager.prototype.render = function render () {
	    if (this.props.p5) {
	        this._lastRedrawResult = undefined;
	        this.props.p5.redraw();
	        return this._lastRedrawResult;
	    } else {
	        return this.submitDrawCall();
	    }
	};
	SketchManager.prototype.submitDrawCall = function submitDrawCall () {
	    if (!this.sketch) 
	        { return; }
	    var props = this.props;
	    this._preRender();
	    var drawResult;
	    if (typeof this.sketch === 'function') {
	        drawResult = this.sketch(props);
	    } else if (typeof this.sketch.render === 'function') {
	        drawResult = this.sketch.render(props);
	    }
	    this._postRender();
	    return drawResult;
	};
	SketchManager.prototype.update = function update (opt) {
	        var this$1 = this;
	        if ( opt === void 0 ) opt = {};

	    var notYetSupported = ['animate'];
	    Object.keys(opt).forEach(function (key) {
	        if (notYetSupported.indexOf(key) >= 0) {
	            throw new Error(("Sorry, the { " + key + " } option is not yet supported with update()."));
	        }
	    });
	    var oldCanvas = this._settings.canvas;
	    var oldContext = this._settings.context;
	    for (var key in opt) {
	        var value = opt[key];
	        if (typeof value !== 'undefined') {
	            this$1._settings[key] = value;
	        }
	    }
	    var timeOpts = Object.assign({}, this._settings, opt);
	    if ('time' in opt && 'frame' in opt) 
	        { throw new Error('You should specify { time } or { frame } but not both'); }
	     else if ('time' in opt) 
	        { delete timeOpts.frame; }
	     else if ('frame' in opt) 
	        { delete timeOpts.time; }
	    if ('duration' in opt && 'totalFrames' in opt) 
	        { throw new Error('You should specify { duration } or { totalFrames } but not both'); }
	     else if ('duration' in opt) 
	        { delete timeOpts.totalFrames; }
	     else if ('totalFrames' in opt) 
	        { delete timeOpts.duration; }
	    if ('data' in opt) 
	        { this._props.data = opt.data; }
	    var timeProps = this.getTimeProps(timeOpts);
	    Object.assign(this._props, timeProps);
	    if (oldCanvas !== this._settings.canvas || oldContext !== this._settings.context) {
	        var ref = createCanvas(this._settings);
	            var canvas = ref.canvas;
	            var context = ref.context;
	        this.props.canvas = canvas;
	        this.props.context = context;
	        this._setupGLKey();
	        this._appendCanvasIfNeeded();
	    }
	    if (opt.p5 && typeof opt.p5 !== 'function') {
	        this.props.p5 = opt.p5;
	        this.props.p5.draw = (function () {
	            if (this$1._isP5Resizing) 
	                { return; }
	            this$1._lastRedrawResult = this$1.submitDrawCall();
	        });
	    }
	    if ('playing' in opt) {
	        if (opt.playing) 
	            { this.play(); }
	         else 
	            { this.pause(); }
	    }
	    checkSettings(this._settings);
	    this.resize();
	    this.render();
	    return this.props;
	};
	SketchManager.prototype.resize = function resize () {
	    var oldSizes = this._getSizeProps();
	    var settings = this.settings;
	    var props = this.props;
	    var newProps = resizeCanvas(props, settings);
	    Object.assign(this._props, newProps);
	    var ref = this.props;
	        var pixelRatio = ref.pixelRatio;
	        var canvasWidth = ref.canvasWidth;
	        var canvasHeight = ref.canvasHeight;
	        var styleWidth = ref.styleWidth;
	        var styleHeight = ref.styleHeight;
	    var canvas = this.props.canvas;
	    if (canvas && settings.resizeCanvas !== false) {
	        if (props.p5) {
	            if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
	                this._isP5Resizing = true;
	                props.p5.pixelDensity(pixelRatio);
	                props.p5.resizeCanvas(canvasWidth / pixelRatio, canvasHeight / pixelRatio, false);
	                this._isP5Resizing = false;
	            }
	        } else {
	            if (canvas.width !== canvasWidth) 
	                { canvas.width = canvasWidth; }
	            if (canvas.height !== canvasHeight) 
	                { canvas.height = canvasHeight; }
	        }
	        if (isBrowser() && settings.styleCanvas !== false) {
	            canvas.style.width = styleWidth + "px";
	            canvas.style.height = styleHeight + "px";
	        }
	    }
	    var newSizes = this._getSizeProps();
	    var changed = !deepEqual_1(oldSizes, newSizes);
	    if (changed) {
	        this._sizeChanged();
	    }
	    return changed;
	};
	SketchManager.prototype._sizeChanged = function _sizeChanged () {
	    if (this.sketch && typeof this.sketch.resize === 'function') {
	        this.sketch.resize(this.props);
	    }
	};
	SketchManager.prototype.animate = function animate () {
	    if (!this.props.playing) 
	        { return; }
	    if (!isBrowser()) {
	        console.error('[canvas-sketch] WARN: Animation in Node.js is not yet supported');
	        return;
	    }
	    this._raf = window.requestAnimationFrame(this._animateHandler);
	    var now = browser();
	    var fps = this.props.fps;
	    var frameIntervalMS = 1000 / fps;
	    var deltaTimeMS = now - this._lastTime;
	    var duration = this.props.duration;
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    var isNewFrame = true;
	    var playbackRate = this.settings.playbackRate;
	    if (playbackRate === 'fixed') {
	        deltaTimeMS = frameIntervalMS;
	    } else if (playbackRate === 'throttle') {
	        if (deltaTimeMS > frameIntervalMS) {
	            now = now - deltaTimeMS % frameIntervalMS;
	            this._lastTime = now;
	        } else {
	            isNewFrame = false;
	        }
	    } else {
	        this._lastTime = now;
	    }
	    var deltaTime = deltaTimeMS / 1000;
	    var newTime = this.props.time + deltaTime * this.props.timeScale;
	    if (newTime < 0 && hasDuration) {
	        newTime = duration + newTime;
	    }
	    var isFinished = false;
	    var isLoopStart = false;
	    var looping = this.settings.loop !== false;
	    if (hasDuration && newTime >= duration) {
	        if (looping) {
	            isNewFrame = true;
	            newTime = newTime % duration;
	            isLoopStart = true;
	        } else {
	            isNewFrame = false;
	            newTime = duration;
	            isFinished = true;
	        }
	        this._signalEnd();
	    }
	    if (isNewFrame) {
	        this.props.deltaTime = deltaTime;
	        this.props.time = newTime;
	        this.props.playhead = this._computePlayhead(newTime, duration);
	        var lastFrame = this.props.frame;
	        this.props.frame = this._computeCurrentFrame();
	        if (isLoopStart) 
	            { this._signalBegin(); }
	        if (lastFrame !== this.props.frame) 
	            { this.tick(); }
	        this.render();
	        this.props.deltaTime = 0;
	    }
	    if (isFinished) {
	        this.pause();
	    }
	};
	SketchManager.prototype.dispatch = function dispatch (cb) {
	    if (typeof cb !== 'function') 
	        { throw new Error('must pass function into dispatch()'); }
	    cb(this.props);
	    this.render();
	};
	SketchManager.prototype.mount = function mount () {
	    this._appendCanvasIfNeeded();
	};
	SketchManager.prototype.unmount = function unmount () {
	    if (isBrowser()) {
	        window.removeEventListener('resize', this._resizeHandler);
	        this._keyboardShortcuts.detach();
	    }
	    if (this.props.canvas.parentElement) {
	        this.props.canvas.parentElement.removeChild(this.props.canvas);
	    }
	};
	SketchManager.prototype._appendCanvasIfNeeded = function _appendCanvasIfNeeded () {
	    if (!isBrowser()) 
	        { return; }
	    if (this.settings.parent !== false && (this.props.canvas && !this.props.canvas.parentElement)) {
	        var defaultParent = this.settings.parent || document.body;
	        defaultParent.appendChild(this.props.canvas);
	    }
	};
	SketchManager.prototype._setupGLKey = function _setupGLKey () {
	    if (this.props.context) {
	        if (isWebGLContext(this.props.context)) {
	            this._props.gl = this.props.context;
	        } else {
	            delete this._props.gl;
	        }
	    }
	};
	SketchManager.prototype.getTimeProps = function getTimeProps (settings) {
	        if ( settings === void 0 ) settings = {};

	    var duration = settings.duration;
	    var totalFrames = settings.totalFrames;
	    var timeScale = defined(settings.timeScale, 1);
	    var fps = defined(settings.fps, 24);
	    var hasDuration = typeof duration === 'number' && isFinite(duration);
	    var hasTotalFrames = typeof totalFrames === 'number' && isFinite(totalFrames);
	    var totalFramesFromDuration = hasDuration ? Math.floor(fps * duration) : undefined;
	    var durationFromTotalFrames = hasTotalFrames ? totalFrames / fps : undefined;
	    if (hasDuration && hasTotalFrames && totalFramesFromDuration !== totalFrames) {
	        throw new Error('You should specify either duration or totalFrames, but not both. Or, they must match exactly.');
	    }
	    if (typeof settings.dimensions === 'undefined' && typeof settings.units !== 'undefined') {
	        console.warn("You've specified a { units } setting but no { dimension }, so the units will be ignored.");
	    }
	    totalFrames = defined(totalFrames, totalFramesFromDuration, Infinity);
	    duration = defined(duration, durationFromTotalFrames, Infinity);
	    var startTime = settings.time;
	    var startFrame = settings.frame;
	    var hasStartTime = typeof startTime === 'number' && isFinite(startTime);
	    var hasStartFrame = typeof startFrame === 'number' && isFinite(startFrame);
	    var time = 0;
	    var frame = 0;
	    var playhead = 0;
	    if (hasStartTime && hasStartFrame) {
	        throw new Error('You should specify either start frame or time, but not both.');
	    } else if (hasStartTime) {
	        time = startTime;
	        playhead = this._computePlayhead(time, duration);
	        frame = this._computeFrame(playhead, time, totalFrames, fps);
	    } else if (hasStartFrame) {
	        frame = startFrame;
	        time = frame / fps;
	        playhead = this._computePlayhead(time, duration);
	    }
	    return {
	        playhead: playhead,
	        time: time,
	        frame: frame,
	        duration: duration,
	        totalFrames: totalFrames,
	        fps: fps,
	        timeScale: timeScale
	    };
	};
	SketchManager.prototype.setup = function setup (settings) {
	        var this$1 = this;
	        if ( settings === void 0 ) settings = {};

	    if (this.sketch) 
	        { throw new Error('Multiple setup() calls not yet supported.'); }
	    this._settings = Object.assign({}, settings, this._settings);
	    checkSettings(this._settings);
	    var ref = createCanvas(this._settings);
	        var context = ref.context;
	        var canvas = ref.canvas;
	    var timeProps = this.getTimeProps(this._settings);
	    this._props = Object.assign({}, timeProps,
	        {canvas: canvas,
	        context: context,
	        deltaTime: 0,
	        started: false,
	        exporting: false,
	        playing: false,
	        recording: false,
	        settings: this.settings,
	        data: this.settings.data,
	        render: function () { return this$1.render(); },
	        togglePlay: function () { return this$1.togglePlay(); },
	        dispatch: function (cb) { return this$1.dispatch(cb); },
	        tick: function () { return this$1.tick(); },
	        resize: function () { return this$1.resize(); },
	        update: function (opt) { return this$1.update(opt); },
	        exportFrame: function (opt) { return this$1.exportFrame(opt); },
	        record: function () { return this$1.record(); },
	        play: function () { return this$1.play(); },
	        pause: function () { return this$1.pause(); },
	        stop: function () { return this$1.stop(); }});
	    this._setupGLKey();
	    this.resize();
	};
	SketchManager.prototype.loadAndRun = function loadAndRun (canvasSketch, newSettings) {
	        var this$1 = this;

	    return this.load(canvasSketch, newSettings).then(function () {
	        this$1.run();
	        return this$1;
	    });
	};
	SketchManager.prototype.unload = function unload () {
	        var this$1 = this;

	    this.pause();
	    if (!this.sketch) 
	        { return; }
	    if (typeof this.sketch.unload === 'function') {
	        this._wrapContextScale(function (props) { return this$1.sketch.unload(props); });
	    }
	    this._sketch = null;
	};
	SketchManager.prototype.destroy = function destroy () {
	    this.unload();
	    this.unmount();
	};
	SketchManager.prototype.load = function load (createSketch, newSettings) {
	        var this$1 = this;

	    if (typeof createSketch !== 'function') {
	        throw new Error('The function must take in a function as the first parameter. Example:\n  canvasSketcher(() => { ... }, settings)');
	    }
	    if (this.sketch) {
	        this.unload();
	    }
	    if (typeof newSettings !== 'undefined') {
	        this.update(newSettings);
	    }
	    this._preRender();
	    var preload = Promise.resolve();
	    if (this.settings.p5) {
	        if (!isBrowser()) {
	            throw new Error('[canvas-sketch] ERROR: Using p5.js in Node.js is not supported');
	        }
	        preload = new Promise(function (resolve) {
	            var P5Constructor = this$1.settings.p5;
	            var preload;
	            if (P5Constructor.p5) {
	                preload = P5Constructor.preload;
	                P5Constructor = P5Constructor.p5;
	            }
	            var p5Sketch = function (p5) {
	                if (preload) 
	                    { p5.preload = (function () { return preload(p5); }); }
	                p5.setup = (function () {
	                    var props = this$1.props;
	                    var isGL = this$1.settings.context === 'webgl';
	                    var renderer = isGL ? p5.WEBGL : p5.P2D;
	                    p5.noLoop();
	                    p5.pixelDensity(props.pixelRatio);
	                    p5.createCanvas(props.viewportWidth, props.viewportHeight, renderer);
	                    if (isGL && this$1.settings.attributes) {
	                        p5.setAttributes(this$1.settings.attributes);
	                    }
	                    this$1.update({
	                        p5: p5,
	                        canvas: p5.canvas,
	                        context: p5._renderer.drawingContext
	                    });
	                    resolve();
	                });
	            };
	            if (typeof P5Constructor === 'function') {
	                new P5Constructor(p5Sketch);
	            } else {
	                if (typeof window.createCanvas !== 'function') {
	                    throw new Error("{ p5 } setting is passed but can't find p5.js in global (window) scope. Maybe you did not create it globally?\nnew p5(); // <-- attaches to global scope");
	                }
	                p5Sketch(window);
	            }
	        });
	    }
	    return preload.then(function () {
	        var loader = createSketch(this$1.props);
	        if (!isPromise_1(loader)) {
	            loader = Promise.resolve(loader);
	        }
	        return loader;
	    }).then(function (sketch) {
	        if (!sketch) 
	            { sketch = {}; }
	        this$1._sketch = sketch;
	        if (isBrowser()) {
	            this$1._keyboardShortcuts.attach();
	            window.addEventListener('resize', this$1._resizeHandler);
	        }
	        this$1._postRender();
	        this$1._sizeChanged();
	        return this$1;
	    }).catch(function (err) {
	        console.warn('Could not start sketch, the async loading function rejected with an error:\n    Error: ' + err.message);
	        throw err;
	    });
	};

	Object.defineProperties( SketchManager.prototype, prototypeAccessors );

	var CACHE = 'hot-id-cache';
	var runtimeCollisions = [];
	function isHotReload() {
	    var client = getClientAPI();
	    return client && client.hot;
	}

	function cacheGet(id) {
	    var client = getClientAPI();
	    if (!client) 
	        { return undefined; }
	    client[CACHE] = client[CACHE] || {};
	    return client[CACHE][id];
	}

	function cachePut(id, data) {
	    var client = getClientAPI();
	    if (!client) 
	        { return undefined; }
	    client[CACHE] = client[CACHE] || {};
	    client[CACHE][id] = data;
	}

	function getTimeProp(oldManager, newSettings) {
	    return newSettings.animate ? {
	        time: oldManager.props.time
	    } : undefined;
	}

	function canvasSketch(sketch, settings) {
	    if ( settings === void 0 ) settings = {};

	    if (settings.p5) {
	        if (settings.canvas || settings.context && typeof settings.context !== 'string') {
	            throw new Error("In { p5 } mode, you can't pass your own canvas or context, unless the context is a \"webgl\" or \"2d\" string");
	        }
	        var context = typeof settings.context === 'string' ? settings.context : false;
	        settings = Object.assign({}, settings, {
	            canvas: false,
	            context: context
	        });
	    }
	    var isHot = isHotReload();
	    var hotID;
	    if (isHot) {
	        hotID = defined(settings.id, '$__DEFAULT_CANVAS_SKETCH_ID__$');
	    }
	    var isInjecting = isHot && typeof hotID === 'string';
	    if (isInjecting && runtimeCollisions.includes(hotID)) {
	        console.warn("Warning: You have multiple calls to canvasSketch() in --hot mode. You must pass unique { id } strings in settings to enable hot reload across multiple sketches. ", hotID);
	        isInjecting = false;
	    }
	    var preload = Promise.resolve();
	    if (isInjecting) {
	        runtimeCollisions.push(hotID);
	        var previousData = cacheGet(hotID);
	        if (previousData) {
	            var next = function () {
	                var newProps = getTimeProp(previousData.manager, settings);
	                previousData.manager.destroy();
	                return newProps;
	            };
	            preload = previousData.load.then(next).catch(next);
	        }
	    }
	    return preload.then(function (newProps) {
	        var manager = new SketchManager();
	        var result;
	        if (sketch) {
	            settings = Object.assign({}, settings, newProps);
	            manager.setup(settings);
	            manager.mount();
	            result = manager.loadAndRun(sketch);
	        } else {
	            result = Promise.resolve(manager);
	        }
	        if (isInjecting) {
	            cachePut(hotID, {
	                load: result,
	                manager: manager
	            });
	        }
	        return result;
	    });
	}

	canvasSketch.canvasSketch = canvasSketch;
	canvasSketch.PaperSizes = paperSizes;

	return canvasSketch;

})));


}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],7:[function(require,module,exports){
(function (global){(function (){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],8:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  if (!fn) {
    return false
  }
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],9:[function(require,module,exports){
module.exports = isPromise;
module.exports.default = isPromise;

function isPromise(obj) {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

},{}],10:[function(require,module,exports){
var loaders = require('./loaders');
var assign = require('object-assign');
var isPromise = require('is-promise');
var noop = function () {};

module.exports = loadAsset;

module.exports.all = function all (opt, progress) {
  return loadMultiple(opt, progress, false);
};

module.exports.any = function any (opt, progress) {
  return loadMultiple(opt, progress, true);
};

function loadMultiple (opt, progress, skipMissing) {
  progress = progress || noop;
  if (typeof progress !== 'function') {
    return Promise.reject(new Error('The second argument to load.all() and load.any() must be a function, or undefined'));
  }

  var total;
  var count = 0;
  var load;
  var emitProgress = function (item, value, count, error) {
    var obj = {
      target: item,
      total: total,
      count: count,
      progress: count / total,
      value: value
    };
    if (error) obj.error = error;
    progress(obj);
  };

  if (skipMissing) {
    load = function (opt) {
      return loadAsset(opt).then(function (result) {
        return { value: result };
      }, function (error) {
        return { value: null, error: error };
      }).then(function (optional) {
        emitProgress(opt, optional.value, ++count, optional.error);
        return optional.value;
      });
    };
  } else {
    load = function (opt) {
      return loadAsset(opt).then(function (result) {
        emitProgress(opt, result, ++count);
        return result;
      });
    };
  }

  if (Array.isArray(opt)) {
    total = opt.length;
    return Promise.all(opt.map(function (item) {
      return load(item);
    }));
  } else if (opt) {
    var entries = Object.keys(opt).map(function (key) {
      return { key: key, value: opt[key] };
    });
    total = entries.length;
    return Promise.all(entries.map(function (item) {
      var key = item.key;
      return load(item.value).then(function (value) {
        return { value: value, key: key };
      });
    })).then(function (results) {
      return results.reduce(function (obj, item) {
        obj[item.key] = item.value;
        return obj;
      }, {});
    });
  } else {
    return Promise.reject(new Error('You must specify an array of assets or object group to load'));
  }
}

function loadAsset (opt) {
  if (!opt) return Promise.reject(new Error('You must specify a URL or descriptor of the asset to load'));
  if (typeof opt === 'string') {
    opt = { url: opt };
  }
  // If it's a promise, assume nested features...
  if (isPromise(opt)) return opt;
  return getLoader(opt).then(function (loader) {
    opt = assign({}, opt);
    delete opt.type;
    return loader(opt);
  });
}

function getLoader (opt) {
  var i, loader;
  var type = opt.type ? opt.type : null;
  if (type) {
    // Allow user to specify custom type function
    if (typeof type === 'function') {
      return Promise.resolve(type);
    } else {
      type = type.toLowerCase();
    }
    // User specified an explicit type, use that.
    if (!opt.url) {
      return Promise.reject(new Error('When using loadAsset(), you must specify a URL or descriptor of the asset to load'));
    }
    for (i = 0; i < loaders.length; i++) {
      loader = loaders[i];
      if (loader.key === type) return Promise.resolve(loader.load);
    }
    return Promise.reject(new Error('Could not find an asset loader by the key "' + opt.type + '"'));
  } else {
    // User didn't specify type, try to infer from file extension
    if (!opt.url) {
      return Promise.reject(new Error('When using loadAsset(), you must specify a URL or descriptor of the asset to load'));
    }
    var ext = extname(opt.url);
    if (!ext) return Promise.reject(new Error('No extension found for input URL "' + opt.url + '", try to specify a { type } such as "image" or "text"'));
    for (i = 0; i < loaders.length; i++) {
      loader = loaders[i];
      if (!loader.match) continue;
      var isMatch = typeof loader.match === 'function'
        ? loader.match(ext)
        : loader.match.test(ext);
      if (isMatch) return Promise.resolve(loader.load);
    }
    return Promise.reject(new Error('Could not infer an asset loader from the file type "' + ext + '", try specifying { type } such as "image" or "text"'));
  }
}

function extname (url) {
  if (!url) return '';
  var idx = url.lastIndexOf('/');
  if (idx !== -1) url = url.substring(idx + 1); // Keep path without its segments
  idx = url.indexOf('?');
  if (idx !== -1) url = url.substring(0, idx); // Remove query
  idx = url.indexOf('#');
  if (idx !== -1) url = url.substring(0, idx); // Remove fragment
  idx = url.lastIndexOf('.');
  return idx !== -1 ? url.substring(idx) : '';
}

},{"./loaders":13,"is-promise":9,"object-assign":15}],11:[function(require,module,exports){
var xhr = require('xhr');
var assign = require('object-assign');

module.exports = function (type) {
  return function loadFile (opt) {
    var p;
    if ('fetch' in window) {
      p = window.fetch(opt.url, opt)
        .then(function (response) {
          if (/404/.test(response.status)) {
            throw new Error('Resource not found');
          }
          if (!/^2/.test(response.status)) {
            throw new Error('Unexpected HTTP Status Code: ' + response.status);
          }
          if (!response.ok) {
            throw new Error('Response not OK');
          }
          if (type === 'json') {
            return response.json();
          } else if (type === 'binary') {
            return response.arrayBuffer();
          } else if (type === 'blob') {
            return response.blob();
          } else {
            return response.text();
          }
        });
    } else {
      p = xhrFetch(type, opt);
    }
    return p.catch(function (err) {
      throw new Error(
        err.message + ' while loading file ' + opt.url
      );
    });
  };
};

function xhrFetch (type, opt) {
  return new Promise(function (resolve, reject) {
    var responseType = 'text';
    if (type === 'json') responseType = 'text';
    else if (type === 'binary') responseType = 'arraybuffer';
    else if (type === 'blob') responseType = 'blob';
    opt = assign({}, opt, {
      json: false,
      responseType: responseType
    });
    xhr(opt, function (err, res, body) {
      if (err) return reject(err);
      if (/404/.test(res.statusCode)) {
        throw new Error('Resource not found');
      }
      if (!/^2/.test(res.statusCode)) {
        return reject(new Error('Unexpected HTTP Status Code: ' + res.statusCode));
      }
      if (type === 'json') {
        try {
          body = JSON.parse(body);
        } catch (err) {
          return reject(err);
        }
      }
      resolve(body);
    });
  });
}

},{"object-assign":15,"xhr":18}],12:[function(require,module,exports){
var mime = require('browser-media-mime-type');

function getMediaType (ext) {
  var result = mime(ext);
  if (!result) return null;
  if (result.indexOf('audio') === 0) return 'audio';
  if (result.indexOf('video') === 0) return 'video';
  return null;
}

module.exports = function createMediaLoader (type, createElement) {
  return {
    key: type,
    match: function (ext) {
      return getMediaType(ext) === type;
    },
    load: function (opt) {
      return new Promise(function (resolve, reject) {
        var finished = false;
        var media = createElement();
        var onLoaded = function onLoaded () {
          if (finished) return;
          finished = true;
          resolve(media);
        };

        var event = (opt.event || 'canplay').toLowerCase();
        if (event === 'loadedmetadata') {
          media.onloadedmetadata = onLoaded;
        } else if (event === 'canplaythrough') {
          media.oncanplaythrough = onLoaded;
        } else if (event === 'loadeddata') {
          media.onloadeddata = onLoaded;
        } else {
          media.oncanplay = onLoaded;
        }

        media.onerror = function onError (er) {
          if (finished) return;
          finished = true;
          reject(new Error('Error while loading ' + type + ' at ' + opt.url));
        };

        // pass through media properties if defined
        if (opt.crossOrigin) media.crossOrigin = opt.crossOrigin;
        if (typeof opt.volume !== 'undefined') media.volume = opt.volume;
        if (typeof opt.preload !== 'undefined') media.preload = opt.volume;
        if (typeof opt.playbackRate !== 'undefined') media.playbackRate = opt.volume;
        if (typeof opt.muted !== 'undefined') media.muted = opt.volume;
        if (typeof opt.currentTime !== 'undefined') media.currentTime = opt.volume;
        if (typeof opt.controls !== 'undefined') media.controls = opt.volume;
        if (typeof opt.autoPlay !== 'undefined') media.autoPlay = opt.volume;

        media.src = opt.url;

        if (media.readyState >= media.HAVE_ENOUGH_DATA) {
          finished = true;
          return resolve(media);
        }

        media.load();
      });
    }
  };
};

},{"browser-media-mime-type":4}],13:[function(require,module,exports){
const createMediaLoader = require('./createMediaLoader');
const createFileLoader = require('./createFileLoader');
const loadImage = require('./loadImage');

module.exports = [
  // json
  {
    key: 'json',
    match: /\.json$/i,
    load: createFileLoader('json')
  },
  // text
  {
    key: 'text',
    match: /\.txt$/i,
    load: createFileLoader('text')
  },
  // image
  {
    key: 'image',
    match: /\.(jpg|jpeg|svg|png|gif|webp|bmp|tga|tif|apng|wbpm|ico)$/i,
    load: loadImage
  },
  // audio
  createMediaLoader('audio', function () {
    return new window.Audio();
  }),
  // video
  createMediaLoader('video', function () {
    return document.createElement('video');
  }),
  // binary
  {
    key: 'binary',
    match: /\.bin$/i,
    load: createFileLoader('binary')
  },
  // blob
  {
    key: 'blob',
    load: createFileLoader('blob')
  }
];

},{"./createFileLoader":11,"./createMediaLoader":12,"./loadImage":14}],14:[function(require,module,exports){
module.exports = function (opt) {
  return new Promise(function (resolve, reject) {
    var finished = false;
    var image = new window.Image();
    image.onload = function onLoaded () {
      if (finished) return;
      finished = true;
      resolve(image);
    };
    image.onerror = function onError () {
      if (finished) return;
      finished = true;
      reject(new Error('Error while loading image at ' + opt.url));
    };
    if (opt.crossOrigin) image.crossOrigin = opt.crossOrigin;
    image.src = opt.url;
  });
};

},{}],15:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],16:[function(require,module,exports){
var trim = function(string) {
  return string.replace(/^\s+|\s+$/g, '');
}
  , isArray = function(arg) {
      return Object.prototype.toString.call(arg) === '[object Array]';
    }

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  var headersArr = trim(headers).split('\n')

  for (var i = 0; i < headersArr.length; i++) {
    var row = headersArr[i]
    var index = row.indexOf(':')
    , key = trim(row.slice(0, index)).toLowerCase()
    , value = trim(row.slice(index + 1))

    if (typeof(result[key]) === 'undefined') {
      result[key] = value
    } else if (isArray(result[key])) {
      result[key].push(value)
    } else {
      result[key] = [ result[key], value ]
    }
  }

  return result
}

},{}],17:[function(require,module,exports){
(function (global){(function (){
/*
MIT License

Copyright (c) 2012 - 2021 jonobr1 / http://jonobr1.com

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Two = factory());
}(this, (function () { 'use strict';

  /**
   * @name Two.Commands
   * @property {Object} - Map of possible path commands. Taken from the SVG specification.
   */
  var Commands = {
    move: 'M',
    line: 'L',
    curve: 'C',
    arc: 'A',
    close: 'Z'
  };

  var root;
  if (typeof window !== 'undefined') {
    root = window;
  } else if (typeof global !== 'undefined') {
    root = global;
  } else if (typeof self !== 'undefined') {
    root = self;
  }

  var root$1 = root;

  var Matrix$1;

  /**
   * @name Two.Utils.decomposeMatrix
   * @function
   * @param {Two.Matrix} matrix - The matrix to decompose.
   * @returns {Object} An object containing relevant skew values.
   * @description Decompose a 2D 3x3 Matrix to find the skew.
   */
  var decomposeMatrix = function(matrix) {

    // TODO: Include skewX, skewY
    // https://math.stackexchange.com/questions/237369/given-this-transformation-matrix-how-do-i-decompose-it-into-translation-rotati/417813
    // https://stackoverflow.com/questions/45159314/decompose-2d-transformation-matrix

    return {
        translateX: matrix.e,
        translateY: matrix.f,
        scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),
        scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),
        rotation: 180 * Math.atan2(matrix.b, matrix.a) / Math.PI
    };

  };

  var setMatrix = function(M) {
    Matrix$1 = M;
  };

  /**
   * @name Two.Utils.getComputedMatrix
   * @function
   * @param {Two.Shape} object - The Two.js object that has a matrix property to calculate from.
   * @param {Two.Matrix} [matrix] - The matrix to apply calculated transformations to if available.
   * @returns {Two.Matrix} The computed matrix of a nested object. If no `matrix` was passed in arguments then a `new Two.Matrix` is returned.
   * @description Method to get the world space transformation of a given object in a Two.js scene.
   */
  var getComputedMatrix = function(object, matrix) {

    matrix = (matrix && matrix.identity()) || new Matrix$1();
    var parent = object, matrices = [];

    while (parent && parent._matrix) {
      matrices.push(parent._matrix);
      parent = parent.parent;
    }

    matrices.reverse();

    for (var i = 0; i < matrices.length; i++) {

      var m = matrices[i];
      var e = m.elements;
      matrix.multiply(
        e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9]);

    }

    return matrix;

  };

  /**
   * @name Two.Utils.lerp
   * @function
   * @param {Number} a - Start value.
   * @param {Number} b - End value.
   * @param {Number} t - Zero-to-one value describing percentage between a and b.
   * @returns {Number}
   * @description Linear interpolation between two values `a` and `b` by an amount `t`.
   */
  var lerp = function(a, b, t) {
    return t * (b - a) + a;
  };

  /**
   * @name Two.Utils.mod
   * @function
   * @param {Number} v - The value to modulo
   * @param {Number} l - The value to modulo by
   * @returns {Number}
   * @description Modulo with added functionality to handle negative values in a positive manner.
   */
  var mod = function(v, l) {

    while (v < 0) {
      v += l;
    }

    return v % l;

  };

  var NumArray = root$1.Float32Array || Array;

  /**
  * @name Two.Utils.toFixed
  * @function
  * @param {Number} v - Any float
  * @returns {Number} That float trimmed to the third decimal place.
  * @description A pretty fast toFixed(3) alternative.
  * @see {@link http://jsperf.com/parsefloat-tofixed-vs-math-round/18}
  */
  var toFixed = function(v) {
    return Math.floor(v * 1000000) / 1000000;
  };

  var math = /*#__PURE__*/Object.freeze({
    __proto__: null,
    decomposeMatrix: decomposeMatrix,
    getComputedMatrix: getComputedMatrix,
    setMatrix: setMatrix,
    lerp: lerp,
    mod: mod,
    NumArray: NumArray,
    toFixed: toFixed
  });

  var slice = Array.prototype.slice;

  var isArrayLike = function(collection) {
    if (collection === null || collection === undefined) return false;
    var length = collection.length;
    // Arrays cannot hold more than 2^32 - 1 items
    return (typeof length == 'number' && length >= 0 && length < 4294967296);
  };

  var _ = {
    isNaN: function(obj) {
      return typeof obj === 'number' && obj !== +obj;
    },
    isElement: function(obj) {
      return !!(obj && obj.nodeType === 1);
    },
    isObject: function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    },
    extend: function(base) {
      var sources = slice.call(arguments, 1);
      for (var i = 0; i < sources.length; i++) {
        var obj = sources[i];
        for (var k in obj) {
          base[k] = obj[k];
        }
      }
      return base;
    },
    defaults: function(base) {
      var sources = slice.call(arguments, 1);
      for (var i = 0; i < sources.length; i++) {
        var obj = sources[i];
        for (var k in obj) {
          if (base[k] === void 0) {
          base[k] = obj[k];
          }
        }
      }
      return base;
    },
    each: function(obj, iteratee, context) {
      var ctx = context || this;
      var keys = !isArrayLike(obj) && Object.keys(obj);
      var length = (keys || obj).length;
      for (var i = 0; i < length; i++) {
        var k = keys ? keys[i] : i;
        iteratee.call(ctx, obj[k], k, obj);
      }
      return obj;
    },
    /**
     * @name Two.Utils.performance
     * @property {Date} - A special `Date` like object to get the current millis of the session. Used internally to calculate time between frames.
     * e.g: `Utils.performance.now() // milliseconds since epoch`
     */
    performance: ((root$1.performance && root$1.performance.now) ? root$1.performance : Date),
  };

  /**
   * @name Two.Events
   * @class
   * @description Object inherited by many Two.js objects in order to facilitate custom events.
   */
  var Events = {

    /**
     * @name Two.Events#on
     * @function
     * @param {String} [name] - The name of the event to bind a function to.
     * @param {Function} [handler] - The function to be invoked when the event is dispatched.
     * @description Call to add a listener to a specific event name.
     */
    on: addEventListener,

    /**
     * @name Two.Events#off
     * @function
     * @param {String} [name] - The name of the event intended to be removed.
     * @param {Function} [handler] - The handler intended to be reomved.
     * @description Call to remove listeners from a specific event. If only `name` is passed then all the handlers attached to that `name` will be removed. If no arguments are passed then all handlers for every event on the obejct are removed.
     */
    off: removeEventListener,

    /**
     * @name Two.Events#trigger
     * @function
     * @param {String} name - The name of the event to dispatch.
     * @param arguments - Anything can be passed after the name and those will be passed on to handlers attached to the event in the order they are passed.
     * @description Call to trigger a custom event. Any additional arguments passed after the name will be passed along to the attached handlers.
     */
    trigger: function(name) {
      var scope = this;
      if (!scope._events) return scope;
      var args = Array.prototype.slice.call(arguments, 1);
      var events = scope._events[name];
      if (events) dispatch(scope, events, args);
      return scope;
    },

    listen: function(obj, name, handler) {

      var bound = this;

      if (obj) {

        var event = function () {
          handler.apply(bound, arguments);
        };

        // Add references about the object that assigned this listener
        event.obj = obj;
        event.name = name;
        event.handler = handler;

        obj.on(name, event);

      }

      return bound;

    },

    ignore: function(obj, name, handler) {

      var scope = this;
      obj.off(name, handler);
      return scope;

    },

    /**
     * @name Two.Events.Types
     * @property {Object} - Object of different types of Two.js specific events.
     */
    Types: {
      play: 'play',
      pause: 'pause',
      update: 'update',
      render: 'render',
      resize: 'resize',
      change: 'change',
      remove: 'remove',
      insert: 'insert',
      order: 'order',
      load: 'load'
    }

  };


  /**
   * @name Two.Events.bind
   * @function
   * @description Alias for {@link Two.Events.on}.
   */
  Events.bind = addEventListener;

  /**
   * @name Two.Events.unbind
   * @function
   * @description Alias for {@link Two.Events.off}.
   */
  Events.unbind = removeEventListener;

  /**
   * @private
   * @returns {Two.Events} - Returns an instance of self for the purpose of chaining.
   */
  function addEventListener(name, handler) {

    var scope = this;

    scope._events || (scope._events = {});
    var list = scope._events[name] || (scope._events[name] = []);

    list.push(handler);

    return scope;

  }

  /**
   * @private
   * @returns {Two.Events} - Returns an instance of self for the purpose of chaining.
   */
  function removeEventListener(name, handler) {

    var scope = this;

    if (!scope._events) {
      return scope;
    }
    if (!name && !handler) {
      scope._events = {};
      return scope;
    }

    var names = name ? [name] : Object.keys(scope._events);
    for (var i = 0, l = names.length; i < l; i++) {

      name = names[i];
      var list = scope._events[name];

      if (list) {
        var events = [];
        if (handler) {
          for (var j = 0, k = list.length; j < k; j++) {
            var ev = list[j];
            ev = ev.handler ? ev.handler : ev;
            if (handler && handler !== ev) {
              events.push(ev);
            }
          }
        }
        scope._events[name] = events;
      }
    }

    return scope;
  }

  function dispatch(obj, events, args) {
    var method;
    switch (args.length) {
    case 0:
      method = function(i) {
        events[i].call(obj, args[0]);
      };
      break;
    case 1:
      method = function(i) {
        events[i].call(obj, args[0], args[1]);
      };
      break;
    case 2:
      method = function(i) {
        events[i].call(obj, args[0], args[1], args[2]);
      };
      break;
    case 3:
      method = function(i) {
        events[i].call(obj, args[0], args[1], args[2], args[3]);
      };
      break;
    default:
      method = function(i) {
        events[i].apply(obj, args);
      };
    }
    for (var i = 0; i < events.length; i++) {
      method(i);
    }
  }

  /**
   * @name Two.Vector
   * @class
   * @param {Number} [x=0] - Any number to represent the horizontal x-component of the vector.
   * @param {Number} [y=0] - Any number to represent the vertical y-component of the vector.
   * @description A class to store x / y component vector data. In addition to storing data `Two.Vector` has suped up methods for commonplace mathematical operations.
   */
  function Vector(x, y) {

    /**
     * @name Two.Vector#x
     * @property {Number} - The horizontal x-component of the vector.
     */
    this.x = x || 0;

    /**
     * @name Two.Vector#y
     * @property {Number} - The vertical y-component of the vector.
     */
    this.y = y || 0;

  }

  _.extend(Vector, {

    /**
     * @name Two.Vector.zero
     * @readonly
     * @property {Two.Vector} - Handy reference to a vector with component values 0, 0 at all times.
     */
    zero: new Vector(),

    /**
     * @name Two.Vector.add
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Two.Vector}
     * @description Add two vectors together.
     */
    add: function(v1, v2) {
      return new Vector(v1.x + v2.x, v1.y + v2.y);
    },

    /**
     * @name Two.Vector.sub
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Two.Vector}
     * @description Subtract two vectors: `v2` from `v1`.
     */
    sub: function(v1, v2) {
      return new Vector(v1.x - v2.x, v1.y - v2.y);
    },

    /**
     * @name Two.Vector.subtract
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subtract: function(v1, v2) {
      return Vector.sub(v1, v2);
    },

    /**
     * @name Two.Vector.ratioBetween
     * @function
     * @param {Two.Vector} A
     * @param {Two.Vector} B
     * @returns {Number} The ratio betwen two points `v1` and `v2`.
     */
    ratioBetween: function(v1, v2) {

      return (v1.x * v2.x + v1.y * v2.y) / (v1.length() * v2.length());

    },

    /**
     * @name Two.Vector.angleBetween
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The angle between points `v1` and `v2`.
     */
    angleBetween: function(v1, v2) {

      var dx, dy;

      if (arguments.length >= 4) {

        dx = arguments[0] - arguments[2];
        dy = arguments[1] - arguments[3];

        return Math.atan2(dy, dx);

      }

      dx = v1.x - v2.x;
      dy = v1.y - v2.y;

      return Math.atan2(dy, dx);

    },

    /**
     * @name Two.Vector.distanceBetween
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The distance between points `v1` and `v2`. Distance is always positive.
     */
    distanceBetween: function(v1, v2) {

      return Math.sqrt(Vector.distanceBetweenSquared(v1, v2));

    },

    /**
     * @name Two.Vector.distanceBetweenSquared
     * @function
     * @param {Two.Vector} v1
     * @param {Two.Vector} v2
     * @returns {Number} The squared distance between points `v1` and `v2`.
     */
    distanceBetweenSquared: function(v1, v2) {

      var dx = v1.x - v2.x;
      var dy = v1.y - v2.y;

      return dx * dx + dy * dy;

    },

    /**
     * @name Two.Vector.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Vector} to any object. Handy if you'd like to extend the {@link Two.Vector} class on a custom class.
     */
    MakeObservable: function(object) {

      // /**
      //  * Override Backbone bind / on in order to add properly broadcasting.
      //  * This allows Two.Vector to not broadcast events unless event listeners
      //  * are explicity bound to it.
      //  */

      object.bind = object.on = function() {

        if (!this._bound) {
          this._x = this.x;
          this._y = this.y;
          Object.defineProperty(this, 'x', xgs);
          Object.defineProperty(this, 'y', ygs);
          _.extend(this, BoundProto);
          this._bound = true; // Reserved for event initialization check
        }

        Events.bind.apply(this, arguments);

        return this;

      };

    }

  });

  _.extend(Vector.prototype, Events, {

    constructor: Vector,

    /**
     * @name Two.Vector#set
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Set the x / y components of a vector to specific number values.
     */
    set: function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * @name Two.Vector#copy
     * @function
     * @param {Two.Vector} v
     * @description Copy the x / y components of another object `v`.
     */
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    },

    /**
     * @name Two.Vector#clear
     * @function
     * @description Set the x / y component values of the vector to zero.
     */
    clear: function() {
      this.x = 0;
      this.y = 0;
      return this;
    },

    /**
     * @name Two.Vector#clone
     * @function
     * @description Create a new vector and copy the existing values onto the newly created instance.
     */
    clone: function() {
      return new Vector(this.x, this.y);
    },

    /**
     * @name Two.Vector#add
     * @function
     * @param {Two.Vector} v
     * @description Add an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#add
     * @function
     * @param {Number} v
     * @description Add the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#add
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Add `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    add: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x += x;
          this.y += x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x += x.x;
          this.y += x.y;
        }
      } else {
        this.x += x;
        this.y += y;
      }
      return this;
    },

    /**
     * @name Two.Vector#addSelf
     * @function
     * @description Alias for {@link Two.Vector.add}.
     */
    addSelf: function(v) {
      return this.add.apply(this, arguments);
    },

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Two.Vector} v
     * @description Subtract an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Number} v
     * @description Subtract the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#sub
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Subtract `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    sub: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x -= x;
          this.y -= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x -= x.x;
          this.y -= x.y;
        }
      } else {
        this.x -= x;
        this.y -= y;
      }
      return this;
    },

    /**
     * @name Two.Vector#subtract
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subtract: function() {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#subSelf
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subSelf: function(v) {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#subtractSelf
     * @function
     * @description Alias for {@link Two.Vector.sub}.
     */
    subtractSelf: function(v) {
      return this.sub.apply(this, arguments);
    },

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Two.Vector} v
     * @description Multiply an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Number} v
     * @description Multiply the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#multiply
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Multiply `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    multiply: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x *= x;
          this.y *= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x *= x.x;
          this.y *= x.y;
        }
      } else {
        this.x *= x;
        this.y *= y;
      }
      return this;
    },

    /**
     * @name Two.Vector#multiplySelf
     * @function
     * @description Alias for {@link Two.Vector.multiply}.
     */
    multiplySelf: function(v) {
      return this.multiply.apply(this, arguments);
    },

    /**
     * @name Two.Vector#multiplyScalar
     * @function
     * @param {Number} s - The scalar to multiply by.
     * @description Mulitiply the vector by a single number. Shorthand to call {@link Two.Vector#multiply} directly.
     */
    multiplyScalar: function(s) {
      return this.multiply(s);
    },

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Two.Vector} v
     * @description Divide an object with x / y component values to the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Number} v
     * @description Divide the **same** number to both x / y component values of the instance.
     * @overloaded
     */

    /**
     * @name Two.Vector#divide
     * @function
     * @param {Number} x
     * @param {Number} y
     * @description Divide `x` / `y` values to their respective component value on the instance.
     * @overloaded
     */
    divide: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this.x /= x;
          this.y /= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this.x /= x.x;
          this.y /= x.y;
        }
      } else {
        this.x /= x;
        this.y /= y;
      }
      if (_.isNaN(this.x)) {
        this.x = 0;
      }
      if (_.isNaN(this.y)) {
        this.y = 0;
      }
      return this;
    },

    /**
     * @name Two.Vector#divideSelf
     * @function
     * @description Alias for {@link Two.Vector.divide}.
     */
    divideSelf: function(v) {
      return this.divide.apply(this, arguments);
    },

    /**
     * @name Two.Vector#divideScalar
     * @function
     * @param {Number} s - The scalar to divide by.
     * @description Divide the vector by a single number. Shorthand to call {@link Two.Vector#divide} directly.
     */
    divideScalar: function(s) {
      return this.divide(s);
    },

    /**
     * @name Two.Vector#negate
     * @function
     * @description Invert each component's sign value.
     */
    negate: function() {
      return this.multiply(-1);
    },

    /**
     * @name Two.Vector#negate
     * @function
     * @returns {Number}
     * @description Get the [dot product](https://en.wikipedia.org/wiki/Dot_product) of the vector.
     */
    dot: function(v) {
      return this.x * v.x + this.y * v.y;
    },

    /**
     * @name Two.Vector#length
     * @function
     * @returns {Number}
     * @description Get the length of a vector.
     */
    length: function() {
      return Math.sqrt(this.lengthSquared());
    },

    /**
     * @name Two.Vector#lengthSquared
     * @function
     * @returns {Number}
     * @description Get the length of the vector to the power of two. Widely used as less expensive than {@link Two.Vector#length}, because it isn't square-rooting any numbers.
     */
    lengthSquared: function() {
      return this.x * this.x + this.y * this.y;
    },

    /**
     * @name Two.Vector#normalize
     * @function
     * @description Normalize the vector from negative one to one.
     */
    normalize: function() {
      return this.divideScalar(this.length());
    },

    /**
     * @name Two.Vector#distanceTo
     * @function
     * @returns {Number}
     * @description Get the distance between two vectors.
     */
    distanceTo: function(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },

    /**
     * @name Two.Vector#distanceToSquared
     * @function
     * @returns {Number}
     * @description Get the distance between two vectors to the power of two. Widely used as less expensive than {@link Two.Vector#distanceTo}, because it isn't square-rooting any numbers.
     */
    distanceToSquared: function(v) {
      var dx = this.x - v.x,
          dy = this.y - v.y;
      return dx * dx + dy * dy;
    },

    /**
     * @name Two.Vector#setLength
     * @function
     * @param {Number} l - length to set vector to.
     * @description Set the length of a vector.
     */
    setLength: function(l) {
      return this.normalize().multiplyScalar(l);
    },

    /**
     * @name Two.Vector#equals
     * @function
     * @param {Two.Vector} v - The vector to compare against.
     * @param {Number} [eps=0.0001] - An options epsilon for precision.
     * @returns {Boolean}
     * @description Qualify if one vector roughly equal another. With a margin of error defined by epsilon.
     */
    equals: function(v, eps) {
      eps = (typeof eps === 'undefined') ?  0.0001 : eps;
      return (this.distanceTo(v) < eps);
    },

    /**
     * @name Two.Vector#lerp
     * @function
     * @param {Two.Vector} v - The destination vector to step towards.
     * @param {Number} t - The zero to one value of how close the current vector gets to the destination vector.
     * @description Linear interpolate one vector to another by an amount `t` defined as a zero to one number.
     * @see [Matt DesLauriers](https://twitter.com/mattdesl/status/1031305279227478016) has a good thread about this.
     */
    lerp: function(v, t) {
      var x = (v.x - this.x) * t + this.x;
      var y = (v.y - this.y) * t + this.y;
      return this.set(x, y);
    },

    /**
     * @name Two.Vector#isZero
     * @function
     * @param {Number} [eps=0.0001] - Optional precision amount to check against.
     * @returns {Boolean}
     * @description Check to see if vector is roughly zero, based on the `epsilon` precision value.
     */
    isZero: function(eps) {
      eps = (typeof eps === 'undefined') ?  0.0001 : eps;
      return (this.length() < eps);
    },

    /**
     * @name Two.Vector#toString
     * @function
     * @returns {String}
     * @description Return a comma-separated string of x, y value. Great for storing in a database.
     */
    toString: function() {
      return this.x + ', ' + this.y;
    },

    /**
     * @name Two.Vector#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the vector.
     */
    toObject: function() {
      return { x: this.x, y: this.y };
    },

    /**
     * @name Two.Vector#rotate
     * @function
     * @param {Number} Number - The amoun to rotate the vector by.
     * @description Rotate a vector.
     */
    rotate: function(Number) {
      var cos = Math.cos(Number);
      var sin = Math.sin(Number);
      this.x = this.x * cos - this.y * sin;
      this.y = this.x * sin + this.y * cos;
      return this;
    }

  });

  // The same set of prototypical functions, but using the underlying
  // getter or setter for `x` and `y` values. This set of functions
  // is used instead of the previously documented ones above when
  // Two.Vector#bind is invoked and there is event dispatching processed
  // on x / y property changes.
  var BoundProto = {

    constructor: Vector,

    set: function(x, y) {
      this._x = x;
      this._y = y;
      return this.trigger(Events.Types.change);
    },

    copy: function(v) {
      this._x = v.x;
      this._y = v.y;
      return this.trigger(Events.Types.change);
    },

    clear: function() {
      this._x = 0;
      this._y = 0;
      return this.trigger(Events.Types.change);
    },

    clone: function() {
      return new Vector(this._x, this._y);
    },

    add: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x += x;
          this._y += x;
        }  else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x += x.x;
          this._y += x.y;
        }
      } else {
        this._x += x;
        this._y += y;
      }
      return this.trigger(Events.Types.change);
    },

    sub: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x -= x;
          this._y -= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x -= x.x;
          this._y -= x.y;
        }
      } else {
        this._x -= x;
        this._y -= y;
      }
      return this.trigger(Events.Types.change);
    },

    multiply: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x *= x;
          this._y *= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x *= x.x;
          this._y *= x.y;
        }
      } else {
        this._x *= x;
        this._y *= y;
      }
      return this.trigger(Events.Types.change);
    },

    divide: function(x, y) {
      if (arguments.length <= 0) {
        return this;
      } else if (arguments.length <= 1) {
        if (typeof x === 'number') {
          this._x /= x;
          this._y /= x;
        } else if (x && typeof x.x === 'number' && typeof x.y === 'number') {
          this._x /= x.x;
          this._y /= x.y;
        }
      } else {
        this._x /= x;
        this._y /= y;
      }
      if (_.isNaN(this._x)) {
        this._x = 0;
      }
      if (_.isNaN(this._y)) {
        this._y = 0;
      }
      return this.trigger(Events.Types.change);
    },

    dot: function(v) {
      return this._x * v.x + this._y * v.y;
    },

    lengthSquared: function() {
      return this._x * this._x + this._y * this._y;
    },

    distanceToSquared: function(v) {
      var dx = this._x - v.x,
          dy = this._y - v.y;
      return dx * dx + dy * dy;
    },

    lerp: function(v, t) {
      var x = (v.x - this._x) * t + this._x;
      var y = (v.y - this._y) * t + this._y;
      return this.set(x, y);
    },

    toString: function() {
      return this._x + ', ' + this._y;
    },

    toObject: function() {
      return { x: this._x, y: this._y };
    },

    rotate: function (Number) {
      var cos = Math.cos(Number);
      var sin = Math.sin(Number);
      this._x = this._x * cos - this._y * sin;
      this._y = this._x * sin + this._y * cos;
      return this;
    }

  };

  var xgs = {
    enumerable: true,
    get: function() {
      return this._x;
    },
    set: function(v) {
      this._x = v;
      this.trigger(Events.Types.change, 'x');
    }
  };

  var ygs = {
    enumerable: true,
    get: function() {
      return this._y;
    },
    set: function(v) {
      this._y = v;
      this.trigger(Events.Types.change, 'y');
    }
  };

  Vector.MakeObservable(Vector.prototype);

  /**
   * @class
   * @name Two.Anchor
   * @param {Number} [x=0] - The x position of the root anchor point.
   * @param {Number} [y=0] - The y position of the root anchor point.
   * @param {Number} [lx=0] - The x position of the left handle point.
   * @param {Number} [ly=0] - The y position of the left handle point.
   * @param {Number} [rx=0] - The x position of the right handle point.
   * @param {Number} [ry=0] - The y position of the right handle point.
   * @param {String} [command=Two.Commands.move] - The command to describe how to render. Applicable commands are {@link Two.Commands}
   * @extends Two.Vector
   * @description An object that holds 3 {@link Two.Vector}s, the anchor point and its corresponding handles: `left` and `right`. In order to properly describe the bezier curve about the point there is also a command property to describe what type of drawing should occur when Two.js renders the anchors.
   */
  function Anchor(x, y, lx, ly, rx, ry, command) {

    Vector.call(this, x, y);

    this._broadcast = (function() {
      this.trigger(Events.Types.change);
    }).bind(this);

    this._command = command || Commands.move;
    this._relative = true;

    var ilx = typeof lx === 'number';
    var ily = typeof ly === 'number';
    var irx = typeof rx === 'number';
    var iry = typeof ry === 'number';

    // Append the `controls` object only if control points are specified,
    // keeping the Two.Anchor inline with a Two.Vector until it needs to
    // evolve beyond those functions - e.g: a simple 2 component vector.
    if (ilx || ily || irx || iry) {
      Anchor.AppendCurveProperties(this);
    }

    if (ilx) {
      this.controls.left.x = lx;
    }
    if (ily) {
      this.controls.left.y = ly;
    }
    if (irx) {
      this.controls.right.x = rx;
    }
    if (iry) {
      this.controls.right.y = ry;
    }

  }

  _.extend(Anchor, {

    /**
     * @name Two.Anchor.AppendCurveProperties
     * @function
     * @param {Two.Anchor} anchor - The instance to append the `control`object to.
     * @description Adds the `controls` property as an object with `left` and `right` properties to access the bezier control handles that define how the curve is drawn. It also sets the `relative` property to `true` making vectors in the `controls` object relative to their corresponding root anchor point.
     */
    AppendCurveProperties: function(anchor) {

      anchor.relative = true;

      /**
       * @name Two.Anchor#controls
       * @property {Object} controls
       * @description An plain object that holds the controls handles for a {@link Two.Anchor}.
       */
      anchor.controls = {};

      /**
       * @name Two.Anchor#controls#left
       * @property {Two.Vector} left
       * @description The "left" control point to define handles on a bezier curve.
       */
      anchor.controls.left = new Vector(0, 0);

      /**
       * @name Two.Anchor#controls#right
       * @property {Two.Vector} right
       * @description The "left" control point to define handles on a bezier curve.
       */
      anchor.controls.right = new Vector(0, 0);

    },

    /**
     * @name Two.Anchor.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Anchor} to any object. Handy if you'd like to extend the {@link Two.Anchor} class on a custom class.
     */
    MakeObservable: function(object) {

      /**
       * @name Two.Anchor#command
       * @property {Two.Commands}
       * @description A draw command associated with the anchor point.
       */
      Object.defineProperty(object, 'command', {

        enumerable: true,

        get: function() {
          return this._command;
        },

        set: function(c) {
          this._command = c;
          if (this._command === Commands.curve && !_.isObject(this.controls)) {
            Anchor.AppendCurveProperties(this);
          }
          this.trigger(Events.Types.change);
        }

      });

      /**
       * @name Two.Anchor#relative
       * @property {Boolean}
       * @description A boolean to render control points relative to the root anchor point or in global coordinate-space to the rest of the scene.
       */
      Object.defineProperty(object, 'relative', {

        enumerable: true,

        get: function() {
          return this._relative;
        },

        set: function(b) {
          if (this._relative != b) {
            this._relative = !!b;
            this.trigger(Events.Types.change);
          }
        }

      });

      _.extend(object, Vector.prototype, AnchorProto);

      // Make it possible to bind and still have the Anchor specific
      // inheritance from Two.Vector. In this case relying on `Two.Vector`
      // to do much of the heavy event-listener binding / unbinding.
      object.bind = object.on = function() {
        var bound = this._bound;
        Vector.prototype.bind.apply(this, arguments);
        if (!bound) {
          _.extend(this, AnchorProto);
        }
      };

    }

  });

  var AnchorProto = {

    constructor: Anchor,

    /**
     * @name Two.Anchor#listen
     * @function
     * @description Convenience method used mainly by {@link Two.Path#vertices} to listen and propagate changes from control points up to their respective anchors and further if necessary.
     */
    listen: function() {

      if (!_.isObject(this.controls)) {
        Anchor.AppendCurveProperties(this);
      }

      this.controls.left.bind(Events.Types.change, this._broadcast);
      this.controls.right.bind(Events.Types.change, this._broadcast);

      return this;

    },

    /**
     * @name Two.Anchor#ignore
     * @function
     * @description Convenience method used mainly by {@link Two.Path#vertices} to ignore changes from a specific anchor's control points.
     */
    ignore: function() {

      this.controls.left.unbind(Events.Types.change, this._broadcast);
      this.controls.right.unbind(Events.Types.change, this._broadcast);

      return this;

    },

    /**
     * @name Two.Anchor#copy
     * @function
     * @param {Two.Anchor} v - The anchor to apply values to.
     * @description Copy the properties of one {@link Two.Anchor} onto another.
     */
    copy: function(v) {

      this.x = v.x;
      this.y = v.y;

      if (typeof v.command === 'string') {
        this.command = v.command;
      }
      if (_.isObject(v.controls)) {
        if (!_.isObject(this.controls)) {
          Anchor.AppendCurveProperties(this);
        }
        // TODO: Do we need to listen here?
        this.controls.left.copy(v.controls.left);
        this.controls.right.copy(v.controls.right);
      }
      if (typeof v.relative === 'boolean') {
        this.relative = v.relative;
      }

      // TODO: Hack for `Two.Commands.arc`
      if (this.command === Commands.arc) {
        this.rx = v.rx;
        this.ry = v.ry;
        this.xAxisRotation = v.xAxisRotation;
        this.largeArcFlag = v.largeArcFlag;
        this.sweepFlag = v.sweepFlag;
      }

      return this;

    },

    /**
     * @name Two.Anchor#clone
     * @function
     * @returns {Two.Anchor}
     * @description Create a new {@link Two.Anchor}, set all its values to the current instance and return it for use.
     */
    clone: function() {

      var controls = this.controls;

      var clone = new Anchor(
        this.x,
        this.y,
        controls && controls.left.x,
        controls && controls.left.y,
        controls && controls.right.x,
        controls && controls.right.y,
        this.command
      );
      clone.relative = this._relative;
      return clone;

    },

    /**
     * @name Two.Anchor#toObject
     * @function
     * @returns {Object} - An object with properties filled out to mirror {@link Two.Anchor}.
     * @description Create a JSON compatible plain object of the current instance. Intended for use with storing values in a database.
     */
    toObject: function() {
      var o = {
        x: this.x,
        y: this.y
      };
      if (this._command) {
        o.command = this._command;
      }
      if (this._relative) {
        o.relative = this._relative;
      }
      if (this.controls) {
        o.controls = {
          left: this.controls.left.toObject(),
          right: this.controls.right.toObject()
        };
      }
      return o;
    },

    /**
     * @name Two.Anchor#toString
     * @function
     * @returns {String} - A String with comma-separated values reflecting the various values on the current instance.
     * @description Create a string form of the current instance. Intended for use with storing values in a database. This is lighter to store than the JSON compatible {@link Two.Anchor#toObject}.
     */
    toString: function() {
      if (!this.controls) {
        return [this._x, this._y].join(', ');
      }
      return [this._x, this._y, this.controls.left.x, this.controls.left.y,
        this.controls.right.x, this.controls.right.y, this._command,
        this._relative ? 1 : 0].join(', ');
    }

  };

  Anchor.MakeObservable(Anchor.prototype);

  var count = 0;

  var Constants = {

    /**
     * @name Two.nextFrameID
     * @property {Number}
     * @description The id of the next requestAnimationFrame function.
     */
    nextFrameID: null,

    // Primitive

    /**
     * @name Two.Types
     * @property {Object} - The different rendering types available in the library.
     */
    Types: {
      webgl: 'WebGLRenderer',
      svg: 'SVGRenderer',
      canvas: 'CanvasRenderer'
    },

    /**
     * @name Two.Version
     * @property {String} - The current working version of the library.
     */
    Version: 'v0.7.8',

    /**
     * @name Two.PublishDate
     * @property {String} - The automatically generated publish date in the build process to verify version release candidates.
     */
    PublishDate: '2021-07-14T02:15:23.697Z',

    /**
     * @name Two.Identifier
     * @property {String} - String prefix for all Two.js object's ids. This trickles down to SVG ids.
     */
    Identifier: 'two-',

    /**
     * @name Two.Resolution
     * @property {Number} - Default amount of vertices to be used for interpreting Arcs and ArcSegments.
     */
    Resolution: 12,

    /**
     * @name Two.AutoCalculateImportedMatrices
     * @property {Boolean} - When importing SVGs through the {@link two#interpret} and {@link two#load}, this boolean determines whether Two.js infers and then overrides the exact transformation matrix of the reference SVG.
     * @nota-bene `false` copies the exact transformation matrix values, but also sets the path's `matrix.manual = true`.
     */
    AutoCalculateImportedMatrices: true,

    /**
     * @name Two.Instances
     * @property {Two[]} - Registered list of all Two.js instances in the current session.
     */
    Instances: [],

    /**
     * @function Two.uniqueId
     * @description Simple method to access an incrementing value. Used for `id` allocation on all Two.js objects.
     * @returns {Number} Ever increasing Number.
     */
    uniqueId: function() {
      return count++;
    }

  };

  var HALF_PI$3 = Math.PI / 2;

  /**
   * @name Two.Utils.Curve
   * @property {Object} - Additional utility constant variables related to curve math and calculations.
   */
  var Curve = {

    CollinearityEpsilon: Math.pow(10, -30),

    RecursionLimit: 16,

    CuspLimit: 0,

    Tolerance: {
      distance: 0.25,
      angle: 0,
      epsilon: Number.EPSILON
    },

    // Lookup tables for abscissas and weights with values for n = 2 .. 16.
    // As values are symmetric, only store half of them and adapt algorithm
    // to factor in symmetry.
    abscissas: [
      [  0.5773502691896257645091488],
      [0,0.7745966692414833770358531],
      [  0.3399810435848562648026658,0.8611363115940525752239465],
      [0,0.5384693101056830910363144,0.9061798459386639927976269],
      [  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
      [0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
      [  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
      [0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
      [  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
      [0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
      [  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
      [0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
      [  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
      [0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
      [  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
    ],

    weights: [
      [1],
      [0.8888888888888888888888889,0.5555555555555555555555556],
      [0.6521451548625461426269361,0.3478548451374538573730639],
      [0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
      [0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
      [0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
      [0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
      [0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
      [0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
      [0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
      [0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
      [0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
      [0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
      [0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
      [0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
    ]

  };

  /**
   * @name Two.Utils.getComponentOnCubicBezier
   * @function
   * @param {Number} t - Zero-to-one value describing what percentage to calculate.
   * @param {Number} a - The firt point's component value.
   * @param {Number} b - The first point's bezier component value.
   * @param {Number} c - The second point's bezier component value.
   * @param {Number} d - The second point's component value.
   * @returns {Number} The coordinate value for a specific component along a cubic bezier curve by `t`.
   */
  var getComponentOnCubicBezier = function(t, a, b, c, d) {
    var k = 1 - t;
    return (k * k * k * a) + (3 * k * k * t * b) + (3 * k * t * t * c) +
        (t * t * t * d);
  };

  /**
   * @name Two.Utils.subdivide
   * @function
   * @param {Number} x1 - x position of first anchor point.
   * @param {Number} y1 - y position of first anchor point.
   * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
   * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
   * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
   * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
   * @param {Number} x4 - x position of second anchor point.
   * @param {Number} y4 - y position of second anchor point.
   * @param {Number} [limit=Two.Utils.Curve.RecursionLimit] - The amount of vertices to create by subdividing.
   * @returns {Anchor[]} A list of anchor points ordered in between `x1`, `y1` and `x4`, `y4`
   * @description Given 2 points (a, b) and corresponding control point for each return an array of points that represent points plotted along the curve. The number of returned points is determined by `limit`.
   */
  var subdivide = function(x1, y1, x2, y2, x3, y3, x4, y4, limit) {

    limit = limit || Curve.RecursionLimit;
    var amount = limit + 1;

    // TODO: Abstract 0.001 to a limiting variable
    // Don't recurse if the end points are identical
    if (Math.abs(x1 - x4) < 0.001 && Math.abs(y1 - y4) < 0.001) {
      return [new Anchor(x4, y4)];
    }

    var result = [];

    for (var i = 0; i < amount; i++) {
      var t = i / amount;
      var x = getComponentOnCubicBezier(t, x1, x2, x3, x4);
      var y = getComponentOnCubicBezier(t, y1, y2, y3, y4);
      result.push(new Anchor(x, y));
    }

    return result;

  };

  /**
   * @name Two.Utils.getCurveLength
   * @function
   * @param {Number} x1 - x position of first anchor point.
   * @param {Number} y1 - y position of first anchor point.
   * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
   * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
   * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
   * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
   * @param {Number} x4 - x position of second anchor point.
   * @param {Number} y4 - y position of second anchor point.
   * @param {Number} [limit=Two.Utils.Curve.RecursionLimit] - The amount of vertices to create by subdividing.
   * @returns {Number} The length of a curve.
   * @description Given 2 points (a, b) and corresponding control point for each, return a float that represents the length of the curve using Gauss-Legendre algorithm. Limit iterations of calculation by `limit`.
   */
  var getCurveLength$1 = function(x1, y1, x2, y2, x3, y3, x4, y4, limit) {

    // TODO: Better / fuzzier equality check
    // Linear calculation
    if (x1 === x2 && y1 === y2 && x3 === x4 && y3 === y4) {
      var dx = x4 - x1;
      var dy = y4 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }

    // Calculate the coefficients of a Bezier derivative.
    var ax = 9 * (x2 - x3) + 3 * (x4 - x1),
      bx = 6 * (x1 + x3) - 12 * x2,
      cx = 3 * (x2 - x1),

      ay = 9 * (y2 - y3) + 3 * (y4 - y1),
      by = 6 * (y1 + y3) - 12 * y2,
      cy = 3 * (y2 - y1);

    var integrand = function(t) {
      // Calculate quadratic equations of derivatives for x and y
      var dx = (ax * t + bx) * t + cx,
        dy = (ay * t + by) * t + cy;
      return Math.sqrt(dx * dx + dy * dy);
    };

    return integrate(
      integrand, 0, 1, limit || Curve.RecursionLimit
    );

  };

  /**
   * @name Two.Utils.getCurveBoundingBox
   * @function
   * @param {Number} x1 - x position of first anchor point.
   * @param {Number} y1 - y position of first anchor point.
   * @param {Number} x2 - x position of first anchor point's "right" bezier handle.
   * @param {Number} y2 - y position of first anchor point's "right" bezier handle.
   * @param {Number} x3 - x position of second anchor point's "left" bezier handle.
   * @param {Number} y3 - y position of second anchor point's "left" bezier handle.
   * @param {Number} x4 - x position of second anchor point.
   * @param {Number} y4 - y position of second anchor point.
   * @returns {Object} Object contains min and max `x` / `y` bounds.
   * @see {@link https://github.com/adobe-webplatform/Snap.svg/blob/master/src/path.js#L856}
   */
  var getCurveBoundingBox = function(x1, y1, x2, y2, x3, y3, x4, y4) {

    var tvalues = [];
    var bounds = [[], []];
    var a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    for (var i = 0; i < 2; ++i) {
        if (i == 0) {
          b = 6 * x1 - 12 * x2 + 6 * x3;
          a = -3 * x1 + 9 * x2 - 9 * x3 + 3 * x4;
          c = 3 * x2 - 3 * x1;
        } else {
          b = 6 * y1 - 12 * y2 + 6 * y3;
          a = -3 * y1 + 9 * y2 - 9 * y3 + 3 * y4;
          c = 3 * y2 - 3 * y1;
        }
        if (Math.abs(a) < 1e-12) {
          if (Math.abs(b) < 1e-12) {
            continue;
          }
          t = -c / b;
          if (0 < t && t < 1) {
            tvalues.push(t);
          }
          continue;
        }
        b2ac = b * b - 4 * c * a;
        sqrtb2ac = Math.sqrt(b2ac);
        if (b2ac < 0) {
          continue;
        }
        t1 = (-b + sqrtb2ac) / (2 * a);
        if (0 < t1 && t1 < 1) {
          tvalues.push(t1);
        }
        t2 = (-b - sqrtb2ac) / (2 * a);
        if (0 < t2 && t2 < 1) {
          tvalues.push(t2);
        }
    }

    var j = tvalues.length;
    var jlen = j;
    var mt;

    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x1 + 3 * mt * mt * t * x2 + 3 * mt * t * t * x3 + t * t * t * x4;
      bounds[1][j] = mt * mt * mt * y1 + 3 * mt * mt * t * y2 + 3 * mt * t * t * y3 + t * t * t * y4;
    }

    bounds[0][jlen] = x1;
    bounds[1][jlen] = y1;
    bounds[0][jlen + 1] = x4;
    bounds[1][jlen + 1] = y4;
    bounds[0].length = bounds[1].length = jlen + 2;

    return {
      min: { x: Math.min.apply(0, bounds[0]), y: Math.min.apply(0, bounds[1]) },
      max: { x: Math.max.apply(0, bounds[0]), y: Math.max.apply(0, bounds[1]) }
    };

  };

  /**
   * @name Two.Utils.integrate
   * @function
   * @param {Function} f
   * @param {Number} a
   * @param {Number} b
   * @param {Number} n
   * @description Integration for `getCurveLength` calculations.
   * @see [Paper.js](@link https://github.com/paperjs/paper.js/blob/master/src/util/Numerical.js#L101)
   */
  var integrate = function(f, a, b, n) {
    var x = Curve.abscissas[n - 2],
      w = Curve.weights[n - 2],
      A = 0.5 * (b - a),
      B = A + a,
      i = 0,
      m = (n + 1) >> 1,
      sum = n & 1 ? w[i++] * f(B) : 0; // Handle odd n
    while (i < m) {
      var Ax = A * x[i];
      sum += w[i++] * (f(B + Ax) + f(B - Ax));
    }
    return A * sum;
  };

  /**
   * @name Two.Utils.getCurveFromPoints
   * @function
   * @param {Anchor[]} points
   * @param {Boolean} closed
   * @description Sets the bezier handles on {@link Anchor}s in the `points` list with estimated values to create a catmull-rom like curve. Used by {@link Two.Path#plot}.
   */
  var getCurveFromPoints = function(points, closed) {

    var l = points.length, last = l - 1;

    for (var i = 0; i < l; i++) {

      var point = points[i];

      if (!_.isObject(point.controls)) {
        Anchor.AppendCurveProperties(point);
      }

      var prev = closed ? mod(i - 1, l) : Math.max(i - 1, 0);
      var next = closed ? mod(i + 1, l) : Math.min(i + 1, last);

      var a = points[prev];
      var b = point;
      var c = points[next];
      getControlPoints(a, b, c);

      b.command = i === 0 ? Commands.move : Commands.curve;

    }

  };

  /**
   * @name Two.Utils.getControlPoints
   * @function
   * @param {Anchor} a
   * @param {Anchor} b
   * @param {Anchor} c
   * @returns {Anchor} Returns the passed middle point `b`.
   * @description Given three coordinates set the control points for the middle, b, vertex based on its position with the adjacent points.
   */
  var getControlPoints = function(a, b, c) {

    var a1 = Vector.angleBetween(a, b);
    var a2 = Vector.angleBetween(c, b);

    var d1 = Vector.distanceBetween(a, b);
    var d2 = Vector.distanceBetween(c, b);

    var mid = (a1 + a2) / 2;

    // TODO: Issue 73
    if (d1 < 0.0001 || d2 < 0.0001) {
      if (typeof b.relative === 'boolean' && !b.relative) {
        b.controls.left.copy(b);
        b.controls.right.copy(b);
      }
      return b;
    }

    d1 *= 0.33; // Why 0.33?
    d2 *= 0.33;

    if (a2 < a1) {
      mid += HALF_PI$3;
    } else {
      mid -= HALF_PI$3;
    }

    b.controls.left.x = Math.cos(mid) * d1;
    b.controls.left.y = Math.sin(mid) * d1;

    mid -= Math.PI;

    b.controls.right.x = Math.cos(mid) * d2;
    b.controls.right.y = Math.sin(mid) * d2;

    if (typeof b.relative === 'boolean' && !b.relative) {
      b.controls.left.x += b.x;
      b.controls.left.y += b.y;
      b.controls.right.x += b.x;
      b.controls.right.y += b.y;
    }

    return b;

  };

  /**
   * @name Two.Utils.getReflection
   * @function
   * @param {Vector} a
   * @param {Vector} b
   * @param {Boolean} [relative=false]
   * @returns {Vector} New {@link Vector} that represents the reflection point.
   * @description Get the reflection of a point `b` about point `a`. Where `a` is in absolute space and `b` is relative to `a`.
   * @see {@link http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes}
   */
  var getReflection = function(a, b, relative) {

    return new Vector(
      2 * a.x - (b.x + a.x) - (relative ? a.x : 0),
      2 * a.y - (b.y + a.y) - (relative ? a.y : 0)
    );

  };

  /**
   * @name Two.Utils.getAnchorsFromArcData
   * @function
   * @param {Vector} center
   * @param {Number} xAxisRotation
   * @param {Number} rx - x radius
   * @param {Number} ry - y radius
   * @param {Number} ts
   * @param {Number} td
   * @param {Boolean} [ccw=false] - Set path traversal to counter-clockwise
   */
  var getAnchorsFromArcData = function(center, xAxisRotation, rx, ry, ts, td, ccw) {

    var resolution = Constants.Resolution;

    for (var i = 0; i < resolution; i++) {
      var pct = (i + 1) / resolution;
      if (ccw) {
        pct = 1 - pct;
      }

      var theta = pct * td + ts;
      var x = rx * Math.cos(theta);
      var y = ry * Math.sin(theta);

      // x += center.x;
      // y += center.y;

      var anchor = new Anchor(x, y);
      Anchor.AppendCurveProperties(anchor);
      anchor.command = Commands.line;
    }

  };

  var Curves = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Curve: Curve,
    getComponentOnCubicBezier: getComponentOnCubicBezier,
    subdivide: subdivide,
    getCurveLength: getCurveLength$1,
    getCurveBoundingBox: getCurveBoundingBox,
    integrate: integrate,
    getCurveFromPoints: getCurveFromPoints,
    getControlPoints: getControlPoints,
    getReflection: getReflection,
    getAnchorsFromArcData: getAnchorsFromArcData
  });

  var devicePixelRatio = root$1.devicePixelRatio || 1;

  var getBackingStoreRatio = function(ctx) {
    return ctx.webkitBackingStorePixelRatio ||
    ctx.mozBackingStorePixelRatio ||
    ctx.msBackingStorePixelRatio ||
    ctx.oBackingStorePixelRatio ||
    ctx.backingStorePixelRatio || 1;
  };

  /**
   * @name Two.Utils.getRatio
   * @function
   * @param {CanvasRenderingContext2D} ctx
   * @returns {Number} The ratio of a unit in Two.js to the pixel density of a session's screen.
   * @see [High DPI Rendering](http://www.html5rocks.com/en/tutorials/canvas/hidpi/)
   */
  var getRatio = function(ctx) {
    return devicePixelRatio / getBackingStoreRatio(ctx);
  };

  // Constants

  var cos$5 = Math.cos, sin$5 = Math.sin, tan = Math.tan;
  var array = [];

  /**
   * @name Two.Matrix
   * @class
   * @param {Number} [a=1] - The value for element at the first column and first row.
   * @param {Number} [b=0] - The value for element at the second column and first row.
   * @param {Number} [c=0] - The value for element at the third column and first row.
   * @param {Number} [d=0] - The value for element at the first column and second row.
   * @param {Number} [e=1] - The value for element at the second column and second row.
   * @param {Number} [f=0] - The value for element at the third column and second row.
   * @param {Number} [g=0] - The value for element at the first column and third row.
   * @param {Number} [h=0] - The value for element at the second column and third row.
   * @param {Number} [i=1] - The value for element at the third column and third row.
   * @description A class to store 3 x 3 transformation matrix information. In addition to storing data `Two.Matrix` has suped up methods for commonplace mathematical operations.
   * @nota-bene Order is based on how to construct transformation strings for the browser.
   */
  function Matrix(a, b, c, d, e, f) {

    /**
     * @name Two.Matrix#elements
     * @property {Number[]} - The underlying data stored as an array.
     */
    this.elements = new NumArray(9);

    var elements = a;
    if (!Array.isArray(elements)) {
      elements = Array.prototype.slice.call(arguments);
    }

    // initialize the elements with default values.
    this.identity();

    if (elements.length > 0) {
      this.set(elements);
    }

  }

  setMatrix(Matrix);

  _.extend(Matrix, {

    /**
     * @name Two.Matrix.Identity
     * @property {Number[]} - A stored reference to the default value of a 3 x 3 matrix.
     */
    Identity: [
      1, 0, 0,
      0, 1, 0,
      0, 0, 1
    ],

    /**
     * @name Two.Matrix.Multiply
     * @function
     * @param {Two.Matrix} A
     * @param {Two.Matrix} B
     * @param {Two.Matrix} [C] - An optional matrix to apply the multiplication to.
     * @returns {Two.Matrix} - If an optional `C` matrix isn't passed then a new one is created and returned.
     * @description Multiply two matrices together and return the result.
     */
    Multiply: function(A, B, C) {

      if (B.length <= 3) { // Multiply Vector

        var x, y, z, e = A;

        var a = B[0] || 0,
            b = B[1] || 0,
            c = B[2] || 0;

        // Go down rows first
        // a, d, g, b, e, h, c, f, i

        x = e[0] * a + e[1] * b + e[2] * c;
        y = e[3] * a + e[4] * b + e[5] * c;
        z = e[6] * a + e[7] * b + e[8] * c;

        return { x: x, y: y, z: z };

      }

      var A0 = A[0], A1 = A[1], A2 = A[2];
      var A3 = A[3], A4 = A[4], A5 = A[5];
      var A6 = A[6], A7 = A[7], A8 = A[8];

      var B0 = B[0], B1 = B[1], B2 = B[2];
      var B3 = B[3], B4 = B[4], B5 = B[5];
      var B6 = B[6], B7 = B[7], B8 = B[8];

      C = C || new NumArray(9);

      C[0] = A0 * B0 + A1 * B3 + A2 * B6;
      C[1] = A0 * B1 + A1 * B4 + A2 * B7;
      C[2] = A0 * B2 + A1 * B5 + A2 * B8;
      C[3] = A3 * B0 + A4 * B3 + A5 * B6;
      C[4] = A3 * B1 + A4 * B4 + A5 * B7;
      C[5] = A3 * B2 + A4 * B5 + A5 * B8;
      C[6] = A6 * B0 + A7 * B3 + A8 * B6;
      C[7] = A6 * B1 + A7 * B4 + A8 * B7;
      C[8] = A6 * B2 + A7 * B5 + A8 * B8;

      return C;

    }

  });

  _.extend(Matrix.prototype, Events, {

    constructor: Matrix,

    /**
     * @name Two.Matrix#manual
     * @property {Boolean} - Determines whether Two.js automatically calculates the values for the matrix or if the developer intends to manage the matrix.
     * @nota-bene - Setting to `true` nullifies {@link Two.Shape#translation}, {@link Two.Shape#rotation}, and {@link Two.Shape#scale}.
     */
    manual: false,

    /**
     * @name Two.Matrix#set
     * @function
     * @param {Number} a - The value for element at the first column and first row.
     * @param {Number} b - The value for element at the second column and first row.
     * @param {Number} c - The value for element at the third column and first row.
     * @param {Number} d - The value for element at the first column and second row.
     * @param {Number} e - The value for element at the second column and second row.
     * @param {Number} f - The value for element at the third column and second row.
     * @param {Number} g - The value for element at the first column and third row.
     * @param {Number} h - The value for element at the second column and third row.
     * @param {Number} i - The value for element at the third column and third row.
     * @description Set an array of values onto the matrix. Order described in {@link Two.Matrix}.
     */

      /**
      * @name Two.Matrix#set
      * @function
      * @param {Number[]} a - The array of elements to apply.
      * @description Set an array of values onto the matrix. Order described in {@link Two.Matrix}.
      */
    set: function(a, b, c, d, e, f, g, h, i) {

      var elements;

      if (typeof b === 'undefined') {
        elements = a;
        a = elements[0];
        b = elements[1];
        c = elements[2];
        d = elements[3];
        e = elements[4];
        f = elements[5];
        g = elements[6];
        h = elements[7];
        i = elements[8];
      }

      this.elements[0] = a;
      this.elements[1] = b;
      this.elements[2] = c;
      this.elements[3] = d;
      this.elements[4] = e;
      this.elements[5] = f;
      this.elements[6] = g;
      this.elements[7] = h;
      this.elements[8] = i;

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#copy
     * @function
     * @description Copy the matrix of one to the current instance.
     */
    copy: function(m) {

      this.elements[0] = m.elements[0];
      this.elements[1] = m.elements[1];
      this.elements[2] = m.elements[2];
      this.elements[3] = m.elements[3];
      this.elements[4] = m.elements[4];
      this.elements[5] = m.elements[5];
      this.elements[6] = m.elements[6];
      this.elements[7] = m.elements[7];
      this.elements[8] = m.elements[8];

      this.manual = m.manual;

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#identity
     * @function
     * @description Turn matrix to the identity, like resetting.
     */
    identity: function() {

      this.elements[0] = Matrix.Identity[0];
      this.elements[1] = Matrix.Identity[1];
      this.elements[2] = Matrix.Identity[2];
      this.elements[3] = Matrix.Identity[3];
      this.elements[4] = Matrix.Identity[4];
      this.elements[5] = Matrix.Identity[5];
      this.elements[6] = Matrix.Identity[6];
      this.elements[7] = Matrix.Identity[7];
      this.elements[8] = Matrix.Identity[8];

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#multiply
     * @function
     * @param {Number} a - The scalar to be multiplied.
     * @description Multiply all components of the matrix against a single scalar value.
     * @overloaded
     */

    /**
     * @name Two.Matrix#multiply
     * @function
     * @param {Number} a - The x component to be multiplied.
     * @param {Number} b - The y component to be multiplied.
     * @param {Number} c - The z component to be multiplied.
     * @description Multiply all components of a matrix against a 3 component vector.
     * @overloaded
     */

    /**
     * @name Two.Matrix#multiply
     * @function
     * @param {Number} a - The value at the first column and first row of the matrix to be multiplied.
     * @param {Number} b - The value at the second column and first row of the matrix to be multiplied.
     * @param {Number} c - The value at the third column and first row of the matrix to be multiplied.
     * @param {Number} d - The value at the first column and second row of the matrix to be multiplied.
     * @param {Number} e - The value at the second column and second row of the matrix to be multiplied.
     * @param {Number} f - The value at the third column and second row of the matrix to be multiplied.
     * @param {Number} g - The value at the first column and third row of the matrix to be multiplied.
     * @param {Number} h - The value at the second column and third row of the matrix to be multiplied.
     * @param {Number} i - The value at the third column and third row of the matrix to be multiplied.
     * @description Multiply all components of a matrix against another matrix.
     * @overloaded
     */
    multiply: function(a, b, c, d, e, f, g, h, i) {

      // Multiply scalar

      if (typeof b === 'undefined') {

        this.elements[0] *= a;
        this.elements[1] *= a;
        this.elements[2] *= a;
        this.elements[3] *= a;
        this.elements[4] *= a;
        this.elements[5] *= a;
        this.elements[6] *= a;
        this.elements[7] *= a;
        this.elements[8] *= a;

        return this.trigger(Events.Types.change);

      }

      if (typeof d === 'undefined') { // Multiply Vector

        var x, y, z;
        a = a || 0;
        b = b || 0;
        c = c || 0;
        e = this.elements;

        // Go down rows first
        // a, d, g, b, e, h, c, f, i

        x = e[0] * a + e[1] * b + e[2] * c;
        y = e[3] * a + e[4] * b + e[5] * c;
        z = e[6] * a + e[7] * b + e[8] * c;

        return { x: x, y: y, z: z };

      }

      // Multiple matrix

      var A = this.elements;
      var B = [a, b, c, d, e, f, g, h, i];

      var A0 = A[0], A1 = A[1], A2 = A[2];
      var A3 = A[3], A4 = A[4], A5 = A[5];
      var A6 = A[6], A7 = A[7], A8 = A[8];

      var B0 = B[0], B1 = B[1], B2 = B[2];
      var B3 = B[3], B4 = B[4], B5 = B[5];
      var B6 = B[6], B7 = B[7], B8 = B[8];

      this.elements[0] = A0 * B0 + A1 * B3 + A2 * B6;
      this.elements[1] = A0 * B1 + A1 * B4 + A2 * B7;
      this.elements[2] = A0 * B2 + A1 * B5 + A2 * B8;

      this.elements[3] = A3 * B0 + A4 * B3 + A5 * B6;
      this.elements[4] = A3 * B1 + A4 * B4 + A5 * B7;
      this.elements[5] = A3 * B2 + A4 * B5 + A5 * B8;

      this.elements[6] = A6 * B0 + A7 * B3 + A8 * B6;
      this.elements[7] = A6 * B1 + A7 * B4 + A8 * B7;
      this.elements[8] = A6 * B2 + A7 * B5 + A8 * B8;

      return this.trigger(Events.Types.change);

    },

    /**
     * @name Two.Matrix#inverse
     * @function
     * @param {Two.Matrix} [out] - The optional matrix to apply the inversion to.
     * @description Return an inverted version of the matrix. If no optional one is passed a new matrix is created and returned.
     */
    inverse: function(out) {

      var a = this.elements;
      out = out || new Matrix();

      var a00 = a[0], a01 = a[1], a02 = a[2];
      var a10 = a[3], a11 = a[4], a12 = a[5];
      var a20 = a[6], a21 = a[7], a22 = a[8];

      var b01 = a22 * a11 - a12 * a21;
      var b11 = -a22 * a10 + a12 * a20;
      var b21 = a21 * a10 - a11 * a20;

      // Calculate the determinant
      var det = a00 * b01 + a01 * b11 + a02 * b21;

      if (!det) {
        return null;
      }

      det = 1.0 / det;

      out.elements[0] = b01 * det;
      out.elements[1] = (-a22 * a01 + a02 * a21) * det;
      out.elements[2] = (a12 * a01 - a02 * a11) * det;
      out.elements[3] = b11 * det;
      out.elements[4] = (a22 * a00 - a02 * a20) * det;
      out.elements[5] = (-a12 * a00 + a02 * a10) * det;
      out.elements[6] = b21 * det;
      out.elements[7] = (-a21 * a00 + a01 * a20) * det;
      out.elements[8] = (a11 * a00 - a01 * a10) * det;

      return out;

    },

    /**
     * @name Two.Matrix#scale
     * @function
     * @param {Number} scale - The one dimensional scale to apply to the matrix.
     * @description Uniformly scale the transformation matrix.
     */

    /**
     * @name Two.Matrix#scale
     * @function
     * @param {Number} sx - The horizontal scale factor.
     * @param {Number} sy - The vertical scale factor
     * @description Scale the transformation matrix in two dimensions.
     */
    scale: function(sx, sy) {

      var l = arguments.length;
      if (l <= 1) {
        sy = sx;
      }

      return this.multiply(sx, 0, 0, 0, sy, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#rotate
     * @function
     * @param {Number} Number - The amount to rotate in Number.
     * @description Rotate the matrix.
     */
    rotate: function(Number) {

      var c = cos$5(Number);
      var s = sin$5(Number);

      return this.multiply(c, -s, 0, s, c, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#translate
     * @function
     * @param {Number} x - The horizontal translation value to apply.
     * @param {Number} y - The vertical translation value to apply.
     * @description Translate the matrix.
     */
    translate: function(x, y) {

      return this.multiply(1, 0, x, 0, 1, y, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#skewX
     * @function
     * @param {Number} Number - The amount to skew in Number.
     * @description Skew the matrix by an angle in the x axis direction.
     */
    skewX: function(Number) {

      var a = tan(Number);

      return this.multiply(1, a, 0, 0, 1, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#skewY
     * @function
     * @param {Number} Number - The amount to skew in Number.
     * @description Skew the matrix by an angle in the y axis direction.
     */
    skewY: function(Number) {

      var a = tan(Number);

      return this.multiply(1, 0, 0, a, 1, 0, 0, 0, 1);

    },

    /**
     * @name Two.Matrix#toString
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 for 2D transformations.
     * @returns {String} - The transformation matrix as a 6 component string separated by spaces.
     * @description Create a transform string. Used for the Two.js rendering APIs.
     */
    toString: function(fullMatrix) {

      array.length = 0;
      this.toTransformArray(fullMatrix, array);

      return array.map(toFixed).join(' ');

    },

    /**
     * @name Two.Matrix#toTransformArray
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 in the format for 2D transformations.
     * @param {Number[]} [output] - An array empty or otherwise to apply the values to.
     * @description Create a transform array. Used for the Two.js rendering APIs.
     */
    toTransformArray: function(fullMatrix, output) {

      var elements = this.elements;
      var hasOutput = !!output;

      var a = elements[0];
      var b = elements[1];
      var c = elements[2];
      var d = elements[3];
      var e = elements[4];
      var f = elements[5];

      if (fullMatrix) {

        var g = elements[6];
        var h = elements[7];
        var i = elements[8];

        if (hasOutput) {
          output[0] = a;
          output[1] = d;
          output[2] = g;
          output[3] = b;
          output[4] = e;
          output[5] = h;
          output[6] = c;
          output[7] = f;
          output[8] = i;
          return;
        }

        return [
          a, d, g, b, e, h, c, f, i
        ];
      }

      if (hasOutput) {
        output[0] = a;
        output[1] = d;
        output[2] = b;
        output[3] = e;
        output[4] = c;
        output[5] = f;
        return;
      }

      return [
        a, d, b, e, c, f  // Specific format see LN:19
      ];

    },

    /**
     * @name Two.Matrix#toArray
     * @function
     * @param {Boolean} [fullMatrix=false] - Return the full 9 elements of the matrix or just 6 for 2D transformations.
     * @param {Number[]} [output] - An array empty or otherwise to apply the values to.
     * @description Create a transform array. Used for the Two.js rendering APIs.
     */
    toArray: function(fullMatrix, output) {

      var elements = this.elements;
      var hasOutput = !!output;

      var a = elements[0];
      var b = elements[1];
      var c = elements[2];
      var d = elements[3];
      var e = elements[4];
      var f = elements[5];

      if (fullMatrix) {

        var g = elements[6];
        var h = elements[7];
        var i = elements[8];

        if (hasOutput) {
          output[0] = a;
          output[1] = b;
          output[2] = c;
          output[3] = d;
          output[4] = e;
          output[5] = f;
          output[6] = g;
          output[7] = h;
          output[8] = i;
          return;
        }

        return [
          a, b, c, d, e, f, g, h, i
        ];
      }

      if (hasOutput) {
        output[0] = a;
        output[1] = b;
        output[2] = c;
        output[3] = d;
        output[4] = e;
        output[5] = f;
        return;
      }

      return [
        a, b, c, d, e, f
      ];

    },

    /**
     * @name Two.Matrix#toObject
     * @function
     * @description Create a JSON compatible object that represents information of the matrix.
     */
    toObject: function() {
      return {
        elements: this.toArray(true),
        manual: !!this.manual
      };
    },

    /**
     * @name Two.Matrix#clone
     * @function
     * @description Clone the current matrix.
     */
    clone: function() {

      return new Matrix().copy(this);

    }

  });

  /**
   * @name Two.Shape
   * @class
   * @extends Two.Events
   * @description The foundational transformation object for the Two.js scenegraph.
   */
  function Shape() {

    /**
     * @name Two.Shape#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.flagMatrix = Shape.FlagMatrix.bind(this);
    this.isShape = true;

    /**
     * @name Two.Shape#id
     * @property {String} - Session specific unique identifier.
     * @nota-bene In the {@link Two.SvgRenderer} change this to change the underlying SVG element's id too.
     */
    this.id = Constants.Identifier + Constants.uniqueId();

    /**
     * @name Two.Shape#classList
     * @property {String[]}
     * @description A list of class strings stored if imported / interpreted  from an SVG element.
     */
    this.classList = [];

    /**
     * @name Two.Shape#matrix
     * @property {Two.Matrix}
     * @description The transformation matrix of the shape.
     * @nota-bene {@link Two.Shape#translation}, {@link Two.Shape#rotation}, {@link Two.Shape#scale}, {@link Two.Shape#skewX}, and {@link Two.Shape#skewY} apply their values to the matrix when changed. The matrix is what is sent to the renderer to be drawn.
     */
    this.matrix = new Matrix();

    /**
     * @name Two.Shape#translation
     * @property {Two.Vector} - The x and y value for where the shape is placed relative to its parent.
     */
    this.translation = new Vector();

    /**
     * @name Two.Shape#rotation
     * @property {Number} - The value in Number for how much the shape is rotated relative to its parent.
     */
    this.rotation = 0;

    /**
     * @name Two.Shape#scale
     * @property {Number} - The value for how much the shape is scaled relative to its parent.
     * @nota-bene This value can be replaced with a {@link Two.Vector} to do non-uniform scaling. e.g: `shape.scale = new Two.Vector(2, 1);`
     */
    this.scale = 1;

    /**
     * @name Two.Shape#skewX
     * @property {Number} - The value in Number for how much the shape is skewed relative to its parent.
     * @description Skew the shape by an angle in the x axis direction.
     */
    this.skewX = 0;

    /**
     * @name Two.Shape#skewY
     * @property {Number} - The value in Number for how much the shape is skewed relative to its parent.
     * @description Skew the shape by an angle in the y axis direction.
     */
    this.skewY = 0;

  }

  _.extend(Shape, {

    /**
     * @name Two.Shape.FlagMatrix
     * @function
     * @description Utility function used in conjunction with event handlers to update the flagMatrix of a shape.
     */
    FlagMatrix: function() {
      this._flagMatrix = true;
    },

    /**
     * @name Two.Shape.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Shape} to any object. Handy if you'd like to extend the {@link Two.Shape} class on a custom class.
     */
    MakeObservable: function(object) {

      var translation = {
        enumerable: false,
        get: function() {
          return this._translation;
        },
        set: function(v) {
          if (this._translation) {
            this._translation.unbind(Events.Types.change, this._renderer.flagMatrix);
          }
          this._translation = v;
          this._translation.bind(Events.Types.change, this._renderer.flagMatrix);
          Shape.FlagMatrix.call(this);
        }
      };

      Object.defineProperty(object, 'translation', translation);
      Object.defineProperty(object, 'position', translation);

      Object.defineProperty(object, 'rotation', {
        enumerable: true,
        get: function() {
          return this._rotation;
        },
        set: function(v) {
          this._rotation = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'scale', {
        enumerable: true,
        get: function() {
          return this._scale;
        },
        set: function(v) {

          if (this._scale instanceof Vector) {
            this._scale.unbind(Events.Types.change, this._renderer.flagMatrix);
          }

          this._scale = v;

          if (this._scale instanceof Vector) {
            this._scale.bind(Events.Types.change, this._renderer.flagMatrix);
          }

          this._flagMatrix = true;
          this._flagScale = true;

        }
      });

      Object.defineProperty(object, 'skewX', {
        enumerable: true,
        get: function() {
          return this._skewX;
        },
        set: function(v) {
          this._skewX = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'skewY', {
        enumerable: true,
        get: function() {
          return this._skewY;
        },
        set: function(v) {
          this._skewY = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'matrix', {
        enumerable: true,
        get: function() {
          return this._matrix;
        },
        set: function(v) {
          this._matrix = v;
          this._flagMatrix = true;
        }
      });

      Object.defineProperty(object, 'id', {
        enumerable: true,
        get: function() {
          return this._id;
        },
        set: function(v) {
          var id = this._id;
          if (v === this._id) {
            return;
          }
          this._id = v;
          this._flagId = true;
          if (this.parent) {
            delete this.parent.children.ids[id];
            this.parent.children.ids[this._id] = this;
          }
        }
      });

      Object.defineProperty(object, 'className', {

        enumerable: true,

        get: function() {
          return this._className;
        },

        set: function(v) {

          this._flagClassName = this._className !== v;

          if (this._flagClassName) {

            var prev = this._className.split(/\s+?/);
            var dest = v.split(/\s+?/);

            for (var i = 0; i < prev.length; i++) {
              var className = prev[i];
              var index = Array.prototype.indexOf.call(this.classList, className);
              if (index >= 0) {
                this.classList.splice(index, 1);
              }
            }

            this.classList = this.classList.concat(dest);

          }

          this._className = v;

        }

      });

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

    }

  });

  _.extend(Shape.prototype, Events, {

    constructor: Shape,

    // Flags

    /**
     * @name Two.Shape#_id
     * @private
     * @property {Boolean} - Determines whether the id needs updating.
     */
    _flagId: true,

    /**
     * @name Two.Shape#_flagMatrix
     * @private
     * @property {Boolean} - Determines whether the matrix needs updating.
     */
    _flagMatrix: true,

    /**
     * @name Two.Shape#_flagScale
     * @private
     * @property {Boolean} - Determines whether the scale needs updating.
     */
    _flagScale: false,

    // _flagMask: false,
    // _flagClip: false,

    /**
     * @name Two.Shape#_flagClassName
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#className} need updating.
     */
    _flagClassName: false,

    // Underlying Properties

    _id: '',

    /**
     * @name Two.Shape#_translation
     * @private
     * @property {Two.Vector} - The translation values as a {@link Two.Vector}.
     */
    _translation: null,

    /**
     * @name Two.Shape#_rotation
     * @private
     * @property {Number} - The rotation value in Number.
     */
    _rotation: 0,

    /**
     * @name Two.Shape#_translation
     * @private
     * @property {Two.Vector} - The translation values as a {@link Two.Vector}.
     */
    _scale: 1,

    /**
     * @name Two.Shape#_skewX
     * @private
     * @property {Number} - The rotation value in Number.
     */
    _skewX: 0,

    /**
     * @name Two.Shape#_skewY
     * @private
     * @property {Number} - The rotation value in Number.
     */
    _skewY: 0,

    /**
     * @name Two.Shape#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling.
     * @nota-bene Only available for the SVG renderer.
     */
    _className: '',

    /**
     * @name Two.Shape#addTo
     * @function
     * @param {Two.Group} group - The parent the shape adds itself to.
     * @description Convenience method to add itself to the scenegraph.
     */
    addTo: function(group) {
      group.add(this);
      return this;
    },

    /**
     * @name Two.Shape#clone
     * @function
     * @param {Two.Group} [parent] - Optional argument to automatically add the shape to a scenegraph.
     * @returns {Two.Shape}
     * @description Create a new {@link Two.Shape} with the same values as the current shape.
     */
    clone: function(parent) {

      var clone = new Shape();

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Shape#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function(bubbles) {

      if (!this._matrix.manual && this._flagMatrix) {

        this._matrix
          .identity()
          .translate(this.translation.x, this.translation.y);

          if (this._scale instanceof Vector) {
            this._matrix.scale(this._scale.x, this._scale.y);
          } else {
            this._matrix.scale(this._scale);
          }

          this._matrix.rotate(this.rotation);
          this._matrix.skewX(this.skewX);
          this._matrix.skewY(this.skewY);
      }

      if (bubbles) {
        if (this.parent && this.parent._update) {
          this.parent._update();
        }
      }

      return this;

    },

    /**
     * @name Two.Shape#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagId = this._flagMatrix = this._flagScale =
        this._flagClassName = false;

      return this;

    }

  });

  Shape.MakeObservable(Shape.prototype);

  /**
   * @name Two.Collection
   * @class
   * @extends Two.Events
   * @description An `Array` like object with additional event propagation on actions. `pop`, `shift`, and `splice` trigger `removed` events. `push`, `unshift`, and `splice` with more than 2 arguments trigger 'inserted'. Finally, `sort` and `reverse` trigger `order` events.
   */
  function Collection() {

    Array.call(this);

    if (arguments[0] && Array.isArray(arguments[0])) {
      if (arguments[0].length > 0) {
        Array.prototype.push.apply(this, arguments[0]);
      }
    } else if (arguments.length > 0) {
      Array.prototype.push.apply(this, arguments);
    }

  }

  Collection.prototype = new Array();

  _.extend(Collection.prototype, Events, {

    constructor: Collection,

    pop: function() {
      var popped = Array.prototype.pop.apply(this, arguments);
      this.trigger(Events.Types.remove, [popped]);
      return popped;
    },

    shift: function() {
      var shifted = Array.prototype.shift.apply(this, arguments);
      this.trigger(Events.Types.remove, [shifted]);
      return shifted;
    },

    push: function() {
      var pushed = Array.prototype.push.apply(this, arguments);
      this.trigger(Events.Types.insert, arguments);
      return pushed;
    },

    unshift: function() {
      var unshifted = Array.prototype.unshift.apply(this, arguments);
      this.trigger(Events.Types.insert, arguments);
      return unshifted;
    },

    splice: function() {
      var spliced = Array.prototype.splice.apply(this, arguments);
      var inserted;

      this.trigger(Events.Types.remove, spliced);

      if (arguments.length > 2) {
        inserted = this.slice(arguments[0], arguments[0] + arguments.length - 2);
        this.trigger(Events.Types.insert, inserted);
        this.trigger(Events.Types.order);
      }
      return spliced;
    },

    sort: function() {
      Array.prototype.sort.apply(this, arguments);
      this.trigger(Events.Types.order);
      return this;
    },

    reverse: function() {
      Array.prototype.reverse.apply(this, arguments);
      this.trigger(Events.Types.order);
      return this;
    },

    indexOf: function() {
      return Array.prototype.indexOf.apply(this, arguments);
    }

  });

  /**
   * @class
   * @name Two.Group.Children
   * @extends Two.Collection
   * @description A children collection which is accesible both by index and by object `id`.
   */
  function Children(children) {

    Collection.apply(this, arguments);

    Object.defineProperty(this, '_events', {
      value : {},
      enumerable: false
    });

    /**
     * @name Two.Group.Children#ids
     * @property {Object} - Map of all elements in the list keyed by `id`s.
     */
    this.ids = {};

    this.attach(
      Array.isArray(children) ? children : Array.prototype.slice.call(arguments)
    );

    this.on(Events.Types.insert, this.attach);
    this.on(Events.Types.remove, this.detach);

  }

  Children.prototype = new Collection();

  _.extend(Children.prototype, {

    constructor: Children,

    /**
     * @function
     * @name Two.Group.Children#attach
     * @param {Two.Shape[]} children - The objects which extend {@link Two.Shape} to be added.
     * @description Adds elements to the `ids` map.
     */
    attach: function(children) {
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child && child.id) {
          this.ids[child.id] = child;
        }
      }
      return this;
    },

    /**
     * @function
     * @name Two.Group.Children#detach
     * @param {Two.Shape[]} children - The objects which extend {@link Two.Shape} to be removed.
     * @description Removes elements to the `ids` map.
     */
    detach: function(children) {
      for (var i = 0; i < children.length; i++) {
        delete this.ids[children[i].id];
      }
      return this;
    }

  });

  // Constants

  var min$3 = Math.min, max$3 = Math.max;

  /**
   * @name Two.Group
   * @class
   * @extends Two.Shape
   * @param {Two.Shape[]} [children] - A list of objects that inherit {@link Two.Shape}. For instance, the array could be a {@link Two.Path}, {@link Two.Text}, and {@link Two.RoundedRectangle}.
   * @description This is the primary class for grouping objects that are then drawn in Two.js. In Illustrator this is a group, in After Effects it would be a Null Object. Whichever the case, the `Two.Group` contains a transformation matrix and commands to style its children, but it by itself doesn't render to the screen.
   * @nota-bene The {@link Two#scene} is an instance of `Two.Group`.
   */
  function Group(children) {

    Shape.call(this, true);

    this._renderer.type = 'group';

    /**
     * @name Two.Group#additions
     * @property {Two.Shape[]}
     * @description An automatically updated list of children that need to be appended to the renderer's scenegraph.
     */
    this.additions = [];

    /**
     * @name Two.Group#subtractions
     * @property {Two.Shape[]}
     * @description An automatically updated list of children that need to be removed from the renderer's scenegraph.
     */
    this.subtractions = [];

    /**
     * @name Two.Group#children
     * @property {Two.Group.Children}
     * @description A list of all the children in the scenegraph.
     * @nota-bene Ther order of this list indicates the order each element is rendered to the screen.
     */
    this.children = Array.isArray(children) ? children : Array.prototype.slice.call(arguments);

  }

  _.extend(Group, {

    Children: Children,

    /**
     * @name Two.Group.InsertChildren
     * @function
     * @param {Two.Shape[]} children - The objects to be inserted.
     * @description Cached method to let renderers know children have been added to a {@link Two.Group}.
     */
    InsertChildren: function(children) {
      for (var i = 0; i < children.length; i++) {
        replaceParent.call(this, children[i], this);
      }
    },

    /**
     * @name Two.Group.RemoveChildren
     * @function
     * @param {Two.Shape[]} children - The objects to be removed.
     * @description Cached method to let renderers know children have been removed from a {@link Two.Group}.
     */
    RemoveChildren: function(children) {
      for (var i = 0; i < children.length; i++) {
        replaceParent.call(this, children[i]);
      }
    },

    /**
     * @name Two.Group.OrderChildren
     * @function
     * @description Cached method to let renderers know order has been updated on a {@link Two.Group}.
     */
    OrderChildren: function(children) {
      this._flagOrder = true;
    },

    /**
     * @name Two.Group.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Group}.
     */
    Properties: [
      'fill',
      'stroke',
      'linewidth',
      'cap',
      'join',
      'miter',

      'closed',
      'curved',
      'automatic'
    ],

    /**
     * @name Two.Group.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Group} to any object. Handy if you'd like to extend the {@link Two.Group} class on a custom class.
     */
    MakeObservable: function(object) {

      var properties = Group.Properties;

      Object.defineProperty(object, 'visible', {

        enumerable: true,

        get: function() {
          return this._visible;
        },

        set: function(v) {
          this._flagVisible = this._visible !== v || this._flagVisible;
          this._visible = v;
        }

      });

      Object.defineProperty(object, 'opacity', {

        enumerable: true,

        get: function() {
          return this._opacity;
        },

        set: function(v) {
          this._flagOpacity = this._opacity !== v || this._flagOpacity;
          this._opacity = v;
        }

      });

      Object.defineProperty(object, 'beginning', {

        enumerable: true,

        get: function() {
          return this._beginning;
        },

        set: function(v) {
          this._flagBeginning = this._beginning !== v || this._flagBeginning;
          this._beginning = v;
        }

      });

      Object.defineProperty(object, 'ending', {

        enumerable: true,

        get: function() {
          return this._ending;
        },

        set: function(v) {
          this._flagEnding = this._ending !== v || this._flagEnding;
          this._ending = v;
        }

      });

      Object.defineProperty(object, 'length', {

        enumerable: true,

        get: function() {
          if (this._flagLength || this._length <= 0) {
            this._length = 0;
            if (!this.children) {
              return this._length;
            }
            for (var i = 0; i < this.children.length; i++) {
              var child = this.children[i];
              this._length += child.length;
            }
          }
          return this._length;
        }

      });

      Shape.MakeObservable(object);
      Group.MakeGetterSetters(object, properties);

      Object.defineProperty(object, 'children', {

        enumerable: true,

        get: function() {
          return this._children;
        },

        set: function(children) {

          var insertChildren = Group.InsertChildren.bind(this);
          var removeChildren = Group.RemoveChildren.bind(this);
          var orderChildren = Group.OrderChildren.bind(this);

          if (this._children) {
            this._children.unbind();
            if (this._children.length > 0) {
              removeChildren(this._children);
            }
          }

          this._children = new Children(children);
          this._children.bind(Events.Types.insert, insertChildren);
          this._children.bind(Events.Types.remove, removeChildren);
          this._children.bind(Events.Types.order, orderChildren);

          if (children.length > 0) {
            insertChildren(children);
          }

        }

      });

      Object.defineProperty(object, 'mask', {

        enumerable: true,

        get: function() {
          return this._mask;
        },

        set: function(v) {
          this._mask = v;
          this._flagMask = true;
          if (!v.clip) {
            v.clip = true;
          }
        }

      });

    },

    /**
     * @name Two.Group.MakeGetterSetters
     * @function
     * @param {Two.Group} group - The group to apply getters and setters.
     * @param {Object} properties - A key / value object containing properties to inherit.
     * @description Convenience method to apply getter / setter logic on an array of properties. Used in {@link Two.Group.MakeObservable}.
     */
    MakeGetterSetters: function(group, properties) {

      if (!Array.isArray(properties)) {
        properties = [properties];
      }

      _.each(properties, function(k) {
        Group.MakeGetterSetter(group, k);
      });

    },

    /**
     * @name Two.Group.MakeGetterSetter
     * @function
     * @param {Two.Group} group - The group to apply getters and setters.
     * @param {String} key - The key which will become a property on the group.
     * @description Convenience method to apply getter / setter logic specific to how `Two.Group`s trickle down styles to their children. Used in {@link Two.Group.MakeObservable}.
     */
    MakeGetterSetter: function(group, key) {

      var secret = '_' + key;

      Object.defineProperty(group, key, {

        enumerable: true,

        get: function() {
          return this[secret];
        },

        set: function(v) {
          this[secret] = v;
          // Trickle down styles
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            child[key] = v;
          }
        }

      });

    }

  });

  _.extend(Group.prototype, Shape.prototype, {

    constructor: Group,

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Group#_flagAdditions
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#additions} needs updating.
     */
    _flagAdditions: false,

    /**
     * @name Two.Group#_flagSubtractions
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#subtractions} needs updating.
     */
    _flagSubtractions: false,

    /**
     * @name Two.Group#_flagOrder
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#order} needs updating.
     */
    _flagOrder: false,

    /**
     * @name Two.Group#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#visible} needs updating.
     */

    /**
     * @name Two.Group#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#opacity} needs updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Group#_flagBeginning
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#beginning} needs updating.
     */
    _flagBeginning: false,

    /**
     * @name Two.Group#_flagEnding
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#ending} needs updating.
     */
    _flagEnding: false,

    /**
     * @name Two.Group#_flagLength
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#length} needs updating.
     */
    _flagLength: false,

    /**
     * @name Two.Group#_flagMask
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Group#mask} needs updating.
     */
    _flagMask: false,

    // Underlying Properties

    /**
     * @name Two.Group#fill
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what all child shapes should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _fill: '#fff',

    /**
     * @name Two.Group#stroke
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what all child shapes should be outlined in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _stroke: '#000',

    /**
     * @name Two.Group#linewidth
     * @property {Number} - The thickness in pixels of the stroke for all child shapes.
     */
    _linewidth: 1.0,

    /**
     * @name Two.Group#opacity
     * @property {Number} - The opaqueness of all child shapes.
     * @nota-bene Becomes multiplied by the individual child's opacity property.
     */
    _opacity: 1.0,

    /**
     * @name Two.Group#visible
     * @property {Boolean} - Display the path or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    _visible: true,

    /**
     * @name Two.Group#cap
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty}
     */
    _cap: 'round',

    /**
     * @name Two.Group#join
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty}
     */
    _join: 'round',

    /**
     * @name Two.Group#miter
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeMiterlimitProperty}
     */
    _miter: 4,

    /**
     * @name Two.Group#closed
     * @property {Boolean} - Determines whether a final line is drawn between the final point in the `vertices` array and the first point of all child shapes.
     */
    _closed: true,

    /**
     * @name Two.Group#curved
     * @property {Boolean} - When the child's path is `automatic = true` this boolean determines whether the lines between the points are curved or not.
     */
    _curved: false,

    /**
     * @name Two.Group#automatic
     * @property {Boolean} - Determines whether or not Two.js should calculate curves, lines, and commands automatically for you or to let the developer manipulate them for themselves.
     */
    _automatic: true,

    /**
     * @name Two.Group#beginning
     * @property {Number} - Number between zero and one to state the beginning of where the path is rendered.
     * @description {@link Two.Group#beginning} is a percentage value that represents at what percentage into all child shapes should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Group#ending}.
     */
    _beginning: 0,

    /**
     * @name Two.Group#ending
     * @property {Number} - Number between zero and one to state the ending of where the path is rendered.
     * @description {@link Two.Group#ending} is a percentage value that represents at what percentage into all child shapes should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Group#beginning}.
     */
    _ending: 1.0,

    /**
     * @name Two.Group#length
     * @property {Number} - The sum of distances between all child lengths.
     */
    _length: 0,

    /**
     * @name Two.Group#mask
     * @property {Two.Shape} - The Two.js object to clip from a group's rendering.
     */
    _mask: null,

    /**
     * @name Two.Group#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Group}
     * @description Create a new instance of {@link Two.Group} with the same properties of the current group.
     */
    clone: function(parent) {

      // /**
      //  * TODO: Group has a gotcha in that it's at the moment required to be bound to
      //  * an instance of two in order to add elements correctly. This needs to
      //  * be rethought and fixed.
      //  */

      var clone = new Group();
      var children = this.children.map(function(child) {
        return child.clone();
      });

      clone.add(children);

      clone.opacity = this.opacity;

      if (this.mask) {
        clone.mask = this.mask;
      }

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.className = this.className;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Group#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the group.
     */
    toObject: function() {

      var result = {
        children: [],
        translation: this.translation.toObject(),
        rotation: this.rotation,
        scale: this.scale instanceof Vector ? this.scale.toObject() : this.scale,
        opacity: this.opacity,
        className: this.className,
        mask: (this.mask ? this.mask.toObject() : null)
      };

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      _.each(this.children, function(child, i) {
        result.children[i] = child.toObject();
      }, this);

      return result;

    },

    /**
     * @name Two.Group#corner
     * @function
     * @description Orient the children of the group to the upper left-hand corner of that group.
     */
    corner: function() {

      var rect = this.getBoundingClientRect(true);

      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        child.translation.x -= rect.left;
        child.translation.y -= rect.top;
      }

      return this;

    },

    /**
     * @name Two.Group#center
     * @function
     * @description Orient the children of the group to the center of that group.
     */
    center: function() {

      var rect = this.getBoundingClientRect(true);
      var cx = rect.left + rect.width / 2 - this.translation.x;
      var cy = rect.top + rect.height / 2 - this.translation.y;

      for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i];
        if (child.isShape) {
          child.translation.x -= cx;
          child.translation.y -= cy;
        }
      }

      return this;

    },

    /**
     * @name Two.Group#getById
     * @function
     * @description Recursively search for id. Returns the first element found.
     * @returns {Two.Shape} - Or `null` if nothing is found.
     */
    getById: function (id) {
      var found = null;
      function search(node) {
        if (node.id === id) {
          return node;
        } else if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            found = search(node.children[i]);
            if (found) {
              return found;
            }
          }
        }
        return null;
      }
      return search(this);
    },

    /**
     * @name Two.Group#getByClassName
     * @function
     * @description Recursively search for classes. Returns an array of matching elements.
     * @returns {Two.Shape[]} - Or empty array if nothing is found.
     */
    getByClassName: function(className) {
      var found = [];
      function search(node) {
        if (Array.prototype.indexOf.call(node.classList, className) >= 0) {
          found.push(node);
        }
        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            search(child);
          }
        }
        return found;
      }
      return search(this);
    },

    /**
     * @name Two.Group#getByType
     * @function
     * @description Recursively search for children of a specific type, e.g. {@link Two.Path}. Pass a reference to this type as the param. Returns an array of matching elements.
     * @returns {Two.Shape[]} - Empty array if nothing is found.
     */
    getByType: function(type) {
      var found = [];
      function search(node) {
        if (node instanceof type) {
          found.push(node);
        }
        if (node.children) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            search(child);
          }
        }
        return found;
      }
      return search(this);
    },

    /**
     * @name Two.Group#add
     * @function
     * @param {Two.Shape[]} objects - An array of objects to be added. Can be also be supplied as individual arguments.
     * @description Add objects to the group.
     */
    add: function(objects) {

      // Allow to pass multiple objects either as array or as multiple arguments
      // If it's an array also create copy of it in case we're getting passed
      // a childrens array directly.
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      } else {
        objects = objects.slice();
      }

      // Add the objects
      for (var i = 0; i < objects.length; i++) {
        var child = objects[i];
        if (!(child && child.id)) {
          continue;
        }
        var index = Array.prototype.indexOf.call(this.children, child);
        if (index >= 0) {
          this.children.splice(index, 1);
        }
        this.children.push(child);
      }

      return this;

    },

    /**
     * @name Two.Group#add
     * @function
     * @param {Two.Shape[]} objects - An array of objects to be removed. Can be also removed as individual arguments.
     * @description Remove objects from the group.
     */
    remove: function(objects) {

      var l = arguments.length,
        grandparent = this.parent;

      // Allow to call remove without arguments
      // This will detach the object from its own parent.
      if (l <= 0 && grandparent) {
        grandparent.remove(this);
        return this;
      }

      // Allow to pass multiple objects either as array or as multiple arguments
      // If it's an array also create copy of it in case we're getting passed
      // a childrens array directly.
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      } else {
        objects = objects.slice();
      }

      // Remove the objects
      for (var i = 0; i < objects.length; i++) {
        var object = objects[i];
        if (!object || !this.children.ids[object.id]) {
          continue;
        }
        var index = this.children.indexOf(object);
        if (index >= 0) {
          this.children.splice(index, 1);
        }
      }

      return this;

    },

    /**
     * @name Two.Group#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the group.
     */
    getBoundingClientRect: function(shallow) {
      var rect, matrix, a, b, c, d, tc, lc, rc, bc;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      // Variables need to be defined here, because of nested nature of groups.
      var left = Infinity, right = -Infinity,
          top = Infinity, bottom = -Infinity;

      var regex = /texture|gradient/i;

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      for (var i = 0; i < this.children.length; i++) {

        var child = this.children[i];

        if (!child.visible || regex.test(child._renderer.type)) {
          continue;
        }

        rect = child.getBoundingClientRect(shallow);

        tc = typeof rect.top !== 'number' || _.isNaN(rect.top) || !isFinite(rect.top);
        lc = typeof rect.left !== 'number' || _.isNaN(rect.left) || !isFinite(rect.left);
        rc = typeof rect.right !== 'number' || _.isNaN(rect.right) || !isFinite(rect.right);
        bc = typeof rect.bottom !== 'number' || _.isNaN(rect.bottom) || !isFinite(rect.bottom);

        if (tc || lc || rc || bc) {
          continue;
        }

        top = min$3(rect.top, top);
        left = min$3(rect.left, left);
        right = max$3(rect.right, right);
        bottom = max$3(rect.bottom, bottom);

      }

      if (shallow) {

        a = matrix.multiply(left, top, 1);
        b = matrix.multiply(left, bottom, 1);
        c = matrix.multiply(right, top, 1);
        d = matrix.multiply(right, bottom, 1);

        top = min$3(a.y, b.y, c.y, d.y);
        left = min$3(a.x, b.x, c.x, d.x);
        right = max$3(a.x, b.x, c.x, d.x);
        bottom = max$3(a.y, b.y, c.y, d.y);

      }

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Group#noFill
     * @function
     * @description Apply `noFill` method to all child shapes.
     */
    noFill: function() {
      this.children.forEach(function(child) {
        child.noFill();
      });
      return this;
    },

    /**
     * @name Two.Group#noStroke
     * @function
     * @description Apply `noStroke` method to all child shapes.
     */
    noStroke: function() {
      this.children.forEach(function(child) {
        child.noStroke();
      });
      return this;
    },

    /**
     * @name Two.Group#subdivide
     * @function
     * @description Apply `subdivide` method to all child shapes.
     */
    subdivide: function() {
      var args = arguments;
      this.children.forEach(function(child) {
        child.subdivide.apply(child, args);
      });
      return this;
    },

    /**
     * @name Two.Group#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var i, l, child;

      if (this._flagBeginning || this._flagEnding) {

        var beginning = Math.min(this._beginning, this._ending);
        var ending = Math.max(this._beginning, this._ending);
        var length = this.length;
        var sum = 0;

        var bd = beginning * length;
        var ed = ending * length;

        for (i = 0; i < this.children.length; i++) {

          child = this.children[i];
          l = child.length;

          if (bd > sum + l) {
            child.beginning = 1;
            child.ending = 1;
          } else if (ed < sum) {
            child.beginning = 0;
            child.ending = 0;
          } else if (bd > sum && bd < sum + l) {
            child.beginning = (bd - sum) / l;
            child.ending = 1;
          } else if (ed > sum && ed < sum + l) {
            child.beginning = 0;
            child.ending = (ed - sum) / l;
          } else {
            child.beginning = 0;
            child.ending = 1;
          }

          sum += l;

        }

      }

      return Shape.prototype._update.apply(this, arguments);

    },

    /**
     * @name Two.Group#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      if (this._flagAdditions) {
        this.additions.length = 0;
        this._flagAdditions = false;
      }

      if (this._flagSubtractions) {
        this.subtractions.length = 0;
        this._flagSubtractions = false;
      }

      this._flagOrder = this._flagMask = this._flagOpacity =
        this._flagBeginning = this._flagEnding = false;

      Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Group.MakeObservable(Group.prototype);

  // /**
  //  * Helper function used to sync parent-child relationship within the
  //  * `Two.Group.children` object.
  //  *
  //  * Set the parent of the passed object to another object
  //  * and updates parent-child relationships
  //  * Calling with one arguments will simply remove the parenting
  //  */
  function replaceParent(child, newParent) {

    var parent = child.parent;
    var index;

    if (parent === newParent) {
      add();
      return;
    }

    if (parent && parent.children.ids[child.id]) {

      index = Array.prototype.indexOf.call(parent.children, child);
      parent.children.splice(index, 1);

      splice();

    }

    if (newParent) {
      add();
      return;
    }

    splice();

    if (parent._flagAdditions && parent.additions.length === 0) {
      parent._flagAdditions = false;
    }
    if (parent._flagSubtractions && parent.subtractions.length === 0) {
      parent._flagSubtractions = false;
    }

    delete child.parent;

    function add() {

      if (newParent.subtractions.length > 0) {
        index = Array.prototype.indexOf.call(newParent.subtractions, child);

        if (index >= 0) {
          newParent.subtractions.splice(index, 1);
        }
      }

      if (newParent.additions.length > 0) {
        index = Array.prototype.indexOf.call(newParent.additions, child);

        if (index >= 0) {
          newParent.additions.splice(index, 1);
        }
      }

      child.parent = newParent;
      newParent.additions.push(child);
      newParent._flagAdditions = true;

    }

    function splice() {

      index = Array.prototype.indexOf.call(parent.additions, child);

      if (index >= 0) {
        parent.additions.splice(index, 1);
      }

      index = Array.prototype.indexOf.call(parent.subtractions, child);

      if (index < 0) {
        parent.subtractions.push(child);
        parent._flagSubtractions = true;
      }

    }

  }

  // Constants
  var emptyArray = [];
  var TWO_PI$5 = Math.PI * 2,
    max$2 = Math.max,
    min$2 = Math.min,
    abs = Math.abs,
    sin$4 = Math.sin,
    cos$4 = Math.cos,
    acos = Math.acos,
    sqrt = Math.sqrt;

  // Returns true if this is a non-transforming matrix
  var isDefaultMatrix = function (m) {
    return (m[0] == 1 && m[3] == 0 && m[1] == 0 && m[4] == 1 && m[2] == 0 && m[5] == 0);
  };

  var canvas = {

    isHidden: /(undefined|none|transparent)/i,

    alignments: {
      left: 'start',
      middle: 'center',
      right: 'end'
    },

    shim: function(elem, name) {
      elem.tagName = elem.nodeName = name || 'canvas';
      elem.nodeType = 1;
      elem.getAttribute = function(prop) {
        return this[prop];
      };
      elem.setAttribute = function(prop, val) {
        this[prop] = val;
        return this;
      };
      return elem;
    },

    group: {

      renderChild: function(child) {
        canvas[child._renderer.type].render.call(child, this.ctx, true, this.clip);
      },

      render: function(ctx) {

        if (!this._visible) {
          return this;
        }

        this._update();

        var matrix = this._matrix.elements;
        var parent = this.parent;
        this._renderer.opacity = this._opacity
          * (parent && parent._renderer ? parent._renderer.opacity : 1);

        var mask = this._mask;
        // var clip = this._clip;

        var defaultMatrix = isDefaultMatrix(matrix);
        var shouldIsolate = !defaultMatrix || !!mask;

        if (!this._renderer.context) {
          this._renderer.context = {};
        }

        this._renderer.context.ctx = ctx;
        // this._renderer.context.clip = clip;

        if (shouldIsolate) {
          ctx.save();
          if (!defaultMatrix) {
            ctx.transform(matrix[0], matrix[3], matrix[1],
              matrix[4], matrix[2], matrix[5]);
          }
        }

        if (mask) {
          canvas[mask._renderer.type].render.call(mask, ctx, true);
        }

        if (this._opacity > 0 && this._scale !== 0) {
          for (var i = 0; i < this.children.length; i++) {
            var child = this.children[i];
            canvas[child._renderer.type].render.call(child, ctx);
          }
        }

        if (shouldIsolate) {
          ctx.restore();
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        // if (clip) {
        //   ctx.clip();
        // }

        return this.flagReset();

      }

    },

    path: {

      render: function(ctx, forced, parentClipped) {

        var matrix, stroke, linewidth, fill, opacity, visible, cap, join, miter,
            closed, commands, length, last, next, prev, a, b, c, d, ux, uy, vx, vy,
            ar, bl, br, cl, x, y, mask, clip, defaultMatrix, isOffset, dashes, po;

        po = (this.parent && this.parent._renderer)
          ? this.parent._renderer.opacity : 1;
        mask = this._mask;
        clip = this._clip;
        opacity = this._opacity * (po || 1);
        visible = this._visible;

        if (!forced && (!visible || clip || opacity === 0)) {
          return this;
        }

        this._update();

        matrix = this._matrix.elements;
        stroke = this._stroke;
        linewidth = this._linewidth;
        fill = this._fill;
        cap = this._cap;
        join = this._join;
        miter = this._miter;
        closed = this._closed;
        commands = this._renderer.vertices; // Commands
        length = commands.length;
        last = length - 1;
        defaultMatrix = isDefaultMatrix(matrix);
        dashes = this.dashes;

        // Transform
        if (!defaultMatrix) {
          ctx.save();
          ctx.transform(matrix[0], matrix[3], matrix[1], matrix[4], matrix[2], matrix[5]);
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951
        if (mask) {
          canvas[mask._renderer.type].render.call(mask, ctx, true);
        }

        // Styles
        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            canvas[fill._renderer.type].render.call(fill, ctx);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            canvas[stroke._renderer.type].render.call(stroke, ctx);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
          if (miter) {
            ctx.miterLimit = miter;
          }
          if (join) {
            ctx.lineJoin = join;
          }
          if (!closed && cap) {
            ctx.lineCap = cap;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }

        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        ctx.beginPath();

        for (var i = 0; i < commands.length; i++) {

          b = commands[i];

          x = b.x;
          y = b.y;

          switch (b.command) {

            case Commands.close:
              ctx.closePath();
              break;

            case Commands.arc:

              var rx = b.rx;
              var ry = b.ry;
              var xAxisRotation = b.xAxisRotation;
              var largeArcFlag = b.largeArcFlag;
              var sweepFlag = b.sweepFlag;

              prev = closed ? mod(i - 1, length) : max$2(i - 1, 0);
              a = commands[prev];

              var ax = a.x;
              var ay = a.y;

              canvas.renderSvgArcCommand(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y);
              break;

            case Commands.curve:

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              next = closed ? mod(i + 1, length) : Math.min(i + 1, last);

              a = commands[prev];
              c = commands[next];
              ar = (a.controls && a.controls.right) || Vector.zero;
              bl = (b.controls && b.controls.left) || Vector.zero;

              if (a._relative) {
                vx = (ar.x + a.x);
                vy = (ar.y + a.y);
              } else {
                vx = ar.x;
                vy = ar.y;
              }

              if (b._relative) {
                ux = (bl.x + b.x);
                uy = (bl.y + b.y);
              } else {
                ux = bl.x;
                uy = bl.y;
              }

              ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              if (i >= last && closed) {

                c = d;

                br = (b.controls && b.controls.right) || Vector.zero;
                cl = (c.controls && c.controls.left) || Vector.zero;

                if (b._relative) {
                  vx = (br.x + b.x);
                  vy = (br.y + b.y);
                } else {
                  vx = br.x;
                  vy = br.y;
                }

                if (c._relative) {
                  ux = (cl.x + c.x);
                  uy = (cl.y + c.y);
                } else {
                  ux = cl.x;
                  uy = cl.y;
                }

                x = c.x;
                y = c.y;

                ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              }

              break;

            case Commands.line:
              ctx.lineTo(x, y);
              break;

            case Commands.move:
              d = b;
              ctx.moveTo(x, y);
              break;

          }
        }

        // Loose ends

        if (closed) {
          ctx.closePath();
        }

        if (!clip && !parentClipped) {
          if (!canvas.isHidden.test(fill)) {
            isOffset = fill._renderer && fill._renderer.offset;
            if (isOffset) {
              ctx.save();
              ctx.translate(
                - fill._renderer.offset.x, - fill._renderer.offset.y);
              ctx.scale(fill._renderer.scale.x, fill._renderer.scale.y);
            }
            ctx.fill();
            if (isOffset) {
              ctx.restore();
            }
          }
          if (!canvas.isHidden.test(stroke)) {
            isOffset = stroke._renderer && stroke._renderer.offset;
            if (isOffset) {
              ctx.save();
              ctx.translate(
                - stroke._renderer.offset.x, - stroke._renderer.offset.y);
              ctx.scale(stroke._renderer.scale.x, stroke._renderer.scale.y);
              ctx.lineWidth = linewidth / stroke._renderer.scale.x;
            }
            ctx.stroke();
            if (isOffset) {
              ctx.restore();
            }
          }
        }

        if (!defaultMatrix) {
          ctx.restore();
        }

        if (clip && !parentClipped) {
          ctx.clip();
        }

        if (dashes && dashes.length > 0) {
          ctx.setLineDash(emptyArray);
        }

        return this.flagReset();

      }

    },

    text: {

      render: function(ctx, forced, parentClipped) {

        var po = (this.parent && this.parent._renderer)
          ? this.parent._renderer.opacity : 1;
        var opacity = this._opacity * po;
        var visible = this._visible;
        var mask = this._mask;
        var clip = this._clip;

        if (!forced && (!visible || clip || opacity === 0)) {
          return this;
        }

        this._update();

        var matrix = this._matrix.elements;
        var stroke = this._stroke;
        var linewidth = this._linewidth;
        var fill = this._fill;
        var decoration = this._decoration;
        var defaultMatrix = isDefaultMatrix(matrix);
        var isOffset = fill._renderer && fill._renderer.offset
          && stroke._renderer && stroke._renderer.offset;
        var dashes = this.dashes;
        var alignment = canvas.alignments[this._alignment] || this._alignment;
        var baseline = this._baseline;

        var a, b, c, d, e, sx, sy, x1, y1, x2, y2;

        // Transform
        if (!defaultMatrix) {
          ctx.save();
          ctx.transform(matrix[0], matrix[3], matrix[1], matrix[4], matrix[2], matrix[5]);
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951
        if (mask) {
          canvas[mask._renderer.type].render.call(mask, ctx, true);
        }

        if (!isOffset) {
          ctx.font = [this._style, this._weight, this._size + 'px/' +
            this._leading + 'px', this._family].join(' ');
        }

        ctx.textAlign = alignment;
        ctx.textBaseline = baseline;

        // Styles
        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            canvas[fill._renderer.type].render.call(fill, ctx);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            canvas[stroke._renderer.type].render.call(stroke, ctx);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }
        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        if (!clip && !parentClipped) {

          if (!canvas.isHidden.test(fill)) {

            if (fill._renderer && fill._renderer.offset) {

              sx = fill._renderer.scale.x;
              sy = fill._renderer.scale.y;

              ctx.save();
              ctx.translate( - fill._renderer.offset.x,
                - fill._renderer.offset.y);
              ctx.scale(sx, sy);

              a = this._size / fill._renderer.scale.y;
              b = this._leading / fill._renderer.scale.y;
              ctx.font = [this._style, this._weight, a + 'px/',
                b + 'px', this._family].join(' ');

              c = fill._renderer.offset.x / fill._renderer.scale.x;
              d = fill._renderer.offset.y / fill._renderer.scale.y;

              ctx.fillText(this.value, c, d);
              ctx.restore();

            } else {
              ctx.fillText(this.value, 0, 0);
            }

          }

          if (!canvas.isHidden.test(stroke)) {

            if (stroke._renderer && stroke._renderer.offset) {

              sx = stroke._renderer.scale.x;
              sy = stroke._renderer.scale.y;

              ctx.save();
              ctx.translate(- stroke._renderer.offset.x,
                - stroke._renderer.offset.y);
              ctx.scale(sx, sy);

              a = this._size / stroke._renderer.scale.y;
              b = this._leading / stroke._renderer.scale.y;
              ctx.font = [this._style, this._weight, a + 'px/',
                b + 'px', this._family].join(' ');

              c = stroke._renderer.offset.x / stroke._renderer.scale.x;
              d = stroke._renderer.offset.y / stroke._renderer.scale.y;
              e = linewidth / stroke._renderer.scale.x;

              ctx.lineWidth = e;
              ctx.strokeText(this.value, c, d);
              ctx.restore();

            } else {
              ctx.strokeText(this.value, 0, 0);
            }
          }
        }

        // Handle text-decoration
        if (/(underline|strikethrough)/i.test(decoration)) {

          var metrics = ctx.measureText(this.value);
          var scalar = 1;

          switch (decoration) {
            case 'underline':
              y1 = metrics.actualBoundingBoxAscent;
              y2 = metrics.actualBoundingBoxAscent;
              break;
            case 'strikethrough':
              y1 = 0;
              y2 = 0;
              scalar = 0.5;
              break;
          }

          switch (baseline) {
            case 'top':
              y1 += this._size * scalar;
              y2 += this._size * scalar;
              break;
            case 'baseline':
            case 'bottom':
              y1 -= this._size * scalar;
              y2 -= this._size * scalar;
              break;
          }

          switch (alignment) {
            case 'left':
            case 'start':
              x1 = 0;
              x2 = metrics.width;
              break;
            case 'right':
            case 'end':
              x1 = - metrics.width;
              x2 = 0;
              break;
            default:
              x1 = - metrics.width / 2;
              x2 = metrics.width / 2;
          }

          ctx.lineWidth = Math.max(Math.floor(this._size / 15), 1);
          ctx.strokeStyle = ctx.fillStyle;

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();

        }

        if (!defaultMatrix) {
          ctx.restore();
        }

        // TODO: Test for text
        if (clip && !parentClipped) {
          ctx.clip();
        }

        if (dashes && dashes.length > 0) {
          ctx.setLineDash(emptyArray);
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(ctx) {

        this._update();

        if (!this._renderer.effect || this._flagEndPoints || this._flagStops) {

          this._renderer.effect = ctx.createLinearGradient(
            this.left._x, this.left._y,
            this.right._x, this.right._y
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(ctx) {

        this._update();

        if (!this._renderer.effect || this._flagCenter || this._flagFocal
            || this._flagRadius || this._flagStops) {

          this._renderer.effect = ctx.createRadialGradient(
            this.center._x, this.center._y, 0,
            this.focal._x, this.focal._y, this._radius
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(ctx) {

        this._update();

        var image = this.image;

        if (!this._renderer.effect || ((this._flagLoaded || this._flagImage || this._flagVideo || this._flagRepeat) && this.loaded)) {
          this._renderer.effect = ctx.createPattern(this.image, this._repeat);
        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          if (!(this._renderer.offset instanceof Vector)) {
            this._renderer.offset = new Vector();
          }

          this._renderer.offset.x = - this._offset.x;
          this._renderer.offset.y = - this._offset.y;

          if (image) {

            this._renderer.offset.x += image.width / 2;
            this._renderer.offset.y += image.height / 2;

            if (this._scale instanceof Vector) {
              this._renderer.offset.x *= this._scale.x;
              this._renderer.offset.y *= this._scale.y;
            } else {
              this._renderer.offset.x *= this._scale;
              this._renderer.offset.y *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }

          if (this._scale instanceof Vector) {
            this._renderer.scale.copy(this._scale);
          } else {
            this._renderer.scale.set(this._scale, this._scale);
          }

        }

        return this.flagReset();

      }

    },

    renderSvgArcCommand: function(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y) {

      xAxisRotation = xAxisRotation * Math.PI / 180;

      // Ensure radii are positive
      rx = abs(rx);
      ry = abs(ry);

      // Compute (x1â€², y1â€²)
      var dx2 = (ax - x) / 2.0;
      var dy2 = (ay - y) / 2.0;
      var x1p = cos$4(xAxisRotation) * dx2 + sin$4(xAxisRotation) * dy2;
      var y1p = - sin$4(xAxisRotation) * dx2 + cos$4(xAxisRotation) * dy2;

      // Compute (cxâ€², cyâ€²)
      var rxs = rx * rx;
      var rys = ry * ry;
      var x1ps = x1p * x1p;
      var y1ps = y1p * y1p;

      // Ensure radii are large enough
      var cr = x1ps / rxs + y1ps / rys;

      if (cr > 1) {

        // scale up rx,ry equally so cr == 1
        var s = sqrt(cr);
        rx = s * rx;
        ry = s * ry;
        rxs = rx * rx;
        rys = ry * ry;

      }

      var dq = (rxs * y1ps + rys * x1ps);
      var pq = (rxs * rys - dq) / dq;
      var q = sqrt(max$2(0, pq));
      if (largeArcFlag === sweepFlag) q = - q;
      var cxp = q * rx * y1p / ry;
      var cyp = - q * ry * x1p / rx;

      // Step 3: Compute (cx, cy) from (cxâ€², cyâ€²)
      var cx = cos$4(xAxisRotation) * cxp
        - sin$4(xAxisRotation) * cyp + (ax + x) / 2;
      var cy = sin$4(xAxisRotation) * cxp
        + cos$4(xAxisRotation) * cyp + (ay + y) / 2;

      // Step 4: Compute Î¸1 and Î”Î¸
      var startAngle = svgAngle(1, 0, (x1p - cxp) / rx, (y1p - cyp) / ry);
      var delta = svgAngle((x1p - cxp) / rx, (y1p - cyp) / ry,
        (- x1p - cxp) / rx, (- y1p - cyp) / ry) % TWO_PI$5;

      var endAngle = startAngle + delta;

      var clockwise = sweepFlag === 0;

      renderArcEstimate(ctx, cx, cy, rx, ry, startAngle, endAngle,
        clockwise, xAxisRotation);

    }

  };

  /**
   * @name Two.CanvasRenderer
   * @class
   * @extends Two.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<canvas />` to draw to. If none given a new one will be constructed.
   * @param {Boolean} [parameters.overdraw] - Determines whether the canvas should clear the background or not. Defaults to `true`.
   * @param {Boolean} [parameters.smoothing=true] - Determines whether the canvas should antialias drawing. Set it to `false` when working with pixel art. `false` can lead to better performance, since it would use a cheaper interpolation algorithm.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.canvas`. It takes Two.js' scenegraph and renders it to a `<canvas />`.
   */
  function Renderer$2(params) {

    // It might not make a big difference on GPU backed canvases.
    var smoothing = (params.smoothing !== false);

    /**
     * @name Two.CanvasRenderer#domElement
     * @property {Element} - The `<canvas />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || document.createElement('canvas');

    /**
     * @name Two.CanvasRenderer#ctx
     * @property {Canvas2DContext} - Associated two dimensional context to render on the `<canvas />`.
     */
    this.ctx = this.domElement.getContext('2d');

    /**
     * @name Two.CanvasRenderer#overdraw
     * @property {Boolean} - Determines whether the canvas clears the background each draw call.
     * @default true
     */
    this.overdraw = params.overdraw || false;

    if (typeof this.ctx.imageSmoothingEnabled !== 'undefined') {
      this.ctx.imageSmoothingEnabled = smoothing;
    }

    /**
     * @name Two.CanvasRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Group();
    this.scene.parent = this;
  }


  _.extend(Renderer$2, {

    /**
     * @name Two.CanvasRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<canvas />`.
     */
    Utils: canvas

  });

  _.extend(Renderer$2.prototype, Events, {

    constructor: Renderer$2,

    /**
     * @name Two.CanvasRenderer#setSize
     * @function
     * @fires resize
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @param {Number} [ratio] - The new pixel ratio (pixel density) of the renderer. Defaults to calculate the pixel density of the user's screen.
     * @description Change the size of the renderer.
     */
    setSize: function(width, height, ratio) {

      this.width = width;
      this.height = height;

      this.ratio = typeof ratio === 'undefined' ? getRatio(this.ctx) : ratio;

      this.domElement.width = width * this.ratio;
      this.domElement.height = height * this.ratio;

      if (this.domElement.style) {
        _.extend(this.domElement.style, {
          width: width + 'px',
          height: height + 'px'
        });
      }

      return this.trigger(Events.Types.resize, width, height, ratio);

    },

    /**
     * @name Two.CanvasRenderer#render
     * @function
     * @description Render the current scene to the `<canvas />`.
     */
    render: function() {

      var isOne = this.ratio === 1;

      if (!isOne) {
        this.ctx.save();
        this.ctx.scale(this.ratio, this.ratio);
      }

      if (!this.overdraw) {
        this.ctx.clearRect(0, 0, this.width, this.height);
      }

      canvas.group.render.call(this.scene, this.ctx);

      if (!isOne) {
        this.ctx.restore();
      }

      return this;

    }

  });

  function renderArcEstimate(ctx, ox, oy, rx, ry, startAngle, endAngle, clockwise, xAxisRotation) {

    var epsilon = Curve.Tolerance.epsilon;
    var deltaAngle = endAngle - startAngle;
    var samePoints = Math.abs(deltaAngle) < epsilon;

    // ensures that deltaAngle is 0 .. 2 PI
    deltaAngle = mod(deltaAngle, TWO_PI$5);

    if (deltaAngle < epsilon) {

      if (samePoints) {

        deltaAngle = 0;

      } else {

        deltaAngle = TWO_PI$5;

      }

    }

    if (clockwise === true && ! samePoints) {

      if (deltaAngle === TWO_PI$5) {

        deltaAngle = - TWO_PI$5;

      } else {

        deltaAngle = deltaAngle - TWO_PI$5;

      }

    }

    for (var i = 0; i < Constants.Resolution; i++) {

      var t = i / (Constants.Resolution - 1);

      var angle = startAngle + t * deltaAngle;
      var x = ox + rx * Math.cos(angle);
      var y = oy + ry * Math.sin(angle);

      if (xAxisRotation !== 0) {

        var cos = Math.cos(xAxisRotation);
        var sin = Math.sin(xAxisRotation);

        var tx = x - ox;
        var ty = y - oy;

        // Rotate the point about the center of the ellipse.
        x = tx * cos - ty * sin + ox;
        y = tx * sin + ty * cos + oy;

      }

      ctx.lineTo(x, y);

    }

  }

  function svgAngle(ux, uy, vx, vy) {

    var dot = ux * vx + uy * vy;
    var len = sqrt(ux * ux + uy * uy) *  sqrt(vx * vx + vy * vy);
    // floating point precision, slightly over values appear
    var ang = acos(max$2(-1, min$2(1, dot / len)));
    if ((ux * vy - uy * vx) < 0) {
      ang = - ang;
    }

    return ang;

  }

  var CanvasShim = {

    Image: null,

    isHeadless: false,

    /**
     * @name Two.Utils.shim
     * @function
     * @param {canvas} canvas - The instanced `Canvas` object provided by `node-canvas`.
     * @param {Image} [Image] - The prototypical `Image` object provided by `node-canvas`. This is only necessary to pass if you're going to load bitmap imagery.
     * @returns {canvas} Returns the instanced canvas object you passed from with additional attributes needed for Two.js.
     * @description Convenience method for defining all the dependencies from the npm package `node-canvas`. See [node-canvas](https://github.com/Automattic/node-canvas) for additional information on setting up HTML5 `<canvas />` drawing in a node.js environment.
     */
    shim: function(canvas, Image) {
      Renderer$2.Utils.shim(canvas);
      if (typeof Image !== 'undefined') {
        CanvasShim.Image = Image;
      }
      CanvasShim.isHeadless = true;
      return canvas;
    }

  };

  var dom = {

    hasEventListeners: typeof root$1.addEventListener === 'function',

    bind: function(elem, event, func, bool) {
      if (this.hasEventListeners) {
        elem.addEventListener(event, func, !!bool);
      } else {
        elem.attachEvent('on' + event, func);
      }
      return dom;
    },

    unbind: function(elem, event, func, bool) {
      if (dom.hasEventListeners) {
        elem.removeEventListeners(event, func, !!bool);
      } else {
        elem.detachEvent('on' + event, func);
      }
      return dom;
    },

    getRequestAnimationFrame: function() {

      var lastTime = 0;
      var vendors = ['ms', 'moz', 'webkit', 'o'];
      var request = root$1.requestAnimationFrame, cancel;

      if(!request) {
        for (var i = 0; i < vendors.length; i++) {
          request = root$1[vendors[i] + 'RequestAnimationFrame'] || request;
          cancel = root$1[vendors[i] + 'CancelAnimationFrame']
            || root$1[vendors[i] + 'CancelRequestAnimationFrame'] || cancel;
        }

        request = request || function(callback, element) {
          var currTime = new Date().getTime();
          var timeToCall = Math.max(0, 16 - (currTime - lastTime));
          var id = root$1.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
          lastTime = currTime + timeToCall;
          return id;
        };
      }

      return request;

    }

  };

  var temp = (root$1.document ? root$1.document.createElement('div') : {});
  temp.id = 'help-two-load';

  Object.defineProperty(dom, 'temp', {
    enumerable: true,
    get: function() {
      if (_.isElement(temp) && !root$1.document.head.contains(temp)) {
        _.extend(temp.style, {
          display: 'none'
        });
        root$1.document.head.appendChild(temp);
      }
      return temp;
    }
  });

  /**
   * @name Two.Utils.Error
   * @class
   * @description Custom error throwing for Two.js specific identification.
   */
  function TwoError(message) {
    this.name = 'Two.js';
    this.message = message;
  }

  TwoError.prototype = new Error();

  _.extend(TwoError.prototype, {
    constructor: TwoError
  });

  /**
   * @name Two.Utils.defineGetterSetter
   * @function
   * @this Two#
   * @param {String} property - The property to add an enumerable getter / setter to.
   * @description Convenience function to setup the flag based getter / setter that most properties are defined as in Two.js.
   */
  var defineGetterSetter = function(property) {

    var object = this;
    var secret = '_' + property;
    var flag = '_flag' + property.charAt(0).toUpperCase() + property.slice(1);

    Object.defineProperty(object, property, {
      enumerable: true,
      get: function() {
        return this[secret];
      },
      set: function(v) {
        this[secret] = v;
        this[flag] = true;
      }
    });

  };

  /**
   * @name Two.Registry
   * @class
   * @description An arbitrary class to manage a directory of things. Mainly used for keeping tabs of textures in Two.js.
   */
  function Registry() {

    this.map = {};

  }

  _.extend(Registry.prototype, {

    constructor: Registry,

    /**
     * @name Two.Registry#add
     * @function
     * @param {String} id - A unique identifier.
     * @param value - Any type of variable to be registered to the directory.
     * @description Adds any value to the directory. Assigned by the `id`.
     */
    add: function(id, obj) {
      this.map[id] = obj;
      return this;
    },

    /**
     * @name Two.Registry#remove
     * @function
     * @param {String} id - A unique identifier.
     * @description Remove any value from the directory by its `id`.
     */
    remove: function(id) {
      delete this.map[id];
      return this;
    },

    /**
     * @name Two.Registry#get
     * @function
     * @param {String} id - A unique identifier.
     * @returns {?Object} The associated value. If unavailable then `undefined` is returned.
     * @description Get a registered value by its `id`.
     */
    get: function(id) {
      return this.map[id];
    },

    /**
     * @name Two.Registry#contains
     * @function
     * @param {String} id - A unique identifier.
     * @returns {Boolean}
     * @description Convenience method to see if a value is registered to an `id` already.
     */
    contains: function(id) {
      return id in this.map;
    }

  });

  /**
   * @name Two.Stop
   * @class
   * @param {Number} [offset] - The offset percentage of the stop represented as a zero-to-one value. Default value flip flops from zero-to-one as new stops are created.
   * @param {String} [color] - The color of the stop. Default value flip flops from white to black as new stops are created.
   * @param {Number} [opacity] - The opacity value. Default value is 1, cannot be lower than 0.
   * @nota-bene Used specifically in conjunction with {@link Two.Gradient}s to control color graduation.
   */
  function Stop(offset, color, opacity) {

    /**
     * @name Two.Stop#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.type = 'stop';

    /**
     * @name Two.Stop#offset
     * @property {Number} - The offset percentage of the stop represented as a zero-to-one value.
     */
    this.offset = typeof offset === 'number' ? offset
      : Stop.Index <= 0 ? 0 : 1;

    /**
     * @name Two.Stop#opacity
     * @property {Number} - The alpha percentage of the stop represented as a zero-to-one value.
     */
    this.opacity = typeof opacity === 'number' ? opacity : 1;

    /**
     * @name Two.Stop#color
     * @property {String} - The color of the stop.
     */
    this.color = (typeof color === 'string') ? color
      : Stop.Index <= 0 ? '#fff' : '#000';

    Stop.Index = (Stop.Index + 1) % 2;

  }

  _.extend(Stop, {

    /**
     * @name Two.Stop.Index
     * @property {Number} - The current index being referenced for calculating a stop's default offset value.
     */
    Index: 0,

    /**
     * @name Two.Stop.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Stop}.
     */
    Properties: [
      'offset',
      'opacity',
      'color'
    ],

    /**
     * @name Two.Stop.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Stop} to any object. Handy if you'd like to extend the {@link Two.Stop} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Stop.Properties, function(property) {

        var object = this;
        var secret = '_' + property;
        var flag = '_flag' + property.charAt(0).toUpperCase() + property.slice(1);

        Object.defineProperty(object, property, {
          enumerable: true,
          get: function() {
            return this[secret];
          },
          set: function(v) {
            this[secret] = v;
            this[flag] = true;
            if (this.parent) {
              this.parent._flagStops = true;
            }
          }
        });

      }, object);

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

    }

  });

  _.extend(Stop.prototype, Events, {

    constructor: Stop,

    /**
     * @name Two.Stop#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Stop}
     * @description Create a new instance of {@link Two.Stop} with the same properties of the current path.
     */
    clone: function() {

      var clone = new Stop();

      _.each(Stop.Properties, function(property) {
        clone[property] = this[property];
      }, this);

      return clone;

    },

    /**
     * @name Two.Stop#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {};

      _.each(Stop.Properties, function(k) {
        result[k] = this[k];
      }, this);

      return result;

    },

    /**
     * @name Two.Stop#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagOffset = this._flagColor = this._flagOpacity = false;

      return this;

    }

  });

  Stop.MakeObservable(Stop.prototype);

  /**
   * @name Two.Gradient
   * @class
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @description This is the base class for constructing different types of gradients with Two.js. The two common gradients are {@link Two.LinearGradient} and {@link Two.RadialGradient}.
   */
  function Gradient(stops) {

    /**
     * @name Two.Gradient#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.type = 'gradient';

    /**
     * @name Two.Gradient#id
     * @property {String} - Session specific unique identifier.
     * @nota-bene In the {@link Two.SvgRenderer} change this to change the underlying SVG element's id too.
     */
    this.id = Constants.Identifier + Constants.uniqueId();
    this.classList = [];

    this._renderer.flagStops = Gradient.FlagStops.bind(this);
    this._renderer.bindStops = Gradient.BindStops.bind(this);
    this._renderer.unbindStops = Gradient.UnbindStops.bind(this);

    /**
     * @name Two.Gradient#spread
     * @property {String} - Indicates what happens if the gradient starts or ends inside the bounds of the target rectangle. Possible values are `'pad'`, `'reflect'`, and `'repeat'`.
     * @see {@link https://www.w3.org/TR/SVG11/pservers.html#LinearGradientElementSpreadMethodAttribute} for more information
     */
    this.spread = 'pad';

    /**
     * @name Two.Gradient#stops
     * @property {Two.Stop[]} - An ordered list of {@link Two.Stop}s for rendering the gradient.
     */
    if (stops) {
      this.stops = stops;
    }

  }

  _.extend(Gradient, {

    /**
     * @name Two.Gradient.Stop
     * @see {@link Two.Stop}
     */
    Stop: Stop,

    /**
     * @name Two.Gradient.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Gradient}.
     */
    Properties: [
      'spread'
    ],

    /**
     * @name Two.Gradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Gradient} to any object. Handy if you'd like to extend the {@link Two.Gradient} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Gradient.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'stops', {

        enumerable: true,

        get: function() {
          return this._stops;
        },

        set: function(stops) {

          var bindStops = this._renderer.bindStops;
          var unbindStops = this._renderer.unbindStops;

          // Remove previous listeners
          if (this._stops) {
            this._stops
              .unbind(Events.Types.insert, bindStops)
              .unbind(Events.Types.remove, unbindStops);
          }

          // Create new Collection with copy of Stops
          this._stops = new Collection((stops || []).slice(0));

          // Listen for Collection changes and bind / unbind
          this._stops
            .bind(Events.Types.insert, bindStops)
            .bind(Events.Types.remove, unbindStops);

          // Bind Initial Stops
          bindStops(this._stops);

        }

      });

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

      Object.defineProperty(object, 'id', {

        enumerable: true,

        get: function() {
          return this._id;
        },

        set: function(v) {
          this._id = v;
        }

      });

    },

    /**
     * @name Two.Gradient.FlagStops
     * @function
     * @description Cached method to let renderers know stops have been updated on a {@link Two.Gradient}.
     */
    FlagStops: function() {
      this._flagStops = true;
    },

    /**
     * @name Two.Gradient.BindVertices
     * @function
     * @description Cached method to let {@link Two.Gradient} know vertices have been added to the instance.
     */
    BindStops: function(items) {

      // This function is called a lot
      // when importing a large SVG
      var i = items.length;
      while(i--) {
        items[i].bind(Events.Types.change, this._renderer.flagStops);
        items[i].parent = this;
      }

      this._renderer.flagStops();

    },

    /**
     * @name Two.Gradient.UnbindStops
     * @function
     * @description Cached method to let {@link Two.Gradient} know vertices have been removed from the instance.
     */
    UnbindStops: function(items) {

      var i = items.length;
      while(i--) {
        items[i].unbind(Events.Types.change, this._renderer.flagStops);
        delete items[i].parent;
      }

      this._renderer.flagStops();

    }

  });

  _.extend(Gradient.prototype, Events, {

    constructor: Gradient,

    /**
     * @name Two.Gradient#_flagId
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#id} needs updating.
     */
    _flagId: false,

    /**
     * @name Two.Gradient#_flagStops
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#stops} needs updating.
     */
    _flagStops: false,
    /**
     * @name Two.Gradient#_flagSpread
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Gradient#spread} needs updating.
     */
    _flagSpread: false,

    _id: '',

    /**
     * @name Two.Gradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.Gradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = this.stops.map(function(s) {
        return s.clone();
      });

      var clone = new Gradient(stops);

      _.each(Gradient.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Gradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {
        stops: this.stops.map(function(s) {
          return s.toObject();
        })
      };

      _.each(Gradient.Properties, function(k) {
        result[k] = this[k];
      }, this);

      return result;

    },

    /**
     * @name Two.Gradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagSpread || this._flagStops) {
        this.trigger(Events.Types.change);
      }

      return this;

    },

    /**
     * @name Two.Gradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagSpread = this._flagStops = false;

      return this;

    }

  });

  Gradient.MakeObservable(Gradient.prototype);

  /**
   * @name Two.LinearGradient
   * @class
   * @extends Two.Gradient
   * @param {Number} [x1=0] - The x position of the first end point of the linear gradient.
   * @param {Number} [y1=0] - The y position of the first end point of the linear gradient.
   * @param {Number} [x2=0] - The x position of the second end point of the linear gradient.
   * @param {Number} [y2=0] - The y position of the second end point of the linear gradient.
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @nota-bene The linear gradient lives within the space of the parent object's matrix space.
   */
  function LinearGradient(x1, y1, x2, y2, stops) {

    Gradient.call(this, stops);

    this._renderer.type = 'linear-gradient';

    var flagEndPoints = LinearGradient.FlagEndPoints.bind(this);

    /**
     * @name Two.LinearGradient#left
     * @property {Two.Vector} - The x and y value for where the first end point is placed on the canvas.
     */
    this.left = new Vector().bind(Events.Types.change, flagEndPoints);
    /**
     * @name Two.LinearGradient#right
     * @property {Two.Vector} - The x and y value for where the second end point is placed on the canvas.
     */
    this.right = new Vector().bind(Events.Types.change, flagEndPoints);

    if (typeof x1 === 'number') {
      this.left.x = x1;
    }
    if (typeof y1 === 'number') {
      this.left.y = y1;
    }
    if (typeof x2 === 'number') {
      this.right.x = x2;
    }
    if (typeof y2 === 'number') {
      this.right.y = y2;
    }

  }

  _.extend(LinearGradient, {

    /**
     * @name Two.LinearGradient.Stop
     * @see {@link Two.Stop}
     */
    Stop: Stop,

    /**
     * @name Two.LinearGradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.LinearGradient} to any object. Handy if you'd like to extend the {@link Two.LinearGradient} class on a custom class.
     */
    MakeObservable: function(object) {
      Gradient.MakeObservable(object);
    },

    /**
     * @name Two.LinearGradient.FlagEndPoints
     * @function
     * @description Cached method to let renderers know end points have been updated on a {@link Two.LinearGradient}.
     */
    FlagEndPoints: function() {
      this._flagEndPoints = true;
    }

  });

  _.extend(LinearGradient.prototype, Gradient.prototype, {

    constructor: LinearGradient,

    /**
     * @name Two.LinearGradient#_flagEndPoints
     * @private
     * @property {Boolean} - Determines whether the {@link Two.LinearGradient#left} or {@link Two.LinearGradient#right} changed and needs to update.
     */
    _flagEndPoints: false,

    /**
     * @name Two.LinearGradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.LinearGradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = this.stops.map(function(stop) {
        return stop.clone();
      });

      var clone = new LinearGradient(this.left._x, this.left._y,
        this.right._x, this.right._y, stops);

      _.each(Gradient.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.LinearGradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = Gradient.prototype.toObject.call(this);

      result.left = this.left.toObject();
      result.right = this.right.toObject();

      return result;

    },

    /**
     * @name Two.LinearGradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagEndPoints || this._flagSpread || this._flagStops) {
        this.trigger(Events.Types.change);
      }

      return this;

    },

    /**
     * @name Two.LinearGradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagEndPoints = false;

      Gradient.prototype.flagReset.call(this);

      return this;

    }

  });

  LinearGradient.MakeObservable(LinearGradient.prototype);

  /**
   * @name Two.RadialGradient
   * @class
   * @extends Two.Gradient
   * @param {Number} [x=0] - The x position of the origin of the radial gradient.
   * @param {Number} [y=0] - The y position of the origin of the radial gradient.
   * @param {Number} [radius=0] - The radius of the radial gradient.
   * @param {Two.Stop[]} [stops] - A list of {@link Two.Stop}s that contain the gradient fill pattern for the gradient.
   * @param {Number} [focalX=0] - The x position of the focal point on the radial gradient.
   * @param {Number} [focalY=0] - The y position of the focal point on the radial gradient.
   * @nota-bene The radial gradient lives within the space of the parent object's matrix space.
   */
  function RadialGradient(cx, cy, r, stops, fx, fy) {

    Gradient.call(this, stops);

    this._renderer.type = 'radial-gradient';

    /**
     * @name Two.RadialGradient#center
     * @property {Two.Vector} - The x and y value for where the origin of the radial gradient is.
     */
    this.center = new Vector()
      .bind(Events.Types.change, (function() {
        this._flagCenter = true;
      }).bind(this));

    this.radius = typeof r === 'number' ? r : 20;

    /**
     * @name Two.RadialGradient#focal
     * @property {Two.Vector} - The x and y value for where the focal point of the radial gradient is.
     * @nota-bene This effects the spray or spread of the radial gradient.
     */
    this.focal = new Vector()
      .bind(Events.Types.change, (function() {
        this._flagFocal = true;
      }).bind(this));

    if (typeof cx === 'number') {
      this.center.x = cx;
    }
    if (typeof cy === 'number') {
      this.center.y = cy;
    }

    this.focal.copy(this.center);

    if (typeof fx === 'number') {
      this.focal.x = fx;
    }
    if (typeof fy === 'number') {
      this.focal.y = fy;
    }

  }

  _.extend(RadialGradient, {

    /**
     * @name Two.RadialGradient.Stop
     * @see {@link Two.Stop}
     */
    Stop: Stop,

    /**
     * @name Two.RadialGradient.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.RadialGradient}.
     */
    Properties: [
      'radius'
    ],

    /**
     * @name Two.RadialGradient.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.RadialGradient} to any object. Handy if you'd like to extend the {@link Two.RadialGradient} class on a custom class.
     */
    MakeObservable: function(object) {

      Gradient.MakeObservable(object);

      _.each(RadialGradient.Properties, defineGetterSetter, object);

    }

  });

  _.extend(RadialGradient.prototype, Gradient.prototype, {

    constructor: RadialGradient,

    /**
     * @name Two.RadialGradient#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#radius} changed and needs to update.
     */
    _flagRadius: false,
    /**
     * @name Two.RadialGradient#_flagCenter
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#center} changed and needs to update.
     */
    _flagCenter: false,
    /**
     * @name Two.RadialGradient#_flagFocal
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RadialGradient#focal} changed and needs to update.
     */
    _flagFocal: false,

    /**
     * @name Two.RadialGradient#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Gradient}
     * @description Create a new instance of {@link Two.RadialGradient} with the same properties of the current path.
     */
    clone: function(parent) {

      var stops = this.stops.map(function(stop) {
        return stop.clone();
      });

      var clone = new RadialGradient(this.center._x, this.center._y,
          this._radius, stops, this.focal._x, this.focal._y);

      _.each(Gradient.Properties.concat(RadialGradient.Properties), function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.RadialGradient#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = Gradient.prototype.toObject.call(this);

      _.each(RadialGradient.Properties, function(k) {
        result[k] = this[k];
      }, this);

      result.center = this.center.toObject();
      result.focal = this.focal.toObject();

      return result;

    },

    /**
     * @name Two.RadialGradient#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagRadius || this._flatCenter || this._flagFocal
        || this._flagSpread || this._flagStops) {
        this.trigger(Events.Types.change);
      }

      return this;

    },

    /**
     * @name Two.RadialGradient#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagRadius = this._flagCenter = this._flagFocal = false;

      Gradient.prototype.flagReset.call(this);

      return this;

    }

  });

  RadialGradient.MakeObservable(RadialGradient.prototype);

  var anchor;
  var regex$1 = {
    video: /\.(mp4|webm|ogg)$/i,
    image: /\.(jpe?g|png|gif|tiff|webp)$/i,
    effect: /texture|gradient/i
  };

  if (root$1.document) {
    anchor = document.createElement('a');
  }

  /**
   * @name Two.Texture
   * @class
   * @extends Two.Shape
   * @param {String|HTMLImageElement} [src] - The URL path to an image file or an `<img />` element.
   * @param {Function} [callback] - An optional callback function once the image has been loaded.
   * @description Fundamental to work with bitmap data, a.k.a. pregenerated imagery, in Two.js. Supported formats include jpg, png, gif, and tiff. See {@link Two.Texture.RegularExpressions} for a full list of supported formats.
   */
  function Texture(src, callback) {

    /**
     * @name Two.Texture#renderer
     * @property {Object}
     * @description Object access to store relevant renderer specific variables. Warning: manipulating this object can create unintended consequences.
     * @nota-bene With the {@link Two.SvgRenderer} you can access the underlying SVG element created via `shape.renderer.elem`.
     */
    this.renderer = {};
    this._renderer.type = 'texture';
    this._renderer.flagOffset = Texture.FlagOffset.bind(this);
    this._renderer.flagScale = Texture.FlagScale.bind(this);

    this.id = Constants.Identifier + Constants.uniqueId();
    this.classList = [];

    /**
     * @name Two.Texture#loaded
     * @property {Boolean} - Shorthand value to determine if image has been loaded into the texture.
     */
    this.loaded = false;

    /**
     * @name Two.Texture#repeat
     * @property {String} - CSS style declaration to tile {@link Two.Path}. Valid values include: `'no-repeat'`, `'repeat'`, `'repeat-x'`, `'repeat-y'`.
     * @see {@link https://www.w3.org/TR/2dcontext/#dom-context-2d-createpattern}
     */
    this.repeat = 'no-repeat';

    /**
     * @name Two.Texture#offset
     * @property {Two.Vector} - A two-component vector describing any pixel offset of the texture when applied to a {@link Two.Path}.
     */
    this.offset = new Vector();

    if (typeof callback === 'function') {
      var loaded = (function() {
        this.unbind(Events.Types.load, loaded);
        if (typeof callback === 'function') {
          callback();
        }
      }).bind(this);
      this.bind(Events.Types.load, loaded);
    }

    /**
     * @name Two.Texture#src
     * @property {String} - The URL path to the image data.
     * @nota-bene This property is ultimately serialized in a {@link Two.Registry} to cache retrieval.
     */
    if (typeof src === 'string') {
      this.src = src;
    } else if (typeof src === 'object') {
      var elemString = Object.prototype.toString.call(src);
      if (
        elemString === '[object HTMLImageElement]' ||
        elemString === '[object HTMLCanvasElement]' ||
        elemString === '[object HTMLVideoElement]' ||
        elemString === '[object Image]'
      ) {
        /**
         * @name Two.Texture#image
         * @property {Element} - The corresponding DOM Element of the texture. Can be a `<img />`, `<canvas />`, or `<video />` element. See {@link Two.Texture.RegularExpressions} for a full list of supported elements.
         * @nota-bene In headless environments this is a `Canvas.Image` object. See {@link https://github.com/Automattic/node-canvas} for more information on headless image objects.
         */
        this.image = src;
      }
    }

    this._update();

  }

  _.extend(Texture, {

    /**
     * @name Two.Texture.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Texture}.
     */
    Properties: [
      'id',
      'src',
      'loaded',
      'repeat'
    ],

    /**
     * @name Two.Texture.RegularExpressions
     * @property {Object} - A map of compatible DOM Elements categorized by media format.
     */
    RegularExpressions: regex$1,

    /**
     * @name Two.Texture.ImageRegistry
     * @property {Two.Registry} - A canonical listing of image data used in a single session of Two.js.
     * @nota-bene This object is used to cache image data between different textures.
     */
    ImageRegistry: new Registry(),

    /**
     * @name Two.Texture.getAbsoluteURL
     * @property {Function} - Serializes a URL as an absolute path for canonical attribution in {@link Two.ImageRegistry}.
     * @param {String} path
     * @returns {String} - The serialized absolute path.
     */
    getAbsoluteURL: function(path) {
      if (!anchor) {
        // TODO: Fix for headless environments
        return path;
      }
      anchor.href = path;
      return anchor.href;
    },

    /**
     * @name Two.Texture.loadHeadlessBuffer
     * @property {Function} - Loads an image as a buffer in headless environments.
     * @param {Two.Texture} texture - The {@link Two.Texture} to be loaded.
     * @param {Function} loaded - The callback function to be triggered once the image is loaded.
     * @nota-bene - This function uses node's `fs.readFileSync` to spoof the `<img />` loading process in the browser.
     */
    loadHeadlessBuffer: function(texture, loaded) {

      texture.image.onload = loaded;
      texture.image.src = texture.src;

    },

    /**
     * @name Two.Texture.getTag
     * @property {Function} - Retrieves the tag name of an image, video, or canvas node.
     * @param {HTMLImageElement} - The image to infer the tag name from.
     * @returns {String} - Returns the tag name of an image, video, or canvas node.
     */
    getTag: function(image) {
      return (image && image.nodeName && image.nodeName.toLowerCase())
        // Headless environments
        || 'img';
    },

    /**
     * @name Two.Texture.getImage
     * @property {Function} - Convenience function to set {@link Two.Texture#image} properties with canonincal versions set in {@link Two.Texture.ImageRegistry}.
     * @param {String} src - The URL path of the image.
     * @returns {HTMLImageElement} - Returns either a cached version of the image or a new one that is registered in {@link Two.Texture.ImageRegistry}.
     */
    getImage: function(src) {

      var absoluteSrc = Texture.getAbsoluteURL(src);

      if (Texture.ImageRegistry.contains(absoluteSrc)) {
        return Texture.ImageRegistry.get(absoluteSrc);
      }

      var image;

      if (CanvasShim.Image) {

        // TODO: Fix for headless environments
        image = new CanvasShim.Image();
        Renderer$2.Utils.shim(image, 'img');

      } else if (root$1.document) {

        if (regex$1.video.test(absoluteSrc)) {
          image = document.createElement('video');
        } else {
          image = document.createElement('img');
        }

      } else {

        console.warn('Two.js: no prototypical image defined for Two.Texture');

      }

      image.crossOrigin = 'anonymous';

      return image;

    },

    /**
     * @name Two.Register
     * @interface
     * @description A collection of functions to register different types of textures. Used internally by a {@link Two.Texture}.
     */
    Register: {
      canvas: function(texture, callback) {
        texture._src = '#' + texture.id;
        Texture.ImageRegistry.add(texture.src, texture.image);
        if (typeof callback === 'function') {
          callback();
        }
      },
      img: function(texture, callback) {

        var image = texture.image;

        var loaded = function(e) {
          if (!CanvasShim.isHeadless && image.removeEventListener && typeof image.removeEventListener === 'function') {
            image.removeEventListener('load', loaded, false);
            image.removeEventListener('error', error, false);
          }
          if (typeof callback === 'function') {
            callback();
          }
        };
        var error = function(e) {
          if (!CanvasShim.isHeadless && typeof image.removeEventListener === 'function') {
            image.removeEventListener('load', loaded, false);
            image.removeEventListener('error', error, false);
          }
          throw new TwoError('unable to load ' + texture.src);
        };

        if (typeof image.width === 'number' && image.width > 0
          && typeof image.height === 'number' && image.height > 0) {
            loaded();
        } else if (!CanvasShim.isHeadless && typeof image.addEventListener === 'function') {
          image.addEventListener('load', loaded, false);
          image.addEventListener('error', error, false);
        }

        texture._src = Texture.getAbsoluteURL(texture._src);

        if (!CanvasShim.isHeadless && image && image.getAttribute('two-src')) {
          return;
        }

        if (!CanvasShim.isHeadless) {
          image.setAttribute('two-src', texture.src);
        }

        Texture.ImageRegistry.add(texture.src, image);

        if (CanvasShim.isHeadless) {

          Texture.loadHeadlessBuffer(texture, loaded);

        } else {

          texture.image.src = texture.src;

        }

      },
      video: function(texture, callback) {

        if (CanvasShim.isHeadless) {
          throw new TwoError('video textures are not implemented in headless environments.');
        }

        var loaded = function(e) {
          texture.image.removeEventListener('canplaythrough', loaded, false);
          texture.image.removeEventListener('error', error, false);
          texture.image.width = texture.image.videoWidth;
          texture.image.height = texture.image.videoHeight;
          if (typeof callback === 'function') {
            callback();
          }
        };
        var error = function(e) {
          texture.image.removeEventListener('canplaythrough', loaded, false);
          texture.image.removeEventListener('error', error, false);
          throw new TwoError('unable to load ' + texture.src);
        };

        texture._src = Texture.getAbsoluteURL(texture._src);

        if (!texture.image.getAttribute('two-src')) {
          texture.image.setAttribute('two-src', texture.src);
          Texture.ImageRegistry.add(texture.src, texture.image);
        }

        if (texture.image.readyState >= 4) {
          loaded();
        } else {
          texture.image.addEventListener('canplaythrough', loaded, false);
          texture.image.addEventListener('error', error, false);
          texture.image.src = texture.src;
          texture.image.load();
        }

      }
    },

    /**
     * @name Two.Texture.load
     * @function
     * @param {Two.Texture} texture - The texture to load.
     * @param {Function} callback - The function to be called once the texture is loaded.
     */
    load: function(texture, callback) {

      var image = texture.image;
      var tag = Texture.getTag(image);

      if (texture._flagImage) {
        if (/canvas/i.test(tag)) {
          Texture.Register.canvas(texture, callback);
        } else {
          texture._src = (!CanvasShim.isHeadless && image.getAttribute('two-src')) || image.src;
          Texture.Register[tag](texture, callback);
        }
      }

      if (texture._flagSrc) {
        if (!image) {
          image = Texture.getImage(texture.src);
          texture.image = image;
        }
        tag = Texture.getTag(image);
        Texture.Register[tag](texture, callback);
      }

    },

    /**
     * @name Two.Texture.FlagOffset
     * @function
     * @description Cached method to let renderers know `offset` has been updated on a {@link Two.Texture}.
     */
    FlagOffset: function() {
      this._flagOffset = true;
    },

    /**
     * @name Two.Texture.FlagScale
     * @function
     * @description Cached method to let renderers know `scale` has been updated on a {@link Two.Texture}.
     */
    FlagScale: function() {
      this._flagScale = true;
    },

    /**
     * @name Two.Texture.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Texture} to any object. Handy if you'd like to extend or inherit the {@link Two.Texture} class on a custom class.
     */
    MakeObservable: function(object) {

      _.each(Texture.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'image', {
        enumerable: true,
        get: function() {
          return this._image;
        },
        set: function(image) {

          var tag = Texture.getTag(image);
          var index;

          switch (tag) {
            case 'canvas':
              index = '#' + image.id;
              break;
            default:
              index = image.src;
          }

          if (Texture.ImageRegistry.contains(index)) {
            this._image = Texture.ImageRegistry.get(image.src);
          } else {
            this._image = image;
          }

          this._flagImage = true;

        }

      });

      Object.defineProperty(object, 'offset', {
        enumerable: true,
        get: function() {
          return this._offset;
        },
        set: function(v) {
          if (this._offset) {
            this._offset.unbind(Events.Types.change, this._renderer.flagOffset);
          }
          this._offset = v;
          this._offset.bind(Events.Types.change, this._renderer.flagOffset);
          this._flagOffset = true;
        }
      });

      Object.defineProperty(object, 'scale', {
        enumerable: true,
        get: function() {
          return this._scale;
        },
        set: function(v) {

          if (this._scale instanceof Vector) {
            this._scale.unbind(Events.Types.change, this._renderer.flagScale);
          }

          this._scale = v;

          if (this._scale instanceof Vector) {
            this._scale.bind(Events.Types.change, this._renderer.flagScale);
          }

          this._flagScale = true;

        }
      });

      Object.defineProperty(object, 'renderer', {

        enumerable: false,

        get: function() {
          return this._renderer;
        },

        set: function(obj) {
          this._renderer = obj;
        }

      });

    }

  });

  _.extend(Texture.prototype, Events, Shape.prototype, {

    constructor: Texture,

    /**
     * @name Two.Texture#_flagId
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#id} needs updating.
     */
    _flagId: false,

    /**
     * @name Two.Texture#_flagSrc
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#src} needs updating.
     */
    _flagSrc: false,

    /**
     * @name Two.Texture#_flagImage
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#image} needs updating.
     */
    _flagImage: false,

    /**
     * @name Two.Texture#_flagVideo
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#video} needs updating.
     */
    _flagVideo: false,

    /**
     * @name Two.Texture#_flagLoaded
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#loaded} needs updating.
     */
    _flagLoaded: false,

    /**
     * @name Two.Texture#_flagRepeat
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#repeat} needs updating.
     */
    _flagRepeat: false,

    /**
     * @name Two.Texture#_flagOffset
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#offset} needs updating.
     */
    _flagOffset: false,

    /**
     * @name Two.Texture#_flagScale
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Texture#scale} needs updating.
     */
    _flagScale: false,

    /**
     * @name Two.Texture#_id
     * @private
     * @see {@link Two.Texture#id}
     */
    _id: '',

    /**
     * @name Two.Texture#_src
     * @private
     * @see {@link Two.Texture#src}
     */
    _src: '',

    /**
     * @name Two.Texture#_image
     * @private
     * @see {@link Two.Texture#image}
     */
    _image: null,

    /**
     * @name Two.Texture#_loaded
     * @private
     * @see {@link Two.Texture#loaded}
     */
    _loaded: false,

    /**
     * @name Two.Texture#_repeat
     * @private
     * @see {@link Two.Texture#repeat}
     */
    _repeat: 'no-repeat',

    /**
     * @name Two.Texture#_scale
     * @private
     * @see {@link Two.Texture#scale}
     */
    _scale: 1,

    /**
     * @name Two.Texture#_offset
     * @private
     * @see {@link Two.Texture#offset}
     */
    _offset: null,

    /**
     * @name Two.Texture#clone
     * @function
     * @returns {Two.Texture}
     * @description Create a new instance of {@link Two.Texture} with the same properties of the current texture.
     */
    clone: function() {
      var clone = new Texture(this.src);
      clone.repeat = this.repeat;
      clone.offset.copy(this.origin);
      clone.scale = this.scale;
      return clone;
    },

    /**
     * @name Two.Texture#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the texture.
     */
    toObject: function() {
      return {
        src: this.src,
        // image: this.image,
        repeat: this.repeat,
        origin: this.origin.toObject(),
        scale: typeof this.scale === 'number' ? this.scale : this.scale.toObject()
      };
    },

    /**
     * @name Two.Texture#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagSrc || this._flagImage) {

        this.trigger(Events.Types.change);

        if (this._flagSrc || this._flagImage) {
          this.loaded = false;
          Texture.load(this, (function() {
            this.loaded = true;
            this
              .trigger(Events.Types.change)
              .trigger(Events.Types.load);
          }).bind(this));
        }

      }

      if (this._image && this._image.readyState >= 4) {
        this._flagVideo = true;
      }

      return this;

    },

    /**
     * @name Two.Texture#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagSrc = this._flagImage = this._flagLoaded
        = this._flagVideo = this._flagScale = this._flagOffset = false;

      return this;

    }

  });

  Texture.MakeObservable(Texture.prototype);

  // Constants

  var min$1 = Math.min, max$1 = Math.max,
    ceil = Math.ceil, floor = Math.floor;

  /**
   * @name Two.Path
   * @class
   * @extends Two.Shape
   * @param {Two.Anchor[]} [vertices] - A list of {@link Two.Anchor}s that represent the order and coordinates to construct the rendered shape.
   * @param {Boolean} [closed=false] - Describes whether the shape is closed or open.
   * @param {Boolean} [curved=false] - Describes whether the shape automatically calculates bezier handles for each vertex.
   * @param {Boolean} [manual=false] - Describes whether the developer controls how vertices are plotted or if Two.js automatically plots coordinates based on closed and curved booleans.
   * @description This is the primary primitive class for creating all drawable shapes in Two.js. Unless specified methods return their instance of `Two.Path` for the purpose of chaining.
   */
  function Path(vertices, closed, curved, manual) {

    Shape.call(this);

    this._renderer.type = 'path';
    this._renderer.flagVertices = Path.FlagVertices.bind(this);
    this._renderer.bindVertices = Path.BindVertices.bind(this);
    this._renderer.unbindVertices = Path.UnbindVertices.bind(this);

    this._renderer.flagFill = Path.FlagFill.bind(this);
    this._renderer.flagStroke = Path.FlagStroke.bind(this);
    this._renderer.vertices = [];
    this._renderer.collection = [];

    /**
     * @name Two.Path#closed
     * @property {Boolean} - Determines whether a final line is drawn between the final point in the `vertices` array and the first point.
     */
    this._closed = !!closed;

    /**
     * @name Two.Path#curved
     * @property {Boolean} - When the path is `automatic = true` this boolean determines whether the lines between the points are curved or not.
     */
    this._curved = !!curved;

    /**
     * @name Two.Path#beginning
     * @property {Number} - Number between zero and one to state the beginning of where the path is rendered.
     * @description {@link Two.Path#beginning} is a percentage value that represents at what percentage into the path should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Path#ending}.
     */
    this.beginning = 0;

    /**
     * @name Two.Path#ending
     * @property {Number} - Number between zero and one to state the ending of where the path is rendered.
     * @description {@link Two.Path#ending} is a percentage value that represents at what percentage into the path should the renderer start drawing.
     * @nota-bene This is great for animating in and out stroked paths in conjunction with {@link Two.Path#beginning}.
     */
    this.ending = 1;

    // Style properties

    /**
     * @name Two.Path#fill
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the path should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    this.fill = '#fff';

    /**
     * @name Two.Path#stroke
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the path should be outlined in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    this.stroke = '#000';

    /**
     * @name Two.Path#linewidth
     * @property {Number} - The thickness in pixels of the stroke.
     */
    this.linewidth = 1.0;

    /**
     * @name Two.Path#opacity
     * @property {Number} - The opaqueness of the path.
     * @nota-bene Can be used in conjunction with CSS Colors that have an alpha value.
     */
    this.opacity = 1.0;

    /**
     * @name Two.Path#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling.
     * @nota-bene Only available for the SVG renderer.
     */
    this.className = '';

    /**
     * @name Two.Path#visible
     * @property {Boolean} - Display the path or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    this.visible = true;

    /**
     * @name Two.Path#cap
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinecapProperty}
     */
    this.cap = 'butt';      // Default of Adobe Illustrator

    /**
     * @name Two.Path#join
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeLinejoinProperty}
     */
    this.join = 'miter';    // Default of Adobe Illustrator

    /**
     * @name Two.Path#miter
     * @property {String}
     * @see {@link https://www.w3.org/TR/SVG11/painting.html#StrokeMiterlimitProperty}
     */
    this.miter = 4;         // Default of Adobe Illustrator

    /**
     * @name Two.Path#vertices
     * @property {Two.Anchor[]} - An ordered list of anchor points for rendering the path.
     * @description A list of {@link Two.Anchor} objects that consist of what form the path takes.
     * @nota-bene The array when manipulating is actually a {@link Two.Collection}.
     */
    this.vertices = vertices;

    /**
     * @name Two.Path#automatic
     * @property {Boolean} - Determines whether or not Two.js should calculate curves, lines, and commands automatically for you or to let the developer manipulate them for themselves.
     */
    this.automatic = !manual;

    /**
     * @name Two.Path#dashes
     * @property {Number[]} - Array of numbers. Odd indices represent dash length. Even indices represent dash space.
     * @description A list of numbers that represent the repeated dash length and dash space applied to the stroke of the text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more information on the SVG stroke-dasharray attribute.
     */
    this.dashes = [];

    /**
     * @name Two.Path#dashes#offset
     * @property {Number} - A number in pixels to offset {@link Two.Path#dashes} display.
     */
    this.dashes.offset = 0;

  }

  _.extend(Path, {

    /**
     * @name Two.Path.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Path}.
     */
    Properties: [
      'fill',
      'stroke',
      'linewidth',
      'opacity',
      'visible',
      'cap',
      'join',
      'miter',

      'closed',
      'curved',
      'automatic',
      'beginning',
      'ending'
    ],

    Utils: {
      getCurveLength: getCurveLength
    },

    /**
     * @name Two.Path.FlagVertices
     * @function
     * @description Cached method to let renderers know vertices have been updated on a {@link Two.Path}.
     */
    FlagVertices: function() {
      this._flagVertices = true;
      this._flagLength = true;
      if (this.parent) {
        this.parent._flagLength = true;
      }
    },

    /**
     * @name Two.Path.BindVertices
     * @function
     * @description Cached method to let {@link Two.Path} know vertices have been added to the instance.
     */
    BindVertices: function(items) {

      // This function is called a lot
      // when importing a large SVG
      var i = items.length;
      while (i--) {
        items[i].bind(Events.Types.change, this._renderer.flagVertices);
      }

      this._renderer.flagVertices();

    },

    /**
     * @name Two.Path.UnbindVertices
     * @function
     * @description Cached method to let {@link Two.Path} know vertices have been removed from the instance.
     */
    UnbindVertices: function(items) {

      var i = items.length;
      while (i--) {
        items[i].unbind(Events.Types.change, this._renderer.flagVertices);
      }

      this._renderer.flagVertices();

    },

    /**
     * @name Two.Path.FlagFill
     * @function
     * @description Cached method to let {@link Two.Path} know the fill has changed.
     */
    FlagFill: function() {
      this._flagFill = true;
    },

    /**
     * @name Two.Path.FlagFill
     * @function
     * @description Cached method to let {@link Two.Path} know the stroke has changed.
     */
    FlagStroke: function() {
      this._flagStroke = true;
    },

    /**
     * @name Two.Path.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Path} to any object. Handy if you'd like to extend the {@link Two.Path} class on a custom class.
     */
    MakeObservable: function(object) {

      Shape.MakeObservable(object);

      // Only the 7 defined properties are flagged like this. The subsequent
      // properties behave differently and need to be hand written.
      _.each(Path.Properties.slice(2, 8), defineGetterSetter, object);

      Object.defineProperty(object, 'fill', {
        enumerable: true,
        get: function() {
          return this._fill;
        },
        set: function(f) {

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.unbind(Events.Types.change, this._renderer.flagFill);
          }

          this._fill = f;
          this._flagFill = true;

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.bind(Events.Types.change, this._renderer.flagFill);
          }

        }
      });

      Object.defineProperty(object, 'stroke', {
        enumerable: true,
        get: function() {
          return this._stroke;
        },
        set: function(f) {

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.unbind(Events.Types.change, this._renderer.flagStroke);
          }

          this._stroke = f;
          this._flagStroke = true;

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.bind(Events.Types.change, this._renderer.flagStroke);
          }

        }
      });

      /**
       * @name Two.Path#length
       * @property {Number} - The sum of distances between all {@link Two.Path#vertices}.
       */
      Object.defineProperty(object, 'length', {
        get: function() {
          if (this._flagLength) {
            this._updateLength();
          }
          return this._length;
        }
      });

      Object.defineProperty(object, 'closed', {
        enumerable: true,
        get: function() {
          return this._closed;
        },
        set: function(v) {
          this._closed = !!v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'curved', {
        enumerable: true,
        get: function() {
          return this._curved;
        },
        set: function(v) {
          this._curved = !!v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'automatic', {
        enumerable: true,
        get: function() {
          return this._automatic;
        },
        set: function(v) {
          if (v === this._automatic) {
            return;
          }
          this._automatic = !!v;
          var method = this._automatic ? 'ignore' : 'listen';
          _.each(this.vertices, function(v) {
            v[method]();
          });
        }
      });

      Object.defineProperty(object, 'beginning', {
        enumerable: true,
        get: function() {
          return this._beginning;
        },
        set: function(v) {
          this._beginning = v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'ending', {
        enumerable: true,
        get: function() {
          return this._ending;
        },
        set: function(v) {
          this._ending = v;
          this._flagVertices = true;
        }
      });

      Object.defineProperty(object, 'vertices', {

        enumerable: true,

        get: function() {
          return this._collection;
        },

        set: function(vertices) {

          var bindVertices = this._renderer.bindVertices;
          var unbindVertices = this._renderer.unbindVertices;

          // Remove previous listeners
          if (this._collection) {
            this._collection
              .unbind(Events.Types.insert, bindVertices)
              .unbind(Events.Types.remove, unbindVertices);
          }

          // Create new Collection with copy of vertices
          if (vertices instanceof Collection) {
            this._collection = vertices;
          } else {
            this._collection = new Collection(vertices || []);
          }


          // Listen for Collection changes and bind / unbind
          this._collection
            .bind(Events.Types.insert, bindVertices)
            .bind(Events.Types.remove, unbindVertices);

          // Bind Initial Vertices
          bindVertices(this._collection);

        }

      });

      /**
       * @name Two.Path#mask
       * @property {Two.Shape} - The shape whose alpha property becomes a clipping area for the path.
       * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
       */
      Object.defineProperty(object, 'mask', {

        enumerable: true,

        get: function() {
          return this._mask;
        },

        set: function(v) {
          this._mask = v;
          this._flagMask = true;
          if (!v.clip) {
            v.clip = true;
          }
        }

      });

      /**
       * @name Two.Path#clip
       * @property {Boolean} - Tells Two.js renderer if this object represents a mask for another object (or not).
       */
      Object.defineProperty(object, 'clip', {
        enumerable: true,
        get: function() {
          return this._clip;
        },
        set: function(v) {
          this._clip = v;
          this._flagClip = true;
        }
      });

      Object.defineProperty(object, 'dashes', {
        enumerable: true,
        get: function() {
          return this._dashes;
        },
        set: function(v) {
          if (typeof v.offset !== 'number') {
            v.offset = this._dashes.offset || 0;
          }
          this._dashes = v;
        }
      });

    }

  });

  _.extend(Path.prototype, Shape.prototype, {

    constructor: Path,

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Path#_flagVertices
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#vertices} need updating.
     */
    _flagVertices: true,

    /**
     * @name Two.Path#_flagLength
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#length} needs updating.
     */
    _flagLength: true,

    /**
     * @name Two.Path#_flagFill
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#fill} needs updating.
     */
    _flagFill: true,

    /**
     * @name Two.Path#_flagStroke
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#stroke} needs updating.
     */
    _flagStroke: true,

    /**
     * @name Two.Path#_flagLinewidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#linewidth} needs updating.
     */
    _flagLinewidth: true,

    /**
     * @name Two.Path#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#opacity} needs updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Path#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#visible} needs updating.
     */
    _flagVisible: true,

    /**
     * @name Two.Path#_flagCap
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#cap} needs updating.
     */
    _flagCap: true,

    /**
     * @name Two.Path#_flagJoin
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#join} needs updating.
     */
    _flagJoin: true,

    /**
     * @name Two.Path#_flagMiter
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#miter} needs updating.
     */
    _flagMiter: true,

    /**
     * @name Two.Path#_flagMask
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#mask} needs updating.
     */
    _flagMask: false,

    /**
     * @name Two.Path#_flagClip
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#clip} needs updating.
     */
    _flagClip: false,

    // Underlying Properties

    /**
     * @name Two.Path#_length
     * @private
     * @see {@link Two.Path#length}
     */
    _length: 0,

    /**
     * @name Two.Path#_fill
     * @private
     * @see {@link Two.Path#fill}
     */
    _fill: '#fff',

    /**
     * @name Two.Path#_stroke
     * @private
     * @see {@link Two.Path#stroke}
     */
    _stroke: '#000',

    /**
     * @name Two.Path#_linewidth
     * @private
     * @see {@link Two.Path#linewidth}
     */
    _linewidth: 1.0,

    /**
     * @name Two.Path#_opacity
     * @private
     * @see {@link Two.Path#opacity}
     */
    _opacity: 1.0,

    /**
     * @name Two.Path#_visible
     * @private
     * @see {@link Two.Path#visible}
     */
    _visible: true,

    /**
     * @name Two.Path#_cap
     * @private
     * @see {@link Two.Path#cap}
     */
    _cap: 'round',

    /**
     * @name Two.Path#_join
     * @private
     * @see {@link Two.Path#join}
     */
    _join: 'round',

    /**
     * @name Two.Path#_miter
     * @private
     * @see {@link Two.Path#miter}
     */
    _miter: 4,

    /**
     * @name Two.Path#_closed
     * @private
     * @see {@link Two.Path#closed}
     */
    _closed: true,

    /**
     * @name Two.Path#_curved
     * @private
     * @see {@link Two.Path#curved}
     */
    _curved: false,

    /**
     * @name Two.Path#_automatic
     * @private
     * @see {@link Two.Path#automatic}
     */
    _automatic: true,

    /**
     * @name Two.Path#_beginning
     * @private
     * @see {@link Two.Path#beginning}
     */
    _beginning: 0,

    /**
     * @name Two.Path#_ending
     * @private
     * @see {@link Two.Path#ending}
     */
    _ending: 1.0,

    /**
     * @name Two.Path#_mask
     * @private
     * @see {@link Two.Path#mask}
     */
    _mask: null,

    /**
     * @name Two.Path#_clip
     * @private
     * @see {@link Two.Path#clip}
     */
    _clip: false,

    /**
     * @name Two.Path#_dashes
     * @private
     * @see {@link Two.Path#dashes}
     */
    _dashes: [],

    /**
     * @name Two.Path#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Path}
     * @description Create a new instance of {@link Two.Path} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Path();

      for (var j = 0; j < this.vertices.length; j++) {
        clone.vertices.push(this.vertices[j].clone());
      }

      for (var i = 0; i < Path.Properties.length; i++) {
        var k = Path.Properties[i];
        clone[k] = this[k];
      }

      clone.className = this.className;

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Path#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var result = {
        vertices: this.vertices.map(function(v) {
          return v.toObject();
        })
      };

      _.each(Path.Properties, function(k) {
        result[k] = this[k];
      }, this);

      result.className = this.className;

      result.translation = this.translation.toObject();
      result.rotation = this.rotation;
      result.scale = this.scale instanceof Vector ? this.scale.toObject() : this.scale;
      result.skewX = this.skewX;
      result.skewY = this.skewY;

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      return result;

    },

    /**
     * @name Two.Path#noFill
     * @function
     * @description Short hand method to set fill to `transparent`.
     */
    noFill: function() {
      this.fill = 'transparent';
      return this;
    },

    /**
     * @name Two.Path#noStroke
     * @function
     * @description Short hand method to set stroke to `transparent`.
     */
    noStroke: function() {
      this.stroke = undefined;
      return this;
    },

    /**
     * @name Two.Path#corner
     * @function
     * @description Orient the vertices of the shape to the upper left-hand corner of the path.
     */
    corner: function() {

      var rect = this.getBoundingClientRect(true);
      var hw = rect.width / 2;
      var hh = rect.height / 2;
      var cx = rect.left + rect.width / 2;
      var cy = rect.top + rect.height / 2;

      for (var i = 0; i < this.vertices.length; i++) {
        var v = this.vertices[i];
        v.x -= cx;
        v.y -= cy;
        v.x += hw;
        v.y += hh;
      }

      return this;

    },

    /**
     * @name Two.Path#center
     * @function
     * @description Orient the vertices of the shape to the center of the path.
     */
    center: function() {

      var rect = this.getBoundingClientRect(true);

      var cx = rect.left + rect.width / 2 - this.translation.x;
      var cy = rect.top + rect.height / 2 - this.translation.y;

      for (var i = 0; i < this.vertices.length; i++) {
        var v = this.vertices[i];
        v.x -= cx;
        v.y -= cy;
      }

      return this;

    },

    /**
     * @name Two.Path#remove
     * @function
     * @description Remove self from the scene / parent.
     */
    remove: function() {

      if (!this.parent) {
        return this;
      }

      this.parent.remove(this);

      return this;

    },

    /**
     * @name Two.Path#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the path.
     */
    getBoundingClientRect: function(shallow) {
      var matrix, border, l, i, v0, v1, c0x, c0y, c1x, c1y, a, b, c, d;

      var left = Infinity, right = -Infinity,
          top = Infinity, bottom = -Infinity;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      border = (this.linewidth || 0) / 2;
      l = this._renderer.vertices.length;

      if (l <= 0) {
        return {
          width: 0,
          height: 0
        };
      }

      for (i = 0; i < l; i++) {

        v1 = this._renderer.vertices[i];
        // If i = 0, then this "wraps around" to the last vertex. Otherwise, it's the previous vertex.
        // This is important for handling cyclic paths.
        v0 = this._renderer.vertices[(i + l - 1) % l];

        if (v0.controls && v1.controls) {

          c0x = v0.controls.right.x;
          c0y = v0.controls.right.y;

          if (v0.relative) {
            c0x += v0.x;
            c0y += v0.y;
          }

          c1x = v1.controls.left.x;
          c1y = v1.controls.left.y;

          if (v1.relative) {
            c1x += v1.x;
            c1y += v1.y;
          }

          var bb = getCurveBoundingBox(v0.x, v0.y,
            c0x, c0y, c1x, c1y, v1.x, v1.y);

          top = min$1(bb.min.y - border, top);
          left = min$1(bb.min.x - border, left);
          right = max$1(bb.max.x + border, right);
          bottom = max$1(bb.max.y + border, bottom);

        } else {

          if (i <= 1) {

            top = min$1(v0.y - border, top);
            left = min$1(v0.x - border, left);
            right = max$1(v0.x + border, right);
            bottom = max$1(v0.y + border, bottom);

          }

          top = min$1(v1.y - border, top);
          left = min$1(v1.x - border, left);
          right = max$1(v1.x + border, right);
          bottom = max$1(v1.y + border, bottom);

        }

      }

      a = matrix.multiply(left, top, 1);
      b = matrix.multiply(left, bottom, 1);
      c = matrix.multiply(right, top, 1);
      d = matrix.multiply(right, bottom, 1);

      top = min$1(a.y, b.y, c.y, d.y);
      left = min$1(a.x, b.x, c.x, d.x);
      right = max$1(a.x, b.x, c.x, d.x);
      bottom = max$1(a.y, b.y, c.y, d.y);

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Path#getPointAt
     * @function
     * @param {Boolean} t - Percentage value describing where on the Two.Path to estimate and assign coordinate values.
     * @param {Two.Vector} [obj=undefined] - Object to apply calculated x, y to. If none available returns new Object.
     * @returns {Object}
     * @description Given a float `t` from 0 to 1, return a point or assign a passed `obj`'s coordinates to that percentage on this Two.Path's curve.
     */
    getPointAt: function(t, obj) {

      var ia, ib, result;
      var x, x1, x2, x3, x4, y, y1, y2, y3, y4, left, right;
      var target = this.length * Math.min(Math.max(t, 0), 1);
      var length = this.vertices.length;
      var last = length - 1;

      var a = null;
      var b = null;

      for (var i = 0, l = this._lengths.length, sum = 0; i < l; i++) {

        if (sum + this._lengths[i] >= target) {

          if (this._closed) {
            ia = mod(i, length);
            ib = mod(i - 1, length);
            if (i === 0) {
              ia = ib;
              ib = i;
            }
          } else {
            ia = i;
            ib = Math.min(Math.max(i - 1, 0), last);
          }

          a = this.vertices[ia];
          b = this.vertices[ib];
          target -= sum;
          if (this._lengths[i] !== 0) {
            t = target / this._lengths[i];
          } else {
            t = 0;
          }

          break;

        }

        sum += this._lengths[i];

      }

      if (a === null || b === null) {
        return null;
      }

      if (!a) {
        return b;
      } else if (!b) {
        return a;
      }

      right = b.controls && b.controls.right;
      left = a.controls && a.controls.left;

      x1 = b.x;
      y1 = b.y;
      x2 = (right || b).x;
      y2 = (right || b).y;
      x3 = (left || a).x;
      y3 = (left || a).y;
      x4 = a.x;
      y4 = a.y;

      if (right && b.relative) {
        x2 += b.x;
        y2 += b.y;
      }

      if (left && a.relative) {
        x3 += a.x;
        y3 += a.y;
      }

      x = getComponentOnCubicBezier(t, x1, x2, x3, x4);
      y = getComponentOnCubicBezier(t, y1, y2, y3, y4);

      // Higher order points for control calculation.
      var t1x = lerp(x1, x2, t);
      var t1y = lerp(y1, y2, t);
      var t2x = lerp(x2, x3, t);
      var t2y = lerp(y2, y3, t);
      var t3x = lerp(x3, x4, t);
      var t3y = lerp(y3, y4, t);

      // Calculate the returned points control points.
      var brx = lerp(t1x, t2x, t);
      var bry = lerp(t1y, t2y, t);
      var alx = lerp(t2x, t3x, t);
      var aly = lerp(t2y, t3y, t);

      if (_.isObject(obj)) {

        obj.x = x;
        obj.y = y;

        if (!_.isObject(obj.controls)) {
          Anchor.AppendCurveProperties(obj);
        }

        obj.controls.left.x = brx;
        obj.controls.left.y = bry;
        obj.controls.right.x = alx;
        obj.controls.right.y = aly;

        if (!typeof obj.relative === 'boolean' || obj.relative) {
          obj.controls.left.x -= x;
          obj.controls.left.y -= y;
          obj.controls.right.x -= x;
          obj.controls.right.y -= y;
        }

        obj.t = t;

        return obj;

      }

      result = new Anchor(
        x, y, brx - x, bry - y, alx - x, aly - y,
        this._curved ? Commands.curve : Commands.line
      );

      result.t = t;

      return result;

    },

    /**
     * @name Two.Path#plot
     * @function
     * @description Based on closed / curved and sorting of vertices plot where all points should be and where the respective handles should be too.
     * @nota-bene While this method is public it is internally called by {@link Two.Path#_update} when `automatic = true`.
     */
    plot: function() {

      if (this.curved) {
        getCurveFromPoints(this._collection, this.closed);
        return this;
      }

      for (var i = 0; i < this._collection.length; i++) {
        this._collection[i].command = i === 0 ? Commands.move : Commands.line;
      }

      return this;

    },

    /**
     * @name Two.Path#subdivide
     * @function
     * @param {Number} limit - How many times to recurse subdivisions.
     * @description Insert a {@link Two.Anchor} at the midpoint between every item in {@link Two.Path#vertices}.
     */
    subdivide: function(limit) {
      //TODO: DRYness (function below)
      this._update();

      var last = this.vertices.length - 1;
      var b = this.vertices[last];
      var closed = this._closed || this.vertices[last]._command === Commands.close;
      var points = [];
      _.each(this.vertices, function(a, i) {

        if (i <= 0 && !closed) {
          b = a;
          return;
        }

        if (a.command === Commands.move) {
          points.push(new Anchor(b.x, b.y));
          if (i > 0) {
            points[points.length - 1].command = Commands.line;
          }
          b = a;
          return;
        }

        var verts = getSubdivisions(a, b, limit);
        points = points.concat(verts);

        // Assign commands to all the verts
        _.each(verts, function(v, i) {
          if (i <= 0 && b.command === Commands.move) {
            v.command = Commands.move;
          } else {
            v.command = Commands.line;
          }
        });

        if (i >= last) {

          // TODO: Add check if the two vectors in question are the same values.
          if (this._closed && this._automatic) {

            b = a;

            verts = getSubdivisions(a, b, limit);
            points = points.concat(verts);

            // Assign commands to all the verts
            _.each(verts, function(v, i) {
              if (i <= 0 && b.command === Commands.move) {
                v.command = Commands.move;
              } else {
                v.command = Commands.line;
              }
            });

          } else if (closed) {
            points.push(new Anchor(a.x, a.y));
          }

          points[points.length - 1].command = closed
            ? Commands.close : Commands.line;

        }

        b = a;

      }, this);

      this._automatic = false;
      this._curved = false;
      this.vertices = points;

      return this;

    },

    /**
     * @name Two.Path#_updateLength
     * @function
     * @private
     * @param {Number} [limit=] -
     * @param {Boolean} [silent=false] - If set to `true` then the path isn't updated before calculation. Useful for internal use.
     * @description Recalculate the {@link Two.Path#length} value.
     */
    _updateLength: function(limit, silent) {
      //TODO: DRYness (function above)
      if (!silent) {
        this._update();
      }

      var length = this.vertices.length;
      var last = length - 1;
      var b = this.vertices[last];
      var closed = false;//this._closed || this.vertices[last]._command === Commands.close;
      var sum = 0;

      if (typeof this._lengths === 'undefined') {
        this._lengths = [];
      }

      _.each(this.vertices, function(a, i) {

        if ((i <= 0 && !closed) || a.command === Commands.move) {
          b = a;
          this._lengths[i] = 0;
          return;
        }

        this._lengths[i] = getCurveLength(a, b, limit);
        sum += this._lengths[i];

        if (i >= last && closed) {

          b = this.vertices[(i + 1) % length];

          this._lengths[i + 1] = getCurveLength(a, b, limit);
          sum += this._lengths[i + 1];

        }

        b = a;

      }, this);

      this._length = sum;
      this._flagLength = false;

      return this;

    },

    /**
     * @name Two.Path#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices) {

        if (this._automatic) {
          this.plot();
        }

        if (this._flagLength) {
          this._updateLength(undefined, true);
        }

        var l = this._collection.length;
        var closed = this._closed;

        var beginning = Math.min(this._beginning, this._ending);
        var ending = Math.max(this._beginning, this._ending);

        var bid = getIdByLength(this, beginning * this._length);
        var eid = getIdByLength(this, ending * this._length);

        var low = ceil(bid);
        var high = floor(eid);

        var left, right, prev, next, v;

        this._renderer.vertices.length = 0;

        for (var i = 0; i < l; i++) {

          if (this._renderer.collection.length <= i) {
            // Expected to be `relative` anchor points.
            this._renderer.collection.push(new Anchor());
          }

          if (i > high && !right) {

            v = this._renderer.collection[i];
            v.copy(this._collection[i]);
            this.getPointAt(ending, v);
            v.command = this._renderer.collection[i].command;
            this._renderer.vertices.push(v);

            right = v;
            prev = this._collection[i - 1];

            // Project control over the percentage `t`
            // of the in-between point
            if (prev && prev.controls) {

              v.controls.right.clear();

              this._renderer.collection[i - 1].controls.right
                .clear()
                .lerp(prev.controls.right, v.t);

            }

          } else if (i >= low && i <= high) {

            v = this._renderer.collection[i]
              .copy(this._collection[i]);
            this._renderer.vertices.push(v);

            if (i === high && contains(this, ending)) {
              right = v;
              if (!closed && right.controls) {
                right.controls.right.clear();
              }
            } else if (i === low && contains(this, beginning)) {
              left = v;
              left.command = Commands.move;
              if (!closed && left.controls) {
                left.controls.left.clear();
              }
            }

          }

        }

        // Prepend the trimmed point if necessary.
        if (low > 0 && !left) {

          i = low - 1;

          v = this._renderer.collection[i];
          v.copy(this._collection[i]);
          this.getPointAt(beginning, v);
          v.command = Commands.move;
          this._renderer.vertices.unshift(v);

          left = v;
          next = this._collection[i + 1];

          // Project control over the percentage `t`
          // of the in-between point
          if (next && next.controls) {

            v.controls.left.clear();

            this._renderer.collection[i + 1].controls.left
              .copy(next.controls.left)
              .lerp(Vector.zero, v.t);

          }

        }

      }

      Shape.prototype._update.apply(this, arguments);

      return this;

    },

    /**
     * @name Two.Path#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagVertices =  this._flagFill =  this._flagStroke =
          this._flagLinewidth = this._flagOpacity = this._flagVisible =
          this._flagCap = this._flagJoin = this._flagMiter =
          this._flagClip = false;

      Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Path.MakeObservable(Path.prototype);

    // Utility functions

  function contains(path, t) {

    if (t === 0 || t === 1) {
      return true;
    }

    var length = path._length;
    var target = length * t;
    var elapsed = 0;

    for (var i = 0; i < path._lengths.length; i++) {
      var dist = path._lengths[i];
      if (elapsed >= target) {
        return target - elapsed >= 0;
      }
      elapsed += dist;
    }

    return false;

  }

  /**
   * @private
   * @param {Two.Path} path - The path to analyze against.
   * @param {Number} target - The target length at which to find an anchor.
   * @returns {Number}
   * @description Return the id of an anchor based on a target length.
   */
  function getIdByLength(path, target) {

    var total = path._length;

    if (target <= 0) {
      return 0;
    } else if (target >= total) {
      return path._lengths.length - 1;
    }

    for (var i = 0, sum = 0; i < path._lengths.length; i++) {

      if (sum + path._lengths[i] >= target) {
        target -= sum;
        return Math.max(i - 1, 0) + target / path._lengths[i];
      }

      sum += path._lengths[i];

    }

    return - 1;

  }

  function getCurveLength(a, b, limit) {
    // TODO: DRYness
    var x1, x2, x3, x4, y1, y2, y3, y4;

    var right = b.controls && b.controls.right;
    var left = a.controls && a.controls.left;

    x1 = b.x;
    y1 = b.y;
    x2 = (right || b).x;
    y2 = (right || b).y;
    x3 = (left || a).x;
    y3 = (left || a).y;
    x4 = a.x;
    y4 = a.y;

    if (right && b._relative) {
      x2 += b.x;
      y2 += b.y;
    }

    if (left && a._relative) {
      x3 += a.x;
      y3 += a.y;
    }

    return getCurveLength$1(x1, y1, x2, y2, x3, y3, x4, y4, limit);

  }

  function getSubdivisions(a, b, limit) {
    // TODO: DRYness
    var x1, x2, x3, x4, y1, y2, y3, y4;

    var right = b.controls && b.controls.right;
    var left = a.controls && a.controls.left;

    x1 = b.x;
    y1 = b.y;
    x2 = (right || b).x;
    y2 = (right || b).y;
    x3 = (left || a).x;
    y3 = (left || a).y;
    x4 = a.x;
    y4 = a.y;

    if (right && b._relative) {
      x2 += b.x;
      y2 += b.y;
    }

    if (left && a._relative) {
      x3 += a.x;
      y3 += a.y;
    }

    return subdivide(x1, y1, x2, y2, x3, y3, x4, y4, limit);

  }

  /**
   * @name Two.Rectangle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the rectangle.
   * @param {Number} [y=0] - The y position of the rectangle.
   * @param {Number} [width] - The width value of the rectangle.
   * @param {Number} [height] - The width value of the rectangle.
   */
  function Rectangle(x, y, width, height) {

    Path.call(this, [
      new Anchor(),
      new Anchor(),
      new Anchor(),
      new Anchor()
      // new Anchor() // TODO: Figure out how to handle this for `beginning` / `ending` animations
    ], true, false, true);

    /**
     * @name Two.Rectangle#width
     * @property {Number} - The size of the width of the rectangle.
     */
    this.width = width;
    /**
     * @name Two.Rectangle#height
     * @property {Number} - The size of the height of the rectangle.
     */
    this.height = height;

    /**
     * @name Two.Rectangle#origin
     * @property {Number} - A two-component vector describing the origin offset to draw the rectangle. Default is `0, 0`.
     */
    this.origin = new Vector();
    this.translation.set(x, y);

    this._update();

  }

  _.extend(Rectangle, {

    /**
     * @name Two.Rectangle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Rectangle}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.Rectangle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Rectangle} to any object. Handy if you'd like to extend the {@link Two.Rectangle} class on a custom class.
     */
    MakeObservable: function(object) {

      Path.MakeObservable(object);
      _.each(Rectangle.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'origin', {
        enumerable: true,
        get: function() {
          return this._origin;
        },
        set: function(v) {
          if (this._origin) {
            this._origin.unbind(Events.Types.change, this._renderer.flagVertices);
          }
          this._origin = v;
          this._origin.bind(Events.Types.change, this._renderer.flagVertices);
          this._renderer.flagVertices();
        }
      });

    }

  });

  _.extend(Rectangle.prototype, Path.prototype, {

    constructor: Rectangle,

    /**
     * @name Two.Rectangle#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Rectangle#width} needs updating.
     */
    _flagWidth: 0,
    /**
     * @name Two.Rectangle#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Rectangle#height} needs updating.
     */
    _flagHeight: 0,

    /**
     * @name Two.Rectangle#_width
     * @private
     * @see {@link Two.Rectangle#width}
     */
    _width: 0,
    /**
     * @name Two.Rectangle#_height
     * @private
     * @see {@link Two.Rectangle#height}
     */
    _height: 0,

    _origin: null,

    /**
     * @name Two.Rectangle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight) {

        var xr = this._width / 2;
        var yr = this._height / 2;

        if (!this._closed && this.vertices.length === 4) {
          this.vertices.push(new Anchor());
        }

        this.vertices[0].set(-xr, -yr).add(this._origin).command = Commands.move;
        this.vertices[1].set(xr, -yr).add(this._origin).command = Commands.line;
        this.vertices[2].set(xr, yr).add(this._origin).command = Commands.line;
        this.vertices[3].set(-xr, yr).add(this._origin).command = Commands.line;
        // FYI: Two.Sprite and Two.ImageSequence have 4 verts
        if (this.vertices[4]) {
          this.vertices[4].set(-xr, -yr).add(this._origin).command = Commands.line;
        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Rectangle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Rectangle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Rectangle}
     * @description Create a new instance of {@link Two.Rectangle} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Rectangle(0, 0, this.width, this.height);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Rectangle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);
      object.width = this.width;
      object.height = this.height;
      object.origin = this.origin.toObject();
      return object;

    }

  });

  Rectangle.MakeObservable(Rectangle.prototype);

  /**
   * @name Two.Sprite
   * @class
   * @extends Two.Rectangle
   * @param {String|Two.Texture} [path] - The URL path or {@link Two.Texture} to be used as the bitmap data displayed on the sprite.
   * @param {Number} [ox=0] - The initial `x` position of the Two.Sprite.
   * @param {Number} [oy=0] - The initial `y` position of the Two.Sprite.
   * @param {Number} [cols=1] - The number of columns the sprite contains.
   * @param {Number} [rows=1] - The number of rows the sprite contains.
   * @param {Number} [frameRate=0] - The frame rate at which the partitions of the image should playback at.
   * @description A convenient package to display still or animated images through a tiled image source. For more information on the principals of animated imagery through tiling see [Texture Atlas](https://en.wikipedia.org/wiki/Texture_atlas) on Wikipedia.
   */
  function Sprite(path, ox, oy, cols, rows, frameRate) {

    // Not using default constructor of Rectangle due to odd `beginning` / `ending` behavior.
    // See: https://github.com/jonobr1/two.js/issues/383
    Path.call(this, [
      new Anchor(),
      new Anchor(),
      new Anchor(),
      new Anchor()
    ], true);

    this.noStroke();
    this.noFill();

    /**
     * @name Two.Sprite#texture
     * @property {Two.Texture} - The texture to be used as bitmap data to display image in the scene.
     */
    if (path instanceof Texture) {
      this.texture = path;
    } else if (typeof path === 'string') {
      this.texture = new Texture(path);
    }

    this.origin = new Vector();

    this._update();
    this.translation.set(ox || 0, oy || 0);

    /**
     * @name Two.Sprite#columns
     * @property {Number} - The number of columns to split the texture into. Defaults to `1`.
     */
    if (typeof cols === 'number') {
      this.columns = cols;
    }

    /**
     * @name Two.Sprite#rows
     * @property {Number} - The number of rows to split the texture into. Defaults to `1`.
     */
    if (typeof rows === 'number') {
      this.rows = rows;
    }

    /**
     * @name Two.Sprite#frameRate
     * @property {Number} - The number of frames to animate against per second. Defaults to `0` for non-animated sprites.
     */
    if (typeof frameRate === 'number') {
      this.frameRate = frameRate;
    }

    /**
     * @name Two.Sprite#index
     * @property {Number} - The index of the current tile of the sprite to display. Defaults to `0`.
     */
    this.index = 0;

  }

  _.extend(Sprite, {

    /**
     * @name Two.Sprite.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Sprite}.
     */
    Properties: [
      'texture', 'columns', 'rows', 'frameRate', 'index'
    ],

    /**
     * @name Two.Sprite.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Sprite} to any object. Handy if you'd like to extend or inherit the {@link Two.Sprite} class on a custom class.
     */
    MakeObservable: function(obj) {

      Rectangle.MakeObservable(obj);
      _.each(Sprite.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Sprite.prototype, Rectangle.prototype, {

    constructor: Sprite,

    /**
     * @name Two.Sprite#_flagTexture
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#texture} needs updating.
     */
    _flagTexture: false,

    /**
     * @name Two.Sprite#_flagColumns
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#columns} need updating.
     */
    _flagColumns: false,

    /**
     * @name Two.Sprite#_flagRows
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#rows} need updating.
     */
    _flagRows: false,

    /**
     * @name Two.Sprite#_flagFrameRate
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#flagFrameRate} needs updating.
     */
    _flagFrameRate: false,

    /**
     * @name Two.Sprite#_flagIndex
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Sprite#index} needs updating.
     */
    flagIndex: false,

    // Private variables

    /**
     * @name Two.Sprite#_amount
     * @private
     * @property {Number} - Number of frames for a given {@link Two.Sprite}.
     */
    _amount: 1,

    /**
     * @name Two.Sprite#_duration
     * @private
     * @property {Number} - Number of milliseconds a {@link Two.Sprite}.
     */
    _duration: 0,

    /**
     * @name Two.Sprite#_startTime
     * @private
     * @property {Milliseconds} - Epoch time in milliseconds of when the {@link Two.Sprite} started.
     */
    _startTime: 0,

    /**
     * @name Two.Sprite#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.Sprite} is animating or not.
     */
    _playing: false,

    /**
     * @name Two.Sprite#_firstFrame
     * @private
     * @property {Number} - The frame the {@link Two.Sprite} should start with.
     */
    _firstFrame: 0,

    /**
     * @name Two.Sprite#_lastFrame
     * @private
     * @property {Number} - The frame the {@link Two.Sprite} should end with.
     */
    _lastFrame: 0,

    /**
     * @name Two.Sprite#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.Sprite} should loop or not.
     */
    _loop: true,

    // Exposed through getter-setter

    /**
     * @name Two.Sprite#_texture
     * @private
     * @see {@link Two.Sprite#texture}
     */
    _texture: null,

    /**
     * @name Two.Sprite#_columns
     * @private
     * @see {@link Two.Sprite#columns}
     */
    _columns: 1,

    /**
     * @name Two.Sprite#_rows
     * @private
     * @see {@link Two.Sprite#rows}
     */
    _rows: 1,

    /**
     * @name Two.Sprite#_frameRate
     * @private
     * @see {@link Two.Sprite#frameRate}
     */
    _frameRate: 0,

    /**
     * @name Two.Sprite#_index
     * @private
     * @property {Number} - The current frame the {@link Two.Sprite} is currently displaying.
     */
    _index: 0,

    /**
     * @name Two.Sprite#_origin
     * @private
     * @see {@link Two.Sprite#origin}
     */
    _origin: null,

    /**
     * @name Two.Sprite#play
     * @function
     * @param {Number} [firstFrame=0] - The index of the frame to start the animation with.
     * @param {Number} [lastFrame] - The index of the frame to end the animation with. Defaults to the last item in the {@link Two.Sprite#textures}.
     * @param {Function} [onLastFrame] - Optional callback function to be triggered after playing the last frame. This fires multiple times when the sprite is looped.
     * @description Initiate animation playback of a {@link Two.Sprite}.
     */
    play: function(firstFrame, lastFrame, onLastFrame) {

      this._playing = true;
      this._firstFrame = 0;
      this._lastFrame = this.amount - 1;
      this._startTime = _.performance.now();

      if (typeof firstFrame === 'number') {
        this._firstFrame = firstFrame;
      }
      if (typeof lastFrame === 'number') {
        this._lastFrame = lastFrame;
      }
      if (typeof onLastFrame === 'function') {
        this._onLastFrame = onLastFrame;
      } else {
        delete this._onLastFrame;
      }

      if (this._index !== this._firstFrame) {
        this._startTime -= 1000 * Math.abs(this._index - this._firstFrame)
          / this._frameRate;
      }

      return this;

    },

    /**
     * @name Two.Sprite#pause
     * @function
     * @description Halt animation playback of a {@link Two.Sprite}.
     */
    pause: function() {

      this._playing = false;
      return this;

    },

    /**
     * @name Two.Sprite#stop
     * @function
     * @description Halt animation playback of a {@link Two.Sprite} and set the current frame back to the first frame.
     */
    stop: function() {

      this._playing = false;
      this._index = 0;

      return this;

    },

    /**
     * @name Two.Sprite#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Sprite}
     * @description Create a new instance of {@link Two.Sprite} with the same properties of the current sprite.
     */
    clone: function(parent) {

      var clone = new Sprite(
        this.texture, this.translation.x, this.translation.y,
        this.columns, this.rows, this.frameRate
      );

      if (this.playing) {
        clone.play(this._firstFrame, this._lastFrame);
        clone._loop = this._loop;
      }

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Sprite#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {
      var object = Rectangle.prototype.toObject.call(this);
      object.texture = this.texture.toObject();
      object.columns = this.columns;
      object.rows = this.rows;
      object.frameRate = this.frameRate;
      object.index = this.index;
      object._firstFrame = this._firstFrame;
      object._lastFrame = this._lastFrame;
      object._loop = this._loop;
      return object;
    },

    /**
     * @name Two.Sprite#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var effect = this._texture;
      var cols = this._columns;
      var rows = this._rows;

      var width, height, elapsed, amount, duration;
      var index, iw, ih, frames;

      if (this._flagColumns || this._flagRows) {
        this._amount = this._columns * this._rows;
      }

      if (this._flagFrameRate) {
        this._duration = 1000 * this._amount / this._frameRate;
      }

      if (this._flagTexture) {
        this.fill = this._texture;
      }

      if (this._texture.loaded) {

        iw = effect.image.width;
        ih = effect.image.height;

        width = iw / cols;
        height = ih / rows;
        amount = this._amount;

        if (this.width !== width) {
          this.width = width;
        }
        if (this.height !== height) {
          this.height = height;
        }

        if (this._playing && this._frameRate > 0) {

          if (_.isNaN(this._lastFrame)) {
            this._lastFrame = amount - 1;
          }

          // TODO: Offload perf logic to instance of `Two`.
          elapsed = _.performance.now() - this._startTime;
          frames = this._lastFrame + 1;
          duration = 1000 * (frames - this._firstFrame) / this._frameRate;

          if (this._loop) {
            elapsed = elapsed % duration;
          } else {
            elapsed = Math.min(elapsed, duration);
          }

          index = lerp(this._firstFrame, frames, elapsed / duration);
          index = Math.floor(index);

          if (index !== this._index) {
            this._index = index;
            if (index >= this._lastFrame - 1 && this._onLastFrame) {
              this._onLastFrame();  // Shortcut for chainable sprite animations
            }
          }

        }

        var col = this._index % cols;
        var row = Math.floor(this._index / cols);

        var ox = - width * col + (iw - width) / 2;
        var oy = - height * row + (ih - height) / 2;

        // TODO: Improve performance
        if (ox !== effect.offset.x) {
          effect.offset.x = ox;
        }
        if (oy !== effect.offset.y) {
          effect.offset.y = oy;
        }

      }

      Rectangle.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Sprite#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagTexture = this._flagColumns = this._flagRows
        = this._flagFrameRate = false;

      Rectangle.prototype.flagReset.call(this);

      return this;
    }


  });

  Sprite.MakeObservable(Sprite.prototype);

  var TWO_PI$4 = Math.PI * 2, HALF_PI$2 = Math.PI / 2;
  var cos$3 = Math.cos, sin$3 = Math.sin;

  /**
   * @name Two.Circle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the circle.
   * @param {Number} [y=0] - The y position of the circle.
   * @param {Number} [radius=0] - The radius value of the circle.
   * @param {Number} [resolution=4] - The number of vertices used to construct the circle.
   */
  function Circle(ox, oy, r, resolution) {

    // At least 2 vertices are required for proper circlage
    var amount = resolution ? Math.max(resolution, 2) : 4;

    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(new Anchor(0, 0, 0, 0, 0, 0));
    }

    Path.call(this, points, true, true, true);

    /**
     * @name Two.Circle#radius
     * @property {Number} - The size of the radius of the circle.
     */
    if (typeof r === 'number') {
      this.radius = r;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(Circle, {

    /**
     * @name Two.Circle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Circle}.
     */
    Properties: ['radius'],

    /**
     * @name Two.Circle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Circle} to any object. Handy if you'd like to extend the {@link Two.Circle} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Circle.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Circle.prototype, Path.prototype, {

    constructor: Circle,

    /**
     * @name Two.Circle#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Circle#radius} needs updating.
     */
    _flagRadius: false,

    /**
     * @name Two.Circle#_radius
     * @private
     * @see {@link Two.Circle#radius}
     */
    _radius: 0,

    /**
     * @name Two.Circle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagRadius) {

        var length = this.vertices.length;

        if (!this._closed && length > 2) {
          length -= 1;
        }

        // Coefficient for approximating circular arcs with Bezier curves
        var c = (4 / 3) * Math.tan(Math.PI / (length * 2));
        var radius = this._radius;
        var rc = radius * c;

        for (var i = 0; i < this.vertices.length; i++) {
          var pct = i / length;
          var theta = pct * TWO_PI$4;

          var x = radius * cos$3(theta);
          var y = radius * sin$3(theta);

          var lx = rc * cos$3(theta - HALF_PI$2);
          var ly = rc * sin$3(theta - HALF_PI$2);

          var rx = rc * cos$3(theta + HALF_PI$2);
          var ry = rc * sin$3(theta + HALF_PI$2);

          var v = this.vertices[i];

          v.command = i === 0 ? Commands.move : Commands.curve;
          v.set(x, y);
          v.controls.left.set(lx, ly);
          v.controls.right.set(rx, ry);
        }
      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Circle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagRadius = false;

      Path.prototype.flagReset.call(this);
      return this;

    },

    /**
     * @name Two.Circle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Circle}
     * @description Create a new instance of {@link Two.Circle} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Circle(0, 0, this.radius, this.vertices.length);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Circle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Circle.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Circle.MakeObservable(Circle.prototype);

  var TWO_PI$3 = Math.PI * 2, HALF_PI$1 = Math.PI / 2;
  var cos$2 = Math.cos, sin$2 = Math.sin;

  /**
   * @name Two.Ellipse
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the ellipse.
   * @param {Number} [y=0] - The y position of the ellipse.
   * @param {Number} [rx=0] - The radius value of the ellipse in the x direction.
   * @param {Number} [ry=0] - The radius value of the ellipse in the y direction.
   * @param {Number} [resolution=4] - The number of vertices used to construct the ellipse.
   */
  function Ellipse(ox, oy, rx, ry, resolution) {

    if (typeof ry !== 'number' && typeof rx === 'number') {
      ry = rx;
    }

    // At least 2 vertices are required for proper circlage
    var amount = resolution ? Math.max(resolution, 2) : 4;

    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(new Anchor());
    }

    Path.call(this, points, true, true, true);

    /**
     * @name Two.Ellipse#width
     * @property {Number} - The width of the ellipse.
     */
    if (typeof rx === 'number') {
      this.width = rx * 2;
    }

    /**
     * @name Two.Ellipse#height
     * @property {Number} - The height of the ellipse.
     */
    if (typeof ry === 'number') {
      this.height = ry * 2;
    }

    this._update();
    this.translation.set(ox, oy);

  }

  _.extend(Ellipse, {

    /**
     * @name Two.Ellipse.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Ellipse}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.Ellipse.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Ellipse} to any object. Handy if you'd like to extend the {@link Two.Ellipse} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Ellipse.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Ellipse.prototype, Path.prototype, {

    /**
     * @name Two.Ellipse#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Ellipse#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.Ellipse#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Ellipse#height} needs updating.
     */
    _flagHeight: false,

    /**
     * @name Two.Polygon#_width
     * @private
     * @see {@link Two.Ellipse#width}
     */
    _width: 0,
    /**
     * @name Two.Polygon#_height
     * @private
     * @see {@link Two.Ellipse#height}
     */
    _height: 0,

    constructor: Ellipse,

    /**
     * @name Two.Ellipse#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight) {

        var length = this.vertices.length;

        if (!this._closed && length > 2) {
          length -= 1;
        }

        // Coefficient for approximating circular arcs with Bezier curves
        var c = (4 / 3) * Math.tan(Math.PI / (this.vertices.length * 2));
        var radiusX = this._width / 2;
        var radiusY = this._height / 2;

        for (var i = 0; i < this.vertices.length; i++) {
          var pct = i / length;
          var theta = pct * TWO_PI$3;

          var x = radiusX * cos$2(theta);
          var y = radiusY * sin$2(theta);

          var lx = radiusX * c * cos$2(theta - HALF_PI$1);
          var ly = radiusY * c * sin$2(theta - HALF_PI$1);

          var rx = radiusX * c * cos$2(theta + HALF_PI$1);
          var ry = radiusY * c * sin$2(theta + HALF_PI$1);

          var v = this.vertices[i];

          v.command = i === 0 ? Commands.move : Commands.curve;
          v.set(x, y);
          v.controls.left.set(lx, ly);
          v.controls.right.set(rx, ry);
        }
      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Ellipse#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = false;

      Path.prototype.flagReset.call(this);
      return this;

    },

    /**
     * @name Two.Ellipse#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Polygon}
     * @description Create a new instance of {@link Two.Polygon} with the same properties of the current path.
     */
    clone: function(parent) {

      var rx = this.width / 2;
      var ry = this.height / 2;
      var resolution = this.vertices.length;
      var clone = new Ellipse(0, 0, rx, ry, resolution);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Ellipse#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Ellipse.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Ellipse.MakeObservable(Ellipse.prototype);

  /**
   * @name Two.Line
   * @class
   * @extends Two.Path
   * @param {Number} [x1=0] - The x position of the first vertex on the line.
   * @param {Number} [y1=0] - The y position of the first vertex on the line.
   * @param {Number} [x2=0] - The x position of the second vertex on the line.
   * @param {Number} [y2=0] - The y position of the second vertex on the line.
   */
  function Line(x1, y1, x2, y2) {

    Path.call(this, [
        new Anchor(x1, y1),
        new Anchor(x2, y2)
    ]);

    this.vertices[0].command = Commands.move;
    this.vertices[1].command = Commands.line;

    this.automatic = false;

  }

  _.extend(Line.prototype, Path.prototype, {

    constructor: Line

  });

  Path.MakeObservable(Line.prototype);

  /**
   * @name Two.RoundedRectangle
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the rounded rectangle.
   * @param {Number} [y=0] - The y position of the rounded rectangle.
   * @param {Number} [width=0] - The width value of the rounded rectangle.
   * @param {Number} [height=0] - The width value of the rounded rectangle.
   * @param {Number} [radius=0] - The radius value of the rounded rectangle.
   * @param {Number} [resolution=12] - The number of vertices used to construct the rounded rectangle.
   */
  function RoundedRectangle(ox, oy, width, height, radius) {

    if (typeof radius === 'undefined' &&
      typeof width === 'number' && typeof height === 'number') {
      radius = Math.floor(Math.min(width, height) / 12);
    }

    var amount = 10;

    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(
        new Anchor(0, 0, 0, 0, 0, 0,
          i === 0 ? Commands.move : Commands.curve)
      );
    }

    // points[points.length - 1].command = Two.Commands.close;

    Path.call(this, points);

    this.closed = true;
    this.automatic = false;

    this._renderer.flagRadius = RoundedRectangle.FlagRadius.bind(this);

    /**
     * @name Two.RoundedRectangle#width
     * @property {Number} - The width of the rounded rectangle.
     */
    if (typeof width === 'number') {
      this.width = width;
    }

    /**
     * @name Two.RoundedRectangle#height
     * @property {Number} - The height of the rounded rectangle.
     */
    if (typeof height === 'number') {
      this.height = height;
    }

    /**
     * @name Two.RoundedRectangle#radius
     * @property {Number} - The size of the radius of the rounded rectangle.
     */
    if (typeof radius === 'number') {
      this.radius = radius;
    }

    this._update();
    this.translation.set(ox, oy);

  }

  _.extend(RoundedRectangle, {

    /**
     * @name Two.RoundedRectangle.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.RoundedRectangle}.
     */
    Properties: ['width', 'height'],

    /**
     * @name Two.RoundedRectangle.FlagRadius
     * @property {Function} - A convenience function to trigger the flag for radius changing.
     */
    FlagRadius: function() {
      this._flagRadius = true;
    },

    /**
     * @name Two.RoundedRectangle.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.RoundedRectangle} to any object. Handy if you'd like to extend the {@link Two.RoundedRectangle} class on a custom class.
     */
    MakeObservable: function(object) {

      Path.MakeObservable(object);
      _.each(RoundedRectangle.Properties, defineGetterSetter, object);

      Object.defineProperty(object, 'radius', {
        enumerable: true,
        get: function() {
          return this._radius;
        },
        set: function(v) {

          if (this._radius instanceof Vector) {
            this._radius.unbind(Events.Types.change, this._renderer.flagRadius);
          }

          this._radius = v;

          if (this._radius instanceof Vector) {
            this._radius.bind(Events.Types.change, this._renderer.flagRadius);
          }

          this._flagRadius = true;

        }
      });

    }

  });

  _.extend(RoundedRectangle.prototype, Path.prototype, {

    constructor: RoundedRectangle,

    /**
     * @name Two.RoundedRectangle#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.RoundedRectangle#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#height} needs updating.
     */
    _flagHeight: false,
    /**
     * @name Two.RoundedRectangle#_flagRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.RoundedRectangle#radius} needs updating.
     */
    _flagRadius: false,

    /**
     * @name Two.RoundedRectangle#_width
     * @private
     * @see {@link Two.RoundedRectangle#width}
     */
    _width: 0,
    /**
     * @name Two.RoundedRectangle#_height
     * @private
     * @see {@link Two.RoundedRectangle#height}
     */
    _height: 0,
    /**
     * @name Two.RoundedRectangle#_radius
     * @private
     * @see {@link Two.RoundedRectangle#radius}
     */
    _radius: 12,

    /**
     * @name Two.RoundedRectangle#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight || this._flagRadius) {

        var width = this._width;
        var height = this._height;

        var rx, ry;

        if (this._radius instanceof Vector) {
          rx = this._radius.x;
          ry = this._radius.y;
        } else {
          rx = this._radius;
          ry = this._radius;
        }

        var v;
        var w = width / 2;
        var h = height / 2;

        v = this.vertices[0];
        v.x = - (w - rx);
        v.y = - h;

        // Upper Right Corner

        v = this.vertices[1];
        v.x = (w - rx);
        v.y = - h;
        v.controls.left.clear();
        v.controls.right.x = rx;
        v.controls.right.y = 0;

        v = this.vertices[2];
        v.x = w;
        v.y = - (h - ry);
        v.controls.right.clear();
        v.controls.left.clear();

        // Bottom Right Corner

        v = this.vertices[3];
        v.x = w;
        v.y = (h - ry);
        v.controls.left.clear();
        v.controls.right.x = 0;
        v.controls.right.y = ry;

        v = this.vertices[4];
        v.x = (w - rx);
        v.y = h;
        v.controls.right.clear();
        v.controls.left.clear();

        // Bottom Left Corner

        v = this.vertices[5];
        v.x = - (w - rx);
        v.y = h;
        v.controls.left.clear();
        v.controls.right.x = - rx;
        v.controls.right.y = 0;

        v = this.vertices[6];
        v.x = - w;
        v.y = (h - ry);
        v.controls.left.clear();
        v.controls.right.clear();

        // Upper Left Corner

        v = this.vertices[7];
        v.x = - w;
        v.y = - (h - ry);
        v.controls.left.clear();
        v.controls.right.x = 0;
        v.controls.right.y = - ry;

        v = this.vertices[8];
        v.x = - (w - rx);
        v.y = - h;
        v.controls.left.clear();
        v.controls.right.clear();

        v = this.vertices[9];
        v.copy(this.vertices[8]);

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.RoundedRectangle#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = this._flagRadius = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.RoundedRectangle#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.RoundedRectangle}
     * @description Create a new instance of {@link Two.RoundedRectangle} with the same properties of the current path.
     */
    clone: function(parent) {

      var width = this.width;
      var height = this.height;
      var radius = this.radius;

      var clone = new RoundedRectangle(0, 0, width, height, radius);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.RoundedRectangle#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(RoundedRectangle.Properties, function(property) {
        object[property] = this[property];
      }, this);

      object.radius = typeof this.radius === 'number'
        ? this.radius : this.radius.toObject();

      return object;

    }

  });

  RoundedRectangle.MakeObservable(RoundedRectangle.prototype);

  var min = Math.min, max = Math.max;

  /**
   * @name Two.Text
   * @class
   * @extends Two.Shape
   * @param {String} [message] - The String to be rendered to the scene.
   * @param {Number} [x=0] - The position in the x direction for the object.
   * @param {Number} [y=0] - The position in the y direction for the object.
   * @param {Object} [styles] - An object where styles are applied. Attribute must exist in Two.Text.Properties.
   * @description This is a primitive class for creating drawable text that can be added to the scenegraph.
   * @returns {Two.Text}
   */
  function Text(message, x, y, styles) {

    Shape.call(this);

    this._renderer.type = 'text';
    this._renderer.flagFill = Text.FlagFill.bind(this);
    this._renderer.flagStroke = Text.FlagStroke.bind(this);

    this.value = message;

    if (typeof x === 'number') {
      this.translation.x = x;
    }
    if (typeof y === 'number') {
      this.translation.y = y;
    }

    /**
     * @name Two.Text#dashes
     * @property {Number[]} - Array of numbers. Odd indices represent dash length. Even indices represent dash space.
     * @description A list of numbers that represent the repeated dash length and dash space applied to the stroke of the text.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-dasharray} for more information on the SVG stroke-dasharray attribute.
     */
    this.dashes = [];

    /**
     * @name Two.Text#dashes#offset
     * @property {Number} - A number in pixels to offset {@link Two.Text#dashes} display.
     */
    this.dashes.offset = 0;

    if (!_.isObject(styles)) {
      return this;
    }

    _.each(Text.Properties, function(property) {

      if (property in styles) {
        this[property] = styles[property];
      }

    }, this);

  }

  _.extend(Text, {

    /**
     * @name Two.Text.Ratio
     * @property {Number} - Approximate aspect ratio of a typeface's character width to height.
     */
    Ratio: 0.6,

    /**
     * @name Two.Text.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Text}.
     */
    Properties: [
      'value', 'family', 'size', 'leading', 'alignment', 'linewidth', 'style',
      'weight', 'decoration', 'baseline', 'opacity', 'visible', 'className',
      'fill', 'stroke',
    ],

    /**
     * @name Two.Text.FlagFill
     * @function
     * @description Cached method to let renderers know the fill property have been updated on a {@link Two.Text}.
     */
    FlagFill: function() {
      this._flagFill = true;
    },

    /**
     * @name Two.Text.FlagStroke
     * @function
     * @description Cached method to let renderers know the stroke property have been updated on a {@link Two.Text}.
     */
    FlagStroke: function() {
      this._flagStroke = true;
    },

    MakeObservable: function(object) {

      Shape.MakeObservable(object);

      _.each(Text.Properties.slice(0, 12), defineGetterSetter, object);

      Object.defineProperty(object, 'fill', {
        enumerable: true,
        get: function() {
          return this._fill;
        },
        set: function(f) {

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.unbind(Events.Types.change, this._renderer.flagFill);
          }

          this._fill = f;
          this._flagFill = true;

          if (this._fill instanceof Gradient
            || this._fill instanceof LinearGradient
            || this._fill instanceof RadialGradient
            || this._fill instanceof Texture) {
            this._fill.bind(Events.Types.change, this._renderer.flagFill);
          }

        }
      });

      Object.defineProperty(object, 'stroke', {
        enumerable: true,
        get: function() {
          return this._stroke;
        },
        set: function(f) {

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.unbind(Events.Types.change, this._renderer.flagStroke);
          }

          this._stroke = f;
          this._flagStroke = true;

          if (this._stroke instanceof Gradient
            || this._stroke instanceof LinearGradient
            || this._stroke instanceof RadialGradient
            || this._stroke instanceof Texture) {
            this._stroke.bind(Events.Types.change, this._renderer.flagStroke);
          }

        }
      });

      Object.defineProperty(object, 'mask', {

        enumerable: true,

        get: function() {
          return this._mask;
        },

        set: function(v) {
          this._mask = v;
          this._flagMask = true;
          if (!v.clip) {
            v.clip = true;
          }
        }

      });

      Object.defineProperty(object, 'clip', {
        enumerable: true,
        get: function() {
          return this._clip;
        },
        set: function(v) {
          this._clip = v;
          this._flagClip = true;
        }
      });

      Object.defineProperty(object, 'dashes', {
        enumerable: true,
        get: function() {
          return this._dashes;
        },
        set: function(v) {
          if (typeof v.offset !== 'number') {
            v.offset = this._dashes.offset || 0;
          }
          this._dashes = v;
        }
      });

    }

  });

  _.extend(Text.prototype, Shape.prototype, {

    constructor: Text,

    // Flags
    // http://en.wikipedia.org/wiki/Flag

    /**
     * @name Two.Text#_flagValue
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#value} need updating.
     */
    _flagValue: true,

    /**
     * @name Two.Text#_flagFamily
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#family} need updating.
     */
    _flagFamily: true,

    /**
     * @name Two.Text#_flagSize
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#size} need updating.
     */
    _flagSize: true,

    /**
     * @name Two.Text#_flagLeading
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#leading} need updating.
     */
    _flagLeading: true,

    /**
     * @name Two.Text#_flagAlignment
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#alignment} need updating.
     */
    _flagAlignment: true,

    /**
     * @name Two.Text#_flagBaseline
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#baseline} need updating.
     */
    _flagBaseline: true,

    /**
     * @name Two.Text#_flagStyle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#style} need updating.
     */
    _flagStyle: true,

    /**
     * @name Two.Text#_flagWeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#weight} need updating.
     */
    _flagWeight: true,

    /**
     * @name Two.Text#_flagDecoration
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#decoration} need updating.
     */
    _flagDecoration: true,

    /**
     * @name Two.Text#_flagFill
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#fill} need updating.
     */
    _flagFill: true,

    /**
     * @name Two.Text#_flagStroke
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#stroke} need updating.
     */
    _flagStroke: true,

    /**
     * @name Two.Text#_flagLinewidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#linewidth} need updating.
     */
    _flagLinewidth: true,

    /**
     * @name Two.Text#_flagOpacity
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#opacity} need updating.
     */
    _flagOpacity: true,

    /**
     * @name Two.Text#_flagClassName
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#className} need updating.
     */
    _flagClassName: true,

    /**
     * @name Two.Text#_flagVisible
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#visible} need updating.
     */
    _flagVisible: true,

    /**
     * @name Two.Path#_flagMask
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Path#mask} needs updating.
     */
    _flagMask: false,

    /**
     * @name Two.Text#_flagClip
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Text#clip} need updating.
     */
    _flagClip: false,

    // Underlying Properties

    /**
     * @name Two.Text#value
     * @property {String} - The characters to be rendered to the the screen. Referred to in the documentation sometimes as the `message`.
     */
    _value: '',

    /**
     * @name Two.Text#family
     * @property {String} - The font family Two.js should attempt to regsiter for rendering. The default value is `'sans-serif'`. Comma separated font names can be supplied as a "stack", similar to the CSS implementation of `font-family`.
     */
    _family: 'sans-serif',

    /**
     * @name Two.Text#size
     * @property {Number} - The font size in Two.js point space. Defaults to `13`.
     */
    _size: 13,

    /**
     * @name Two.Text#leading
     * @property {Number} - The height between lines measured from base to base in Two.js point space. Defaults to `17`.
     */
    _leading: 17,

    /**
     * @name Two.Text#alignment
     * @property {String} - Alignment of text in relation to {@link Two.Text#translation}'s coordinates. Possible values include `'left'`, `'center'`, `'right'`. Defaults to `'center'`.
     */
    _alignment: 'center',

    /**
     * @name Two.Text#baseline
     * @property {String} - The vertical aligment of the text in relation to {@link Two.Text#translation}'s coordinates. Possible values include `'top'`, `'middle'`, `'bottom'`, and `'baseline'`. Defaults to `'baseline'`.
     */
    _baseline: 'middle',

    /**
     * @name Two.Text#style
     * @property {String} - The font's style. Possible values include '`normal`', `'italic'`. Defaults to `'normal'`.
     */
    _style: 'normal',

    /**
     * @name Two.Text#weight
     * @property {Number} - A number at intervals of 100 to describe the font's weight. This compatibility varies with the typeface's variant weights. Larger values are bolder. Smaller values are thinner. Defaults to `'500'`.
     */
    _weight: 500,

    /**
     * @name Two.Text#decoration
     * @property {String} - String to delineate whether text should be decorated with for instance an `'underline'`. Defaults to `'none'`.
     */
    _decoration: 'none',

    /**
     * @name Two.Text#fill
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the text object should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _fill: '#000',

    /**
     * @name Two.Text#stroke
     * @property {(String|Two.Gradient|Two.Texture)} - The value of what the text object should be filled in with.
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/CSS/color_value} for more information on CSS's colors as `String`.
     */
    _stroke: 'transparent',

    /**
     * @name Two.Text#linewidth
     * @property {Number} - The thickness in pixels of the stroke.
     */
    _linewidth: 1,

    /**
     * @name Two.Text#opacity
     * @property {Number} - The opaqueness of the text object.
     * @nota-bene Can be used in conjunction with CSS Colors that have an alpha value.
     */
    _opacity: 1,

    /**
     * @name Two.Text#className
     * @property {String} - A class to be applied to the element to be compatible with CSS styling. Only available for the {@link Two.SvgRenderer}.
     */
    _className: '',

    /**
     * @name Two.Text#visible
     * @property {Boolean} - Display the text object or not.
     * @nota-bene For {@link Two.CanvasRenderer} and {@link Two.WebGLRenderer} when set to false all updating is disabled improving performance dramatically with many objects in the scene.
     */
    _visible: true,

    /**
     * @name Two.Text#mask
     * @property {Two.Shape} - The shape whose alpha property becomes a clipping area for the text.
     * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
     */
    _mask: null,

    /**
     * @name Two.Text#clip
     * @property {Two.Shape} - Object to define clipping area.
     * @nota-bene This property is currently not working becuase of SVG spec issues found here {@link https://code.google.com/p/chromium/issues/detail?id=370951}.
     */
    _clip: false,

    /**
     * @name Two.Text#_dashes
     * @private
     * @see {@link Two.Text#dashes}
     */
    _dashes: [],

    /**
     * @name Two.Text#remove
     * @function
     * @description Remove self from the scene / parent.
     */
    remove: function() {

      if (!this.parent) {
        return this;
      }

      this.parent.remove(this);

      return this;

    },

    /**
     * @name Two.Text#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Text}
     * @description Create a new instance of {@link Two.Text} with the same properties of the current text object.
     */
    clone: function(parent) {

      var clone = new Text(this.value);
      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;

      _.each(Text.Properties, function(property) {
        clone[property] = this[property];
      }, this);

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      if (parent) {
        parent.add(clone);
      }

      return clone._update();

    },

    /**
     * @name Two.Text#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the text object.
     */
    toObject: function() {

      var result = {
        translation: this.translation.toObject(),
        rotation: this.rotation,
        scale: this.scale
      };

      if (this.matrix.manual) {
        result.matrix = this.matrix.toObject();
      }

      _.each(Text.Properties, function(property) {
        result[property] = this[property];
      }, this);

      return result;

    },

    /**
     * @name Two.Text#noFill
     * @function
     * @description Short hand method to set fill to `transparent`.
     */
    noFill: function() {
      this.fill = 'transparent';
      return this;
    },

    /**
     * @name Two.Text#noStroke
     * @function
     * @description Short hand method to set stroke to `transparent`.
     */
    noStroke: function() {
      this.stroke = undefined;
      this.linewidth = undefined;
      return this;
    },

    // A shim to not break `getBoundingClientRect` calls.
    // TODO: Implement a way to calculate proper bounding
    // boxes of `Two.Text`.

    /**
     * @name Two.Text#getBoundingClientRect
     * @function
     * @param {Boolean} [shallow=false] - Describes whether to calculate off local matrix or world matrix.
     * @returns {Object} - Returns object with top, left, right, bottom, width, height attributes.
     * @description Return an object with top, left, right, bottom, width, and height parameters of the text object.
     */
    getBoundingClientRect: function(shallow) {

      var matrix, a, b, c, d;
      var left, right, top, bottom;

      // TODO: Update this to not __always__ update. Just when it needs to.
      this._update(true);

      matrix = shallow ? this._matrix : getComputedMatrix(this);

      var height = this.leading;
      var width = this.value.length * this.size * Text.Ratio;
      var border = (this._linewidth || 0) / 2;

      switch (this.alignment) {
        case 'left':
          left = - border;
          right = width + border;
          break;
        case 'right':
          left = - (width + border);
          right = border;
          break;
        default:
          left = - (width / 2 + border);
          right = width / 2 + border;
      }

      switch (this.baseline) {
        case 'top':
          top = - border;
          bottom = height + border;
          break;
        case 'bottom':
          top = - (height + border);
          bottom = border;
          break;
        default:
          top = - (height / 2 + border);
          bottom = height / 2 + border;
      }

      a = matrix.multiply(left, top, 1);
      b = matrix.multiply(left, bottom, 1);
      c = matrix.multiply(right, top, 1);
      d = matrix.multiply(right, bottom, 1);

      top = min(a.y, b.y, c.y, d.y);
      left = min(a.x, b.x, c.x, d.x);
      right = max(a.x, b.x, c.x, d.x);
      bottom = max(a.y, b.y, c.y, d.y);

      return {
        top: top,
        left: left,
        right: right,
        bottom: bottom,
        width: right - left,
        height: bottom - top
      };

    },

    /**
     * @name Two.Text#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagValue = this._flagFamily = this._flagSize =
        this._flagLeading = this._flagAlignment = this._flagFill =
        this._flagStroke = this._flagLinewidth = this._flagOpacity =
        this._flagVisible = this._flagClip = this._flagDecoration =
        this._flagClassName = this._flagBaseline = this._flagWeight =
          this._flagStyle = false;

      Shape.prototype.flagReset.call(this);

      return this;

    }

  });

  Text.MakeObservable(Text.prototype);

  // https://github.com/jonobr1/two.js/issues/507#issuecomment-777159213
  var regex = {
    path: /[+-]?(?:\d*\.\d+|\d+)(?:[eE][+-]\d+)?/g
  };

  var alignments = {
    start: 'left',
    middle: 'center',
    end: 'right'
  };

  /**
   * @name Two.Utils.getAlignment
   * @function
   * @param {AlignmentString}
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/text-anchor}
   */
  var getAlignment = function(anchor) {
    return alignments[anchor];
  };

  var getBaseline = function(node) {
    var a = node.getAttribute('dominant-baseline');
    var b = node.getAttribute('alignment-baseline');
    return a || b;
  };

  var getTagName = function(tag) {
    return tag.replace(/svg:/ig, '').toLowerCase();
  };

  var applyTransformsToVector = function(transforms, vector) {

    vector.x += transforms.translateX;
    vector.y += transforms.translateY;

    vector.x *= transforms.scaleX;
    vector.y *= transforms.scaleY;

    if (transforms.rotation !== 0) {
      // TODO: Test further
      var l = vector.length();
      vector.x = l * Math.cos(transforms.rotation);
      vector.y = l * Math.sin(transforms.rotation);
    }

  };

  /**
   * @name Two.Utils.extractCSSText
   * @function
   * @param {String} text - The CSS text body to be parsed and extracted.
   * @param {Object} [styles] - The styles object to apply CSS key values to.
   * @returns {Object} styles
   * @description Parse CSS text body and apply them as key value pairs to a JavaScript object.
   */
  var extractCSSText = function(text, styles) {

    var commands, command, name, value;

    if (!styles) {
      styles = {};
    }

    commands = text.split(';');

    for (var i = 0; i < commands.length; i++) {
      command = commands[i].split(':');
      name = command[0];
      value = command[1];
      if (typeof name === 'undefined' || typeof value === 'undefined') {
        continue;
      }
      styles[name] = value.replace(/\s/, '');
    }

    return styles;

  };

  /**
   * @name Two.Utils.getSvgStyles
   * @function
   * @param {SVGElement} node - The SVG node to parse.
   * @returns {Object} styles
   * @description Get the CSS comands from the `style` attribute of an SVG node and apply them as key value pairs to a JavaScript object.
   */
  var getSvgStyles = function(node) {

    var styles = {};
    var attributes = getSvgAttributes(node);
    var length = Math.max(attributes.length, node.style.length);

    for (var i = 0; i < length; i++) {

      var command = node.style[i];
      var attribute = attributes[i];

      if (command) {
        styles[command] = node.style[command];
      }
      if (attribute) {
        styles[attribute] = node.getAttribute(attribute);
      }

    }

    return styles;

  };

  var getSvgAttributes = function(node) {

    var attributes = node.getAttributeNames();

    // Reserved attributes to remove
    var keywords = ['id', 'class', 'transform', 'xmlns', 'viewBox'];

    for (var i = 0; i < keywords.length; i++) {
      var keyword = keywords[i];
      var index = Array.prototype.indexOf.call(attributes, keyword);
      if (index >= 0) {
        attributes.splice(index, 1);
      }
    }

    return attributes;

  };

  /**
   * @name Two.Utils.applySvgViewBox
   * @function
   * @param {Two.Shape} node - The Two.js object to apply viewbox matrix to
   * @param {String} value - The viewBox value from the SVG attribute
   * @returns {Two.Shape} node
   * @description Applies the transform of the SVG Viewbox on a given node.
   */
  var applySvgViewBox = function(node, value) {

    var elements = value.split(/\s/);

    var x = parseFloat(elements[0]);
    var y = parseFloat(elements[1]);
    var width = parseFloat(elements[2]);
    var height = parseFloat(elements[3]);

    var s = Math.min(this.width / width, this.height / height);

    node.translation.x -= x * s;
    node.translation.y -= y * s;
    node.scale = s;

    return node;

  };

  /**
   * @name Two.Utils.applySvgAttributes
   * @function
   * @param {SVGElement} node - An SVG Node to extrapolate attributes from.
   * @param {Two.Shape} elem - The Two.js object to apply extrapolated attributes to.
   * @returns {Two.Shape} The Two.js object passed now with applied attributes.
   * @description This function iterates through an SVG Node's properties and stores ones of interest. It tries to resolve styles applied via CSS as well.
   * @TODO Reverse calculate {@link Two.Gradient}s for fill / stroke of any given path.
   */
  var applySvgAttributes = function(node, elem, parentStyles) {

    var styles = {}, attributes = {}, extracted = {}, i, m, key, value, attr;
    var transforms, x, y;
    var id, scene, ref, tagName;

    // Not available in non browser environments
    if (root$1.getComputedStyle) {
      // Convert CSSStyleDeclaration to a normal object
      var computedStyles = root$1.getComputedStyle(node);
      i = computedStyles.length;

      while (i--) {
        key = computedStyles[i];
        value = computedStyles[key];
        // Gecko returns undefined for unset properties
        // Webkit returns the default value
        if (typeof value !== 'undefined') {
          styles[key] = value;
        }
      }
    }

    // Convert NodeMap to a normal object
    for (i = 0; i < node.attributes.length; i++) {
      attr = node.attributes[i];
      if (/style/i.test(attr.nodeName)) {
        extractCSSText(attr.value, extracted);
      } else {
        attributes[attr.nodeName] = attr.value;
      }
    }

    // Getting the correct opacity is a bit tricky, since SVG path elements don't
    // support opacity as an attribute, but you can apply it via CSS.
    // So we take the opacity and set (stroke/fill)-opacity to the same value.
    if (typeof styles.opacity !== 'undefined') {
      styles['stroke-opacity'] = styles.opacity;
      styles['fill-opacity'] = styles.opacity;
      delete styles.opacity;
    }

    // Merge attributes and applied styles (attributes take precedence)
    if (parentStyles) {
      _.defaults(styles, parentStyles);
    }
    _.extend(styles, extracted, attributes);

    // Similarly visibility is influenced by the value of both display and visibility.
    // Calculate a unified value here which defaults to `true`.
    styles.visible = !(typeof styles.display === 'undefined' && /none/i.test(styles.display))
      || (typeof styles.visibility === 'undefined' && /hidden/i.test(styles.visibility));

    // Now iterate the whole thing
    for (key in styles) {
      value = styles[key];

      switch (key) {
        case 'gradientTransform':
          // TODO: Check this out https://github.com/paperjs/paper.js/blob/develop/src/svg/SvgImport.js#L315
          if (/none/i.test(value)) break;
          m = (node.gradientTransform && node.gradientTransform.baseVal && node.gradientTransform.baseVal.length > 0)
            ? node.gradientTransform.baseVal[0].matrix
            : (node.getCTM ? node.getCTM() : null);

          if (m === null) break;

          transforms = decomposeMatrix(m);

          switch (elem._renderer.type) {
            case 'linear-gradient':
              applyTransformsToVector(transforms, elem.left);
              applyTransformsToVector(transforms, elem.right);
              break;
            case 'radial-gradient':
              elem.center.x += transforms.translateX;
              elem.center.y += transforms.translateY;

              elem.focal.x += transforms.translateX;
              elem.focal.y += transforms.translateY;

              elem.radius *= Math.max(transforms.scaleX, transforms.scaleY);
              break;
          }

          break;
        case 'transform':
          // TODO: Check this out https://github.com/paperjs/paper.js/blob/develop/src/svg/SvgImport.js#L315
          if (/none/i.test(value)) break;
          m = (node.transform && node.transform.baseVal && node.transform.baseVal.length > 0)
            ? node.transform.baseVal[0].matrix
            : (node.getCTM ? node.getCTM() : null);

          // Might happen when transform string is empty or not valid.
          if (m === null) break;

          if (Constants.AutoCalculateImportedMatrices) {

            // Decompose and infer Two.js related properties.
            transforms = decomposeMatrix(m);

            elem.translation.set(transforms.translateX, transforms.translateY);
            elem.rotation = Math.PI * (transforms.rotation / 180);
            elem.scale = new Vector(transforms.scaleX, transforms.scaleY);

            x = parseFloat((styles.x + '').replace('px'));
            y = parseFloat((styles.y + '').replace('px'));

            // Override based on attributes.
            if (x) {
              elem.translation.x = x;
            }

            if (y) {
              elem.translation.y = y;
            }

          } else {

            // Edit the underlying matrix and don't force an auto calc.
            m = node.getCTM();
            elem._matrix.manual = true;
            elem._matrix.set(m.a, m.b, m.c, m.d, m.e, m.f);

          }

          break;
        case 'viewBox':
          applySvgViewBox.call(this, elem, value);
          break;
        case 'visible':
          if (elem instanceof Group) {
            elem._visible = value;
            break;
          }
          elem.visible = value;
          break;
        case 'stroke-linecap':
          if (elem instanceof Group) {
            elem._cap = value;
            break;
          }
          elem.cap = value;
          break;
        case 'stroke-linejoin':
          if (elem instanceof Group) {
            elem._join = value;
            break;
          }
          elem.join = value;
          break;
        case 'stroke-miterlimit':
          if (elem instanceof Group) {
            elem._miter = value;
            break;
          }
          elem.miter = value;
          break;
        case 'stroke-width':
          if (elem instanceof Group) {
            elem._linewidth = parseFloat(value);
            break;
          }
          elem.linewidth = parseFloat(value);
          break;
        case 'opacity':
        case 'stroke-opacity':
        case 'fill-opacity':
          // Only apply styles to rendered shapes
          // in the scene.
          if (elem instanceof Group) {
            elem._opacity = parseFloat(value);
            break;
          }
          elem.opacity = parseFloat(value);
          break;
        case 'clip-path':
          if (/url\(#.*\)/i.test(value)) {
            id = value.replace(/url\(#(.*)\)/i, '$1');
            if (read.defs.current && read.defs.current.contains(id)) {
              ref = read.defs.current.get(id);
              if (ref && ref.childNodes.length > 0) {
                ref = ref.childNodes[0];
                tagName = getTagName(ref.nodeName);
                elem.mask = read[tagName].call(this, ref, {});
                switch (elem._renderer.type) {
                  case 'text':
                  case 'path':
                    // The matrix here needs to change to insure that the object
                    // clipping is in the same coordinate space as the `elem`.
                    elem.position.add(elem.mask.position);
                    elem.mask.position.clear();
                    break;
                }
              }
            }
          }
          break;
        case 'fill':
        case 'stroke':
          if (elem instanceof Group) {
            key = '_' + key;
          }
          if (/url\(#.*\)/i.test(value)) {
            id = value.replace(/url\(#(.*)\)/i, '$1');
            if (read.defs.current && read.defs.current.contains(id)) {
              ref = read.defs.current.get(id);
              tagName = getTagName(ref.nodeName);
              ref = read[tagName].call(this, ref, {});
            } else {
              scene = getScene(this);
              ref = scene.getById(id);
            }
            elem[key] = ref;
          } else {
            elem[key] = (/none/i.test(value)) ? 'transparent' : value;
          }
          break;
        case 'id':
          elem.id = value;
          // Overwritten id for non-conflicts on same page SVG documents
          // TODO: Make this non-descructive
          node.id = value + '-' + Constants.Identifier + 'applied';
          break;
        case 'class':
        case 'className':
          elem.classList = value.split(' ');
          break;
        case 'x':
        case 'y':
          var ca = elem instanceof Gradient;
          var cb = elem instanceof LinearGradient;
          var cc = elem instanceof RadialGradient;
          if (ca || cb || cc) {
            break;
          }
          if (value.match('[a-z%]$') && !value.endsWith('px')) {
            var error = new TwoError(
              'only pixel values are supported with the ' + key + ' attribute.');
            console.warn(error.name, error.message);
          }
          elem.translation[key] = parseFloat(value);
          break;
        case 'font-family':
          if (elem instanceof Text) {
            elem.family = value;
          }
          break;
        case 'font-size':
          if (elem instanceof Text) {
            elem.size = value;
          }
          break;
        case 'font-weight':
          if (elem instanceof Text) {
            elem.weight = value;
          }
          break;
        case 'font-style':
          if (elem instanceof Text) {
            elem.style = value;
          }
          break;
        case 'text-decoration':
          if (elem instanceof Text) {
            elem.decoration = value;
          }
          break;
        case 'line-height':
          if (elem instanceof Text) {
            elem.leading = value;
          }
          break;
      }
    }

    return styles;

  };

  /**
   * @name Two.Utils.updateDefsCache
   * @function
   * @param {SVGElement} node - The SVG Node with which to update the defs cache.
   * @param {Object} Object - The defs cache to be updated.
   * @description Update the cache of children of <defs /> tags.
   */
  var updateDefsCache = function(node, defsCache) {
    for (var i = 0, l = node.childNodes.length; i < l; i++) {
      var n = node.childNodes[i];
      if (!n.id) continue;

      var tagName = getTagName(node.nodeName);
      if (tagName === '#text') continue;

      defsCache.add(n.id, n);
    }
  };

  /**
   * @name Two.Utils.getScene
   * @param {Two.Shape} node - The currently available object in the scenegraph.
   * @returns {Group} - The highest order {@link Two.Group} in the scenegraph.
   * @property {Function}
   */
  var getScene = function(node) {

    while (node.parent) {
      node = node.parent;
    }

    return node.scene;

  };

  /**
   * @name Two.Utils.read
   * @property {Object} read - A map of functions to read any number of SVG node types and create Two.js equivalents of them. Primarily used by the {@link Two#interpret} method.
   */
  var read = {

    svg: function(node) {

      var defs = read.defs.current = new Registry();
      var elements = node.getElementsByTagName('defs');

      for (var i = 0; i < elements.length; i++) {
        updateDefsCache(elements[i], defs);
      }

      var svg = read.g.call(this, node);
      // var viewBox = node.getAttribute('viewBox');

      svg.defs = defs;  // Export out the <defs /> for later use
      // Utils.applySvgViewBox(svg, viewBox);

      delete read.defs.current;

      return svg;

    },

    defs: function(node) {
      return null;
    },

    use: function(node, styles) {

      var error;
      var href = node.getAttribute('href') || node.getAttribute('xlink:href');
      if (!href) {
        error = new TwoError('encountered <use /> with no href.');
        console.warn(error.name, error.message);
        return null;
      }

      var id = href.slice(1);
      if (!read.defs.current.contains(id)) {
        error = new TwoError(
          'unable to find element for reference ' + href + '.');
        console.warn(error.name, error.message);
        return null;
      }

      var template = read.defs.current.get(id);
      var fullNode = template.cloneNode(true);
      var overwriteAttrs = ['x', 'y', 'width', 'height', 'href', 'xlink:href'];

      for (var i = 0; i < node.attributes.length; i++) {
        var attr = node.attributes[i];
        var ca = overwriteAttrs.includes(attr.nodeName);
        var cb = !fullNode.hasAttribute(attr.nodeName);
        if (ca || cb) {
          fullNode.setAttribute(attr.nodeName, attr.value);
        }
      }

      var tagName = getTagName(fullNode.nodeName);
      return read[tagName].call(this, fullNode, styles);

    },

    g: function(node, parentStyles) {

      var styles;
      var group = new Group();

      applySvgAttributes.call(this, node, group, parentStyles);

      this.add(group);

      // Switched up order to inherit more specific styles
      styles = getSvgStyles.call(this, node);

      for (var i = 0, l = node.childNodes.length; i < l; i++) {
        var n = node.childNodes[i];
        var tag = n.nodeName;
        if (!tag) return;

        var tagName = getTagName(tag);

        if (tagName in read) {
          var o = read[tagName].call(group, n, styles);
          if (!!o && !o.parent) {
            group.add(o);
          }
        }
      }

      return group;

    },

    polygon: function(node, parentStyles) {

      var points = node.getAttribute('points');

      var verts = [];
      points.replace(/(-?[\d.eE-]+)[,|\s](-?[\d.eE-]+)/g, function(match, p1, p2) {
        verts.push(new Anchor(parseFloat(p1), parseFloat(p2)));
      });

      var poly = new Path(verts, true).noStroke();
      poly.fill = 'black';

      applySvgAttributes.call(this, node, poly, parentStyles);

      return poly;

    },

    polyline: function(node, parentStyles) {
      var poly = read.polygon.call(this, node, parentStyles);
      poly.closed = false;
      return poly;
    },

    path: function(node, parentStyles) {

      var path = node.getAttribute('d');
      var points = [];
      var closed = false, relative = false;

      if (path) {

        // Create a Two.Path from the paths.

        var coord = new Anchor();
        var control, coords;
        var commands = path.match(/[a-df-z][^a-df-z]*/ig);
        var last = commands.length - 1;

        // Split up polybeziers

        _.each(commands.slice(0), function(command, i) {

          var items = command.slice(1).trim().match(regex.path);
          var type = command[0];
          var lower = type.toLowerCase();
          var bin, j, l, ct, times, result = [];

          if (i === 0) {
            commands = [];
          }

          switch (lower) {
            case 'h':
            case 'v':
              if (items.length > 1) {
                bin = 1;
              }
              break;
            case 'm':
            case 'l':
            case 't':
              if (items.length > 2) {
                bin = 2;
              }
              break;
            case 's':
            case 'q':
              if (items.length > 4) {
                bin = 4;
              }
              break;
            case 'c':
              if (items.length > 6) {
                bin = 6;
              }
              break;
            case 'a':
              if (items.length > 7) {
                bin = 7;
              }
              break;
          }

          // This means we have a polybezier.
          if (bin) {

            for (j = 0, l = items.length, times = 0; j < l; j+=bin) {

              ct = type;
              if (times > 0) {

                switch (type) {
                  case 'm':
                    ct = 'l';
                    break;
                  case 'M':
                    ct = 'L';
                    break;
                }

              }

              result.push(ct + items.slice(j, j + bin).join(' '));
              times++;

            }

            commands = Array.prototype.concat.apply(commands, result);

          } else {

            commands.push(command);

          }

        });

        // Create the vertices for our Two.Path

        _.each(commands, function(command, i) {

          var result, x, y;
          var type = command[0];
          var lower = type.toLowerCase();

          coords = command.slice(1).trim().match(regex.path);
          relative = type === lower;

          var x1, y1, x2, y2, x3, y3, x4, y4, reflection;

          switch (lower) {

            case 'z':
              if (i >= last) {
                closed = true;
              } else {
                x = coord.x;
                y = coord.y;
                result = new Anchor(
                  x, y,
                  undefined, undefined,
                  undefined, undefined,
                  Commands.close
                );
                // Make coord be the last `m` command
                for (var j = points.length - 1; j >= 0; j--) {
                  var point = points[j];
                  if (/m/i.test(point.command)) {
                    coord = point;
                    break;
                  }
                }
              }
              break;

            case 'm':
            case 'l':

              control = undefined;

              x = parseFloat(coords[0]);
              y = parseFloat(coords[1]);

              result = new Anchor(
                x, y,
                undefined, undefined,
                undefined, undefined,
                /m/i.test(lower) ? Commands.move : Commands.line
              );

              if (relative) {
                result.addSelf(coord);
              }

              // result.controls.left.copy(result);
              // result.controls.right.copy(result);

              coord = result;
              break;

            case 'h':
            case 'v':

              var a = /h/i.test(lower) ? 'x' : 'y';
              var b = /x/i.test(a) ? 'y' : 'x';

              result = new Anchor(
                undefined, undefined,
                undefined, undefined,
                undefined, undefined,
                Commands.line
              );
              result[a] = parseFloat(coords[0]);
              result[b] = coord[b];

              if (relative) {
                result[a] += coord[a];
              }

              // result.controls.left.copy(result);
              // result.controls.right.copy(result);

              coord = result;
              break;

            case 'c':
            case 's':

              x1 = coord.x;
              y1 = coord.y;

              if (!control) {
                control = new Vector();//.copy(coord);
              }

              if (/c/i.test(lower)) {

                x2 = parseFloat(coords[0]);
                y2 = parseFloat(coords[1]);
                x3 = parseFloat(coords[2]);
                y3 = parseFloat(coords[3]);
                x4 = parseFloat(coords[4]);
                y4 = parseFloat(coords[5]);

              } else {

                // Calculate reflection control point for proper x2, y2
                // inclusion.

                reflection = getReflection(coord, control, relative);

                x2 = reflection.x;
                y2 = reflection.y;
                x3 = parseFloat(coords[0]);
                y3 = parseFloat(coords[1]);
                x4 = parseFloat(coords[2]);
                y4 = parseFloat(coords[3]);

              }

              if (relative) {
                x2 += x1;
                y2 += y1;
                x3 += x1;
                y3 += y1;
                x4 += x1;
                y4 += y1;
              }

              if (!_.isObject(coord.controls)) {
                Anchor.AppendCurveProperties(coord);
              }

              coord.controls.right.set(x2 - coord.x, y2 - coord.y);
              result = new Anchor(
                x4, y4,
                x3 - x4, y3 - y4,
                undefined, undefined,
                Commands.curve
              );

              coord = result;
              control = result.controls.left;

              break;

            case 't':
            case 'q':

              x1 = coord.x;
              y1 = coord.y;

              if (!control) {
                control = new Vector();
              }

              if (/q/i.test(lower)) {

                x2 = parseFloat(coords[0]);
                y2 = parseFloat(coords[1]);
                x3 = parseFloat(coords[0]);
                y3 = parseFloat(coords[1]);
                x4 = parseFloat(coords[2]);
                y4 = parseFloat(coords[3]);

              } else {

                reflection = getReflection(coord, control, relative);

                x2 = reflection.x;
                y2 = reflection.y;
                x3 = reflection.x;
                y3 = reflection.y;
                x4 = parseFloat(coords[0]);
                y4 = parseFloat(coords[1]);

              }

              if (relative) {
                x2 += x1;
                y2 += y1;
                x3 += x1;
                y3 += y1;
                x4 += x1;
                y4 += y1;
              }

              if (!_.isObject(coord.controls)) {
                Anchor.AppendCurveProperties(coord);
              }

              coord.controls.right.set(
                (x2 - coord.x) * 0.33, (y2 - coord.y) * 0.33);
              result = new Anchor(
                x4, y4,
                x3 - x4, y3 - y4,
                undefined, undefined,
                Commands.curve
              );

              coord = result;
              control = result.controls.left;

              break;

            case 'a':

              x1 = coord.x;
              y1 = coord.y;

              var rx = parseFloat(coords[0]);
              var ry = parseFloat(coords[1]);
              var xAxisRotation = parseFloat(coords[2]);// * PI / 180;
              var largeArcFlag = parseFloat(coords[3]);
              var sweepFlag = parseFloat(coords[4]);

              x4 = parseFloat(coords[5]);
              y4 = parseFloat(coords[6]);

              if (relative) {
                x4 += x1;
                y4 += y1;
              }

              var anchor = new Anchor(x4, y4);
              anchor.command = Commands.arc;
              anchor.rx = rx;
              anchor.ry = ry;
              anchor.xAxisRotation = xAxisRotation;
              anchor.largeArcFlag = largeArcFlag;
              anchor.sweepFlag = sweepFlag;

              result = anchor;

              coord = anchor;
              control = undefined;

              break;

          }

          if (result) {
            if (Array.isArray(result)) {
              points = points.concat(result);
            } else {
              points.push(result);
            }
          }

        });

      }

      path = new Path(points, closed, undefined, true).noStroke();
      path.fill = 'black';

      var rect = path.getBoundingClientRect(true);

      // Center objects to stay consistent
      // with the rest of the Two.js API.
      rect.centroid = {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };

      _.each(path.vertices, function(v) {
        v.subSelf(rect.centroid);
      });

      applySvgAttributes.call(this, node, path, parentStyles);

      path.translation.addSelf(rect.centroid);

      return path;

    },

    circle: function(node, parentStyles) {

      var x = parseFloat(node.getAttribute('cx'));
      var y = parseFloat(node.getAttribute('cy'));
      var r = parseFloat(node.getAttribute('r'));

      var circle = new Circle(0, 0, r).noStroke();
      circle.fill = 'black';

      applySvgAttributes.call(this, node, circle, parentStyles);

      circle.translation.x = x;
      circle.translation.y = y;

      return circle;

    },

    ellipse: function(node, parentStyles) {

      var x = parseFloat(node.getAttribute('cx'));
      var y = parseFloat(node.getAttribute('cy'));
      var width = parseFloat(node.getAttribute('rx'));
      var height = parseFloat(node.getAttribute('ry'));

      var ellipse = new Ellipse(0, 0, width, height).noStroke();
      ellipse.fill = 'black';

      applySvgAttributes.call(this, node, ellipse, parentStyles);

      ellipse.translation.x = x;
      ellipse.translation.y = y;

      return ellipse;

    },

    rect: function(node, parentStyles) {

      var rx = parseFloat(node.getAttribute('rx'));
      var ry = parseFloat(node.getAttribute('ry'));

      if (!_.isNaN(rx) || !_.isNaN(ry)) {
        return read['rounded-rect'](node);
      }

      var width = parseFloat(node.getAttribute('width'));
      var height = parseFloat(node.getAttribute('height'));

      var w2 = width / 2;
      var h2 = height / 2;

      var rect = new Rectangle(0, 0, width, height)
        .noStroke();
      rect.fill = 'black';

      applySvgAttributes.call(this, node, rect, parentStyles);

      // For rectangles, (x, y) is the center of the shape rather than the top
      // left corner.
      rect.translation.x += w2;
      rect.translation.y += h2;

      return rect;

    },

    'rounded-rect': function(node, parentStyles) {

      var rx = parseFloat(node.getAttribute('rx')) || 0;
      var ry = parseFloat(node.getAttribute('ry')) || 0;

      var width = parseFloat(node.getAttribute('width'));
      var height = parseFloat(node.getAttribute('height'));

      var w2 = width / 2;
      var h2 = height / 2;
      var radius = new Vector(rx, ry);

      var rect = new RoundedRectangle(0, 0, width, height, radius)
        .noStroke();
      rect.fill = 'black';

      applySvgAttributes.call(this, node, rect, parentStyles);

      // For rectangles, (x, y) is the center of the shape rather than the top
      // left corner.
      rect.translation.x += w2;
      rect.translation.y += h2;

      return rect;

    },

    line: function(node, parentStyles) {

      var x1 = parseFloat(node.getAttribute('x1'));
      var y1 = parseFloat(node.getAttribute('y1'));
      var x2 = parseFloat(node.getAttribute('x2'));
      var y2 = parseFloat(node.getAttribute('y2'));

      var line = new Line(x1, y1, x2, y2).noFill();

      applySvgAttributes.call(this, node, line, parentStyles);

      return line;

    },

    lineargradient: function(node, parentStyles) {

      var x1 = parseFloat(node.getAttribute('x1'));
      var y1 = parseFloat(node.getAttribute('y1'));
      var x2 = parseFloat(node.getAttribute('x2'));
      var y2 = parseFloat(node.getAttribute('y2'));

      var ox = (x2 + x1) / 2;
      var oy = (y2 + y1) / 2;

      var stops = [];
      for (var i = 0; i < node.children.length; i++) {

        var child = node.children[i];

        var offset = child.getAttribute('offset');
        if (/%/ig.test(offset)) {
          offset = parseFloat(offset.replace(/%/ig, '')) / 100;
        }
        offset = parseFloat(offset);

        var color = child.getAttribute('stop-color');
        var opacity = child.getAttribute('stop-opacity');
        var style = child.getAttribute('style');

        var matches;
        if (color === null) {
          matches = style ? style.match(/stop-color:\s?([#a-fA-F0-9]*)/) : false;
          color = matches && matches.length > 1 ? matches[1] : undefined;
        }

        if (opacity === null) {
          matches = style ? style.match(/stop-opacity:\s?([0-9.-]*)/) : false;
          opacity = matches && matches.length > 1 ? parseFloat(matches[1]) : 1;
        } else {
          opacity = parseFloat(opacity);
        }

        stops.push(new Stop(offset, color, opacity));

      }

      var gradient = new LinearGradient(x1 - ox, y1 - oy, x2 - ox,
        y2 - oy, stops);

      applySvgAttributes.call(this, node, gradient, parentStyles);

      return gradient;

    },

    radialgradient: function(node, parentStyles) {

      var cx = parseFloat(node.getAttribute('cx')) || 0;
      var cy = parseFloat(node.getAttribute('cy')) || 0;
      var r = parseFloat(node.getAttribute('r'));

      var fx = parseFloat(node.getAttribute('fx'));
      var fy = parseFloat(node.getAttribute('fy'));

      if (_.isNaN(fx)) {
        fx = cx;
      }

      if (_.isNaN(fy)) {
        fy = cy;
      }

      var ox = Math.abs(cx + fx) / 2;
      var oy = Math.abs(cy + fy) / 2;

      var stops = [];
      for (var i = 0; i < node.children.length; i++) {

        var child = node.children[i];

        var offset = child.getAttribute('offset');
        if (/%/ig.test(offset)) {
          offset = parseFloat(offset.replace(/%/ig, '')) / 100;
        }
        offset = parseFloat(offset);

        var color = child.getAttribute('stop-color');
        var opacity = child.getAttribute('stop-opacity');
        var style = child.getAttribute('style');

        var matches;
        if (color === null) {
          matches = style ? style.match(/stop-color:\s?([#a-fA-F0-9]*)/) : false;
          color = matches && matches.length > 1 ? matches[1] : undefined;
        }

        if (opacity === null) {
          matches = style ? style.match(/stop-opacity:\s?([0-9.-]*)/) : false;
          opacity = matches && matches.length > 1 ? parseFloat(matches[1]) : 1;
        } else {
          opacity = parseFloat(opacity);
        }

        stops.push(new Stop(offset, color, opacity));

      }

      var gradient = new RadialGradient(cx - ox, cy - oy, r,
        stops, fx - ox, fy - oy);

      applySvgAttributes.call(this, node, gradient, parentStyles);

      return gradient;

    },

    text: function(node, parentStyles) {

      var alignment = getAlignment(node.getAttribute('text-anchor')) || 'left';
      var baseline = getBaseline(node) || 'baseline';
      var message = node.textContent;

      var text = new Text(message);

      applySvgAttributes.call(this, node, text, parentStyles);

      text.alignment = alignment;
      text.baseline = baseline;

      return text;

    },

    clippath: function(node, parentStyles) {
      if (read.defs.current && !read.defs.current.contains(node.id)) {
        read.defs.current.add(node.id, node);
      }
      return null;
    },

    image: function(node, parentStyles) {

      var href = node.getAttribute('href') || node.getAttribute('xlink:href');
      if (!href) {
        var error = new TwoError('encountered <image /> with no href.');
        console.warn(error.name, error.message);
        return null;
      }

      var x = parseFloat(node.getAttribute('x')) || 0;
      var y = parseFloat(node.getAttribute('y')) || 0;
      var width = parseFloat(node.getAttribute('width'));
      var height = parseFloat(node.getAttribute('height'));

      var sprite = new Sprite(href, x, y);

      if (!_.isNaN(width)) {
        sprite.width = width;
      }
      if (!_.isNaN(height)) {
        sprite.height = height;
      }

      applySvgAttributes.call(this, node, sprite, parentStyles);

      return sprite;
    }

  };

  /**
   * @name Two.Utils.xhr
   * @function
   * @param {String} path
   * @param {Function} callback
   * @returns {XMLHttpRequest} The constructed and called XHR request.
   * @description Canonical method to initiate `GET` requests in the browser. Mainly used by {@link Two#load} method.
   */
  function xhr(path, callback) {

    var xhr = new XMLHttpRequest();
    xhr.open('GET', path);

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        callback(xhr.responseText);
      }
    };

    xhr.send();
    return xhr;

  }

  /**
   * @name Two.ImageSequence
   * @class
   * @extends Two.Rectangle
   * @param {String|String[]|Two.Texture|Two.Texture[]} paths - A list of URLs or {@link Two.Texture}s.
   * @param {Number} [ox=0] - The initial `x` position of the Two.ImageSequence.
   * @param {Number} [oy=0] - The initial `y` position of the Two.ImageSequence.
   * @param {Number} [frameRate=30] - The frame rate at which the images should playback at.
   * @description A convenient package to display still or animated images organized as a series of still images.
   */
  function ImageSequence(paths, ox, oy, frameRate) {

    // Not using default constructor of Rectangle due to odd `beginning` / `ending` behavior.
    // See: https://github.com/jonobr1/two.js/issues/383
    Path.call(this, [
      new Anchor(),
      new Anchor(),
      new Anchor(),
      new Anchor()
    ], true);

    this._renderer.flagTextures = ImageSequence.FlagTextures.bind(this);
    this._renderer.bindTextures = ImageSequence.BindTextures.bind(this);
    this._renderer.unbindTextures = ImageSequence.UnbindTextures.bind(this);

    this.noStroke();
    this.noFill();

    /**
     * @name Two.ImageSequence#textures
     * @property {Two.Texture[]} - A list of textures to be used as frames for animating the {@link Two.ImageSequence}.
     */
    if (Array.isArray(paths)) {
      this.textures = paths.map(ImageSequence.GenerateTexture.bind(this));
    } else {
      // If just a single path convert into a single Two.Texture
      this.textures = [ImageSequence.GenerateTexture(paths)];
    }

    this.origin = new Vector();

    this._update();
    this.translation.set(ox || 0, oy || 0);

    /**
     * @name Two.ImageSequence#frameRate
     * @property {Number} - The number of frames to animate against per second.
     */
    if (typeof frameRate === 'number') {
      this.frameRate = frameRate;
    } else {
      this.frameRate = ImageSequence.DefaultFrameRate;
    }

    /**
     * @name Two.ImageSequence#index
     * @property {Number} - The index of the current tile of the sprite to display. Defaults to `0`.
     */
    this.index = 0;

  }

  _.extend(ImageSequence, {

    /**
     * @name Two.ImageSequence.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.ImageSequence}.
     */
    Properties: [
      'frameRate',
      'index'
    ],

    /**
     * @name Two.ImageSequence.DefaultFrameRate
     * @property The default frame rate that {@link Two.ImageSequence#frameRate} is set to when instantiated.
     */
    DefaultFrameRate: 30,

    /**
     * @name Two.ImageSequence.FlagTextures
     * @function
     * @description Cached method to let renderers know textures have been updated on a {@link Two.ImageSequence}.
     */
    FlagTextures: function() {
      this._flagTextures = true;
    },

    /**
     * @name Two.ImageSequence.BindTextures
     * @function
     * @description Cached method to let {@link Two.ImageSequence} know textures have been added to the instance.
     */
    BindTextures: function(items) {

      var i = items.length;
      while (i--) {
        items[i].bind(Events.Types.change, this._renderer.flagTextures);
      }

      this._renderer.flagTextures();

    },

    /**
     * @name Two.ImageSequence.UnbindVertices
     * @function
     * @description Cached method to let {@link Two.ImageSequence} know textures have been removed from the instance.
     */
    UnbindTextures: function(items) {

      var i = items.length;
      while (i--) {
        items[i].unbind(Events.Types.change, this._renderer.flagTextures);
      }

      this._renderer.flagTextures();

    },

    /**
     * @name Two.ImageSequence.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.ImageSequence} to any object. Handy if you'd like to extend or inherit the {@link Two.ImageSequence} class on a custom class.
     */
    MakeObservable: function(obj) {

      Rectangle.MakeObservable(obj);
      _.each(ImageSequence.Properties, defineGetterSetter, obj);

      Object.defineProperty(obj, 'textures', {

        enumerable: true,

        get: function() {
          return this._textures;
        },

        set: function(textures) {

          var bindTextures = this._renderer.bindTextures;
          var unbindTextures = this._renderer.unbindTextures;

          // Remove previous listeners
          if (this._textures) {
            this._textures
              .unbind(Events.Types.insert, bindTextures)
              .unbind(Events.Types.remove, unbindTextures);
          }

          // Create new Collection with copy of vertices
          this._textures = new Collection((textures || []).slice(0));

          // Listen for Collection changes and bind / unbind
          this._textures
            .bind(Events.Types.insert, bindTextures)
            .bind(Events.Types.remove, unbindTextures);

          // Bind Initial Textures
          bindTextures(this._textures);

        }

      });

    },

    /**
     * @name Two.ImageSequence.GenerateTexture
     * @property {Function} - Shorthand function to prepare source image material into readable format by {@link Two.ImageSequence}.
     * @param {String|Two.Texture} textureOrString - The texture or string to create a {@link Two.Texture} from.
     * @description Function used internally by {@link Two.ImageSequence} to parse arguments and return {@link Two.Texture}s.
     * @returns {Two.Texture}
     */
    GenerateTexture: function(obj) {
      if (obj instanceof Texture) {
        return obj;
      } else if (typeof obj === 'string') {
        return new Texture(obj);
      }
    }

  });

  _.extend(ImageSequence.prototype, Rectangle.prototype, {

    constructor: ImageSequence,

    /**
     * @name Two.ImageSequence#_flagTextures
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#textures} need updating.
     */
    _flagTextures: false,

    /**
     * @name Two.ImageSequence#_flagFrameRate
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#frameRate} needs updating.
     */
    _flagFrameRate: false,

    /**
     * @name Two.ImageSequence#_flagIndex
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ImageSequence#index} needs updating.
     */
    _flagIndex: false,

    // Private variables

    /**
     * @name Two.ImageSequence#_amount
     * @private
     * @property {Number} - Number of frames for a given {@link Two.ImageSequence}.
     */
    _amount: 1,

    /**
     * @name Two.ImageSequence#_duration
     * @private
     * @property {Number} - Number of milliseconds a {@link Two.ImageSequence}.
     */
    _duration: 0,

    /**
     * @name Two.ImageSequence#_index
     * @private
     * @property {Number} - The current frame the {@link Two.ImageSequence} is currently displaying.
     */
    _index: 0,

    /**
     * @name Two.ImageSequence#_startTime
     * @private
     * @property {Milliseconds} - Epoch time in milliseconds of when the {@link Two.ImageSequence} started.
     */
    _startTime: 0,

    /**
     * @name Two.ImageSequence#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.ImageSequence} is animating or not.
     */
    _playing: false,

    /**
     * @name Two.ImageSequence#_firstFrame
     * @private
     * @property {Number} - The frame the {@link Two.ImageSequence} should start with.
     */
    _firstFrame: 0,

    /**
     * @name Two.ImageSequence#_lastFrame
     * @private
     * @property {Number} - The frame the {@link Two.ImageSequence} should end with.
     */
    _lastFrame: 0,

    /**
     * @name Two.ImageSequence#_playing
     * @private
     * @property {Boolean} - Dictates whether the {@link Two.ImageSequence} should loop or not.
     */
    _loop: true,

    // Exposed through getter-setter

    /**
     * @name Two.ImageSequence#_textures
     * @private
     * @see {@link Two.ImageSequence#textures}
     */
    _textures: null,

    /**
     * @name Two.ImageSequence#_frameRate
     * @private
     * @see {@link Two.ImageSequence#frameRate}
     */
    _frameRate: 0,

    /**
     * @name Two.ImageSequence#_origin
     * @private
     * @see {@link Two.ImageSequence#origin}
     */
    _origin: null,

    /**
     * @name Two.ImageSequence#play
     * @function
     * @param {Number} [firstFrame=0] - The index of the frame to start the animation with.
     * @param {Number} [lastFrame] - The index of the frame to end the animation with. Defaults to the last item in the {@link Two.ImageSequence#textures}.
     * @param {Function} [onLastFrame] - Optional callback function to be triggered after playing the last frame. This fires multiple times when the image sequence is looped.
     * @description Initiate animation playback of a {@link Two.ImageSequence}.
     */
    play: function(firstFrame, lastFrame, onLastFrame) {

      this._playing = true;
      this._firstFrame = 0;
      this._lastFrame = this.amount - 1;
      this._startTime = _.performance.now();

      if (typeof firstFrame === 'number') {
        this._firstFrame = firstFrame;
      }
      if (typeof lastFrame === 'number') {
        this._lastFrame = lastFrame;
      }
      if (typeof onLastFrame === 'function') {
        this._onLastFrame = onLastFrame;
      } else {
        delete this._onLastFrame;
      }

      if (this._index !== this._firstFrame) {
        this._startTime -= 1000 * Math.abs(this._index - this._firstFrame)
          / this._frameRate;
      }

      return this;

    },

    /**
     * @name Two.ImageSequence#pause
     * @function
     * @description Halt animation playback of a {@link Two.ImageSequence}.
     */
    pause: function() {

      this._playing = false;
      return this;

    },

    /**
     * @name Two.ImageSequence#stop
     * @function
     * @description Halt animation playback of a {@link Two.ImageSequence} and set the current frame back to the first frame.
     */
    stop: function() {

      this._playing = false;
      this._index = this._firstFrame;

      return this;

    },

    /**
     * @name Two.ImageSequence#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.ImageSequence}
     * @description Create a new instance of {@link Two.ImageSequence} with the same properties of the current image sequence.
     */
    clone: function(parent) {

      var clone = new ImageSequence(this.textures, this.translation.x,
        this.translation.y, this.frameRate);

      clone._loop = this._loop;

      if (this._playing) {
        clone.play();
      }

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.ImageSequence#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {
      var object = Rectangle.prototype.toObject.call(this);
      object.textures = this.textures.map(function(texture) {
        return texture.toObject();
      });
      object.frameRate = this.frameRate;
      object.index = this.index;
      object._firstFrame = this._firstFrame;
      object._lastFrame = this._lastFrame;
      object._loop = this._loop;
      return object;
    },

    /**
     * @name Two.ImageSequence#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      var effects = this._textures;
      var width, height, elapsed, amount, duration, texture;
      var index, frames;

      if (this._flagTextures) {
        this._amount = effects.length;
      }

      if (this._flagFrameRate) {
        this._duration = 1000 * this._amount / this._frameRate;
      }

      if (this._playing && this._frameRate > 0) {

        amount = this._amount;

        if (_.isNaN(this._lastFrame)) {
          this._lastFrame = amount - 1;
        }

        // TODO: Offload perf logic to instance of `Two`.
        elapsed = _.performance.now() - this._startTime;
        frames = this._lastFrame + 1;
        duration = 1000 * (frames - this._firstFrame) / this._frameRate;

        if (this._loop) {
          elapsed = elapsed % duration;
        } else {
          elapsed = Math.min(elapsed, duration);
        }

        index = lerp(this._firstFrame, frames, elapsed / duration);
        index = Math.floor(index);

        if (index !== this._index) {

          this._index = index;
          texture = effects[this._index];

          if (texture.loaded) {

            width = texture.image.width;
            height = texture.image.height;

            if (this.width !== width) {
              this.width = width;
            }
            if (this.height !== height) {
              this.height = height;
            }

            this.fill = texture;

            if (index >= this._lastFrame - 1 && this._onLastFrame) {
              this._onLastFrame();  // Shortcut for chainable sprite animations
            }

          }

        }

      } else if (this._flagIndex || !(this.fill instanceof Texture)) {

        texture = effects[this._index];

        if (texture.loaded) {

          width = texture.image.width;
          height = texture.image.height;

          if (this.width !== width) {
            this.width = width;
          }
          if (this.height !== height) {
            this.height = height;
          }

        }

        this.fill = texture;

      }

      Rectangle.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.ImageSequence#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagTextures = this._flagFrameRate = false;
      Rectangle.prototype.flagReset.call(this);

      return this;

    }

  });

  ImageSequence.MakeObservable(ImageSequence.prototype);

  var TWO_PI$2 = Math.PI * 2, HALF_PI = Math.PI / 2;

  /**
   * @name Two.ArcSegment
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the arc segment.
   * @param {Number} [y=0] - The y position of the arc segment.
   * @param {Number} [innerRadius=0] - The inner radius value of the arc segment.
   * @param {Number} [outerRadius=0] - The outer radius value of the arc segment.
   * @param {Number} [startAngle=0] - The start angle of the arc segment in Number.
   * @param {Number} [endAngle=6.2831] - The end angle of the arc segment in Number.
   * @param {Number} [resolution=24] - The number of vertices used to construct the arc segment.
   */
  function ArcSegment(ox, oy, ir, or, sa, ea, res) {

    var amount = res || (Constants.Resolution * 3);
    var points = [];
    for (var i = 0; i < amount; i++) {
      points.push(new Anchor());
    }

    Path.call(this, points, true, false, true);

    /**
     * @name Two.ArcSegment#innerRadius
     * @property {Number} - The size of the inner radius of the arc segment.
     */
    if (typeof ir === 'number') {
      this.innerRadius = ir;
    }

    /**
     * @name Two.ArcSegment#outerRadius
     * @property {Number} - The size of the outer radius of the arc segment.
     */
    if (typeof or === 'number') {
      this.outerRadius = or;
    }

    /**
     * @name Two.ArcSegment#startRadius
     * @property {Number} - The angle of one side for the arc segment.
     */
    if (typeof sa === 'number') {
      this.startAngle = sa;
    }

    /**
     * @name Two.ArcSegment#endAngle
     * @property {Number} - The angle of the other side for the arc segment.
     */
    if (typeof ea === 'number') {
      this.endAngle = ea;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(ArcSegment, {

    /**
     * @name Two.ArcSegment.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.ArcSegment}.
     */
    Properties: ['startAngle', 'endAngle', 'innerRadius', 'outerRadius'],

    /**
     * @name Two.ArcSegment.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.ArcSegment} to any object. Handy if you'd like to extend the {@link Two.ArcSegment} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(ArcSegment.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(ArcSegment.prototype, Path.prototype, {

    constructor: ArcSegment,

    /**
     * @name Two.ArcSegment#_flagStartAngle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#startAngle} needs updating.
     */
    _flagStartAngle: false,
    /**
     * @name Two.ArcSegment#_flagEndAngle
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#endAngle} needs updating.
     */
    _flagEndAngle: false,
    /**
     * @name Two.ArcSegment#_flagInnerRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#innerRadius} needs updating.
     */
    _flagInnerRadius: false,
    /**
     * @name Two.ArcSegment#_flagOuterRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.ArcSegment#outerRadius} needs updating.
     */
    _flagOuterRadius: false,

    /**
     * @name Two.ArcSegment#_startAngle
     * @private
     * @see {@link Two.ArcSegment#startAngle}
     */
    _startAngle: 0,
    /**
     * @name Two.ArcSegment#_endAngle
     * @private
     * @see {@link Two.ArcSegment#endAngle}
     */
    _endAngle: TWO_PI$2,
    /**
     * @name Two.ArcSegment#_innerRadius
     * @private
     * @see {@link Two.ArcSegment#innerRadius}
     */
    _innerRadius: 0,
    /**
     * @name Two.ArcSegment#_outerRadius
     * @private
     * @see {@link Two.ArcSegment#outerRadius}
     */
    _outerRadius: 0,

    /**
     * @name Two.ArcSegment#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagStartAngle || this._flagEndAngle
        || this._flagInnerRadius || this._flagOuterRadius) {

        var sa = this._startAngle;
        var ea = this._endAngle;

        var ir = this._innerRadius;
        var or = this._outerRadius;

        var connected = mod(sa, TWO_PI$2) === mod(ea, TWO_PI$2);
        var punctured = ir > 0;

        var vertices = this.vertices;
        var length = (punctured ? vertices.length / 2 : vertices.length);
        var command, id = 0;

        if (connected) {
          length--;
        } else if (!punctured) {
          length -= 2;
        }

        /**
         * Outer Circle
         */
        for (var i = 0, last = length - 1; i < length; i++) {

          var pct = i / last;
          var v = vertices[id];
          var theta = pct * (ea - sa) + sa;
          var step = (ea - sa) / length;

          var x = or * Math.cos(theta);
          var y = or * Math.sin(theta);

          switch (i) {
            case 0:
              command = Commands.move;
              break;
            default:
              command = Commands.curve;
          }

          v.command = command;
          v.x = x;
          v.y = y;
          v.controls.left.clear();
          v.controls.right.clear();

          if (v.command === Commands.curve) {
            var amp = or * step / Math.PI;
            v.controls.left.x = amp * Math.cos(theta - HALF_PI);
            v.controls.left.y = amp * Math.sin(theta - HALF_PI);
            v.controls.right.x = amp * Math.cos(theta + HALF_PI);
            v.controls.right.y = amp * Math.sin(theta + HALF_PI);
            if (i === 1) {
              v.controls.left.multiplyScalar(2);
            }
            if (i === last) {
              v.controls.right.multiplyScalar(2);
            }
          }

          id++;

        }

        if (punctured) {

          if (connected) {
            vertices[id].command = Commands.close;
            id++;
          } else {
            length--;
            last = length - 1;
          }

          /**
           * Inner Circle
           */
          for (i = 0; i < length; i++) {

            pct = i / last;
            v = vertices[id];
            theta = (1 - pct) * (ea - sa) + sa;
            step = (ea - sa) / length;

            x = ir * Math.cos(theta);
            y = ir * Math.sin(theta);
            command = Commands.curve;
            if (i <= 0) {
              command = connected ? Commands.move : Commands.line;
            }

            v.command = command;
            v.x = x;
            v.y = y;
            v.controls.left.clear();
            v.controls.right.clear();

            if (v.command === Commands.curve) {
              amp = ir * step / Math.PI;
              v.controls.left.x = amp * Math.cos(theta + HALF_PI);
              v.controls.left.y = amp * Math.sin(theta + HALF_PI);
              v.controls.right.x = amp * Math.cos(theta - HALF_PI);
              v.controls.right.y = amp * Math.sin(theta - HALF_PI);
              if (i === 1) {
                v.controls.left.multiplyScalar(2);
              }
              if (i === last) {
                v.controls.right.multiplyScalar(2);
              }
            }

            id++;

          }

          // Final Point
          vertices[id].copy(vertices[0]);
          vertices[id].command = Commands.line;

        } else if (!connected) {

          vertices[id].command = Commands.line;
          vertices[id].x = 0;
          vertices[id].y = 0;
          id++;

          // Final Point
          vertices[id].copy(vertices[0]);
          vertices[id].command = Commands.line;

        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.ArcSegment#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      Path.prototype.flagReset.call(this);

      this._flagStartAngle = this._flagEndAngle
        = this._flagInnerRadius = this._flagOuterRadius = false;

      return this;

    },

    /**
     * @name Two.ArcSegment#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.ArcSegment}
     * @description Create a new instance of {@link Two.ArcSegment} with the same properties of the current path.
     */
    clone: function(parent) {

      var ir = this.innerRadius;
      var or = this.outerRadius;
      var sa = this.startAngle;
      var ea = this.endAngle;
      var resolution = this.vertices.length;

      var clone = new ArcSegment(0, 0, ir, or, sa, ea, resolution);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.ArcSegment#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(ArcSegment.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  ArcSegment.MakeObservable(ArcSegment.prototype);

  var TWO_PI$1 = Math.PI * 2, cos$1 = Math.cos, sin$1 = Math.sin;

  /**
   * @name Two.Polygon
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the polygon.
   * @param {Number} [y=0] - The y position of the polygon.
   * @param {Number} [radius=0] - The radius value of the polygon.
   * @param {Number} [sides=12] - The number of vertices used to construct the polygon.
   */
  function Polygon(ox, oy, r, sides) {

    sides = Math.max(sides || 0, 3);

    Path.call(this);

    this.closed = true;
    this.automatic = false;

    /**
     * @name Two.Polygon#width
     * @property {Number} - The size of the width of the polygon.
     */
    if (typeof r === 'number') {
      this.width = r * 2;
    }

    /**
     * @name Two.Polygon#height
     * @property {Number} - The size of the height of the polygon.
     */
    if (typeof r === 'number') {
      this.height = r * 2;
    }

    /**
     * @name Two.Polygon#sides
     * @property {Number} - The amount of sides the polyogn has.
     */
    if (typeof sides === 'number') {
      this.sides = sides;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(Polygon, {

    /**
     * @name Two.Polygon.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Polygon}.
     */
    Properties: ['width', 'height', 'sides'],

    /**
     * @name Two.Polygon.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Polygon} to any object. Handy if you'd like to extend the {@link Two.Polygon} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Polygon.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Polygon.prototype, Path.prototype, {

    constructor: Polygon,

    /**
     * @name Two.Polygon#_flagWidth
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#width} needs updating.
     */
    _flagWidth: false,
    /**
     * @name Two.Polygon#_flagHeight
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#height} needs updating.
     */
    _flagHeight: false,
    /**
     * @name Two.Polygon#_flagSides
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Polygon#sides} needs updating.
     */
    _flagSides: false,

    /**
     * @name Two.Polygon#_width
     * @private
     * @see {@link Two.Polygon#width}
     */
    _width: 0,
    /**
     * @name Two.Polygon#_height
     * @private
     * @see {@link Two.Polygon#height}
     */
    _height: 0,
    /**
     * @name Two.Polygon#_sides
     * @private
     * @see {@link Two.Polygon#sides}
     */
    _sides: 0,

    /**
     * @name Two.Polygon#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagWidth || this._flagHeight || this._flagSides) {

        var sides = this._sides;
        var amount = sides + 1;
        var length = this.vertices.length;

        if (length > sides) {
          this.vertices.splice(sides - 1, length - sides);
          length = sides;
        }

        for (var i = 0; i < amount; i++) {

          var pct = (i + 0.5) / sides;
          var theta = TWO_PI$1 * pct + Math.PI / 2;
          var x = this._width * cos$1(theta) / 2;
          var y = this._height * sin$1(theta) / 2;

          if (i >= length) {
            this.vertices.push(new Anchor(x, y));
          } else {
            this.vertices[i].set(x, y);
          }

          this.vertices[i].command = i === 0 ? Commands.move : Commands.line;

        }

      }

      Path.prototype._update.call(this);
      return this;

    },

    /**
     * @name Two.Polygon#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagWidth = this._flagHeight = this._flagSides = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Polygon#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Polygon}
     * @description Create a new instance of {@link Two.Polygon} with the same properties of the current path.
     */
    clone: function(parent) {

      var clone = new Polygon(0, 0, this.radius, this.sides);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Polygon#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Polygon.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Polygon.MakeObservable(Polygon.prototype);

  var TWO_PI = Math.PI * 2, cos = Math.cos, sin = Math.sin;

  /**
   * @name Two.Star
   * @class
   * @extends Two.Path
   * @param {Number} [x=0] - The x position of the star.
   * @param {Number} [y=0] - The y position of the star.
   * @param {Number} [innerRadius=0] - The inner radius value of the star.
   * @param {Number} [outerRadius=0] - The outer radius value of the star.
   * @param {Number} [sides=5] - The number of sides used to construct the star.
   */
  function Star(ox, oy, ir, or, sides) {

    if (arguments.length <= 3) {
      or = ir;
      ir = or / 2;
    }

    if (typeof sides !== 'number' || sides <= 0) {
      sides = 5;
    }

    Path.call(this);
    this.closed = true;
    this.automatic = false;

    /**
     * @name Two.Star#innerRadius
     * @property {Number} - The size of the inner radius of the star.
     */
    if (typeof ir === 'number') {
      this.innerRadius = ir;
    }

    /**
     * @name Two.Star#outerRadius
     * @property {Number} - The size of the outer radius of the star.
     */
    if (typeof or === 'number') {
      this.outerRadius = or;
    }

    /**
     * @name Two.Star#sides
     * @property {Number} - The amount of sides the star has.
     */
    if (typeof sides === 'number') {
      this.sides = sides;
    }

    this._update();

    if (typeof ox === 'number') {
      this.translation.x = ox;
    }
    if (typeof oy === 'number') {
      this.translation.y = oy;
    }

  }

  _.extend(Star, {

    /**
     * @name Two.Star.Properties
     * @property {String[]} - A list of properties that are on every {@link Two.Star}.
     */
    Properties: ['innerRadius', 'outerRadius', 'sides'],

    /**
     * @name Two.Star.MakeObservable
     * @function
     * @param {Object} object - The object to make observable.
     * @description Convenience function to apply observable qualities of a {@link Two.Star} to any object. Handy if you'd like to extend the {@link Two.Star} class on a custom class.
     */
    MakeObservable: function(obj) {

      Path.MakeObservable(obj);
      _.each(Star.Properties, defineGetterSetter, obj);

    }

  });

  _.extend(Star.prototype, Path.prototype, {

    constructor: Star,

    /**
     * @name Two.Star#_flagInnerRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#innerRadius} needs updating.
     */
    _flagInnerRadius: false,
    /**
     * @name Two.Star#_flagOuterRadius
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#outerRadius} needs updating.
     */
    _flagOuterRadius: false,
    /**
     * @name Two.Star#_flagSides
     * @private
     * @property {Boolean} - Determines whether the {@link Two.Star#sides} needs updating.
     */
    _flagSides: false,

    /**
     * @name Two.Star#_innerRadius
     * @private
     * @see {@link Two.Star#innerRadius}
     */
    _innerRadius: 0,
    /**
     * @name Two.Star#_outerRadius
     * @private
     * @see {@link Two.Star#outerRadius}
     */
    _outerRadius: 0,
    /**
     * @name Two.Star#_sides
     * @private
     * @see {@link Two.Star#sides}
     */
    _sides: 0,

    /**
     * @name Two.Star#_update
     * @function
     * @private
     * @param {Boolean} [bubbles=false] - Force the parent to `_update` as well.
     * @description This is called before rendering happens by the renderer. This applies all changes necessary so that rendering is up-to-date but not updated more than it needs to be.
     * @nota-bene Try not to call this method more than once a frame.
     */
    _update: function() {

      if (this._flagVertices || this._flagInnerRadius || this._flagOuterRadius || this._flagSides) {

        var sides = this._sides * 2;
        var amount = sides + 1;
        var length = this.vertices.length;

        if (length > sides) {
          this.vertices.splice(sides - 1, length - sides);
          length = sides;
        }

        for (var i = 0; i < amount; i++) {

          var pct = (i + 0.5) / sides;
          var theta = TWO_PI * pct;
          var r = (!(i % 2) ? this._innerRadius : this._outerRadius) / 2;
          var x = r * cos(theta);
          var y = r * sin(theta);

          if (i >= length) {
            this.vertices.push(new Anchor(x, y));
          } else {
            this.vertices[i].set(x, y);
          }

          this.vertices[i].command = i === 0 ? Commands.move : Commands.line;

        }

      }

      Path.prototype._update.call(this);

      return this;

    },

    /**
     * @name Two.Star#flagReset
     * @function
     * @private
     * @description Called internally to reset all flags. Ensures that only properties that change are updated before being sent to the renderer.
     */
    flagReset: function() {

      this._flagInnerRadius = this._flagOuterRadius = this._flagSides = false;
      Path.prototype.flagReset.call(this);

      return this;

    },

    /**
     * @name Two.Star#clone
     * @function
     * @param {Two.Group} [parent] - The parent group or scene to add the clone to.
     * @returns {Two.Star}
     * @description Create a new instance of {@link Two.Star} with the same properties of the current path.
     */
    clone: function(parent) {

      var ir = this.innerRadius;
      var or = this.outerRadius;
      var sides = this.sides;

      var clone = new Star(0, 0, ir, or, sides);

      clone.translation.copy(this.translation);
      clone.rotation = this.rotation;
      clone.scale = this.scale;
      clone.skewX = this.skewX;
      clone.skewY = this.skewY;

      if (this.matrix.manual) {
        clone.matrix.copy(this.matrix);
      }

      _.each(Path.Properties, function(k) {
        clone[k] = this[k];
      }, this);

      if (parent) {
        parent.add(clone);
      }

      return clone;

    },

    /**
     * @name Two.Star#toObject
     * @function
     * @returns {Object}
     * @description Return a JSON compatible plain object that represents the path.
     */
    toObject: function() {

      var object = Path.prototype.toObject.call(this);

      _.each(Star.Properties, function(property) {
        object[property] = this[property];
      }, this);

      return object;

    }

  });

  Star.MakeObservable(Star.prototype);

  var svg = {

    version: 1.1,

    ns: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink',

    alignments: {
      left: 'start',
      center: 'middle',
      right: 'end'
    },

    // Create an svg namespaced element.
    createElement: function(name, attrs) {
      var tag = name;
      var elem = document.createElementNS(svg.ns, tag);
      if (tag === 'svg') {
        attrs = _.defaults(attrs || {}, {
          version: svg.version
        });
      }
      if (attrs && Object.keys(attrs).length > 0) {
        svg.setAttributes(elem, attrs);
      }
      return elem;
    },

    // Add attributes from an svg element.
    setAttributes: function(elem, attrs) {
      var keys = Object.keys(attrs);
      for (var i = 0; i < keys.length; i++) {
        if (/href/.test(keys[i])) {
          elem.setAttributeNS(svg.xlink, keys[i], attrs[keys[i]]);
        } else {
          elem.setAttribute(keys[i], attrs[keys[i]]);
        }
      }
      return this;
    },

    // Remove attributes from an svg element.
    removeAttributes: function(elem, attrs) {
      for (var key in attrs) {
        elem.removeAttribute(key);
      }
      return this;
    },

    // Turn a set of vertices into a string for the d property of a path
    // element. It is imperative that the string collation is as fast as
    // possible, because this call will be happening multiple times a
    // second.
    toString: function(points, closed) {

      var l = points.length,
        last = l - 1,
        d, // The elusive last Commands.move point
        string = '';

      for (var i = 0; i < l; i++) {
        var b = points[i];
        var command;
        var prev = closed ? mod(i - 1, l) : Math.max(i - 1, 0);
        var next = closed ? mod(i + 1, l) : Math.min(i + 1, last);

        var a = points[prev];
        var c = points[next];

        var vx, vy, ux, uy, ar, bl, br, cl;
        var rx, ry, xAxisRotation, largeArcFlag, sweepFlag;

        // Access x and y directly,
        // bypassing the getter
        var x = toFixed(b.x);
        var y = toFixed(b.y);

        switch (b.command) {

          case Commands.close:
            command = Commands.close;
            break;

          case Commands.arc:

            rx = b.rx;
            ry = b.ry;
            xAxisRotation = b.xAxisRotation;
            largeArcFlag = b.largeArcFlag;
            sweepFlag = b.sweepFlag;

            command = Commands.arc + ' ' + rx + ' ' + ry + ' '
              + xAxisRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' '
              + x + ' ' + y;
            break;

          case Commands.curve:

            ar = (a.controls && a.controls.right) || Vector.zero;
            bl = (b.controls && b.controls.left) || Vector.zero;

            if (a.relative) {
              vx = toFixed((ar.x + a.x));
              vy = toFixed((ar.y + a.y));
            } else {
              vx = toFixed(ar.x);
              vy = toFixed(ar.y);
            }

            if (b.relative) {
              ux = toFixed((bl.x + b.x));
              uy = toFixed((bl.y + b.y));
            } else {
              ux = toFixed(bl.x);
              uy = toFixed(bl.y);
            }

            command = ((i === 0) ? Commands.move : Commands.curve) +
              ' ' + vx + ' ' + vy + ' ' + ux + ' ' + uy + ' ' + x + ' ' + y;
            break;

          case Commands.move:
            d = b;
            command = Commands.move + ' ' + x + ' ' + y;
            break;

          default:
            command = b.command + ' ' + x + ' ' + y;

        }

        // Add a final point and close it off

        if (i >= last && closed) {

          if (b.command === Commands.curve) {

            // Make sure we close to the most previous Commands.move
            c = d;

            br = (b.controls && b.controls.right) || b;
            cl = (c.controls && c.controls.left) || c;

            if (b.relative) {
              vx = toFixed((br.x + b.x));
              vy = toFixed((br.y + b.y));
            } else {
              vx = toFixed(br.x);
              vy = toFixed(br.y);
            }

            if (c.relative) {
              ux = toFixed((cl.x + c.x));
              uy = toFixed((cl.y + c.y));
            } else {
              ux = toFixed(cl.x);
              uy = toFixed(cl.y);
            }

            x = toFixed(c.x);
            y = toFixed(c.y);

            command +=
              ' C ' + vx + ' ' + vy + ' ' + ux + ' ' + uy + ' ' + x + ' ' + y;

          }

          if (b.command !== Commands.close) {
            command += ' Z';
          }

        }

        string += command + ' ';

      }

      return string;

    },

    getClip: function(shape, domElement) {

      var clip = shape._renderer.clip;

      if (!clip) {

        clip = shape._renderer.clip = svg.createElement('clipPath', {
          'clip-rule': 'nonzero'
        });
        domElement.defs.appendChild(clip);

      }

      return clip;

    },

    group: {

      // TODO: Can speed up.
      // TODO: How does this effect a f
      appendChild: function(object) {

        var elem = object._renderer.elem;

        if (!elem) {
          return;
        }

        var tag = elem.nodeName;

        if (!tag || /(radial|linear)gradient/i.test(tag) || object._clip) {
          return;
        }

        this.elem.appendChild(elem);

      },

      removeChild: function(object) {

        var elem = object._renderer.elem;

        if (!elem || elem.parentNode != this.elem) {
          return;
        }

        var tag = elem.nodeName;

        if (!tag) {
          return;
        }

        // Defer subtractions while clipping.
        if (object._clip) {
          return;
        }

        this.elem.removeChild(elem);

      },

      orderChild: function(object) {
        this.elem.appendChild(object._renderer.elem);
      },

      renderChild: function(child) {
        svg[child._renderer.type].render.call(child, this);
      },

      render: function(domElement) {

        // Shortcut for hidden objects.
        // Doesn't reset the flags, so changes are stored and
        // applied once the object is visible again
        if ((!this._visible && !this._flagVisible)
          || (this._opacity === 0 && !this._flagOpacity)) {
          return this;
        }

        this._update();

        if (!this._renderer.elem) {
          this._renderer.elem = svg.createElement('g', {
            id: this.id
          });
          domElement.appendChild(this._renderer.elem);
        }

        // _Update styles for the <g>
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var context = {
          domElement: domElement,
          elem: this._renderer.elem
        };

        if (flagMatrix) {
          this._renderer.elem.setAttribute('transform', 'matrix(' + this._matrix.toString() + ')');
        }

        for (var i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          svg[child._renderer.type].render.call(child, domElement);
        }

        if (this._flagId) {
          this._renderer.elem.setAttribute('id', this._id);
        }

        if (this._flagOpacity) {
          this._renderer.elem.setAttribute('opacity', this._opacity);
        }

        if (this._flagVisible) {
          this._renderer.elem.setAttribute('display', this._visible ? 'inline' : 'none');
        }

        if (this._flagClassName) {
          this._renderer.elem.setAttribute('class', this.classList.join(' '));
        }

        if (this._flagAdditions) {
          this.additions.forEach(svg.group.appendChild, context);
        }

        if (this._flagSubtractions) {
          this.subtractions.forEach(svg.group.removeChild, context);
        }

        if (this._flagOrder) {
          this.children.forEach(svg.group.orderChild, context);
        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        // if (this._flagClip) {

        //   clip = svg.getClip(this, domElement);
        //   elem = this._renderer.elem;

        //   if (this._clip) {
        //     elem.removeAttribute('id');
        //     clip.setAttribute('id', this.id);
        //     clip.appendChild(elem);
        //   } else {
        //     clip.removeAttribute('id');
        //     elem.setAttribute('id', this.id);
        //     this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
        //   }

        // }

        if (this._flagMask) {
          if (this._mask) {
            svg[this._mask._renderer.type].render.call(this._mask, domElement);
            this._renderer.elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
          } else {
            this._renderer.elem.removeAttribute('clip-path');
          }
        }

        return this.flagReset();

      }

    },

    path: {

      render: function(domElement) {

        // Shortcut for hidden objects.
        // Doesn't reset the flags, so changes are stored and
        // applied once the object is visible again
        if (this._opacity === 0 && !this._flagOpacity) {
          return this;
        }

        this._update();

        // Collect any attribute that needs to be changed here
        var changed = {};

        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagMatrix) {
          changed.transform = 'matrix(' + this._matrix.toString() + ')';
        }

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagVertices) {
          var vertices = svg.toString(this._renderer.vertices, this._closed);
          changed.d = vertices;
        }

        if (this._fill && this._fill._renderer) {
          this._fill._update();
          svg[this._fill._renderer.type].render.call(this._fill, domElement, true);
        }

        if (this._flagFill) {
          changed.fill = this._fill && this._fill.id
            ? 'url(#' + this._fill.id + ')' : this._fill;
        }

        if (this._stroke && this._stroke._renderer) {
          this._stroke._update();
          svg[this._stroke._renderer.type].render.call(this._stroke, domElement, true);
        }

        if (this._flagStroke) {
          changed.stroke = this._stroke && this._stroke.id
            ? 'url(#' + this._stroke.id + ')' : this._stroke;
        }

        if (this._flagLinewidth) {
          changed['stroke-width'] = this._linewidth;
        }

        if (this._flagOpacity) {
          changed['stroke-opacity'] = this._opacity;
          changed['fill-opacity'] = this._opacity;
        }

        if (this._flagClassName) {
          changed['class'] = this.classList.join(' ');
        }

        if (this._flagVisible) {
          changed.visibility = this._visible ? 'visible' : 'hidden';
        }

        if (this._flagCap) {
          changed['stroke-linecap'] = this._cap;
        }

        if (this._flagJoin) {
          changed['stroke-linejoin'] = this._join;
        }

        if (this._flagMiter) {
          changed['stroke-miterlimit'] = this._miter;
        }

        if (this.dashes && this.dashes.length > 0) {
          changed['stroke-dasharray'] = this.dashes.join(' ');
          changed['stroke-dashoffset'] = this.dashes.offset || 0;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this._id;
          this._renderer.elem = svg.createElement('path', changed);
          domElement.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {
          svg.setAttributes(this._renderer.elem, changed);
        }

        if (this._flagClip) {

          var clip = svg.getClip(this, domElement);
          var elem = this._renderer.elem;

          if (this._clip) {
            elem.removeAttribute('id');
            clip.setAttribute('id', this.id);
            clip.appendChild(elem);
          } else {
            clip.removeAttribute('id');
            elem.setAttribute('id', this.id);
            this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
          }

        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        if (this._flagMask) {
          if (this._mask) {
            svg[this._mask._renderer.type].render.call(this._mask, domElement);
            this._renderer.elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
          } else {
            this._renderer.elem.removeAttribute('clip-path');
          }
        }

        return this.flagReset();

      }

    },

    text: {

      render: function(domElement) {

        this._update();

        var changed = {};

        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagMatrix) {
          changed.transform = 'matrix(' + this._matrix.toString() + ')';
        }

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagFamily) {
          changed['font-family'] = this._family;
        }
        if (this._flagSize) {
          changed['font-size'] = this._size;
        }
        if (this._flagLeading) {
          changed['line-height'] = this._leading;
        }
        if (this._flagAlignment) {
          changed['text-anchor'] = svg.alignments[this._alignment] || this._alignment;
        }
        if (this._flagBaseline) {
          changed['alignment-baseline'] = changed['dominant-baseline'] = this._baseline;
        }
        if (this._flagStyle) {
          changed['font-style'] = this._style;
        }
        if (this._flagWeight) {
          changed['font-weight'] = this._weight;
        }
        if (this._flagDecoration) {
          changed['text-decoration'] = this._decoration;
        }
        if (this._fill && this._fill._renderer) {
          this._fill._update();
          svg[this._fill._renderer.type].render.call(this._fill, domElement, true);
        }
        if (this._flagFill) {
          changed.fill = this._fill && this._fill.id
            ? 'url(#' + this._fill.id + ')' : this._fill;
        }
        if (this._stroke && this._stroke._renderer) {
          this._stroke._update();
          svg[this._stroke._renderer.type].render.call(this._stroke, domElement, true);
        }
        if (this._flagStroke) {
          changed.stroke = this._stroke && this._stroke.id
            ? 'url(#' + this._stroke.id + ')' : this._stroke;
        }
        if (this._flagLinewidth) {
          changed['stroke-width'] = this._linewidth;
        }
        if (this._flagOpacity) {
          changed.opacity = this._opacity;
        }
        if (this._flagClassName) {
          changed['class'] = this.classList.join(' ');
        }
        if (this._flagVisible) {
          changed.visibility = this._visible ? 'visible' : 'hidden';
        }
        if (this.dashes && this.dashes.length > 0) {
          changed['stroke-dasharray'] = this.dashes.join(' ');
          changed['stroke-dashoffset'] = this.dashes.offset || 0;
        }

        if (!this._renderer.elem) {

          changed.id = this._id;

          this._renderer.elem = svg.createElement('text', changed);
          domElement.defs.appendChild(this._renderer.elem);

        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagClip) {

          var clip = svg.getClip(this, domElement);
          var elem = this._renderer.elem;

          if (this._clip) {
            elem.removeAttribute('id');
            clip.setAttribute('id', this.id);
            clip.appendChild(elem);
          } else {
            clip.removeAttribute('id');
            elem.setAttribute('id', this.id);
            this.parent._renderer.elem.appendChild(elem); // TODO: should be insertBefore
          }

        }

        // Commented two-way functionality of clips / masks with groups and
        // polygons. Uncomment when this bug is fixed:
        // https://code.google.com/p/chromium/issues/detail?id=370951

        if (this._flagMask) {
          if (this._mask) {
            svg[this._mask._renderer.type].render.call(this._mask, domElement);
            this._renderer.elem.setAttribute('clip-path', 'url(#' + this._mask.id + ')');
          } else {
            this._renderer.elem.removeAttribute('clip-path');
          }
        }

        if (this._flagValue) {
          this._renderer.elem.textContent = this._value;
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagEndPoints) {
          changed.x1 = this.left._x;
          changed.y1 = this.left._y;
          changed.x2 = this.right._x;
          changed.y2 = this.right._y;
        }

        if (this._flagSpread) {
          changed.spreadMethod = this._spread;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this._id;
          changed.gradientUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('linearGradient', changed);
          domElement.defs.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagStops) {

          var lengthChanged = this._renderer.elem.childNodes.length
            !== this.stops.length;

          if (lengthChanged) {
            while (this._renderer.elem.lastChild) {
              this._renderer.elem.removeChild(this._renderer.elem.lastChild);
            }
          }

          for (var i = 0; i < this.stops.length; i++) {

            var stop = this.stops[i];
            var attrs = {};

            if (stop._flagOffset) {
              attrs.offset = 100 * stop._offset + '%';
            }
            if (stop._flagColor) {
              attrs['stop-color'] = stop._color;
            }
            if (stop._flagOpacity) {
              attrs['stop-opacity'] = stop._opacity;
            }

            if (!stop._renderer.elem) {
              stop._renderer.elem = svg.createElement('stop', attrs);
            } else {
              svg.setAttributes(stop._renderer.elem, attrs);
            }

            if (lengthChanged) {
              this._renderer.elem.appendChild(stop._renderer.elem);
            }
            stop.flagReset();

          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagCenter) {
          changed.cx = this.center._x;
          changed.cy = this.center._y;
        }
        if (this._flagFocal) {
          changed.fx = this.focal._x;
          changed.fy = this.focal._y;
        }

        if (this._flagRadius) {
          changed.r = this._radius;
        }

        if (this._flagSpread) {
          changed.spreadMethod = this._spread;
        }

        // If there is no attached DOM element yet,
        // create it with all necessary attributes.
        if (!this._renderer.elem) {

          changed.id = this._id;
          changed.gradientUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('radialGradient', changed);
          domElement.defs.appendChild(this._renderer.elem);

        // Otherwise apply all pending attributes
        } else {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._flagStops) {

          var lengthChanged = this._renderer.elem.childNodes.length
            !== this.stops.length;

          if (lengthChanged) {
            while (this._renderer.elem.lastChild) {
              this._renderer.elem.removeChild(this._renderer.elem.lastChild);
            }
          }

          for (var i = 0; i < this.stops.length; i++) {

            var stop = this.stops[i];
            var attrs = {};

            if (stop._flagOffset) {
              attrs.offset = 100 * stop._offset + '%';
            }
            if (stop._flagColor) {
              attrs['stop-color'] = stop._color;
            }
            if (stop._flagOpacity) {
              attrs['stop-opacity'] = stop._opacity;
            }

            if (!stop._renderer.elem) {
              stop._renderer.elem = svg.createElement('stop', attrs);
            } else {
              svg.setAttributes(stop._renderer.elem, attrs);
            }

            if (lengthChanged) {
              this._renderer.elem.appendChild(stop._renderer.elem);
            }
            stop.flagReset();

          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(domElement, silent) {

        if (!silent) {
          this._update();
        }

        var changed = {};
        var styles = { x: 0, y: 0 };
        var image = this.image;

        if (this._flagId) {
          changed.id = this._id;
        }

        if (this._flagLoaded && this.loaded) {

          switch (image.nodeName.toLowerCase()) {

            case 'canvas':
              styles.href = styles['xlink:href'] = image.toDataURL('image/png');
              break;
            case 'img':
            case 'image':
              styles.href = styles['xlink:href'] = this.src;
              break;

          }

        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          changed.x = this._offset.x;
          changed.y = this._offset.y;

          if (image) {

            changed.x -= image.width / 2;
            changed.y -= image.height / 2;

            if (this._scale instanceof Vector) {
              changed.x *= this._scale.x;
              changed.y *= this._scale.y;
            } else {
              changed.x *= this._scale;
              changed.y *= this._scale;
            }
          }

          if (changed.x > 0) {
            changed.x *= - 1;
          }
          if (changed.y > 0) {
            changed.y *= - 1;
          }

        }

        if (this._flagScale || this._flagLoaded || this._flagRepeat) {

          changed.width = 0;
          changed.height = 0;

          if (image) {

            styles.width = changed.width = image.width;
            styles.height = changed.height = image.height;

            // TODO: Hack / Band-aid
            switch (this._repeat) {
              case 'no-repeat':
                changed.width += 1;
                changed.height += 1;
                break;
            }

            if (this._scale instanceof Vector) {
              changed.width *= this._scale.x;
              changed.height *= this._scale.y;
            } else {
              changed.width *= this._scale;
              changed.height *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {
          if (!this._renderer.image) {
            this._renderer.image = svg.createElement('image', styles);
          } else {
            svg.setAttributes(this._renderer.image, styles);
          }
        }

        if (!this._renderer.elem) {

          changed.id = this._id;
          changed.patternUnits = 'userSpaceOnUse';
          this._renderer.elem = svg.createElement('pattern', changed);
          domElement.defs.appendChild(this._renderer.elem);

        } else if (Object.keys(changed).length !== 0) {

          svg.setAttributes(this._renderer.elem, changed);

        }

        if (this._renderer.elem && this._renderer.image && !this._renderer.appended) {
          this._renderer.elem.appendChild(this._renderer.image);
          this._renderer.appended = true;
        }

        return this.flagReset();

      }

    }

  };

  /**
   * @name Two.SVGRenderer
   * @class
   * @extends Two.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<svg />` to draw to. If none given a new one will be constructed.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.svg` (the default type). It takes Two.js' scenegraph and renders it to a `<svg />`.
   */
  function Renderer$1(params) {

    /**
     * @name Two.SVGRenderer#domElement
     * @property {Element} - The `<svg />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || svg.createElement('svg');

    /**
     * @name Two.SVGRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Group();
    this.scene.parent = this;

    /**
     * @name Two.SVGRenderer#defs
     * @property {SvgDefintionsElement} - The `<defs />` to apply gradients, patterns, and bitmap imagery.
     */
    this.defs = svg.createElement('defs');
    this.domElement.appendChild(this.defs);
    this.domElement.defs = this.defs;
    this.domElement.style.overflow = 'hidden';

  }

  _.extend(Renderer$1, {

    /**
     * @name Two.SVGRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<svg />`.
     */
    Utils: svg

  });

  _.extend(Renderer$1.prototype, Events, {

    constructor: Renderer$1,

    /**
     * @name Two.SVGRenderer#setSize
     * @function
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @description Change the size of the renderer.
     * @nota-bene Triggers a `Two.Events.resize`.
     */
    setSize: function(width, height) {

      this.width = width;
      this.height = height;

      svg.setAttributes(this.domElement, {
        width: width,
        height: height
      });

      return this.trigger(Events.Types.resize, width, height);

    },

    /**
     * @name Two.SVGRenderer#render
     * @function
     * @description Render the current scene to the `<svg />`.
     */
    render: function() {

      svg.group.render.call(this.scene, this.domElement);

      return this;

    }

  });

  // Constants

  var multiplyMatrix = Matrix.Multiply,
    identity = [1, 0, 0, 0, 1, 0, 0, 0, 1],
    transformation = new NumArray(9),
    CanvasUtils = Renderer$2.Utils;

  var webgl = {

    isHidden: /(undefined|none|transparent)/i,

    canvas: (root$1.document ? root$1.document.createElement('canvas') : { getContext: function() {} }),

    alignments: {
      left: 'start',
      middle: 'center',
      right: 'end'
    },

    matrix: new Matrix(),

    group: {

      removeChild: function(child, gl) {
        if (child.children) {
          for (var i = 0; i < child.children.length; i++) {
            webgl.group.removeChild(child.children[i], gl);
          }
          return;
        }
        // Deallocate texture to free up gl memory.
        gl.deleteTexture(child._renderer.texture);
        delete child._renderer.texture;
      },

      render: function(gl, program) {

        if (!this._visible) {
          return;
        }

        this._update();

        var parent = this.parent;
        var flagParentMatrix = (parent._matrix && parent._matrix.manual) || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;

        if (flagParentMatrix || flagMatrix) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new NumArray(9);
          }

          // Reduce amount of object / array creation / deletion
          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }

          if (this._scale instanceof Vector) {
            this._renderer.scale.x = this._scale.x;
            this._renderer.scale.y = this._scale.y;
          } else {
            this._renderer.scale.x = this._scale;
            this._renderer.scale.y = this._scale;
          }

          if (!(/renderer/i.test(parent._renderer.type))) {
            this._renderer.scale.x *= parent._renderer.scale.x;
            this._renderer.scale.y *= parent._renderer.scale.y;
          }

          if (flagParentMatrix) {
            this._flagMatrix = true;
          }

        }

        if (this._mask) {

          // Stencil away everything that isn't rendered by the mask
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);

          gl.stencilFunc(gl.ALWAYS, 1, 0);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          // Don't draw the element onto the canvas, only onto the stencil buffer
          gl.colorMask(false, false, false, false);

          webgl[this._mask._renderer.type].render.call(this._mask, gl, program, this);

          gl.stencilFunc(gl.EQUAL, 1, 0xff);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.colorMask(true, true, true, true);

        }

        this._flagOpacity = parent._flagOpacity || this._flagOpacity;

        this._renderer.opacity = this._opacity
          * (parent && parent._renderer ? parent._renderer.opacity : 1);

        var i;
        if (this._flagSubtractions) {
          for (i = 0; i < this.subtractions.length; i++) {
            webgl.group.removeChild(this.subtractions[i], gl);
          }
        }

        for (i = 0; i < this.children.length; i++) {
          var child = this.children[i];
          webgl[child._renderer.type].render.call(child, gl, program);
        }

        if (this._mask) {
          gl.disable(gl.STENCIL_TEST);
        }

        return this.flagReset();

      }

    },

    path: {

      updateCanvas: function(elem) {

        var next, prev, a, c, ux, uy, vx, vy, ar, bl, br, cl, x, y;
        var isOffset;

        var commands = elem._renderer.vertices;
        var canvas = this.canvas;
        var ctx = this.ctx;

        // Styles
        var scale = elem._renderer.scale;
        var stroke = elem._stroke;
        var linewidth = elem._linewidth;
        var fill = elem._fill;
        var opacity = elem._renderer.opacity || elem._opacity;
        var cap = elem._cap;
        var join = elem._join;
        var miter = elem._miter;
        var closed = elem._closed;
        var dashes = elem.dashes;
        var length = commands.length;
        var last = length - 1;

        canvas.width = Math.max(Math.ceil(elem._renderer.rect.width * scale.x), 1);
        canvas.height = Math.max(Math.ceil(elem._renderer.rect.height * scale.y), 1);

        var centroid = elem._renderer.rect.centroid;
        var cx = centroid.x;
        var cy = centroid.y;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            webgl[fill._renderer.type].render.call(fill, ctx, elem);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            webgl[stroke._renderer.type].render.call(stroke, ctx, elem);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
          if (miter) {
            ctx.miterLimit = miter;
          }
          if (join) {
            ctx.lineJoin = join;
          }
          if (!closed && cap) {
            ctx.lineCap = cap;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }

        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        var d;
        ctx.save();
        ctx.scale(scale.x, scale.y);

        ctx.translate(cx, cy);

        ctx.beginPath();
        for (var i = 0; i < commands.length; i++) {

          var b = commands[i];

          x = b.x;
          y = b.y;

          switch (b.command) {

            case Commands.close:
              ctx.closePath();
              break;

            case Commands.arc:

              var rx = b.rx;
              var ry = b.ry;
              var xAxisRotation = b.xAxisRotation;
              var largeArcFlag = b.largeArcFlag;
              var sweepFlag = b.sweepFlag;

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              a = commands[prev];

              var ax = a.x;
              var ay = a.y;

              CanvasUtils.renderSvgArcCommand(ctx, ax, ay, rx, ry, largeArcFlag, sweepFlag, xAxisRotation, x, y);
              break;

            case Commands.curve:

              prev = closed ? mod(i - 1, length) : Math.max(i - 1, 0);
              next = closed ? mod(i + 1, length) : Math.min(i + 1, last);

              a = commands[prev];
              c = commands[next];
              ar = (a.controls && a.controls.right) || Vector.zero;
              bl = (b.controls && b.controls.left) || Vector.zero;

              if (a._relative) {
                vx = ar.x + a.x;
                vy = ar.y + a.y;
              } else {
                vx = ar.x;
                vy = ar.y;
              }

              if (b._relative) {
                ux = bl.x + b.x;
                uy = bl.y + b.y;
              } else {
                ux = bl.x;
                uy = bl.y;
              }

              ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              if (i >= last && closed) {

                c = d;

                br = (b.controls && b.controls.right) || Vector.zero;
                cl = (c.controls && c.controls.left) || Vector.zero;

                if (b._relative) {
                  vx = br.x + b.x;
                  vy = br.y + b.y;
                } else {
                  vx = br.x;
                  vy = br.y;
                }

                if (c._relative) {
                  ux = cl.x + c.x;
                  uy = cl.y + c.y;
                } else {
                  ux = cl.x;
                  uy = cl.y;
                }

                x = c.x;
                y = c.y;

                ctx.bezierCurveTo(vx, vy, ux, uy, x, y);

              }

              break;

            case Commands.line:
              ctx.lineTo(x, y);
              break;

            case Commands.move:
              d = b;
              ctx.moveTo(x, y);
              break;

          }

        }

        // Loose ends

        if (closed) {
          ctx.closePath();
        }

        if (!webgl.isHidden.test(fill)) {
          isOffset = fill._renderer && fill._renderer.offset;
          if (isOffset) {
            ctx.save();
            ctx.translate(
              - fill._renderer.offset.x, - fill._renderer.offset.y);
            ctx.scale(fill._renderer.scale.x, fill._renderer.scale.y);
          }
          ctx.fill();
          if (isOffset) {
            ctx.restore();
          }
        }

        if (!webgl.isHidden.test(stroke)) {
          isOffset = stroke._renderer && stroke._renderer.offset;
          if (isOffset) {
            ctx.save();
            ctx.translate(
              - stroke._renderer.offset.x, - stroke._renderer.offset.y);
            ctx.scale(stroke._renderer.scale.x, stroke._renderer.scale.y);
            ctx.lineWidth = linewidth / stroke._renderer.scale.x;
          }
          ctx.stroke();
          if (isOffset) {
            ctx.restore();
          }
        }

        ctx.restore();

      },

      // Returns the rect of a set of verts. Typically takes vertices that are
      // "centered" around 0 and returns them to be anchored upper-left.
      getBoundingClientRect: function(vertices, border, rect) {

        var left = Infinity, right = -Infinity,
            top = Infinity, bottom = -Infinity,
            width, height;

        vertices.forEach(function(v) {

          var x = v.x, y = v.y, controls = v.controls;
          var a, b, c, d, cl, cr;

          top = Math.min(y, top);
          left = Math.min(x, left);
          right = Math.max(x, right);
          bottom = Math.max(y, bottom);

          if (!v.controls) {
            return;
          }

          cl = controls.left;
          cr = controls.right;

          if (!cl || !cr) {
            return;
          }

          a = v._relative ? cl.x + x : cl.x;
          b = v._relative ? cl.y + y : cl.y;
          c = v._relative ? cr.x + x : cr.x;
          d = v._relative ? cr.y + y : cr.y;

          if (!a || !b || !c || !d) {
            return;
          }

          top = Math.min(b, d, top);
          left = Math.min(a, c, left);
          right = Math.max(a, c, right);
          bottom = Math.max(b, d, bottom);

        });

        // Expand borders

        if (typeof border === 'number') {
          top -= border;
          left -= border;
          right += border;
          bottom += border;
        }

        width = right - left;
        height = bottom - top;

        rect.top = top;
        rect.left = left;
        rect.right = right;
        rect.bottom = bottom;
        rect.width = width;
        rect.height = height;

        if (!rect.centroid) {
          rect.centroid = {};
        }

        rect.centroid.x = - left;
        rect.centroid.y = - top;

      },

      render: function(gl, program, forcedParent) {

        if (!this._visible || !this._opacity) {
          return this;
        }

        this._update();

        // Calculate what changed

        var parent = forcedParent || this.parent;
        var flagParentMatrix = parent._matrix.manual || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var parentChanged = this._renderer.parent !== parent;
        var flagTexture = this._flagVertices || this._flagFill
          || (this._fill instanceof LinearGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagEndPoints))
          || (this._fill instanceof RadialGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagRadius || this._fill._flagCenter || this._fill._flagFocal))
          || (this._fill instanceof Texture && (this._fill._flagLoaded && this._fill.loaded || this._fill._flagImage || this._fill._flagVideo || this._fill._flagRepeat || this._fill._flagOffset || this._fill._flagScale))
          || (this._stroke instanceof LinearGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagEndPoints))
          || (this._stroke instanceof RadialGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagRadius || this._stroke._flagCenter || this._stroke._flagFocal))
          || (this._stroke instanceof Texture && (this._stroke._flagLoaded && this._stroke.loaded || this._stroke._flagImage || this._stroke._flagVideo || this._stroke._flagRepeat || this._stroke._flagOffset || this._fill._flagScale))
          || this._flagStroke || this._flagLinewidth || this._flagOpacity
          || parent._flagOpacity || this._flagVisible || this._flagCap
          || this._flagJoin || this._flagMiter || this._flagScale
          || (this.dashes && this.dashes.length > 0)
          || !this._renderer.texture;

        if (flagParentMatrix || flagMatrix || parentChanged) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new NumArray(9);
          }

          // Reduce amount of object / array creation / deletion

          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }
          if (this._scale instanceof Vector) {
            this._renderer.scale.x = this._scale.x * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale.y * parent._renderer.scale.y;
          } else {
            this._renderer.scale.x = this._scale * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale * parent._renderer.scale.y;
          }

          if (parentChanged) {
            this._renderer.parent = parent;
          }
        }

        if (this._mask) {

          // Stencil away everything that isn't rendered by the mask
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);

          gl.stencilFunc(gl.ALWAYS, 1, 0);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          // Don't draw the element onto the canvas, only onto the stencil buffer
          gl.colorMask(false, false, false, false);

          webgl[this._mask._renderer.type].render.call(this._mask, gl, program, this);

          gl.stencilFunc(gl.EQUAL, 1, 0xff);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.colorMask(true, true, true, true);

        }

        if (flagTexture) {

          if (!this._renderer.rect) {
            this._renderer.rect = {};
          }

          this._renderer.opacity = this._opacity * parent._renderer.opacity;

          webgl.path.getBoundingClientRect(this._renderer.vertices, this._linewidth, this._renderer.rect);

          webgl.updateTexture.call(webgl, gl, this);

        } else {

          // We still need to update child Two elements on the fill and
          // stroke properties.
          if (this._fill && this._fill._update) {
            this._fill._update();
          }
          if (this._stroke && this._stroke._update) {
            this._stroke._update();
          }

        }

        if (this._clip && !forcedParent) {
          return;
        }

        // Draw Texture
        gl.bindTexture(gl.TEXTURE_2D, this._renderer.texture);

        // Draw Rect
        var rect = this._renderer.rect;
        gl.uniformMatrix3fv(program.matrix, false, this._renderer.matrix);
        gl.uniform4f(program.rect, rect.left, rect.top, rect.right, rect.bottom);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this._mask) {
          gl.disable(gl.STENCIL_TEST);
        }

        return this.flagReset();

      }

    },

    text: {

      updateCanvas: function(elem) {

        var canvas = this.canvas;
        var ctx = this.ctx;

        // Styles
        var scale = elem._renderer.scale;
        var stroke = elem._stroke;
        var linewidth = elem._linewidth * scale;
        var fill = elem._fill;
        var opacity = elem._renderer.opacity || elem._opacity;
        var dashes = elem.dashes;
        var decoration = elem._decoration;

        canvas.width = Math.max(Math.ceil(elem._renderer.rect.width * scale.x), 1);
        canvas.height = Math.max(Math.ceil(elem._renderer.rect.height * scale.y), 1);

        var centroid = elem._renderer.rect.centroid;
        var cx = centroid.x;
        var cy = centroid.y;

        var a, b, c, d, e, sx, sy, x1, y1, x2, y2;
        var isOffset = fill._renderer && fill._renderer.offset
          && stroke._renderer && stroke._renderer.offset;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!isOffset) {
          ctx.font = [elem._style, elem._weight, elem._size + 'px/' +
            elem._leading + 'px', elem._family].join(' ');
        }

        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Styles
        if (fill) {
          if (typeof fill === 'string') {
            ctx.fillStyle = fill;
          } else {
            webgl[fill._renderer.type].render.call(fill, ctx, elem);
            ctx.fillStyle = fill._renderer.effect;
          }
        }
        if (stroke) {
          if (typeof stroke === 'string') {
            ctx.strokeStyle = stroke;
          } else {
            webgl[stroke._renderer.type].render.call(stroke, ctx, elem);
            ctx.strokeStyle = stroke._renderer.effect;
          }
          if (linewidth) {
            ctx.lineWidth = linewidth;
          }
        }
        if (typeof opacity === 'number') {
          ctx.globalAlpha = opacity;
        }
        if (dashes && dashes.length > 0) {
          ctx.lineDashOffset = dashes.offset || 0;
          ctx.setLineDash(dashes);
        }

        ctx.save();
        ctx.scale(scale.x, scale.y);
        ctx.translate(cx, cy);

        if (!webgl.isHidden.test(fill)) {

          if (fill._renderer && fill._renderer.offset) {

            sx = fill._renderer.scale.x;
            sy = fill._renderer.scale.y;

            ctx.save();
            ctx.translate( - fill._renderer.offset.x,
              - fill._renderer.offset.y);
            ctx.scale(sx, sy);

            a = elem._size / fill._renderer.scale.y;
            b = elem._leading / fill._renderer.scale.y;
            ctx.font = [elem._style, elem._weight, a + 'px/',
              b + 'px', elem._family].join(' ');

            c = fill._renderer.offset.x / fill._renderer.scale.x;
            d = fill._renderer.offset.y / fill._renderer.scale.y;

            ctx.fillText(elem.value, c, d);
            ctx.restore();

          } else {
            ctx.fillText(elem.value, 0, 0);
          }

        }

        if (!webgl.isHidden.test(stroke)) {

          if (stroke._renderer && stroke._renderer.offset) {

            sx = stroke._renderer.scale.x;
            sy = stroke._renderer.scale.y;

            ctx.save();
            ctx.translate(- stroke._renderer.offset.x,
              - stroke._renderer.offset.y);
            ctx.scale(sx, sy);

            a = elem._size / stroke._renderer.scale.y;
            b = elem._leading / stroke._renderer.scale.y;
            ctx.font = [elem._style, elem._weight, a + 'px/',
              b + 'px', elem._family].join(' ');

            c = stroke._renderer.offset.x / stroke._renderer.scale.x;
            d = stroke._renderer.offset.y / stroke._renderer.scale.y;
            e = linewidth / stroke._renderer.scale.x;

            ctx.lineWidth = e;
            ctx.strokeText(elem.value, c, d);
            ctx.restore();

          } else {
            ctx.strokeText(elem.value, 0, 0);
          }

        }

        // Handle text-decoration
        if (/(underline|strikethrough)/i.test(decoration)) {

          var metrics = ctx.measureText(elem.value);

          switch (decoration) {
            case 'underline':
              y1 = metrics.actualBoundingBoxAscent;
              y2 = metrics.actualBoundingBoxAscent;
              break;
            case 'strikethrough':
              y1 = 0;
              y2 = 0;
              break;
          }

          x1 = - metrics.width / 2;
          x2 = metrics.width / 2;

          ctx.lineWidth = Math.max(Math.floor(elem._size / 15), 1);
          ctx.strokeStyle = ctx.fillStyle;

          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();

        }

        ctx.restore();

      },

      getBoundingClientRect: function(elem, rect) {

        var ctx = webgl.ctx;

        ctx.font = [elem._style, elem._weight, elem._size + 'px/' +
          elem._leading + 'px', elem._family].join(' ');

        ctx.textAlign = 'center';
        ctx.textBaseline = elem._baseline;

        // TODO: Estimate this better
        var width = ctx.measureText(elem._value).width * 1.25;
        var height = Math.max(elem._size, elem._leading) * 1.25;

        if (this._linewidth && !webgl.isHidden.test(this._stroke)) {
          width += this._linewidth * 2;
          height += this._linewidth * 2;
        }

        var w = width / 2;
        var h = height / 2;

        switch (webgl.alignments[elem._alignment] || elem._alignment) {

          case webgl.alignments.left:
            rect.left = 0;
            rect.right = width;
            break;
          case webgl.alignments.right:
            rect.left = - width;
            rect.right = 0;
            break;
          default:
            rect.left = - w;
            rect.right = w;
        }

        // TODO: Gradients aren't inherited...
        switch (elem._baseline) {
          case 'bottom':
            rect.top = - height;
            rect.bottom = 0;
            break;
          case 'top':
            rect.top = 0;
            rect.bottom = height;
            break;
          default:
            rect.top = - h;
            rect.bottom = h;
        }

        rect.width = width;
        rect.height = height;

        if (!rect.centroid) {
          rect.centroid = {};
        }

        // TODO:
        rect.centroid.x = w;
        rect.centroid.y = h;

      },

      render: function(gl, program, forcedParent) {

        if (!this._visible || !this._opacity) {
          return this;
        }

        this._update();

        // Calculate what changed

        var parent = forcedParent || this.parent;
        var flagParentMatrix = parent._matrix.manual || parent._flagMatrix;
        var flagMatrix = this._matrix.manual || this._flagMatrix;
        var parentChanged = this._renderer.parent !== parent;
        var flagTexture = this._flagVertices || this._flagFill
          || (this._fill instanceof LinearGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagEndPoints))
          || (this._fill instanceof RadialGradient && (this._fill._flagSpread || this._fill._flagStops || this._fill._flagRadius || this._fill._flagCenter || this._fill._flagFocal))
          || (this._fill instanceof Texture && (this._fill._flagLoaded && this._fill.loaded || this._fill._flagImage || this._fill._flagVideo || this._fill._flagRepeat || this._fill._flagOffset || this._fill._flagScale))
          || (this._stroke instanceof LinearGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagEndPoints))
          || (this._stroke instanceof RadialGradient && (this._stroke._flagSpread || this._stroke._flagStops || this._stroke._flagRadius || this._stroke._flagCenter || this._stroke._flagFocal))
          || (this._stroke instanceof Texture && (this._stroke._flagLoaded && this._stroke.loaded || this._stroke._flagImage || this._stroke._flagVideo || this._stroke._flagRepeat || this._stroke._flagOffset || this._fill._flagScale))
          || this._flagStroke || this._flagLinewidth || this._flagOpacity
          || parent._flagOpacity || this._flagVisible || this._flagScale
          || this._flagValue || this._flagFamily || this._flagSize
          || this._flagLeading || this._flagAlignment || this._flagBaseline
          || this._flagStyle || this._flagWeight || this._flagDecoration
          || (this.dashes && this.dashes.length > 0)
          || !this._renderer.texture;

        if (flagParentMatrix || flagMatrix || parentChanged) {

          if (!this._renderer.matrix) {
            this._renderer.matrix = new NumArray(9);
          }

          // Reduce amount of object / array creation / deletion

          this._matrix.toTransformArray(true, transformation);

          multiplyMatrix(transformation, parent._renderer.matrix, this._renderer.matrix);

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }
          if (this._scale instanceof Vector) {
            this._renderer.scale.x = this._scale.x * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale.y * parent._renderer.scale.y;
          } else {
            this._renderer.scale.x = this._scale * parent._renderer.scale.x;
            this._renderer.scale.y = this._scale * parent._renderer.scale.y;
          }

          if (parentChanged) {
            this._renderer.parent = parent;
          }
        }

        if (this._mask) {

          // Stencil away everything that isn't rendered by the mask
          gl.clear(gl.STENCIL_BUFFER_BIT);
          gl.enable(gl.STENCIL_TEST);

          gl.stencilFunc(gl.ALWAYS, 1, 0);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
          // Don't draw the element onto the canvas, only onto the stencil buffer
          gl.colorMask(false, false, false, false);

          webgl[this._mask._renderer.type].render.call(this._mask, gl, program, this);

          gl.stencilFunc(gl.EQUAL, 1, 0xff);
          gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
          gl.colorMask(true, true, true, true);

        }

        if (flagTexture) {

          if (!this._renderer.rect) {
            this._renderer.rect = {};
          }

          this._renderer.opacity = this._opacity * parent._renderer.opacity;

          webgl.text.getBoundingClientRect(this, this._renderer.rect);

          webgl.updateTexture.call(webgl, gl, this);

        } else {

          // We still need to update child Two elements on the fill and
          // stroke properties.
          if (this._fill && this._fill._update) {
            this._fill._update();
          }
          if (this._stroke && this._stroke._update) {
            this._stroke._update();
          }

        }

        if (this._clip && !forcedParent) {
          return;
        }

        // Draw Texture
        gl.bindTexture(gl.TEXTURE_2D, this._renderer.texture);

        // Draw Rect
        var rect = this._renderer.rect;
        gl.uniformMatrix3fv(program.matrix, false, this._renderer.matrix);
        gl.uniform4f(program.rect, rect.left, rect.top, rect.right, rect.bottom);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        if (this._mask) {
          gl.disable(gl.STENCIL_TEST);
        }

        return this.flagReset();

      }

    },

    'linear-gradient': {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        if (!this._renderer.effect || this._flagEndPoints || this._flagStops) {

          this._renderer.effect = ctx.createLinearGradient(
            this.left._x, this.left._y,
            this.right._x, this.right._y
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    'radial-gradient': {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        if (!this._renderer.effect || this._flagCenter || this._flagFocal
            || this._flagRadius || this._flagStops) {

          this._renderer.effect = ctx.createRadialGradient(
            this.center._x, this.center._y, 0,
            this.focal._x, this.focal._y, this._radius
          );

          for (var i = 0; i < this.stops.length; i++) {
            var stop = this.stops[i];
            this._renderer.effect.addColorStop(stop._offset, stop._color);
          }

        }

        return this.flagReset();

      }

    },

    texture: {

      render: function(ctx, elem) {

        if (!ctx.canvas.getContext('2d')) {
          return;
        }

        this._update();

        var image = this.image;

        if (((this._flagLoaded || this._flagImage || this._flagVideo || this._flagRepeat) && this.loaded)) {
          this._renderer.effect = ctx.createPattern(image, this._repeat);
        } else if (!this._renderer.effect) {
          return this.flagReset();
        }

        if (this._flagOffset || this._flagLoaded || this._flagScale) {

          if (!(this._renderer.offset instanceof Vector)) {
            this._renderer.offset = new Vector();
          }

          this._renderer.offset.x = - this._offset.x;
          this._renderer.offset.y = - this._offset.y;

          if (image) {

            this._renderer.offset.x += image.width / 2;
            this._renderer.offset.y += image.height / 2;

            if (this._scale instanceof Vector) {
              this._renderer.offset.x *= this._scale.x;
              this._renderer.offset.y *= this._scale.y;
            } else {
              this._renderer.offset.x *= this._scale;
              this._renderer.offset.y *= this._scale;
            }
          }

        }

        if (this._flagScale || this._flagLoaded) {

          if (!(this._renderer.scale instanceof Vector)) {
            this._renderer.scale = new Vector();
          }

          if (this._scale instanceof Vector) {
            this._renderer.scale.copy(this._scale);
          } else {
            this._renderer.scale.set(this._scale, this._scale);
          }

        }

        return this.flagReset();

      }

    },

    updateTexture: function(gl, elem) {

      this[elem._renderer.type].updateCanvas.call(webgl, elem);

      if (!elem._renderer.texture) {
        elem._renderer.texture = gl.createTexture();
      }

      gl.bindTexture(gl.TEXTURE_2D, elem._renderer.texture);

      // Set the parameters so we can render any size image.
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

      if (this.canvas.width <= 0 || this.canvas.height <= 0) {
        return;
      }

      // Upload the image into the texture.
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);

    },

    program: {

      create: function(gl, shaders) {
        var program, linked, error;
        program = gl.createProgram();
        _.each(shaders, function(s) {
          gl.attachShader(program, s);
        });

        gl.linkProgram(program);
        linked = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!linked) {
          error = gl.getProgramInfoLog(program);
          gl.deleteProgram(program);
          throw new TwoError('unable to link program: ' + error);
        }

        return program;

      }

    },

    shaders: {

      create: function(gl, source, type) {
        var shader, compiled, error;
        shader = gl.createShader(gl[type]);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!compiled) {
          error = gl.getShaderInfoLog(shader);
          gl.deleteShader(shader);
          throw new TwoError('unable to compile shader ' + shader + ': ' + error);
        }

        return shader;

      },

      types: {
        vertex: 'VERTEX_SHADER',
        fragment: 'FRAGMENT_SHADER'
      },

      vertex: [
        'precision mediump float;',
        'attribute vec2 a_position;',
        '',
        'uniform mat3 u_matrix;',
        'uniform vec2 u_resolution;',
        'uniform vec4 u_rect;',
        '',
        'varying vec2 v_textureCoords;',
        '',
        'void main() {',
        '   vec2 rectCoords = (a_position * (u_rect.zw - u_rect.xy)) + u_rect.xy;',
        '   vec2 projected = (u_matrix * vec3(rectCoords, 1.0)).xy;',
        '   vec2 normal = projected / u_resolution;',
        '   vec2 clipspace = (normal * 2.0) - 1.0;',
        '',
        '   gl_Position = vec4(clipspace * vec2(1.0, -1.0), 0.0, 1.0);',
        '   v_textureCoords = a_position;',
        '}'
      ].join('\n'),

      fragment: [
        'precision mediump float;',
        '',
        'uniform sampler2D u_image;',
        'varying vec2 v_textureCoords;',
        '',
        'void main() {',
        '  vec4 texel = texture2D(u_image, v_textureCoords);',
        '  if (texel.a == 0.0) {',
        '    discard;',
        '  }',
        '  gl_FragColor = texel;',
        '}'
      ].join('\n')

    },

    TextureRegistry: new Registry()

  };

  webgl.ctx = webgl.canvas.getContext('2d');

  /**
   * @name Two.WebGLRenderer
   * @class
   * @extends Two.Events
   * @param {Object} [parameters] - This object is inherited when constructing a new instance of {@link Two}.
   * @param {Element} [parameters.domElement] - The `<canvas />` to draw to. If none given a new one will be constructed.
   * @param {HTMLCanvasElement} [parameters.offscreenElement] - The offscreen two dimensional `<canvas />` to render each element on WebGL texture updates.
   * @param {Boolean} [parameters.antialias] - Determines whether the canvas should clear render with antialias on.
   * @description This class is used by {@link Two} when constructing with `type` of `Two.Types.webgl`. It takes Two.js' scenegraph and renders it to a `<canvas />` through the WebGL api.
   * @see {@link https://www.khronos.org/registry/webgl/specs/latest/1.0/}
   */
  function Renderer(params) {

    var gl, vs, fs;

    /**
     * @name Two.WebGLRenderer#domElement
     * @property {Element} - The `<canvas />` associated with the Two.js scene.
     */
    this.domElement = params.domElement || document.createElement('canvas');

    if (typeof params.offscreenElement !== 'undefined') {
      webgl.canvas = params.offscreenElement;
      webgl.ctx = webgl.canvas.getContext('2d');
    }

    /**
     * @name Two.WebGLRenderer#scene
     * @property {Two.Group} - The root group of the scenegraph.
     */
    this.scene = new Group();
    this.scene.parent = this;

    this._renderer = {
      type: 'renderer',
      matrix: new NumArray(identity),
      scale: 1,
      opacity: 1
    };
    this._flagMatrix = true;

    // http://games.greggman.com/game/webgl-and-alpha/
    // http://www.khronos.org/registry/webgl/specs/latest/#5.2
    params = _.defaults(params || {}, {
      antialias: false,
      alpha: true,
      premultipliedAlpha: true,
      stencil: true,
      preserveDrawingBuffer: true,
      overdraw: false
    });

    /**
     * @name Two.WebGLRenderer#overdraw
     * @property {Boolean} - Determines whether the canvas clears the background each draw call.
     * @default true
     */
    this.overdraw = params.overdraw;

    /**
     * @name Two.WebGLRenderer#ctx
     * @property {WebGLContext} - Associated two dimensional context to render on the `<canvas />`.
     */
    gl = this.ctx = this.domElement.getContext('webgl', params) ||
      this.domElement.getContext('experimental-webgl', params);

    if (!this.ctx) {
      throw new TwoError(
        'unable to create a webgl context. Try using another renderer.');
    }

    // Compile Base Shaders to draw in pixel space.
    vs = webgl.shaders.create(
      gl, webgl.shaders.vertex, webgl.shaders.types.vertex);
    fs = webgl.shaders.create(
      gl, webgl.shaders.fragment, webgl.shaders.types.fragment);

    /**
     * @name Two.WebGLRenderer#program
     * @property {WebGLProgram} - Associated WebGL program to render all elements from the scenegraph.
     */
    this.program = webgl.program.create(gl, [vs, fs]);
    gl.useProgram(this.program);

    // Create and bind the drawing buffer

    // look up where the vertex data needs to go.
    this.program.position = gl.getAttribLocation(this.program, 'a_position');
    this.program.matrix = gl.getUniformLocation(this.program, 'u_matrix');
    this.program.rect = gl.getUniformLocation(this.program, 'u_rect');

    // Bind the vertex buffer
    var positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(this.program.position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(this.program.position);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      new NumArray([
        0, 0,
        1, 0,
        0, 1,
        0, 1,
        1, 0,
        1, 1
      ]),
      gl.STATIC_DRAW);

    // Setup some initial statements of the gl context
    gl.enable(gl.BLEND);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  }

  _.extend(Renderer, {

    /**
     * @name Two.WebGLRenderer.Utils
     * @property {Object} - A massive object filled with utility functions and properties to render Two.js objects to a `<canvas />` through the WebGL API.
     */
    Utils: webgl

  });

  _.extend(Renderer.prototype, Events, {

    constructor: Renderer,

    /**
     * @name Two.WebGLRenderer#setSize
     * @function
     * @fires resize
     * @param {Number} width - The new width of the renderer.
     * @param {Number} height - The new height of the renderer.
     * @param {Number} [ratio] - The new pixel ratio (pixel density) of the renderer. Defaults to calculate the pixel density of the user's screen.
     * @description Change the size of the renderer.
     */
    setSize: function(width, height, ratio) {

      this.width = width;
      this.height = height;

      this.ratio = typeof ratio === 'undefined' ? getRatio(this.ctx) : ratio;

      this.domElement.width = width * this.ratio;
      this.domElement.height = height * this.ratio;

      if (_.isObject(this.domElement.style)) {
        _.extend(this.domElement.style, {
          width: width + 'px',
          height: height + 'px'
        });
      }

      // Set for this.stage parent scaling to account for HDPI
      this._renderer.matrix[0] = this._renderer.matrix[4] = this._renderer.scale = this.ratio;

      this._flagMatrix = true;

      this.ctx.viewport(0, 0, width * this.ratio, height * this.ratio);

      var resolutionLocation = this.ctx.getUniformLocation(
        this.program, 'u_resolution');
      this.ctx.uniform2f(resolutionLocation, width * this.ratio, height * this.ratio);

      return this.trigger(Events.Types.resize, width, height, ratio);

    },

    /**
     * @name Two.WebGLRenderer#render
     * @function
     * @description Render the current scene to the `<canvas />`.
     */
    render: function() {

      var gl = this.ctx;

      if (!this.overdraw) {
        gl.clear(gl.COLOR_BUFFER_BIT);
      }

      webgl.group.render.call(this.scene, gl, this.program);
      this._flagMatrix = false;

      return this;

    }

  });

  // Utils

  /**
   * @name Two
   * @class
   * @global
   * @param {Object} [options]
   * @param {Boolean} [options.fullscreen=false] - Set to `true` to automatically make the stage adapt to the width and height of the parent document. This parameter overrides `width` and `height` parameters if set to `true`. This overrides `options.fitted` as well.
   * @param {Boolean} [options.fitted=false] = Set to `true` to automatically make the stage adapt to the width and height of the parent element. This parameter overrides `width` and `height` parameters if set to `true`.
   * @param {Number} [options.width=640] - The width of the stage on construction. This can be set at a later time.
   * @param {Number} [options.height=480] - The height of the stage on construction. This can be set at a later time.
   * @param {String} [options.type=Two.Types.svg] - The type of renderer to setup drawing with. See {@link Two.Types} for available options.
   * @param {Boolean} [options.autostart=false] - Set to `true` to add the instance to draw on `requestAnimationFrame`. This is a convenient substitute for {@link Two#play}.
   * @param {Element} [options.domElement] - The canvas or SVG element to draw into. This overrides the `options.type` argument.
   * @description The entrypoint for Two.js. Instantiate a `new Two` in order to setup a scene to render to. `Two` is also the publicly accessible namespace that all other sub-classes, functions, and utilities attach to.
   */
  function Two(options) {

    // Determine what Renderer to use and setup a scene.

    var params = _.defaults(options || {}, {
      fullscreen: false,
      fitted: false,
      width: 640,
      height: 480,
      type: Two.Types.svg,
      autostart: false
    });

    _.each(params, function(v, k) {
      if (/fullscreen/i.test(k) || /autostart/i.test(k)) {
        return;
      }
      this[k] = v;
    }, this);

    // Specified domElement overrides type declaration only if the element does not support declared renderer type.
    if (_.isElement(params.domElement)) {
      var tagName = params.domElement.tagName.toLowerCase();
      // TODO: Reconsider this if statement's logic.
      if (!/^(CanvasRenderer-canvas|WebGLRenderer-canvas|SVGRenderer-svg)$/.test(this.type+'-'+tagName)) {
        this.type = Two.Types[tagName];
      }
    }

    this.renderer = new Two[this.type](this);
    this.setPlaying(params.autostart);
    this.frameCount = 0;

    /**
     * @name Two#fit
     * @function
     * @description If `options.fullscreen` or `options.fitted` in construction create this function. It sets the `width` and `height` of the instance to its respective parent `window` or `element` depending on the `options` passed.
     */
    if (params.fullscreen) {

      this.fit = fitToWindow.bind(this);
      this.fit.domElement = window;
      this.fit.attached = true;
      _.extend(document.body.style, {
        overflow: 'hidden',
        margin: 0,
        padding: 0,
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        position: 'fixed'
      });
      _.extend(this.renderer.domElement.style, {
        display: 'block',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        position: 'fixed'
      });
      dom.bind(this.fit.domElement, 'resize', this.fit);
      this.fit();

    } else if (params.fitted) {

      this.fit = fitToParent.bind(this);
      _.extend(this.renderer.domElement.style, {
        display: 'block'
      });

    } else if (!_.isElement(params.domElement)) {

      this.renderer.setSize(params.width, params.height, this.ratio);
      this.width = params.width;
      this.height = params.height;

    }

    this.renderer.bind(Events.Types.resize, updateDimensions.bind(this));
    this.scene = this.renderer.scene;

    Two.Instances.push(this);
    if (params.autostart) {
      raf.init();
    }

  }

  _.extend(Two, Constants);

  _.extend(Two.prototype, Events, {

    constructor: Two,

    /**
     * @name Two#type
     * @property {String} - A string representing which type of renderer the instance has instantiated.
     */
    type: '',

    /**
     * @name Two#renderer
     * @property {(Two.SVGRenderer|Two.CanvasRenderer|Two.WebGLRenderer)} - The instantiated rendering class for the instance. For a list of possible rendering types check out Two.Types.
     */
    renderer: null,

    /**
     * @name Two#scene
     * @property {Two.Group} - The base level {@link Two.Group} which houses all objects for the instance. Because it is a {@link Two.Group} transformations can be applied to it that will affect all objects in the instance. This is handy as a makeshift inverted camera.
     */
    scene: null,

    /**
     * @name Two#width
     * @property {Number} - The width of the instance's dom element.
     */
    width: 0,

    /**
     * @name Two#height
     * @property {Number} - The height of the instance's dom element.
     */
    height: 0,

    /**
     * @name Two#frameCount
     * @property {Number} - An integer representing how many frames have elapsed.
     */
    frameCount: 0,

    /**
     * @name Two#timeDelta
     * @property {Number} - A number representing how much time has elapsed since the last frame in milliseconds.
     */
    timeDelta: 0,

    /**
     * @name Two#playing
     * @property {Boolean} - A boolean representing whether or not the instance is being updated through the automatic `requestAnimationFrame`.
     */
    playing: false,

    /**
     * @name Two#appendTo
     * @function
     * @param {Element} elem - The DOM element to append the Two.js stage to.
     * @description Shorthand method to append your instance of Two.js to the `document`.
     */
    appendTo: function(elem) {

      elem.appendChild(this.renderer.domElement);

      if (this.fit) {
        if (this.fit.domElement !== window) {
          this.fit.domElement = elem;
          this.fit.attached = false;
        }
        this.update();
      }

      return this;

    },

    /**
     * @name Two#play
     * @function
     * @fires Two.Events.Types.play event
     * @description Call to start an internal animation loop.
     * @nota-bene This function initiates a `requestAnimationFrame` loop.
     */
    play: function() {

      this.playing = true;
      raf.init();
      return this.trigger(Events.Types.play);

    },

    /**
     * @name Two#pause
     * @function
     * @fires Two.Events.Types.pause event
     * @description Call to stop the internal animation loop for a specific instance of Two.js.
     */
    pause: function() {

      this.playing = false;
      return this.trigger(Events.Types.pause);

    },

    setPlaying: function(p) {
      this.playing = p;
    },

    /**
     * @name Two#release
     * @function
     * @param {Object} obj
     * @returns {Object} The object passed for event deallocation.
     * @description Release an arbitrary class' events from the Two.js corpus and recurse through its children and or vertices.
     */
    release: function(obj) {

      var i, v, child;

      if (!_.isObject(obj)) {
        return;
      }

      if (typeof obj.unbind === 'function') {
        obj.unbind();
      }

      if (obj.vertices) {
        if (typeof obj.vertices.unbind === 'function') {
          obj.vertices.unbind();
        }
        for (i = 0; i < obj.vertices.length; i++) {
          v = obj.vertices[i];
          if (typeof v.unbind === 'function') {
            v.unbind();
          }
        }
      }

      if (obj.children) {
        for (i = 0; i < obj.children.length; i++) {
          child = obj.children[i];
          this.release(child);
        }
      }

      return obj;

    },

    /**
     * @name Two#update
     * @function
     * @fires Two.Events.Types.update event
     * @description Update positions and calculations in one pass before rendering. Then render to the canvas.
     * @nota-bene This function is called automatically if using {@link Two#play} or the `autostart` parameter in construction.
     */
    update: function() {

      var animated = !!this._lastFrame;
      var now = _.performance.now();

      if (animated) {
        this.timeDelta = parseFloat((now - this._lastFrame).toFixed(3));
      }
      this._lastFrame = now;

      if (this.fit && this.fit.domElement && !this.fit.attached) {
          dom.bind(this.fit.domElement, 'resize', this.fit);
          this.fit.attached = true;
          this.fit();
      }

      var width = this.width;
      var height = this.height;
      var renderer = this.renderer;

      // Update width / height for the renderer
      if (width !== renderer.width || height !== renderer.height) {
        renderer.setSize(width, height, this.ratio);
      }

      this.trigger(Events.Types.update, this.frameCount, this.timeDelta);

      return this.render();

    },

    /**
     * @name Two#render
     * @function
     * @fires render
     * @description Render all drawable and visible objects of the scene.
     */
    render: function() {

      this.renderer.render();
      return this.trigger(Events.Types.render, this.frameCount++);

    },

    // Convenience Methods

    /**
     * @name Two#add
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - An array of Two.js objects. Alternatively can add objects as individual arguments.
     * @description A shorthand method to add specific Two.js objects to the scene.
     */
    add: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      }

      this.scene.add(objects);
      return this;

    },

    /**
     * @name Two#remove
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - An array of Two.js objects.
     * @description A shorthand method to remove specific Two.js objects from the scene.
     */
    remove: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      }

      this.scene.remove(objects);

      return this;

    },

    /**
     * @name Two#clear
     * @function
     * @description Removes all objects from the instance's scene. If you intend to have the browser garbage collect this, don't forget to delete the references in your application as well.
     */
    clear: function() {

      this.scene.remove(this.scene.children);
      return this;

    },

    /**
     * @name Two#makeLine
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @returns {Two.Line}
     * @description Creates a Two.js line and adds it to the scene.
     */
    makeLine: function(x1, y1, x2, y2) {

      var line = new Line(x1, y1, x2, y2);
      this.scene.add(line);

      return line;

    },

    /**
     * @name Two#makeArrow
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @returns {Two.Path}
     * @description Creates a Two.js arrow and adds it to the scene.
     */
    makeArrow: function(x1, y1, x2, y2, size) {

      var headlen = typeof size === 'number' ? size : 10;

      var angle = Math.atan2(y2 - y1, x2 - x1);

      var vertices = [

        new Anchor(x1, y1, undefined, undefined, undefined, undefined, Commands.move),
        new Anchor(x2, y2, undefined, undefined, undefined, undefined, Commands.line),
        new Anchor(
          x2 - headlen * Math.cos(angle - Math.PI / 4),
          y2 - headlen * Math.sin(angle - Math.PI / 4),
          undefined, undefined, undefined, undefined, Commands.line
        ),

        new Anchor(x2, y2, undefined, undefined, undefined, undefined, Commands.move),
        new Anchor(
          x2 - headlen * Math.cos(angle + Math.PI / 4),
          y2 - headlen * Math.sin(angle + Math.PI / 4),
          undefined, undefined, undefined, undefined, Commands.line
        )

      ];

      var path = new Path(vertices, false, false, true);
      path.noFill();
      path.cap = 'round';
      path.join = 'round';

      this.scene.add(path);

      return path;
    },

    /**
     * @name Two#makeRectangle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @returns {Two.Rectangle}
     * @description Creates a Two.js rectangle and adds it to the scene.
     */
    makeRectangle: function(x, y, width, height) {

      var rect = new Rectangle(x, y, width, height);
      this.scene.add(rect);

      return rect;

    },

    /**
     * @name Two#makeRoundedRectangle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} width
     * @param {Number} height
     * @param {Number} sides
     * @returns {Two.Rectangle}
     * @description Creates a Two.js rounded rectangle and adds it to the scene.
     */
    makeRoundedRectangle: function(x, y, width, height, sides) {

      var rect = new RoundedRectangle(x, y, width, height, sides);
      this.scene.add(rect);

      return rect;

    },

    /**
     * @name Two#makeCircle
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} radius
     * @param {Number} [resolution=4]
     * @returns {Two.Circle}
     * @description Creates a Two.js circle and adds it to the scene.
     */
    makeCircle: function(x, y, radius, resolution) {

      var circle = new Circle(x, y, radius, resolution);
      this.scene.add(circle);

      return circle;

    },

    /**
     * @name Two#makeEllipse
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} rx
     * @param {Number} ry
     * @param {Number} [resolution=4]
     * @returns {Two.Ellipse}
     * @description Creates a Two.js ellipse and adds it to the scene.
     */
    makeEllipse: function(x, y, rx, ry, resolution) {

      var ellipse = new Ellipse(x, y, rx, ry, resolution);
      this.scene.add(ellipse);

      return ellipse;

    },

    /**
     * @name Two#makeStar
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} outerRadius
     * @param {Number} innerRadius
     * @param {Number} sides
     * @returns {Two.Star}
     * @description Creates a Two.js star and adds it to the scene.
     */
    makeStar: function(ox, oy, outerRadius, innerRadius, sides) {

      var star = new Star(ox, oy, outerRadius, innerRadius, sides);
      this.scene.add(star);

      return star;

    },

    /**
     * @name Two#makeCurve
     * @function
     * @param {Two.Anchor[]} [points] - An array of {@link Two.Anchor} points.
     * @param {...Number} - Alternatively you can pass alternating `x` / `y` coordinate values as individual arguments. These will be combined into {@link Two.Anchor}s for use in the path.
     * @returns {Two.Path} - Where `path.curved` is set to `true`.
     * @description Creates a Two.js path that is curved and adds it to the scene.
     * @nota-bene In either case of passing an array or passing numbered arguments the last argument is an optional `Boolean` that defines whether the path should be open or closed.
     */
    makeCurve: function(p) {

      var l = arguments.length, points = p;
      if (!Array.isArray(p)) {
        points = [];
        for (var i = 0; i < l; i+=2) {
          var x = arguments[i];
          if (typeof x !== 'number') {
            break;
          }
          var y = arguments[i + 1];
          points.push(new Anchor(x, y));
        }
      }

      var last = arguments[l - 1];
      var curve = new Path(points, !(typeof last === 'boolean' ? last : undefined), true);
      var rect = curve.getBoundingClientRect();
      curve.center().translation
        .set(rect.left + rect.width / 2, rect.top + rect.height / 2);

      this.scene.add(curve);

      return curve;

    },

    /**
     * @name Two#makePolygon
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} radius
     * @param {Number} sides
     * @returns {Two.Polygon}
     * @description Creates a Two.js polygon and adds it to the scene.
     */
    makePolygon: function(x, y, radius, sides) {

      var poly = new Polygon(x, y, radius, sides);
      this.scene.add(poly);

      return poly;

    },

    /**
     * @name Two#makeArcSegment
     * @function
     * @param {Number} x
     * @param {Number} y
     * @param {Number} innerRadius
     * @param {Number} outerRadius
     * @param {Number} startAngle
     * @param {Number} endAngle
     * @param {Number} [resolution=Two.Resolution] - The number of vertices that should comprise the arc segment.
     */
    makeArcSegment: function(ox, oy, ir, or, sa, ea, res) {
      var arcSegment = new ArcSegment(ox, oy, ir, or, sa, ea, res);
      this.scene.add(arcSegment);
      return arcSegment;
    },

    /**
     * @name Two#makePath
     * @function
     * @param {Two.Anchor[]} [points] - An array of {@link Two.Anchor} points.
     * @param {...Number} - Alternatively you can pass alternating `x` / `y` coordinate values as individual arguments. These will be combined into {@link Two.Anchor}s for use in the path.
     * @returns {Two.Path}
     * @description Creates a Two.js path and adds it to the scene.
     * @nota-bene In either case of passing an array or passing numbered arguments the last argument is an optional `Boolean` that defines whether the path should be open or closed.
     */
    makePath: function(p) {

      var l = arguments.length, points = p;
      if (!Array.isArray(p)) {
        points = [];
        for (var i = 0; i < l; i+=2) {
          var x = arguments[i];
          if (typeof x !== 'number') {
            break;
          }
          var y = arguments[i + 1];
          points.push(new Anchor(x, y));
        }
      }

      var last = arguments[l - 1];
      var path = new Path(points, !(typeof last === 'boolean' ? last : undefined));
      var rect = path.getBoundingClientRect();
      if (typeof rect.top === 'number'   && typeof rect.left === 'number' &&
          typeof rect.right === 'number' && typeof rect.bottom === 'number') {
        path.center().translation
          .set(rect.left + rect.width / 2, rect.top + rect.height / 2);
      }

      this.scene.add(path);

      return path;

    },

    /**
     * @name Two#makeText
     * @function
     * @param {String} message
     * @param {Number} x
     * @param {Number} y
     * @param {Object} [styles] - An object to describe any of the {@link Two.Text.Properties} including `fill`, `stroke`, `linewidth`, `family`, `alignment`, `leading`, `opacity`, etc..
     * @returns {Two.Text}
     * @description Creates a Two.js text object and adds it to the scene.
     */
    makeText: function(message, x, y, styles) {
      var text = new Text(message, x, y, styles);
      this.add(text);
      return text;
    },

    /**
     * @name Two#makeLinearGradient
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     * @param {...Two.Stop} stops - Any number of color stops sometimes reffered to as ramp stops. If none are supplied then the default black-to-white two stop gradient is applied.
     * @returns {Two.LinearGradient}
     * @description Creates a Two.js linear gradient and ads it to the scene. In the case of an effect it's added to an invisible "definitions" group.
     */
    makeLinearGradient: function(x1, y1, x2, y2 /* stops */) {

      var stops = Array.prototype.slice.call(arguments, 4);
      var gradient = new LinearGradient(x1, y1, x2, y2, stops);

      this.add(gradient);

      return gradient;

    },

    /**
     * @name Two#makeRadialGradient
     * @function
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} radius
     * @param {...Two.Stop} stops - Any number of color stops sometimes reffered to as ramp stops. If none are supplied then the default black-to-white two stop gradient is applied.
     * @returns {Two.RadialGradient}
     * @description Creates a Two.js linear-gradient object and ads it to the scene. In the case of an effect it's added to an invisible "definitions" group.
     */
    makeRadialGradient: function(x1, y1, r /* stops */) {

      var stops = Array.prototype.slice.call(arguments, 3);
      var gradient = new RadialGradient(x1, y1, r, stops);

      this.add(gradient);

      return gradient;

    },

    /**
     * @name Two#makeSprite
     * @function
     * @param {(String|Two.Texture)} pathOrTexture - The URL path to an image or an already created {@link Two.Texture}.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} [columns=1]
     * @param {Number} [rows=1]
     * @param {Number} [frameRate=0]
     * @param {Boolean} [autostart=false]
     * @returns {Two.Sprite}
     * @description Creates a Two.js sprite object and adds it to the scene. Sprites can be used for still images as well as animations.
     */
    makeSprite: function(path, x, y, cols, rows, frameRate, autostart) {

      var sprite = new Sprite(path, x, y, cols, rows, frameRate);
      if (autostart) {
        sprite.play();
      }
      this.add(sprite);

      return sprite;

    },

    /**
     * @name Two#makeImageSequence
     * @function
     * @param {(String[]|Two.Texture[])} pathsOrTextures - An array of paths or of {@link Two.Textures}.
     * @param {Number} x
     * @param {Number} y
     * @param {Number} [frameRate=0]
     * @param {Boolean} [autostart=false]
     * @returns {Two.ImageSequence}
     * @description Creates a Two.js image sequence object and adds it to the scene.
     */
    makeImageSequence: function(paths, x, y, frameRate, autostart) {

      var imageSequence = new ImageSequence(paths, x, y, frameRate);
      if (autostart) {
        imageSequence.play();
      }
      this.add(imageSequence);

      return imageSequence;

    },

    /**
     * @name Two#makeTexture
     * @function
     * @param {(String|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement)} [pathOrSource] - The URL path to an image or a DOM image-like element.
     * @param {Function} [callback] - Function to be invoked when the image is loaded.
     * @returns {Two.Texture}
     * @description Creates a Two.js texture object.
     */
    makeTexture: function(path, callback) {

      var texture = new Texture(path, callback);
      return texture;

    },

    /**
     * @name Two#makeGroup
     * @function
     * @param {(Two.Shape[]|...Two.Shape)} [objects] - Two.js objects to be added to the group in the form of an array or as individual arguments.
     * @returns {Two.Group}
     * @description Creates a Two.js group object and adds it to the scene.
     */
    makeGroup: function(o) {

      var objects = o;
      if (!(objects instanceof Array)) {
        objects = Array.prototype.slice.call(arguments);
      }

      var group = new Group();
      this.scene.add(group);
      group.add(objects);

      return group;

    },

    /**
     * @name Two#interpret
     * @function
     * @param {SVGElement} SVGElement - The SVG node to be parsed.
     * @param {Boolean} shallow - Don't create a top-most group but append all content directly.
     * @param {Boolean} add â€“ Automatically add the reconstructed SVG node to scene.
     * @returns {Two.Group}
     * @description Interpret an SVG Node and add it to this instance's scene. The distinction should be made that this doesn't `import` svg's, it solely interprets them into something compatible for Two.js - this is slightly different than a direct transcription.
     */
    interpret: function(SVGElement, shallow, add) {

      var tag = SVGElement.tagName.toLowerCase();

      add = (typeof add !== 'undefined') ? add : true;

      if (!(tag in read)) {
        return null;
      }

      var node = read[tag].call(this, SVGElement);

      if (add) {
        this.add(shallow && node instanceof Group ? node.children : node);
      } else if (node.parent) {
        // Remove `g` tags that have been added to scenegraph / DOM
        // in order to be compatible with `getById` methods.
        node.remove();
      }

      return node;

    },

    /**
     * @name Two#load
     * @function
     * @param {String|SVGElement} pathOrSVGContent - The URL path of an SVG file or an SVG document as text.
     * @param {Function} callback - Function to call once loading has completed.
     * @returns {Two.Group}
     * @description Load an SVG file or SVG text and interpret it into Two.js legible objects.
     */
    load: function(text, callback) {

      var group = new Group();
      var elem, i, j, child;

      var attach = (function(data) {

        dom.temp.innerHTML = data;

        for (i = 0; i < dom.temp.children.length; i++) {
          elem = dom.temp.children[i];
          if (/svg/i.test(elem.nodeName)) {
            child = this.interpret(elem);
            // Two.Utils.applySvgViewBox.call(this, group, elem.getAttribute('viewBox'));
            for (j = 0; j < child.children.length; j++) {
              group.add(child.children[j]);
            }
          } else {
            group.add(this.interpret(elem));
          }
        }

        if (typeof callback === 'function') {
          var svg = dom.temp.children.length <= 1
            ? dom.temp.children[0] : dom.temp.children;
          callback(group, svg);
        }

      }).bind(this);

      if (/.*\.svg/ig.test(text)) {

        xhr(text, attach);

        return group;

      }

      attach(text);

      return group;

    }

  });

  function fitToWindow() {

    var wr = document.body.getBoundingClientRect();

    var width = this.width = wr.width;
    var height = this.height = wr.height;

    this.renderer.setSize(width, height, this.ratio);

  }

  function fitToParent() {

    var parent = this.renderer.domElement.parentElement;
    if (!parent) {
      console.warn('Two.js: Attempting to fit to parent, but no parent found.');
      return;
    }
    var wr = parent.getBoundingClientRect();

    var width = this.width = wr.width;
    var height = this.height = wr.height;

    this.renderer.setSize(width, height, this.ratio);

  }

  function updateDimensions(width, height) {
    this.width = width;
    this.height = height;
    this.trigger(Events.Types.resize, width, height);
  }

  // Request Animation Frame

  var raf = dom.getRequestAnimationFrame();

  function loop() {

    for (var i = 0; i < Two.Instances.length; i++) {
      var t = Two.Instances[i];
      if (t.playing) {
        t.update();
      }
    }

    Two.nextFrameID = raf(loop);

  }

  raf.init = function() {
    loop();
    raf.init = function() {};
  };

  _.extend(Two, {
    Anchor: Anchor,
    Collection: Collection,
    Events: Events,
    Group: Group,
    Matrix: Matrix,
    Path: Path,
    Registry: Registry,
    Shape: Shape,
    Text: Text,
    Vector: Vector,

    Gradient: Gradient,
    ImageSequence: ImageSequence,
    LinearGradient: LinearGradient,
    RadialGradient: RadialGradient,
    Sprite: Sprite,
    Stop: Stop,
    Texture: Texture,

    ArcSegment: ArcSegment,
    Circle: Circle,
    Ellipse: Ellipse,
    Line: Line,
    Polygon: Polygon,
    Rectangle: Rectangle,
    RoundedRectangle: RoundedRectangle,
    Star: Star,

    CanvasRenderer: Renderer$2,
    SVGRenderer: Renderer$1,
    WebGLRenderer: Renderer,

    Commands: Commands,

    /**
     * @name Two.Utils
     * @property {Object} - A massive object filled with utility functions and properties.
     */
    Utils: _.extend({

      Error: TwoError,
      getRatio: getRatio,
      defineGetterSetter: defineGetterSetter,
      read: read,
      xhr: xhr

    }, _, CanvasShim, Curves, math)

  });

  return Two;

})));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],18:[function(require,module,exports){
"use strict";
var window = require("global/window")
var isFunction = require("is-function")
var parseHeaders = require("parse-headers")
var xtend = require("xtend")

module.exports = createXHR
// Allow use of default import syntax in TypeScript
module.exports.default = createXHR;
createXHR.XMLHttpRequest = window.XMLHttpRequest || noop
createXHR.XDomainRequest = "withCredentials" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest

forEachArray(["get", "put", "post", "patch", "head", "delete"], function(method) {
    createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
        options = initParams(uri, options, callback)
        options.method = method.toUpperCase()
        return _createXHR(options)
    }
})

function forEachArray(array, iterator) {
    for (var i = 0; i < array.length; i++) {
        iterator(array[i])
    }
}

function isEmpty(obj){
    for(var i in obj){
        if(obj.hasOwnProperty(i)) return false
    }
    return true
}

function initParams(uri, options, callback) {
    var params = uri

    if (isFunction(options)) {
        callback = options
        if (typeof uri === "string") {
            params = {uri:uri}
        }
    } else {
        params = xtend(options, {uri: uri})
    }

    params.callback = callback
    return params
}

function createXHR(uri, options, callback) {
    options = initParams(uri, options, callback)
    return _createXHR(options)
}

function _createXHR(options) {
    if(typeof options.callback === "undefined"){
        throw new Error("callback argument missing")
    }

    var called = false
    var callback = function cbOnce(err, response, body){
        if(!called){
            called = true
            options.callback(err, response, body)
        }
    }

    function readystatechange() {
        if (xhr.readyState === 4) {
            setTimeout(loadFunc, 0)
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = undefined

        if (xhr.response) {
            body = xhr.response
        } else {
            body = xhr.responseText || getXml(xhr)
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function errorFunc(evt) {
        clearTimeout(timeoutTimer)
        if(!(evt instanceof Error)){
            evt = new Error("" + (evt || "Unknown XMLHttpRequest Error") )
        }
        evt.statusCode = 0
        return callback(evt, failureResponse)
    }

    // will load the data & process the response in a special response object
    function loadFunc() {
        if (aborted) return
        var status
        clearTimeout(timeoutTimer)
        if(options.useXDR && xhr.status===undefined) {
            //IE8 CORS GET successful response doesn't have a status field, but body is fine
            status = 200
        } else {
            status = (xhr.status === 1223 ? 204 : xhr.status)
        }
        var response = failureResponse
        var err = null

        if (status !== 0){
            response = {
                body: getBody(),
                statusCode: status,
                method: method,
                headers: {},
                url: uri,
                rawRequest: xhr
            }
            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE
                response.headers = parseHeaders(xhr.getAllResponseHeaders())
            }
        } else {
            err = new Error("Internal XMLHttpRequest Error")
        }
        return callback(err, response, response.body)
    }

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new createXHR.XDomainRequest()
        }else{
            xhr = new createXHR.XMLHttpRequest()
        }
    }

    var key
    var aborted
    var uri = xhr.url = options.uri || options.url
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var timeoutTimer
    var failureResponse = {
        body: undefined,
        headers: {},
        statusCode: 0,
        method: method,
        url: uri,
        rawRequest: xhr
    }

    if ("json" in options && options.json !== false) {
        isJson = true
        headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json") //Don't override existing accept header declared by user
        if (method !== "GET" && method !== "HEAD") {
            headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json") //Don't override existing accept header declared by user
            body = JSON.stringify(options.json === true ? body : options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = loadFunc
    xhr.onerror = errorFunc
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    xhr.onabort = function(){
        aborted = true;
    }
    xhr.ontimeout = errorFunc
    xhr.open(method, uri, !sync, options.username, options.password)
    //has to be after open
    if(!sync) {
        xhr.withCredentials = !!options.withCredentials
    }
    // Cannot set timeout with sync request
    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly
    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent
    if (!sync && options.timeout > 0 ) {
        timeoutTimer = setTimeout(function(){
            if (aborted) return
            aborted = true//IE9 may still call readystatechange
            xhr.abort("timeout")
            var e = new Error("XMLHttpRequest timeout")
            e.code = "ETIMEDOUT"
            errorFunc(e)
        }, options.timeout )
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers && !isEmpty(options.headers)) {
        throw new Error("Headers cannot be set on an XDomainRequest object")
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }

    if ("beforeSend" in options &&
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    // Microsoft Edge browser sends "undefined" when send is called with undefined value.
    // XMLHttpRequest spec says to pass null as body to indicate no body
    // See https://github.com/naugtur/xhr/issues/100.
    xhr.send(body || null)

    return xhr


}

function getXml(xhr) {
    // xhr.responseXML will throw Exception "InvalidStateError" or "DOMException"
    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.
    try {
        if (xhr.responseType === "document") {
            return xhr.responseXML
        }
        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror"
        if (xhr.responseType === "" && !firefoxBugTakenEffect) {
            return xhr.responseXML
        }
    } catch (e) {}

    return null
}

function noop() {}

},{"global/window":7,"is-function":8,"parse-headers":16,"xtend":19}],19:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],20:[function(require,module,exports){
(function (global){(function (){

global.CANVAS_SKETCH_DEFAULT_STORAGE_KEY = "D:\\Manuel\\canvas-sketch\\examples\\animated-two-bitmap.js";

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[20,1,2,3])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvc3JjL2luc3RydW1lbnRhdGlvbi9jbGllbnQtZW5hYmxlLW91dHB1dC5qcyIsIkM6L1VzZXJzL0pvdmUvQXBwRGF0YS9Sb2FtaW5nL25wbS9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC1jbGkvc3JjL2luc3RydW1lbnRhdGlvbi9jbGllbnQuanMiLCJhbmltYXRlZC10d28tYml0bWFwLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItbWVkaWEtbWltZS10eXBlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItbWVkaWEtbWltZS10eXBlL21pbWUtdHlwZXMuanNvbiIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL29iamVjdC1hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9yaWdodC1ub3cvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2lzLXByb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9pcy1kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2RlZXAtZXF1YWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9kYXRlZm9ybWF0L2xpYi9kYXRlZm9ybWF0LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvcmVwZWF0LXN0cmluZy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL3BhZC1sZWZ0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvc2F2ZS5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL2FjY2Vzc2liaWxpdHkuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9jb3JlL2tleWJvYXJkU2hvcnRjdXRzLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvcGFwZXItc2l6ZXMuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL25vZGVfbW9kdWxlcy9kZWZpbmVkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9ub2RlX21vZHVsZXMvY29udmVydC1sZW5ndGgvY29udmVydC1sZW5ndGguanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9kaXN0YW5jZXMuanMiLCJub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9kaXN0L25vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2xpYi9jb3JlL3Jlc2l6ZUNhbnZhcy5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbm9kZV9tb2R1bGVzL2dldC1jYW52YXMtY29udGV4dC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW52YXMtc2tldGNoL2Rpc3Qvbm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvbGliL2NvcmUvY3JlYXRlQ2FudmFzLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvY29yZS9Ta2V0Y2hNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2NhbnZhcy1za2V0Y2gvZGlzdC9ub2RlX21vZHVsZXMvY2FudmFzLXNrZXRjaC9saWIvY2FudmFzLXNrZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy9nbG9iYWwvd2luZG93LmpzIiwibm9kZV9tb2R1bGVzL2lzLWZ1bmN0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXByb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9hZC1hc3NldC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2FkLWFzc2V0L2xvYWRlcnMvY3JlYXRlRmlsZUxvYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2FkLWFzc2V0L2xvYWRlcnMvY3JlYXRlTWVkaWFMb2FkZXIuanMiLCJub2RlX21vZHVsZXMvbG9hZC1hc3NldC9sb2FkZXJzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvYWQtYXNzZXQvbG9hZGVycy9sb2FkSW1hZ2UuanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL3BhcnNlLWhlYWRlcnMuanMiLCJub2RlX21vZHVsZXMvdHdvLmpzL2J1aWxkL3R3by5qcyIsIm5vZGVfbW9kdWxlcy94aHIvaW5kZXguanMiLCJub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwiY2FudmFzLXNrZXRjaC1jbGkvaW5qZWN0ZWQvc3RvcmFnZS1rZXkuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBO0FBQ0EsTUFBTSxDQUFDLG1CQUFELENBQU4sR0FBOEIsTUFBTSxDQUFDLG1CQUFELENBQU4sSUFBK0IsRUFBN0Q7QUFDQSxNQUFNLENBQUMsbUJBQUQsQ0FBTixDQUE0QixNQUE1QixHQUFxQyxJQUFyQzs7Ozs7QUNGQSxNQUFNLFNBQVMsR0FBRyxtQkFBbEIsQyxDQUVBOztBQUNBLE1BQU0sQ0FBQyxTQUFELENBQU4sR0FBb0IsTUFBTSxDQUFDLFNBQUQsQ0FBTixJQUFxQixFQUF6Qzs7QUFFQSxJQUFJLENBQUMsTUFBTSxDQUFDLFNBQUQsQ0FBTixDQUFrQixXQUF2QixFQUFvQztBQUNsQyxFQUFBLFVBQVU7QUFDWDs7QUFFRCxTQUFTLFVBQVQsR0FBdUI7QUFDckI7QUFDQSxFQUFBLE1BQU0sQ0FBQyxTQUFELENBQU4sQ0FBa0IsaUJBQWxCLEdBQXNDLFNBQXRDO0FBQ0EsRUFBQSxNQUFNLENBQUMsU0FBRCxDQUFOLENBQWtCLFdBQWxCLEdBQWdDLElBQWhDO0FBRUEsUUFBTSxrQkFBa0IsR0FBRztBQUN6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LEVBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1dBQ1osQ0FBQyxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1dBQ2YsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBQztXQUM3QixDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7V0FDMUUsRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO1dBQzFFLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztXQUMxRSxFQUFFLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7V0FDMUUsQ0FBQyxLQUFLLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFLEVBQUUsQ0FBQztXQUN4RyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFB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QUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxNQUFPLElBQUssS0FDZCxDQUFFO0tBQU8sSUFBSyxLQUNkLENBQUUsTUFBTyxJQUFLLEtBR2QsQ0FBRSxLQUFNLElBQUssTUFDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRTtLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sR0FBSSxLQUNaLENBQUUsS0FBTTtLQUFJLElBQ1osQ0FBRSxLQUFNLEdBQUksSUFDWixDQUFFLE1BQU8sR0FBSSxJQUNiLENBQUUsTUFBTyxLQUFNLE1BQ2YsQ0FBRSxNQUFPLEtBQU0sTUFDZixDQUFFLEtBQU07S0FBTSxNQUNkLENBQUUsS0FBTSxJQUFLLE1BQ2IsQ0FBRSxNQUFPLElBQUssTUFDZCxDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsTUFBTyxJQUFLLEtBQ2QsQ0FBRSxLQUFNO0tBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sR0FBSSxLQUNaLENBQUUsS0FBTSxHQUFJO0tBQ1osQ0FBRSxLQUFNLEdBQUksSUFDWixDQUFFLE1BQU8sR0FBSSxJQUNiLENBQUUsTUFBTyxHQUFJLElBQ2IsQ0FBRSxNQUFPLEdBQUksSUFDYixDQUFFLEtBQU0sSUFBSyxNQUNiLENBQUU7S0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU0sSUFBSyxLQUNiLENBQUUsS0FBTSxJQUFLLEtBQ2IsQ0FBRSxLQUFNLElBQUssS0FDYixDQUFFLEtBQU07S0FBSyxLQUNiLENBQUUsS0FBTSxHQUFJLEtBQ1osQ0FBRSxLQUFNLEdBQUksSUFDWixDQUFFLEtBQU0sR0FBSSxJQUNaLENBQUUsTUFBTyxHQUFJLElBQ2IsQ0FBRSxNQUFPLEdBQUksSUFDYixDQUFFO0tBQU8sR0FBSSxJQUliLENBQUUsY0FBZSxJQUFLLElBQUssTUFDM0IsQ0FBRSxTQUFVLElBQUssR0FBSSxNQUNyQixDQUFFLFFBQVMsSUFBSyxHQUFJO0tBQ3BCLENBQUUsZUFBZ0IsRUFBRyxFQUFHLE1BQ3hCLENBQUUsU0FBVSxHQUFJLEdBQUksTUFDcEIsQ0FBRSxVQUFXLEdBQUksR0FBSSxNQUNyQixDQUFFO0tBQVUsSUFBSyxLQUFNLE1BQ3ZCLENBQUUsU0FBVSxLQUFNLEtBQU0sTUFDeEIsQ0FBRSxTQUFVLEtBQU0sS0FBTSxNQUN4QixDQUFFO0tBQVUsS0FBTSxLQUFNLE1BQ3hCLENBQUUsU0FBVSxLQUFNLEtBQU0sTUFDeEIsQ0FBRSxTQUFVLEVBQUcsR0FBSSxNQUNuQixDQUFFLFNBQVUsR0FBSTtLQUFJLE1BQ3BCLENBQUUsU0FBVSxHQUFJLEdBQUksTUFDcEIsQ0FBRSxTQUFVLEdBQUksR0FBSSxNQUNwQixDQUFFLFNBQVUsR0FBSSxHQUFJLE1BQ3BCLENBQUU7S0FBVyxHQUFJLEdBQUksTUFDckIsQ0FBRSxVQUFXLEdBQUksR0FBSSxNQUNyQixDQUFFLFVBQVcsR0FBSSxHQUFJO0FBR3ZCLGtCQUFlLElBQUEsQ0FBSyxNQUFMLFdBQWEsSUFBTSxFQUFBLFFBQVA7S0FDekIsSUFBTSxPQUFPO1NBQ1gsT0FBTyxNQUFBLENBQU8sRUFBUCxJQUFhLFlBRFQ7U0FFWCxZQUFZLENBQUUsTUFBQSxDQUFPLEdBQUksTUFBQSxDQUFPOztLQUVsQyxJQUFBLENBQUssTUFBQSxDQUFPLEdBQVosR0FBa0I7S0FDbEIsSUFBQSxDQUFLLE1BQUEsQ0FBTyxFQUFQLENBQVUsT0FBVixDQUFrQixNQUFNLEtBQTdCLEdBQXFDO0tBQ3JDLE9BQU87SUFDTjs7Q0NoR0gsYUFBYyxHQUFHLFlBQVk7S0FDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7U0FDdkMsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssU0FBUyxFQUFFLE9BQU8sU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO01BQ3ZEO0VBQ0osQ0FBQzs7Q0NIRixJQUFJLEtBQUssR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQzs7Q0FFOUQsSUFBSSxXQUFXLEdBQUc7O0dBRWhCLENBQUMsRUFBRTtLQUNELE1BQU0sRUFBRSxRQUFRO0tBQ2hCLE1BQU0sRUFBRSxDQUFDO0lBQ1Y7R0FDRCxFQUFFLEVBQUU7S0FDRixNQUFNLEVBQUUsUUFBUTtLQUNoQixNQUFNLEVBQUUsQ0FBQyxHQUFHLEdBQUc7SUFDaEI7R0FDRCxFQUFFLEVBQUU7S0FDRixNQUFNLEVBQUUsUUFBUTtLQUNoQixNQUFNLEVBQUUsQ0FBQyxHQUFHLElBQUk7SUFDakI7O0dBRUQsRUFBRSxFQUFFO0tBQ0YsTUFBTSxFQUFFLFVBQVU7S0FDbEIsTUFBTSxFQUFFLENBQUMsR0FBRyxFQUFFO0lBQ2Y7R0FDRCxFQUFFLEVBQUU7S0FDRixNQUFNLEVBQUUsVUFBVTtLQUNsQixNQUFNLEVBQUUsQ0FBQyxHQUFHLENBQUM7SUFDZDtHQUNELEVBQUUsRUFBRTtLQUNGLE1BQU0sRUFBRSxVQUFVO0tBQ2xCLE1BQU0sRUFBRSxDQUFDO0lBQ1Y7R0FDRCxFQUFFLEVBQUU7S0FDRixNQUFNLEVBQUUsVUFBVTtLQUNsQixNQUFNLEVBQUUsRUFBRTtJQUNYO0VBQ0YsQ0FBQzs7Q0FFRixNQUFNLE9BQU8sR0FBRztHQUNkLE1BQU0sRUFBRTtLQUNOLElBQUksRUFBRSxHQUFHO0tBQ1QsS0FBSyxFQUFFLENBQUMsR0FBRyxNQUFNO0lBQ2xCO0dBQ0QsUUFBUSxFQUFFO0tBQ1IsSUFBSSxFQUFFLElBQUk7S0FDVixLQUFLLEVBQUUsTUFBTTtJQUNkO0VBQ0YsQ0FBQzs7Q0FFRixTQUFTLEtBQUssRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFO0dBQy9CLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUcsR0FBRyxRQUFRLENBQUMsR0FBRyxJQUFJLEdBQUcsUUFBUSxDQUFDLENBQUM7RUFDckU7O0NBRUQsU0FBUyxlQUFlLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO0dBQ3ZELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztHQUNwRyxJQUFJLENBQUMsUUFBUSxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0NBQWdDLENBQUMsQ0FBQzs7R0FFNUUsSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7R0FDbEIsSUFBSSxhQUFhLEdBQUcsU0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsRUFBRSxDQUFDLENBQUM7R0FDcEQsSUFBSSxTQUFTLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQztHQUMvQixJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxLQUFLLEtBQUssQ0FBQzs7R0FFM0MsUUFBUSxHQUFHLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztHQUNsQyxNQUFNLEdBQUcsTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDOztHQUU5QixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyxxQkFBcUIsR0FBRyxRQUFRLEdBQUcscUJBQXFCLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0dBQ2pJLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixHQUFHLE1BQU0sR0FBRyxxQkFBcUIsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7O0dBRTdILElBQUksUUFBUSxLQUFLLE1BQU0sRUFBRTs7S0FFdkIsT0FBTyxLQUFLLENBQUM7SUFDZDs7R0FFRCxJQUFJLFFBQVEsR0FBRyxDQUFDLENBQUM7R0FDakIsSUFBSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO0dBQ25CLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQzs7R0FFdEIsSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFO0tBQ3JCLFVBQVUsR0FBRyxDQUFDLEdBQUcsYUFBYSxDQUFDO0tBQy9CLFFBQVEsR0FBRyxJQUFJLENBQUM7SUFDakI7R0FDRCxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUU7S0FDbkIsU0FBUyxHQUFHLElBQUksQ0FBQztLQUNqQixRQUFRLEdBQUcsYUFBYSxDQUFDO0tBQ3pCLE1BQU0sR0FBRyxJQUFJLENBQUM7SUFDZjs7R0FFRCxJQUFJLFlBQVksR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7R0FDekMsSUFBSSxVQUFVLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDOzs7R0FHckMsSUFBSSxNQUFNLEdBQUcsS0FBSyxHQUFHLFlBQVksQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDOzs7R0FHdEQsSUFBSSxZQUFZLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxNQUFNLEVBQUU7O0tBRTdDLE1BQU0sSUFBSSxPQUFPLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQztJQUM5Qzs7R0FFRCxJQUFJLE1BQU0sR0FBRyxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQU0sR0FBRyxRQUFRLENBQUM7R0FDbkQsSUFBSSxTQUFTLElBQUksVUFBVSxFQUFFO0tBQzNCLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzdCLE1BQU0sSUFBSSxPQUFPLFNBQVMsS0FBSyxRQUFRLElBQUksUUFBUSxDQUFDLFNBQVMsQ0FBQyxFQUFFO0tBQy9ELE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ25DO0dBQ0QsT0FBTyxNQUFNLENBQUM7RUFDZjs7Q0FFRCxpQkFBYyxHQUFHLGVBQWUsQ0FBQztDQUNqQyxXQUFvQixHQUFHLEtBQUssQ0FBQzs7O0NDeEd0QixTQUFTLHdCQUF5QixVQUFZLEVBQUEsT0FBZ0IsRUFBQSxlQUFvQjtzQ0FBcEMsR0FBVTtrREFBTSxHQUFnQjs7S0FDbkYsSUFBSSxPQUFPLFVBQVAsS0FBc0IsVUFBVTtTQUNsQyxJQUFNLE1BQU0sVUFBQSxDQUFXLFdBQVg7U0FDWixJQUFJLEVBQUUsR0FBQSxJQUFPLGFBQWE7YUFDeEIsTUFBTSxJQUFJLEtBQUosOEJBQW1DOztTQUUzQyxJQUFNLFNBQVMsVUFBQSxDQUFXO1NBQzFCLE9BQU8sTUFBQSxDQUFPLFVBQVAsQ0FBa0IsR0FBbEIsV0FBc0IsWUFDcEIsaUJBQUEsQ0FBZ0IsR0FBRyxNQUFBLENBQU8sT0FBTyxTQUFTO1lBRTlDO1NBQ0wsT0FBTzs7OztBQUlYLENBQU8sU0FBUyxrQkFBaUIsU0FBVyxFQUFBLFNBQWtCLEVBQUEsT0FBZ0IsRUFBQSxlQUFvQjswQ0FBdEQsR0FBWTtzQ0FBTSxHQUFVO2tEQUFNLEdBQWdCOztLQUM1RixPQUFPLGFBQUEsQ0FBYyxXQUFXLFdBQVcsU0FBUzt3QkFDbEQsYUFEa0Q7U0FFbEQsV0FBVyxDQUZ1QztTQUdsRCxZQUFZOzs7O0NDbkJoQixTQUFTLHFCQUFzQixVQUFVO0tBQ3ZDLElBQUksQ0FBQyxRQUFBLENBQVM7V0FBWSxPQUFPO0tBQ2pDLElBQUksT0FBTyxRQUFBLENBQVMsVUFBaEIsS0FBK0I7V0FBVSxPQUFPO0tBQ3BELElBQUksS0FBQSxDQUFNLE9BQU4sQ0FBYyxRQUFBLENBQVMsV0FBdkIsSUFBc0MsUUFBQSxDQUFTLFVBQVQsQ0FBb0IsTUFBcEIsSUFBOEI7V0FBRyxPQUFPO0tBQ2xGLE9BQU87OztDQUdULFNBQVMsY0FBZSxLQUFPLEVBQUEsVUFBVTtLQUV2QyxJQUFJLENBQUMsU0FBQSxJQUFhO1NBQ2hCLE9BQU8sQ0FBRSxJQUFLOztLQUdoQixJQUFJLFVBQVUsUUFBQSxDQUFTLE1BQVQsSUFBbUI7S0FFakMsSUFBSSxPQUFBLEtBQVksTUFBWixJQUNBLE9BQUEsS0FBWSxRQURaLElBRUEsT0FBQSxLQUFZLFFBQUEsQ0FBUyxNQUFNO1NBQzdCLE9BQU8sQ0FBRSxNQUFBLENBQU8sV0FBWSxNQUFBLENBQU87WUFDOUI7U0FDTCxVQUEwQixPQUFBLENBQVEscUJBQVI7U0FBbEI7U0FBTztTQUNmLE9BQU8sQ0FBRSxNQUFPOzs7O0FBSXBCLENBQWUsU0FBUyxhQUFjLEtBQU8sRUFBQSxVQUFVO0tBQ3JELElBQUksT0FBTztLQUNYLElBQUksWUFBWTtLQUNoQixJQUFJLGFBQWE7S0FFakIsSUFBTSxVQUFVLFNBQUE7S0FDaEIsSUFBTSxhQUFhLFFBQUEsQ0FBUztLQUM1QixJQUFNLGdCQUFnQixvQkFBQSxDQUFxQjtLQUMzQyxJQUFNLFlBQVksS0FBQSxDQUFNO0tBQ3hCLElBQUksYUFBYSxhQUFBLEdBQWdCLFFBQUEsQ0FBUyxVQUFULEtBQXdCLFFBQVE7S0FDakUsSUFBSSxjQUFlLENBQUMsU0FBRCxJQUFjLGFBQWYsR0FBZ0MsUUFBQSxDQUFTLGNBQWM7S0FFekUsSUFBSSxDQUFDO1dBQVMsVUFBQSxJQUFhLFdBQUEsR0FBYztLQUN6QyxJQUFNLFFBQVEsUUFBQSxDQUFTO0tBQ3ZCLElBQU0sZ0JBQWlCLE9BQU8sUUFBQSxDQUFTLGFBQWhCLEtBQWtDLFFBQWxDLElBQThDLFFBQUEsQ0FBUyxRQUFBLENBQVMsY0FBakUsR0FBbUYsUUFBQSxDQUFTLGdCQUFnQjtLQUNsSSxJQUFNLFFBQVEsT0FBQSxDQUFRLFFBQUEsQ0FBUyxPQUFPO0tBRXRDLElBQU0sbUJBQW1CLE9BQUEsR0FBVSxNQUFBLENBQU8sbUJBQW1CO0tBQzdELElBQU0saUJBQWlCLFdBQUEsR0FBYyxtQkFBbUI7S0FFeEQsSUFBSSxZQUFZO0tBTWhCLElBQUksT0FBTyxRQUFBLENBQVMsVUFBaEIsS0FBK0IsUUFBL0IsSUFBMkMsUUFBQSxDQUFTLFFBQUEsQ0FBUyxhQUFhO1NBRTVFLFVBQUEsR0FBYSxRQUFBLENBQVM7U0FDdEIsZ0JBQUEsR0FBbUIsT0FBQSxDQUFRLFFBQUEsQ0FBUyxrQkFBa0I7WUFDakQ7U0FDTCxJQUFJLGVBQWU7YUFFakIsVUFBQSxHQUFhO2FBR2IsZ0JBQUEsR0FBbUIsT0FBQSxDQUFRLFFBQUEsQ0FBUyxrQkFBa0I7Z0JBQ2pEO2FBRUwsVUFBQSxHQUFhO2FBRWIsZ0JBQUEsR0FBbUIsT0FBQSxDQUFRLFFBQUEsQ0FBUyxrQkFBa0I7OztLQUsxRCxJQUFJLE9BQU8sUUFBQSxDQUFTLGFBQWhCLEtBQWtDLFFBQWxDLElBQThDLFFBQUEsQ0FBUyxRQUFBLENBQVMsZ0JBQWdCO1NBQ2xGLFVBQUEsR0FBYSxJQUFBLENBQUssR0FBTCxDQUFTLFFBQUEsQ0FBUyxlQUFlOztLQUloRCxJQUFJLFdBQVc7U0FDYixVQUFBLEdBQWE7O0tBTWYsVUFBb0MsYUFBQSxDQUFjLE9BQU87S0FBbkQ7S0FBYTtLQUNuQixJQUFJLFdBQVc7S0FHZixJQUFJLGVBQWU7U0FDakIsSUFBTSxTQUFTLHVCQUFBLENBQXdCLFlBQVksT0FBTztTQUMxRCxJQUFNLFVBQVUsSUFBQSxDQUFLLEdBQUwsQ0FBUyxNQUFBLENBQU8sSUFBSSxNQUFBLENBQU87U0FDM0MsSUFBTSxTQUFTLElBQUEsQ0FBSyxHQUFMLENBQVMsTUFBQSxDQUFPLElBQUksTUFBQSxDQUFPO1NBQzFDLElBQUksUUFBQSxDQUFTLGFBQWE7YUFDeEIsSUFBTSxZQUFZLFFBQUEsQ0FBUyxXQUFULEtBQXlCO2FBQzNDLEtBQUEsR0FBUSxTQUFBLEdBQVksVUFBVTthQUM5QixNQUFBLEdBQVMsU0FBQSxHQUFZLFNBQVM7Z0JBQ3pCO2FBQ0wsS0FBQSxHQUFRLE1BQUEsQ0FBTzthQUNmLE1BQUEsR0FBUyxNQUFBLENBQU87O1NBR2xCLFNBQUEsR0FBWTtTQUNaLFVBQUEsR0FBYTtTQUdiLEtBQUEsSUFBUyxLQUFBLEdBQVE7U0FDakIsTUFBQSxJQUFVLEtBQUEsR0FBUTtZQUNiO1NBQ0wsS0FBQSxHQUFRO1NBQ1IsTUFBQSxHQUFTO1NBQ1QsU0FBQSxHQUFZO1NBQ1osVUFBQSxHQUFhOztLQUlmLElBQUksWUFBWTtLQUNoQixJQUFJLGFBQWE7S0FDakIsSUFBSSxhQUFBLElBQWlCLE9BQU87U0FFMUIsU0FBQSxHQUFZLGlCQUFBLENBQWdCLE9BQU8sT0FBTyxNQUFNO1NBQ2hELFVBQUEsR0FBYSxpQkFBQSxDQUFnQixRQUFRLE9BQU8sTUFBTTs7S0FJcEQsVUFBQSxHQUFhLElBQUEsQ0FBSyxLQUFMLENBQVc7S0FDeEIsV0FBQSxHQUFjLElBQUEsQ0FBSyxLQUFMLENBQVc7S0FHekIsSUFBSSxVQUFBLElBQWMsQ0FBQyxTQUFmLElBQTRCLGVBQWU7U0FDN0MsSUFBTSxTQUFTLEtBQUEsR0FBUTtTQUN2QixJQUFNLGVBQWUsV0FBQSxHQUFjO1NBQ25DLElBQU0sb0JBQW9CLE9BQUEsQ0FBUSxRQUFBLENBQVMsbUJBQW1CO1NBQzlELElBQU0sV0FBVyxJQUFBLENBQUssS0FBTCxDQUFXLFdBQUEsR0FBYyxpQkFBQSxHQUFvQjtTQUM5RCxJQUFNLFlBQVksSUFBQSxDQUFLLEtBQUwsQ0FBVyxZQUFBLEdBQWUsaUJBQUEsR0FBb0I7U0FDaEUsSUFBSSxVQUFBLEdBQWEsUUFBYixJQUF5QixXQUFBLEdBQWMsV0FBVzthQUNwRCxJQUFJLFlBQUEsR0FBZSxRQUFRO2lCQUN6QixXQUFBLEdBQWM7aUJBQ2QsVUFBQSxHQUFhLElBQUEsQ0FBSyxLQUFMLENBQVcsV0FBQSxHQUFjO29CQUNqQztpQkFDTCxVQUFBLEdBQWE7aUJBQ2IsV0FBQSxHQUFjLElBQUEsQ0FBSyxLQUFMLENBQVcsVUFBQSxHQUFhOzs7O0tBSzVDLFdBQUEsR0FBYyxXQUFBLEdBQWMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxVQUFBLEdBQWEsY0FBYyxJQUFBLENBQUssS0FBTCxDQUFXLFVBQUEsR0FBYTtLQUMxRixZQUFBLEdBQWUsV0FBQSxHQUFjLElBQUEsQ0FBSyxLQUFMLENBQVcsVUFBQSxHQUFhLGVBQWUsSUFBQSxDQUFLLEtBQUwsQ0FBVyxVQUFBLEdBQWE7S0FFNUYsSUFBTSxnQkFBZ0IsV0FBQSxHQUFjLElBQUEsQ0FBSyxLQUFMLENBQVcsY0FBYyxJQUFBLENBQUssS0FBTCxDQUFXO0tBQ3hFLElBQU0saUJBQWlCLFdBQUEsR0FBYyxJQUFBLENBQUssS0FBTCxDQUFXLGVBQWUsSUFBQSxDQUFLLEtBQUwsQ0FBVztLQUUxRSxJQUFNLFNBQVMsV0FBQSxHQUFjO0tBQzdCLElBQU0sU0FBUyxZQUFBLEdBQWU7S0FHOUIsT0FBTztnQkFDTCxLQURLO3FCQUVMLFVBRks7Z0JBR0wsS0FISztpQkFJTCxNQUpLO1NBS0wsWUFBWSxDQUFFLE1BQU8sT0FMaEI7U0FNTCxPQUFPLEtBQUEsSUFBUyxJQU5YO2lCQU9MLE1BUEs7aUJBUUwsTUFSSzt3QkFTTCxhQVRLO3dCQVVMLGFBVks7eUJBV0wsY0FYSztzQkFZTCxXQVpLO3VCQWFMLFlBYks7b0JBY0wsU0FkSztxQkFlTCxVQWZLO3FCQWdCTCxVQWhCSztzQkFpQkw7Ozs7Q0M5S0osc0JBQWMsR0FBRyxpQkFBZ0I7Q0FDakMsU0FBUyxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0dBQ3JDLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO0tBQzVCLE1BQU0sSUFBSSxTQUFTLENBQUMsMEJBQTBCLENBQUM7SUFDaEQ7O0dBRUQsSUFBSSxHQUFHLElBQUksSUFBSSxHQUFFOztHQUVqQixJQUFJLE9BQU8sUUFBUSxLQUFLLFdBQVcsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7S0FDbkQsT0FBTyxJQUFJO0lBQ1o7O0dBRUQsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsRUFBQztHQUM1RCxJQUFJLE9BQU8sSUFBSSxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7S0FDbEMsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBSztJQUMxQjtHQUNELElBQUksT0FBTyxJQUFJLENBQUMsTUFBTSxLQUFLLFFBQVEsRUFBRTtLQUNuQyxNQUFNLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFNO0lBQzVCOztHQUVELElBQUksT0FBTyxHQUFHLEtBQUk7R0FDbEIsSUFBSSxHQUFFO0dBQ04sSUFBSTtLQUNGLElBQUksS0FBSyxHQUFHLEVBQUUsSUFBSSxHQUFFOztLQUVwQixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO09BQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksRUFBQztNQUNuQzs7S0FFRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtPQUNyQyxFQUFFLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsT0FBTyxFQUFDO09BQ3pDLElBQUksRUFBRSxFQUFFLE9BQU8sRUFBRTtNQUNsQjtJQUNGLENBQUMsT0FBTyxDQUFDLEVBQUU7S0FDVixFQUFFLEdBQUcsS0FBSTtJQUNWO0dBQ0QsUUFBUSxFQUFFLElBQUksSUFBSSxDQUFDO0VBQ3BCOztDQ2pDRCxTQUFTLHNCQUF1QjtLQUM5QixJQUFJLENBQUMsU0FBQSxJQUFhO1NBQ2hCLE1BQU0sSUFBSSxLQUFKLENBQVU7O0tBRWxCLE9BQU8sUUFBQSxDQUFTLGFBQVQsQ0FBdUI7OztBQUdoQyxDQUFlLFNBQVMsYUFBYyxVQUFlO3dDQUFmLEdBQVc7O0tBQy9DLElBQUksU0FBUztLQUNiLElBQUksYUFBYTtLQUNqQixJQUFJLFFBQUEsQ0FBUyxNQUFULEtBQW9CLE9BQU87U0FFN0IsT0FBQSxHQUFVLFFBQUEsQ0FBUztTQUNuQixJQUFJLENBQUMsT0FBRCxJQUFZLE9BQU8sT0FBUCxLQUFtQixVQUFVO2FBQzNDLElBQUksWUFBWSxRQUFBLENBQVM7YUFDekIsSUFBSSxDQUFDLFdBQVc7aUJBQ2QsU0FBQSxHQUFZLG1CQUFBO2lCQUNaLFVBQUEsR0FBYTs7YUFFZixJQUFNLE9BQU8sT0FBQSxJQUFXO2FBQ3hCLElBQUksT0FBTyxTQUFBLENBQVUsVUFBakIsS0FBZ0MsWUFBWTtpQkFDOUMsTUFBTSxJQUFJLEtBQUosQ0FBVTs7YUFFbEIsT0FBQSxHQUFVLGtCQUFBLENBQWlCLE1BQU0sWUFBQSxDQUFPLElBQUksUUFBQSxDQUFTLFlBQVk7aUJBQUUsUUFBUTs7YUFDM0UsSUFBSSxDQUFDLFNBQVM7aUJBQ1osTUFBTSxJQUFJLEtBQUosb0NBQTBDOzs7U0FJcEQsTUFBQSxHQUFTLE9BQUEsQ0FBUTtTQUVqQixJQUFJLFFBQUEsQ0FBUyxNQUFULElBQW1CLE1BQUEsS0FBVyxRQUFBLENBQVMsUUFBUTthQUNqRCxNQUFNLElBQUksS0FBSixDQUFVOztTQUlsQixJQUFJLFFBQUEsQ0FBUyxXQUFXO2FBQ3RCLE9BQUEsQ0FBUSxxQkFBUixHQUFnQzthQUNoQyxPQUFBLENBQVEsd0JBQVIsR0FBbUM7YUFDbkMsT0FBQSxDQUFRLHNCQUFSLEdBQWlDO2FBQ2pDLE9BQUEsQ0FBUSwyQkFBUixHQUFzQzthQUN0QyxPQUFBLENBQVEsdUJBQVIsR0FBa0M7YUFDbEMsTUFBQSxDQUFPLEtBQVAsQ0FBYSxrQkFBYixHQUFrQzs7O0tBR3RDLE9BQU87aUJBQUUsTUFBRjtrQkFBVSxPQUFWO3FCQUFtQjs7OztDQzdCNUIsSUFBTSxnQkFDSix5QkFBZTs7O1NBQ2IsQ0FBSyxTQUFMLEdBQWlCO1NBQ2pCLENBQUssTUFBTCxHQUFjO1NBQ2QsQ0FBSyxPQUFMLEdBQWU7U0FDZixDQUFLLElBQUwsR0FBWTtTQUNaLENBQUssY0FBTCxHQUFzQjtTQUd0QixDQUFLLGlCQUFMLEdBQXlCO1NBQ3pCLENBQUssYUFBTCxHQUFxQjtTQUVyQixDQUFLLGtCQUFMLEdBQTBCLGlCQUFBLENBQWtCOzhCQUNqQyxTQUFNLE1BQUEsQ0FBSyxRQUFMLENBQWMsT0FBZCxLQUEwQixRQURDO3lCQUVuQztpQkFDRCxFQUFBLENBQUcsVUFBVTtxQkFDWCxNQUFBLENBQUssS0FBTCxDQUFXLFdBQVc7MkJBQ3hCLENBQUssU0FBTDsyQkFDQSxDQUFLLEdBQUw7O3VCQUNLLE1BQUEsQ0FBSyxNQUFMO29CQUNGLElBQUksQ0FBQyxNQUFBLENBQUssS0FBTCxDQUFXLFdBQVc7dUJBQ2hDLENBQUssV0FBTDs7VUFUc0M7aUNBWTlCO2lCQUNOLE1BQUEsQ0FBSyxLQUFMLENBQVc7bUJBQVMsTUFBQSxDQUFLLEtBQUw7O21CQUNuQixNQUFBLENBQUssSUFBTDtVQWRtQzsyQkFnQmpDO21CQUNQLENBQUssV0FBTCxDQUFpQjt5QkFBVTs7OztTQUkvQixDQUFLLGVBQUwsZ0JBQXVCLFNBQU0sTUFBQSxDQUFLLE9BQUw7U0FFN0IsQ0FBSyxjQUFMLGdCQUFzQjthQUNkLFVBQVUsTUFBQSxDQUFLLE1BQUw7YUFFWixTQUFTO21CQUNYLENBQUssTUFBTDs7Ozs7O29CQUtGLHlCQUFVO1lBQ0wsSUFBQSxDQUFLOztvQkFHViwyQkFBWTtZQUNQLElBQUEsQ0FBSzs7b0JBR1Ysd0JBQVM7WUFDSixJQUFBLENBQUs7O3lCQUdkLDhDQUFrQixXQUFhLEVBQUEsVUFBVTtTQUNqQyxjQUFjLE9BQU8sUUFBUCxLQUFvQixRQUFwQixJQUFnQyxRQUFBLENBQVM7WUFDdEQsV0FBQSxHQUFjLFdBQUEsR0FBYyxXQUFXOzt5QkFHaEQsd0NBQWUsUUFBVSxFQUFBLElBQU0sRUFBQSxXQUFhLEVBQUEsS0FBSztZQUN2QyxRQUFBLENBQVMsWUFBVCxJQUF5QixXQUFBLEdBQWMsQ0FBeEMsR0FDSCxJQUFBLENBQUssS0FBTCxDQUFXLFFBQUEsSUFBWSxXQUFBLEdBQWMsTUFDckMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxHQUFBLEdBQU07O3lCQUd2Qix3REFBd0I7WUFDZixJQUFBLENBQUssYUFBTCxDQUNMLElBQUEsQ0FBSyxLQUFMLENBQVcsVUFBVSxJQUFBLENBQUssS0FBTCxDQUFXLE1BQ2hDLElBQUEsQ0FBSyxLQUFMLENBQVcsYUFBYSxJQUFBLENBQUssS0FBTCxDQUFXOzt5QkFJdkMsMENBQWlCO1NBQ1QsUUFBUSxJQUFBLENBQUs7WUFDWjtnQkFDRSxLQUFBLENBQU0sS0FEUjtpQkFFRyxLQUFBLENBQU0sTUFGVDtxQkFHTyxLQUFBLENBQU0sVUFIYjtzQkFJUSxLQUFBLENBQU0sV0FKZDt1QkFLUyxLQUFBLENBQU0sWUFMZjt3QkFNVSxLQUFBLENBQU0sYUFOaEI7eUJBT1csS0FBQSxDQUFNOzs7eUJBSTFCLHNCQUFPO1NBQ0QsQ0FBQyxJQUFBLENBQUs7V0FBUSxNQUFNLElBQUksS0FBSixDQUFVO1NBRzlCLElBQUEsQ0FBSyxRQUFMLENBQWMsT0FBZCxLQUEwQixPQUFPO2FBQ25DLENBQUssSUFBTDs7U0FJRSxPQUFPLElBQUEsQ0FBSyxNQUFMLENBQVksT0FBbkIsS0FBK0IsWUFBWTtnQkFDN0MsQ0FBUSxJQUFSLENBQWE7O1NBSVgsQ0FBQyxJQUFBLENBQUssS0FBTCxDQUFXLFNBQVM7YUFDdkIsQ0FBSyxZQUFMO2FBQ0EsQ0FBSyxLQUFMLENBQVcsT0FBWCxHQUFxQjs7U0FJdkIsQ0FBSyxJQUFMO1NBQ0EsQ0FBSyxNQUFMO1lBQ087O3lCQUdULDhDQUFtQjtTQUNiLElBQUEsQ0FBSyxJQUFMLElBQWEsSUFBYixJQUFxQixPQUFPLE1BQVAsS0FBa0IsV0FBdkMsSUFBc0QsT0FBTyxNQUFBLENBQU8sb0JBQWQsS0FBdUMsWUFBWTtlQUMzRyxDQUFPLG9CQUFQLENBQTRCLElBQUEsQ0FBSzthQUNqQyxDQUFLLElBQUwsR0FBWTs7U0FFVixJQUFBLENBQUssY0FBTCxJQUF1QixNQUFNO3FCQUMvQixDQUFhLElBQUEsQ0FBSzthQUNsQixDQUFLLGNBQUwsR0FBc0I7Ozt5QkFJMUIsd0JBQVE7U0FDRixVQUFVLElBQUEsQ0FBSyxRQUFMLENBQWM7U0FDeEIsV0FBQSxJQUFlLElBQUEsQ0FBSyxVQUFVO2dCQUNoQyxHQUFVO2dCQUNWLENBQVEsSUFBUixDQUFhOztTQUVYLENBQUM7V0FBUztTQUNWLENBQUMsU0FBQSxJQUFhO2dCQUNoQixDQUFRLEtBQVIsQ0FBYzs7O1NBR1osSUFBQSxDQUFLLEtBQUwsQ0FBVztXQUFTO1NBQ3BCLENBQUMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxTQUFTO2FBQ3ZCLENBQUssWUFBTDthQUNBLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7O1NBTXZCLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7U0FDckIsQ0FBSyxlQUFMO1NBQ0EsQ0FBSyxTQUFMLEdBQWlCLE9BQUE7U0FDakIsQ0FBSyxJQUFMLEdBQVksTUFBQSxDQUFPLHFCQUFQLENBQTZCLElBQUEsQ0FBSzs7eUJBR2hELDBCQUFTO1NBQ0gsSUFBQSxDQUFLLEtBQUwsQ0FBVztXQUFXLElBQUEsQ0FBSyxTQUFMO1NBQzFCLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7U0FFckIsQ0FBSyxlQUFMOzt5QkFHRixvQ0FBYztTQUNSLElBQUEsQ0FBSyxLQUFMLENBQVc7V0FBUyxJQUFBLENBQUssS0FBTDs7V0FDbkIsSUFBQSxDQUFLLElBQUw7O3lCQUlQLHdCQUFRO1NBQ04sQ0FBSyxLQUFMO1NBQ0EsQ0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQjtTQUNuQixDQUFLLEtBQUwsQ0FBVyxRQUFYLEdBQXNCO1NBQ3RCLENBQUssS0FBTCxDQUFXLElBQVgsR0FBa0I7U0FDbEIsQ0FBSyxLQUFMLENBQVcsU0FBWCxHQUF1QjtTQUN2QixDQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCO1NBQ3JCLENBQUssTUFBTDs7eUJBR0YsNEJBQVU7OztTQUNKLElBQUEsQ0FBSyxLQUFMLENBQVc7V0FBVztTQUN0QixDQUFDLFNBQUEsSUFBYTtnQkFDaEIsQ0FBUSxLQUFSLENBQWM7OztTQUloQixDQUFLLElBQUw7U0FDQSxDQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCO1NBQ3JCLENBQUssS0FBTCxDQUFXLFNBQVgsR0FBdUI7U0FFakIsYUFBYSxJQUFBLENBQUssb0JBQUwsQ0FBMEI7bUJBQVk7O1NBRW5ELGdCQUFnQixDQUFBLEdBQUksSUFBQSxDQUFLLEtBQUwsQ0FBVztTQUVyQyxDQUFLLGVBQUw7U0FDTSxtQkFBTzthQUNQLENBQUMsTUFBQSxDQUFLLEtBQUwsQ0FBVztlQUFXLE9BQU8sT0FBQSxDQUFRLE9BQVI7ZUFDbEMsQ0FBSyxLQUFMLENBQVcsU0FBWCxHQUF1QjtlQUN2QixDQUFLLElBQUw7Z0JBQ08sTUFBQSxDQUFLLFdBQUwsQ0FBaUIsV0FBakIsQ0FDSixJQURJLGFBQ0M7aUJBQ0EsQ0FBQyxNQUFBLENBQUssS0FBTCxDQUFXO21CQUFXO21CQUMzQixDQUFLLEtBQUwsQ0FBVyxTQUFYLEdBQXVCO21CQUN2QixDQUFLLEtBQUwsQ0FBVyxLQUFYO2lCQUNJLE1BQUEsQ0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixNQUFBLENBQUssS0FBTCxDQUFXLGFBQWE7dUJBQzdDLENBQUssS0FBTCxDQUFXLElBQVgsSUFBbUI7dUJBQ25CLENBQUssS0FBTCxDQUFXLFFBQVgsR0FBc0IsTUFBQSxDQUFLLGdCQUFMLENBQXNCLE1BQUEsQ0FBSyxLQUFMLENBQVcsTUFBTSxNQUFBLENBQUssS0FBTCxDQUFXO3VCQUN4RSxDQUFLLGNBQUwsR0FBc0IsVUFBQSxDQUFXLE1BQU07b0JBQ2xDO3dCQUNMLENBQVEsR0FBUixDQUFZO3VCQUNaLENBQUssVUFBTDt1QkFDQSxDQUFLLFNBQUw7dUJBQ0EsQ0FBSyxJQUFMO3VCQUNBLENBQUssR0FBTDs7OztTQU1KLENBQUMsSUFBQSxDQUFLLEtBQUwsQ0FBVyxTQUFTO2FBQ3ZCLENBQUssWUFBTDthQUNBLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7O1NBSW5CLElBQUEsQ0FBSyxNQUFMLElBQWUsT0FBTyxJQUFBLENBQUssTUFBTCxDQUFZLFdBQW5CLEtBQW1DLFlBQVk7YUFDaEUsQ0FBSyxpQkFBTCxXQUF1QixnQkFBUyxNQUFBLENBQUssTUFBTCxDQUFZLFdBQVosQ0FBd0I7O2dCQUkxRCxDQUFZLFdBQVosQ0FDRyxLQURILFdBQ1M7Z0JBQ0wsQ0FBUSxLQUFSLENBQWM7T0FGbEIsQ0FJRyxJQUpILFdBSVE7ZUFDSixDQUFLLElBQUwsR0FBWSxNQUFBLENBQU8scUJBQVAsQ0FBNkI7Ozt5QkFJL0Msd0NBQWdCOzs7U0FDVixJQUFBLENBQUssTUFBTCxJQUFlLE9BQU8sSUFBQSxDQUFLLE1BQUwsQ0FBWSxLQUFuQixLQUE2QixZQUFZO2FBQzFELENBQUssaUJBQUwsV0FBdUIsZ0JBQVMsTUFBQSxDQUFLLE1BQUwsQ0FBWSxLQUFaLENBQWtCOzs7eUJBSXRELG9DQUFjOzs7U0FDUixJQUFBLENBQUssTUFBTCxJQUFlLE9BQU8sSUFBQSxDQUFLLE1BQUwsQ0FBWSxHQUFuQixLQUEyQixZQUFZO2FBQ3hELENBQUssaUJBQUwsV0FBdUIsZ0JBQVMsTUFBQSxDQUFLLE1BQUwsQ0FBWSxHQUFaLENBQWdCOzs7eUJBSXBELGtDQUFhOzs7U0FDTCxlQUFlLElBQUEsQ0FBSyxLQUFMLENBQVc7U0FFaEMsQ0FBSyxlQUFMO1NBQ0EsQ0FBSyxLQUFMLENBQVcsU0FBWCxHQUF1QjtTQUN2QixDQUFLLEtBQUwsQ0FBVyxTQUFYLEdBQXVCO1NBQ3ZCLENBQUssS0FBTCxDQUFXLE9BQVgsR0FBcUI7WUFHZCxTQUFBLEVBQUEsQ0FDSixLQURJLFdBQ0U7Z0JBQ0wsQ0FBUSxLQUFSLENBQWM7T0FGWCxDQUlKLElBSkksYUFJQzthQUVBLFlBQUEsSUFBZ0IsTUFBQSxDQUFLLE1BQXJCLElBQStCLE9BQU8sTUFBQSxDQUFLLE1BQUwsQ0FBWSxTQUFuQixLQUFpQyxZQUFZO21CQUM5RSxDQUFLLGlCQUFMLFdBQXVCLGdCQUFTLE1BQUEsQ0FBSyxNQUFMLENBQVksU0FBWixDQUFzQjs7Ozt5QkFLOUQsc0RBQXNCLEtBQVU7a0NBQVYsR0FBTTs7WUFDbkI7bUJBQ0ssR0FBQSxDQUFJLFFBRFQ7ZUFFQyxHQUFBLENBQUksSUFGTDtjQUdBLElBQUEsQ0FBSyxLQUFMLENBQVcsR0FIWDtnQkFJRSxHQUFBLENBQUksUUFBSixHQUFlLElBQUEsQ0FBSyxLQUFMLENBQVcsUUFBUSxTQUpwQztlQUtDLElBQUEsQ0FBSyxRQUFMLENBQWMsSUFMZjtlQU1DLElBQUEsQ0FBSyxRQUFMLENBQWMsSUFOZjtpQkFPRyxJQUFBLENBQUssUUFBTCxDQUFjLE1BUGpCO2lCQVFHLElBQUEsQ0FBSyxRQUFMLENBQWMsTUFSakI7bUJBU0ssSUFBQSxDQUFLLFFBQUwsQ0FBYyxRQVRuQjswQkFVWSxJQUFBLENBQUssUUFBTCxDQUFjLGVBVjFCO29CQVdNLEdBQUEsQ0FBSSxTQUFKLElBQWlCLFlBQUEsRUFYdkI7c0JBWVEsUUFBQSxDQUFTLElBQUEsQ0FBSyxLQUFMLENBQVcsWUFBcEIsR0FBbUMsSUFBQSxDQUFLLEdBQUwsQ0FBUyxHQUFHLElBQUEsQ0FBSyxLQUFMLENBQVcsZUFBZTs7O3lCQUkxRixvQ0FBYSxLQUFVOztrQ0FBVixHQUFNOztTQUNiLENBQUMsSUFBQSxDQUFLO1dBQVEsT0FBTyxPQUFBLENBQVEsR0FBUixDQUFZO1NBQ2pDLE9BQU8sSUFBQSxDQUFLLE1BQUwsQ0FBWSxTQUFuQixLQUFpQyxZQUFZO2FBQy9DLENBQUssTUFBTCxDQUFZLFNBQVo7O1NBSUUsYUFBYSxJQUFBLENBQUssb0JBQUwsQ0FBMEI7U0FFckMsU0FBUyxZQUFBO1NBQ1gsSUFBSSxPQUFBLENBQVEsT0FBUjtTQUNKLE1BQUEsSUFBVSxHQUFBLENBQUksTUFBZCxJQUF3QixPQUFPLE1BQUEsQ0FBTyxNQUFkLEtBQXlCLFlBQVk7YUFDekQsYUFBYSxZQUFBLENBQU8sSUFBSTthQUN4QixPQUFPLE1BQUEsQ0FBTyxNQUFQLENBQWM7YUFDdkIsV0FBQSxDQUFVO2VBQU8sQ0FBQSxHQUFJOztlQUNwQixDQUFBLEdBQUksT0FBQSxDQUFRLE9BQVIsQ0FBZ0I7O1lBR3BCLENBQUEsQ0FBRSxJQUFGLFdBQU8sZUFDTCxNQUFBLENBQUssY0FBTCxDQUFvQixZQUFBLENBQU8sSUFBSSxZQUFZO2VBQVEsSUFBQSxJQUFRO1lBRDdELENBRUosSUFGSSxXQUVDO2FBR0YsTUFBQSxDQUFPLE1BQVAsS0FBa0I7ZUFBRyxPQUFPLE1BQUEsQ0FBTzs7ZUFDbEMsT0FBTzs7O3lCQUloQiwwQ0FBZ0IsWUFBaUI7O2dEQUFqQixHQUFhOztTQUMzQixDQUFLLE1BQUwsQ0FBWSxTQUFaLEdBQXdCO1NBR3hCLENBQUssTUFBTDtTQUdJLGFBQWEsSUFBQSxDQUFLLE1BQUw7U0FHWCxTQUFTLElBQUEsQ0FBSyxLQUFMLENBQVc7U0FHdEIsT0FBTyxVQUFQLEtBQXNCLGFBQWE7bUJBQ3JDLEdBQWEsQ0FBRTs7ZUFFakIsR0FBYSxFQUFBLENBQUcsTUFBSCxDQUFVLFdBQVYsQ0FBc0IsTUFBdEIsQ0FBNkI7ZUFJMUMsR0FBYSxVQUFBLENBQVcsR0FBWCxXQUFlO2FBQ3BCLGdCQUFnQixPQUFPLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsTUFBOUIsS0FBeUMsTUFBQSxJQUFVLE1BQVYsSUFBb0IsU0FBQSxJQUFhO2FBQzFGLE9BQU8sYUFBQSxHQUFnQixNQUFBLENBQU8sT0FBTzthQUNyQyxPQUFPLGFBQUEsR0FBZ0IsWUFBQSxDQUFPLElBQUksUUFBUTttQkFBRTtjQUFVO21CQUFFOzthQUMxRCxRQUFBLENBQVMsT0FBTztpQkFDWixXQUFXLElBQUEsQ0FBSyxRQUFMLElBQWlCLFVBQUEsQ0FBVztpQkFDdkMsa0JBQWtCLE9BQUEsQ0FBUSxJQUFBLENBQUssaUJBQWlCLFVBQUEsQ0FBVyxpQkFBaUI7dUJBQzdDLFlBQUEsQ0FBYSxNQUFNOzJCQUFFLFFBQUY7a0NBQVk7O2lCQUE1RDtpQkFBUztpQkFBVztvQkFDckIsTUFBQSxDQUFPLE1BQVAsQ0FBYyxNQUFNOzBCQUFFLE9BQUY7NEJBQVcsU0FBWDt1QkFBc0I7O2dCQUM1QztvQkFDRTs7O1NBS1gsQ0FBSyxNQUFMLENBQVksU0FBWixHQUF3QjtTQUN4QixDQUFLLE1BQUw7U0FDQSxDQUFLLE1BQUw7WUFHTyxPQUFBLENBQVEsR0FBUixDQUFZLFVBQUEsQ0FBVyxHQUFYLFdBQWdCLE1BQVEsRUFBQSxDQUFHLEVBQUEsV0FBWjthQUUxQixTQUFTLFlBQUEsQ0FBTzt3QkFDVCxFQURTO3FCQUVaLEVBRlk7cUJBR1o7WUFDUCxZQUFZLFFBQVE7b0JBQ2QsQ0FEYzswQkFFUixTQUFBLENBQVU7O2FBS25CLFlBQVksVUFBQSxDQUFXLElBQVgsS0FBb0IsS0FBcEIsR0FBNEIsUUFBUSxNQUFBLENBQU87ZUFDN0QsQ0FBTyxJQUFQLEdBQWMsU0FBQSxLQUFjO2VBRzVCLENBQU8sUUFBUCxHQUFrQixlQUFBLENBQWdCO2dCQUczQixNQUFBLENBQU87Z0JBQ1AsTUFBQSxDQUFPO2NBR1QsSUFBSSxLQUFLLFFBQVE7aUJBQ2hCLE9BQU8sTUFBQSxDQUFPLEVBQWQsS0FBcUI7bUJBQWEsT0FBTyxNQUFBLENBQU87O2FBR2xELGNBQWMsT0FBQSxDQUFRLE9BQVIsQ0FBZ0I7YUFDOUIsTUFBQSxDQUFPLE1BQU07aUJBRVQsT0FBTyxNQUFBLENBQU87aUJBQ2hCLE1BQUEsQ0FBTyxTQUFTO3FCQUNaLFVBQVUsTUFBQSxDQUFPOzRCQUN2QixHQUFjLFdBQUEsQ0FBWSxTQUFTO29CQUM5Qjs0QkFDTCxHQUFjLFFBQUEsQ0FBUyxNQUFNOzs7Z0JBRzFCLFdBQUEsQ0FBWSxJQUFaLFdBQWlCLHFCQUNmLE1BQUEsQ0FBTyxNQUFQLENBQWMsSUFBSSxRQUFRO1FBeEM5QixDQTBDSCxJQTFDRyxXQTBDRTthQUNELGNBQWMsRUFBQSxDQUFHLE1BQUgsV0FBVSxZQUFLLENBQUEsQ0FBRTthQUNqQyxXQUFBLENBQVksTUFBWixHQUFxQixHQUFHO2lCQUVwQixrQkFBa0IsV0FBQSxDQUFZLElBQVosV0FBaUIsWUFBSyxDQUFBLENBQUU7aUJBQzFDLFdBQVcsV0FBQSxDQUFZLElBQVosV0FBaUIsWUFBSyxDQUFBLENBQUU7aUJBQ25DLGNBQWMsV0FBQSxDQUFZLElBQVosV0FBaUIsWUFBSyxDQUFBLENBQUU7aUJBQ3hDO2lCQUVBLFdBQUEsQ0FBWSxNQUFaLEdBQXFCO21CQUFHLElBQUEsR0FBTyxXQUFBLENBQVk7bUJBRTFDLElBQUk7bUJBQWlCLElBQUEsR0FBTyxDQUFHLGVBQUEsQ0FBZ0IscUJBQWMsV0FBQSxDQUFZLEVBQVosQ0FBZTs7bUJBRTVFLElBQUEsR0FBTyxNQUFHLFdBQUEsQ0FBWSxFQUFaLENBQWU7aUJBQzFCLFFBQVE7aUJBQ1IsVUFBQSxDQUFXLFVBQVU7cUJBQ2pCLGlCQUFpQixRQUFBLENBQVMsTUFBQSxDQUFLLEtBQUwsQ0FBVztzQkFDM0MsR0FBUSxjQUFBLGtCQUE0QixVQUFBLENBQVcsS0FBWCxHQUFtQixjQUFPLE1BQUEsQ0FBSyxLQUFMLENBQVcscUNBQTRCLFVBQUEsQ0FBVztvQkFDM0csSUFBSSxXQUFBLENBQVksTUFBWixHQUFxQixHQUFHO3NCQUNqQyxHQUFROztpQkFFSixTQUFTLFFBQUEsR0FBVyxzQkFBc0I7aUJBQzFDLFNBQVMsV0FBQSxHQUFjLG1CQUFtQjtvQkFDaEQsQ0FBUSxHQUFSLFVBQWtCLGtCQUFhLGlCQUFZLGNBQVMsUUFBUyxtQkFBbUIsbUJBQW1CLHNCQUFzQjs7YUFFdkgsT0FBTyxNQUFBLENBQUssTUFBTCxDQUFZLFVBQW5CLEtBQWtDLFlBQVk7bUJBQ2hELENBQUssTUFBTCxDQUFZLFVBQVo7O2dCQUVLOzs7eUJBSVgsZ0RBQW1CLElBQUk7U0FDckIsQ0FBSyxVQUFMO09BQ0EsQ0FBRyxJQUFBLENBQUs7U0FDUixDQUFLLFdBQUw7O3lCQUdGLG9DQUFjO1NBQ04sUUFBUSxJQUFBLENBQUs7U0FHZixDQUFDLElBQUEsQ0FBSyxLQUFMLENBQVcsRUFBWixJQUFrQixLQUFBLENBQU0sT0FBeEIsSUFBbUMsQ0FBQyxLQUFBLENBQU0sSUFBSTtjQUNoRCxDQUFNLE9BQU4sQ0FBYyxJQUFkO2FBQ0ksSUFBQSxDQUFLLFFBQUwsQ0FBYyxZQUFkLEtBQStCLE9BQU87a0JBQ3hDLENBQU0sT0FBTixDQUFjLEtBQWQsQ0FBb0IsS0FBQSxDQUFNLFFBQVEsS0FBQSxDQUFNOztZQUVyQyxJQUFJLEtBQUEsQ0FBTSxJQUFJO2NBQ25CLENBQU0sRUFBTixDQUFTLEtBQVQsQ0FBZSxLQUFBLENBQU0sTUFBTixHQUFlLEtBQUEsQ0FBTSxZQUFZLEtBQUEsQ0FBTSxNQUFOLEdBQWUsS0FBQSxDQUFNOzs7eUJBSXpFLHNDQUFlO1NBQ1AsUUFBUSxJQUFBLENBQUs7U0FFZixDQUFDLElBQUEsQ0FBSyxLQUFMLENBQVcsRUFBWixJQUFrQixLQUFBLENBQU0sT0FBeEIsSUFBbUMsQ0FBQyxLQUFBLENBQU0sSUFBSTtjQUNoRCxDQUFNLE9BQU4sQ0FBYyxPQUFkOztTQU9FLEtBQUEsQ0FBTSxFQUFOLElBQVksSUFBQSxDQUFLLFFBQUwsQ0FBYyxLQUFkLEtBQXdCLEtBQXBDLElBQTZDLENBQUMsS0FBQSxDQUFNLElBQUk7Y0FDMUQsQ0FBTSxFQUFOLENBQVMsS0FBVDs7O3lCQUlKLHdCQUFRO1NBQ0YsSUFBQSxDQUFLLE1BQUwsSUFBZSxPQUFPLElBQUEsQ0FBSyxNQUFMLENBQVksSUFBbkIsS0FBNEIsWUFBWTthQUN6RCxDQUFLLFVBQUw7YUFDQSxDQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLElBQUEsQ0FBSzthQUN0QixDQUFLLFdBQUw7Ozt5QkFJSiw0QkFBVTtTQUNKLElBQUEsQ0FBSyxLQUFMLENBQVcsSUFBSTthQUNqQixDQUFLLGlCQUFMLEdBQXlCO2FBQ3pCLENBQUssS0FBTCxDQUFXLEVBQVgsQ0FBYyxNQUFkO2dCQUNPLElBQUEsQ0FBSztZQUNQO2dCQUNFLElBQUEsQ0FBSyxjQUFMOzs7eUJBSVgsNENBQWtCO1NBQ1osQ0FBQyxJQUFBLENBQUs7V0FBUTtTQUVaLFFBQVEsSUFBQSxDQUFLO1NBQ25CLENBQUssVUFBTDtTQUVJO1NBRUEsT0FBTyxJQUFBLENBQUssTUFBWixLQUF1QixZQUFZO21CQUNyQyxHQUFhLElBQUEsQ0FBSyxNQUFMLENBQVk7WUFDcEIsSUFBSSxPQUFPLElBQUEsQ0FBSyxNQUFMLENBQVksTUFBbkIsS0FBOEIsWUFBWTttQkFDbkQsR0FBYSxJQUFBLENBQUssTUFBTCxDQUFZLE1BQVosQ0FBbUI7O1NBR2xDLENBQUssV0FBTDtZQUVPOzt5QkFHVCwwQkFBUSxLQUFVOztrQ0FBVixHQUFNOztTQUlOLGtCQUFrQixDQUN0QjtXQUdGLENBQU8sSUFBUCxDQUFZLElBQVosQ0FBaUIsT0FBakIsV0FBeUI7YUFDbkIsZUFBQSxDQUFnQixPQUFoQixDQUF3QixJQUF4QixJQUFnQyxHQUFHO21CQUMvQixJQUFJLEtBQUosb0JBQTBCOzs7U0FJOUIsWUFBWSxJQUFBLENBQUssU0FBTCxDQUFlO1NBQzNCLGFBQWEsSUFBQSxDQUFLLFNBQUwsQ0FBZTtVQUc3QixJQUFJLE9BQU8sS0FBSzthQUNiLFFBQVEsR0FBQSxDQUFJO2FBQ2QsT0FBTyxLQUFQLEtBQWlCLGFBQWE7bUJBQ2hDLENBQUssU0FBTCxDQUFlLElBQWYsR0FBc0I7OztTQUtwQixXQUFXLE1BQUEsQ0FBTyxNQUFQLENBQWMsSUFBSSxJQUFBLENBQUssV0FBVztTQUMvQyxNQUFBLElBQVUsR0FBVixJQUFpQixPQUFBLElBQVc7V0FBSyxNQUFNLElBQUksS0FBSixDQUFVO1dBQ2hELElBQUksTUFBQSxJQUFVO1dBQUssT0FBTyxRQUFBLENBQVM7V0FDbkMsSUFBSSxPQUFBLElBQVc7V0FBSyxPQUFPLFFBQUEsQ0FBUztTQUNyQyxVQUFBLElBQWMsR0FBZCxJQUFxQixhQUFBLElBQWlCO1dBQUssTUFBTSxJQUFJLEtBQUosQ0FBVTtXQUMxRCxJQUFJLFVBQUEsSUFBYztXQUFLLE9BQU8sUUFBQSxDQUFTO1dBQ3ZDLElBQUksYUFBQSxJQUFpQjtXQUFLLE9BQU8sUUFBQSxDQUFTO1NBRzNDLE1BQUEsSUFBVTtXQUFLLElBQUEsQ0FBSyxNQUFMLENBQVksSUFBWixHQUFtQixHQUFBLENBQUk7U0FFcEMsWUFBWSxJQUFBLENBQUssWUFBTCxDQUFrQjtXQUNwQyxDQUFPLE1BQVAsQ0FBYyxJQUFBLENBQUssUUFBUTtTQUd2QixTQUFBLEtBQWMsSUFBQSxDQUFLLFNBQUwsQ0FBZSxNQUE3QixJQUF1QyxVQUFBLEtBQWUsSUFBQSxDQUFLLFNBQUwsQ0FBZSxTQUFTO21CQUNwRCxZQUFBLENBQWEsSUFBQSxDQUFLO2FBQXRDO2FBQVE7YUFFaEIsQ0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQjthQUNwQixDQUFLLEtBQUwsQ0FBVyxPQUFYLEdBQXFCO2FBR3JCLENBQUssV0FBTDthQUdBLENBQUsscUJBQUw7O1NBSUUsR0FBQSxDQUFJLEVBQUosSUFBVSxPQUFPLEdBQUEsQ0FBSSxFQUFYLEtBQWtCLFlBQVk7YUFDMUMsQ0FBSyxLQUFMLENBQVcsRUFBWCxHQUFnQixHQUFBLENBQUk7YUFDcEIsQ0FBSyxLQUFMLENBQVcsRUFBWCxDQUFjLElBQWQsZ0JBQXFCO2lCQUNmLE1BQUEsQ0FBSzttQkFBZTttQkFDeEIsQ0FBSyxpQkFBTCxHQUF5QixNQUFBLENBQUssY0FBTDs7O1NBS3pCLFNBQUEsSUFBYSxLQUFLO2FBQ2hCLEdBQUEsQ0FBSTtlQUFTLElBQUEsQ0FBSyxJQUFMOztlQUNaLElBQUEsQ0FBSyxLQUFMOztrQkFHUCxDQUFjLElBQUEsQ0FBSztTQUduQixDQUFLLE1BQUw7U0FDQSxDQUFLLE1BQUw7WUFDTyxJQUFBLENBQUs7O3lCQUdkLDRCQUFVO1NBQ0YsV0FBVyxJQUFBLENBQUssYUFBTDtTQUVYLFdBQVcsSUFBQSxDQUFLO1NBQ2hCLFFBQVEsSUFBQSxDQUFLO1NBR2IsV0FBVyxZQUFBLENBQWEsT0FBTztXQUdyQyxDQUFPLE1BQVAsQ0FBYyxJQUFBLENBQUssUUFBUTtlQVN2QixJQUFBLENBQUs7U0FMUDtTQUNBO1NBQ0E7U0FDQTtTQUNBO1NBSUksU0FBUyxJQUFBLENBQUssS0FBTCxDQUFXO1NBQ3RCLE1BQUEsSUFBVSxRQUFBLENBQVMsWUFBVCxLQUEwQixPQUFPO2FBQ3pDLEtBQUEsQ0FBTSxJQUFJO2lCQUVSLE1BQUEsQ0FBTyxLQUFQLEtBQWlCLFdBQWpCLElBQWdDLE1BQUEsQ0FBTyxNQUFQLEtBQWtCLGNBQWM7cUJBQ2xFLENBQUssYUFBTCxHQUFxQjtzQkFFckIsQ0FBTSxFQUFOLENBQVMsWUFBVCxDQUFzQjtzQkFDdEIsQ0FBTSxFQUFOLENBQVMsWUFBVCxDQUFzQixXQUFBLEdBQWMsWUFBWSxZQUFBLEdBQWUsWUFBWTtxQkFDM0UsQ0FBSyxhQUFMLEdBQXFCOztnQkFFbEI7aUJBRUQsTUFBQSxDQUFPLEtBQVAsS0FBaUI7bUJBQWEsTUFBQSxDQUFPLEtBQVAsR0FBZTtpQkFDN0MsTUFBQSxDQUFPLE1BQVAsS0FBa0I7bUJBQWMsTUFBQSxDQUFPLE1BQVAsR0FBZ0I7O2FBR2xELFNBQUEsRUFBQSxJQUFlLFFBQUEsQ0FBUyxXQUFULEtBQXlCLE9BQU87bUJBQ2pELENBQU8sS0FBUCxDQUFhLEtBQWIsR0FBcUI7bUJBQ3JCLENBQU8sS0FBUCxDQUFhLE1BQWIsR0FBc0I7OztTQUlwQixXQUFXLElBQUEsQ0FBSyxhQUFMO1NBQ2IsVUFBVSxDQUFDLFdBQUEsQ0FBVSxVQUFVO1NBQy9CLFNBQVM7YUFDWCxDQUFLLFlBQUw7O1lBRUs7O3lCQUdULHdDQUFnQjtTQUVWLElBQUEsQ0FBSyxNQUFMLElBQWUsT0FBTyxJQUFBLENBQUssTUFBTCxDQUFZLE1BQW5CLEtBQThCLFlBQVk7YUFDM0QsQ0FBSyxNQUFMLENBQVksTUFBWixDQUFtQixJQUFBLENBQUs7Ozt5QkFJNUIsOEJBQVc7U0FDTCxDQUFDLElBQUEsQ0FBSyxLQUFMLENBQVc7V0FBUztTQUNyQixDQUFDLFNBQUEsSUFBYTtnQkFDaEIsQ0FBUSxLQUFSLENBQWM7OztTQUdoQixDQUFLLElBQUwsR0FBWSxNQUFBLENBQU8scUJBQVAsQ0FBNkIsSUFBQSxDQUFLO1NBRTFDLE1BQU0sT0FBQTtTQUVKLE1BQU0sSUFBQSxDQUFLLEtBQUwsQ0FBVztTQUNqQixrQkFBa0IsSUFBQSxHQUFPO1NBQzNCLGNBQWMsR0FBQSxHQUFNLElBQUEsQ0FBSztTQUV2QixXQUFXLElBQUEsQ0FBSyxLQUFMLENBQVc7U0FDdEIsY0FBYyxPQUFPLFFBQVAsS0FBb0IsUUFBcEIsSUFBZ0MsUUFBQSxDQUFTO1NBRXpELGFBQWE7U0FDWCxlQUFlLElBQUEsQ0FBSyxRQUFMLENBQWM7U0FDL0IsWUFBQSxLQUFpQixTQUFTO29CQUM1QixHQUFjO1lBQ1QsSUFBSSxZQUFBLEtBQWlCLFlBQVk7YUFDbEMsV0FBQSxHQUFjLGlCQUFpQjtnQkFDakMsR0FBTSxHQUFBLEdBQU8sV0FBQSxHQUFjO2lCQUMzQixDQUFLLFNBQUwsR0FBaUI7Z0JBQ1o7dUJBQ0wsR0FBYTs7WUFFVjthQUNMLENBQUssU0FBTCxHQUFpQjs7U0FHYixZQUFZLFdBQUEsR0FBYztTQUM1QixVQUFVLElBQUEsQ0FBSyxLQUFMLENBQVcsSUFBWCxHQUFrQixTQUFBLEdBQVksSUFBQSxDQUFLLEtBQUwsQ0FBVztTQUduRCxPQUFBLEdBQVUsQ0FBVixJQUFlLGFBQWE7Z0JBQzlCLEdBQVUsUUFBQSxHQUFXOztTQUluQixhQUFhO1NBQ2IsY0FBYztTQUVaLFVBQVUsSUFBQSxDQUFLLFFBQUwsQ0FBYyxJQUFkLEtBQXVCO1NBRW5DLFdBQUEsSUFBZSxPQUFBLElBQVcsVUFBVTthQUVsQyxTQUFTO3VCQUNYLEdBQWE7b0JBQ2IsR0FBVSxPQUFBLEdBQVU7d0JBQ3BCLEdBQWM7Z0JBQ1Q7dUJBQ0wsR0FBYTtvQkFDYixHQUFVO3VCQUNWLEdBQWE7O2FBR2YsQ0FBSyxVQUFMOztTQUdFLFlBQVk7YUFDZCxDQUFLLEtBQUwsQ0FBVyxTQUFYLEdBQXVCO2FBQ3ZCLENBQUssS0FBTCxDQUFXLElBQVgsR0FBa0I7YUFDbEIsQ0FBSyxLQUFMLENBQVcsUUFBWCxHQUFzQixJQUFBLENBQUssZ0JBQUwsQ0FBc0IsU0FBUzthQUMvQyxZQUFZLElBQUEsQ0FBSyxLQUFMLENBQVc7YUFDN0IsQ0FBSyxLQUFMLENBQVcsS0FBWCxHQUFtQixJQUFBLENBQUssb0JBQUw7YUFDZjtlQUFhLElBQUEsQ0FBSyxZQUFMO2FBQ2IsU0FBQSxLQUFjLElBQUEsQ0FBSyxLQUFMLENBQVc7ZUFBTyxJQUFBLENBQUssSUFBTDthQUNwQyxDQUFLLE1BQUw7YUFDQSxDQUFLLEtBQUwsQ0FBVyxTQUFYLEdBQXVCOztTQUdyQixZQUFZO2FBQ2QsQ0FBSyxLQUFMOzs7eUJBSUosOEJBQVUsSUFBSTtTQUNSLE9BQU8sRUFBUCxLQUFjO1dBQVksTUFBTSxJQUFJLEtBQUosQ0FBVTtPQUM5QyxDQUFHLElBQUEsQ0FBSztTQUNSLENBQUssTUFBTDs7eUJBR0YsMEJBQVM7U0FDUCxDQUFLLHFCQUFMOzt5QkFHRiw4QkFBVztTQUNMLFNBQUEsSUFBYTtlQUNmLENBQU8sbUJBQVAsQ0FBMkIsVUFBVSxJQUFBLENBQUs7YUFDMUMsQ0FBSyxrQkFBTCxDQUF3QixNQUF4Qjs7U0FFRSxJQUFBLENBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsZUFBZTthQUNuQyxDQUFLLEtBQUwsQ0FBVyxNQUFYLENBQWtCLGFBQWxCLENBQWdDLFdBQWhDLENBQTRDLElBQUEsQ0FBSyxLQUFMLENBQVc7Ozt5QkFJM0QsMERBQXlCO1NBQ25CLENBQUMsU0FBQTtXQUFhO1NBQ2QsSUFBQSxDQUFLLFFBQUwsQ0FBYyxNQUFkLEtBQXlCLEtBQXpCLEtBQW1DLElBQUEsQ0FBSyxLQUFMLENBQVcsTUFBWCxJQUFxQixDQUFDLElBQUEsQ0FBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixnQkFBZ0I7YUFDdkYsZ0JBQWdCLElBQUEsQ0FBSyxRQUFMLENBQWMsTUFBZCxJQUF3QixRQUFBLENBQVM7c0JBQ3ZELENBQWMsV0FBZCxDQUEwQixJQUFBLENBQUssS0FBTCxDQUFXOzs7eUJBSXpDLHNDQUFlO1NBQ1QsSUFBQSxDQUFLLEtBQUwsQ0FBVyxTQUFTO2FBQ2xCLGNBQUEsQ0FBZSxJQUFBLENBQUssS0FBTCxDQUFXLFVBQVU7aUJBQ3RDLENBQUssTUFBTCxDQUFZLEVBQVosR0FBaUIsSUFBQSxDQUFLLEtBQUwsQ0FBVztnQkFDdkI7b0JBQ0UsSUFBQSxDQUFLLE1BQUwsQ0FBWTs7Ozt5QkFLekIsc0NBQWMsVUFBZTs0Q0FBZixHQUFXOztTQUVuQixXQUFXLFFBQUEsQ0FBUztTQUNwQixjQUFjLFFBQUEsQ0FBUztTQUNyQixZQUFZLE9BQUEsQ0FBUSxRQUFBLENBQVMsV0FBVztTQUN4QyxNQUFNLE9BQUEsQ0FBUSxRQUFBLENBQVMsS0FBSztTQUM1QixjQUFjLE9BQU8sUUFBUCxLQUFvQixRQUFwQixJQUFnQyxRQUFBLENBQVM7U0FDdkQsaUJBQWlCLE9BQU8sV0FBUCxLQUF1QixRQUF2QixJQUFtQyxRQUFBLENBQVM7U0FFN0QsMEJBQTBCLFdBQUEsR0FBYyxJQUFBLENBQUssS0FBTCxDQUFXLEdBQUEsR0FBTSxZQUFZO1NBQ3JFLDBCQUEwQixjQUFBLEdBQWtCLFdBQUEsR0FBYyxNQUFPO1NBQ25FLFdBQUEsSUFBZSxjQUFmLElBQWlDLHVCQUFBLEtBQTRCLGFBQWE7ZUFDdEUsSUFBSSxLQUFKLENBQVU7O1NBR2QsT0FBTyxRQUFBLENBQVMsVUFBaEIsS0FBK0IsV0FBL0IsSUFBOEMsT0FBTyxRQUFBLENBQVMsS0FBaEIsS0FBMEIsYUFBYTtnQkFDdkYsQ0FBUSxJQUFSLENBQWE7O2dCQUdmLEdBQWMsT0FBQSxDQUFRLGFBQWEseUJBQXlCO2FBQzVELEdBQVcsT0FBQSxDQUFRLFVBQVUseUJBQXlCO1NBRWhELFlBQVksUUFBQSxDQUFTO1NBQ3JCLGFBQWEsUUFBQSxDQUFTO1NBQ3RCLGVBQWUsT0FBTyxTQUFQLEtBQXFCLFFBQXJCLElBQWlDLFFBQUEsQ0FBUztTQUN6RCxnQkFBZ0IsT0FBTyxVQUFQLEtBQXNCLFFBQXRCLElBQWtDLFFBQUEsQ0FBUztTQUc3RCxPQUFPO1NBQ1AsUUFBUTtTQUNSLFdBQVc7U0FDWCxZQUFBLElBQWdCLGVBQWU7ZUFDM0IsSUFBSSxLQUFKLENBQVU7WUFDWCxJQUFJLGNBQWM7YUFFdkIsR0FBTztpQkFDUCxHQUFXLElBQUEsQ0FBSyxnQkFBTCxDQUFzQixNQUFNO2NBQ3ZDLEdBQVEsSUFBQSxDQUFLLGFBQUwsQ0FDTixVQUFVLE1BQ1YsYUFBYTtZQUVWLElBQUksZUFBZTtjQUV4QixHQUFRO2FBQ1IsR0FBTyxLQUFBLEdBQVE7aUJBQ2YsR0FBVyxJQUFBLENBQUssZ0JBQUwsQ0FBc0IsTUFBTTs7WUFHbEM7bUJBQ0wsUUFESztlQUVMLElBRks7Z0JBR0wsS0FISzttQkFJTCxRQUpLO3NCQUtMLFdBTEs7Y0FNTCxHQU5LO29CQU9MOzs7eUJBSUosd0JBQU8sVUFBZTs7NENBQWYsR0FBVzs7U0FDWixJQUFBLENBQUs7V0FBUSxNQUFNLElBQUksS0FBSixDQUFVO1NBRWpDLENBQUssU0FBTCxHQUFpQixNQUFBLENBQU8sTUFBUCxDQUFjLElBQUksVUFBVSxJQUFBLENBQUs7a0JBRWxELENBQWMsSUFBQSxDQUFLO2VBR1MsWUFBQSxDQUFhLElBQUEsQ0FBSztTQUF0QztTQUFTO1NBRVgsWUFBWSxJQUFBLENBQUssWUFBTCxDQUFrQixJQUFBLENBQUs7U0FHekMsQ0FBSyxNQUFMLEdBQWMsa0JBQ1QsU0FEUztrQkFFWixNQUZZO2tCQUdaLE9BSFk7b0JBSUQsQ0FKQztrQkFLSCxLQUxHO29CQU1ELEtBTkM7a0JBT0gsS0FQRztvQkFRRCxLQVJDO21CQVNGLElBQUEsQ0FBSyxRQVRIO2VBVU4sSUFBQSxDQUFLLFFBQUwsQ0FBYyxJQVZSOzZCQWFKLFNBQU0sTUFBQSxDQUFLLE1BQUwsS0FiRjtpQ0FjQSxTQUFNLE1BQUEsQ0FBSyxVQUFMLEtBZE47NkJBZUQsYUFBTyxNQUFBLENBQUssUUFBTCxDQUFjLE1BZnBCOzJCQWdCTixTQUFNLE1BQUEsQ0FBSyxJQUFMLEtBaEJBOzZCQWlCSixTQUFNLE1BQUEsQ0FBSyxNQUFMLEtBakJGOzJCQWtCSCxjQUFRLE1BQUEsQ0FBSyxNQUFMLENBQVksT0FsQmpCO2dDQW1CQyxjQUFPLE1BQUEsQ0FBSyxXQUFMLENBQWlCLE9BbkJ6Qjs2QkFvQkosU0FBTSxNQUFBLENBQUssTUFBTCxLQXBCRjsyQkFxQk4sU0FBTSxNQUFBLENBQUssSUFBTCxLQXJCQTs0QkFzQkwsU0FBTSxNQUFBLENBQUssS0FBTCxLQXRCRDsyQkF1Qk4sU0FBTSxNQUFBLENBQUssSUFBTDtTQUlkLENBQUssV0FBTDtTQUlBLENBQUssTUFBTDs7eUJBR0Ysa0NBQVksWUFBYyxFQUFBLGFBQWE7OztZQUM5QixJQUFBLENBQUssSUFBTCxDQUFVLGNBQWMsWUFBeEIsQ0FBcUMsSUFBckMsYUFBMEM7ZUFDL0MsQ0FBSyxHQUFMO2dCQUNPOzs7eUJBSVgsNEJBQVU7OztTQUNSLENBQUssS0FBTDtTQUNJLENBQUMsSUFBQSxDQUFLO1dBQVE7U0FDZCxPQUFPLElBQUEsQ0FBSyxNQUFMLENBQVksTUFBbkIsS0FBOEIsWUFBWTthQUM1QyxDQUFLLGlCQUFMLFdBQXVCLGdCQUFTLE1BQUEsQ0FBSyxNQUFMLENBQVksTUFBWixDQUFtQjs7U0FFckQsQ0FBSyxPQUFMLEdBQWU7O3lCQUdqQiw4QkFBVztTQUNULENBQUssTUFBTDtTQUNBLENBQUssT0FBTDs7eUJBR0Ysc0JBQU0sWUFBYyxFQUFBLGFBQWE7OztTQUUzQixPQUFPLFlBQVAsS0FBd0IsWUFBWTtlQUNoQyxJQUFJLEtBQUosQ0FBVTs7U0FHZCxJQUFBLENBQUssUUFBUTthQUNmLENBQUssTUFBTDs7U0FHRSxPQUFPLFdBQVAsS0FBdUIsYUFBYTthQUN0QyxDQUFLLE1BQUwsQ0FBWTs7U0FNZCxDQUFLLFVBQUw7U0FFSSxVQUFVLE9BQUEsQ0FBUSxPQUFSO1NBSVYsSUFBQSxDQUFLLFFBQUwsQ0FBYyxJQUFJO2FBQ2hCLENBQUMsU0FBQSxJQUFhO21CQUNWLElBQUksS0FBSixDQUFVOztnQkFFbEIsR0FBVSxJQUFJLE9BQUosV0FBWTtpQkFDaEIsZ0JBQWdCLE1BQUEsQ0FBSyxRQUFMLENBQWM7aUJBQzlCO2lCQUNBLGFBQUEsQ0FBYyxJQUFJO3dCQUNwQixHQUFVLGFBQUEsQ0FBYzs4QkFDeEIsR0FBZ0IsYUFBQSxDQUFjOztpQkFJMUIscUJBQVc7cUJBRVg7dUJBQVMsRUFBQSxDQUFHLE9BQUgsZ0JBQWEsU0FBTSxPQUFBLENBQVE7bUJBQ3hDLENBQUcsS0FBSCxnQkFBVzt5QkFDSCxRQUFRLE1BQUEsQ0FBSzt5QkFDYixPQUFPLE1BQUEsQ0FBSyxRQUFMLENBQWMsT0FBZCxLQUEwQjt5QkFDakMsV0FBVyxJQUFBLEdBQU8sRUFBQSxDQUFHLFFBQVEsRUFBQSxDQUFHO3VCQUN0QyxDQUFHLE1BQUg7dUJBQ0EsQ0FBRyxZQUFILENBQWdCLEtBQUEsQ0FBTTt1QkFDdEIsQ0FBRyxZQUFILENBQWdCLEtBQUEsQ0FBTSxlQUFlLEtBQUEsQ0FBTSxnQkFBZ0I7eUJBQ3ZELElBQUEsSUFBUSxNQUFBLENBQUssUUFBTCxDQUFjLFlBQVk7MkJBQ3BDLENBQUcsYUFBSCxDQUFpQixNQUFBLENBQUssUUFBTCxDQUFjOzsyQkFHakMsQ0FBSyxNQUFMLENBQVk7NkJBQUUsRUFBRjtpQ0FBYyxFQUFBLENBQUcsTUFBakI7a0NBQWtDLEVBQUEsQ0FBRyxTQUFILENBQWE7OzRCQUMzRDs7O2lCQUtBLE9BQU8sYUFBUCxLQUF5QixZQUFZO3FCQUNuQyxhQUFKLENBQWtCO29CQUNiO3FCQUNELE9BQU8sTUFBQSxDQUFPLFlBQWQsS0FBK0IsWUFBWTsyQkFDdkMsSUFBSSxLQUFKLENBQVU7O3lCQUVsQixDQUFTOzs7O1lBS1IsT0FBQSxDQUFRLElBQVIsYUFBYTthQUVkLFNBQVMsWUFBQSxDQUFhLE1BQUEsQ0FBSzthQUMzQixDQUFDLFdBQUEsQ0FBVSxTQUFTO21CQUN0QixHQUFTLE9BQUEsQ0FBUSxPQUFSLENBQWdCOztnQkFFcEI7T0FORixDQU9KLElBUEksV0FPQzthQUNGLENBQUM7ZUFBUSxNQUFBLEdBQVM7ZUFDdEIsQ0FBSyxPQUFMLEdBQWU7YUFHWCxTQUFBLElBQWE7bUJBQ2YsQ0FBSyxrQkFBTCxDQUF3QixNQUF4QjttQkFDQSxDQUFPLGdCQUFQLENBQXdCLFVBQVUsTUFBQSxDQUFLOztlQUd6QyxDQUFLLFdBQUw7ZUFNQSxDQUFLLFlBQUw7Z0JBQ087T0F4QkYsQ0F5QkosS0F6QkksV0F5QkU7Z0JBQ1AsQ0FBUSxJQUFSLENBQWEseUZBQUEsR0FBNEYsR0FBQSxDQUFJO2VBQ3ZHOzs7Ozs7Q0MzOUJaLElBQU0sUUFBUTtDQUNkLElBQU0sb0JBQW9CO0NBRTFCLFNBQVMsY0FBZTtLQUN0QixJQUFNLFNBQVMsWUFBQTtLQUNmLE9BQU8sTUFBQSxJQUFVLE1BQUEsQ0FBTzs7O0NBRzFCLFNBQVMsU0FBVSxJQUFJO0tBQ3JCLElBQU0sU0FBUyxZQUFBO0tBQ2YsSUFBSSxDQUFDO1dBQVEsT0FBTztLQUNwQixNQUFBLENBQU8sTUFBUCxHQUFnQixNQUFBLENBQU8sTUFBUCxJQUFpQjtLQUNqQyxPQUFPLE1BQUEsQ0FBTyxNQUFQLENBQWM7OztDQUd2QixTQUFTLFNBQVUsRUFBSSxFQUFBLE1BQU07S0FDM0IsSUFBTSxTQUFTLFlBQUE7S0FDZixJQUFJLENBQUM7V0FBUSxPQUFPO0tBQ3BCLE1BQUEsQ0FBTyxNQUFQLEdBQWdCLE1BQUEsQ0FBTyxNQUFQLElBQWlCO0tBQ2pDLE1BQUEsQ0FBTyxNQUFQLENBQWMsR0FBZCxHQUFvQjs7O0NBR3RCLFNBQVMsWUFBYSxVQUFZLEVBQUEsYUFBYTtLQUU3QyxPQUFPLFdBQUEsQ0FBWSxPQUFaLEdBQXNCO1NBQUUsTUFBTSxVQUFBLENBQVcsS0FBWCxDQUFpQjtTQUFTOzs7Q0FHakUsU0FBUyxhQUFjLE1BQVEsRUFBQSxVQUFlO3dDQUFmLEdBQVc7O0tBQ3hDLElBQUksUUFBQSxDQUFTLElBQUk7U0FDZixJQUFJLFFBQUEsQ0FBUyxNQUFULElBQW9CLFFBQUEsQ0FBUyxPQUFULElBQW9CLE9BQU8sUUFBQSxDQUFTLE9BQWhCLEtBQTRCLFVBQVc7YUFDakYsTUFBTSxJQUFJLEtBQUosQ0FBVTs7U0FJbEIsSUFBTSxVQUFVLE9BQU8sUUFBQSxDQUFTLE9BQWhCLEtBQTRCLFFBQTVCLEdBQXVDLFFBQUEsQ0FBUyxVQUFVO1NBQzFFLFFBQUEsR0FBVyxNQUFBLENBQU8sTUFBUCxDQUFjLElBQUksVUFBVTthQUFFLFFBQVEsS0FBVjtzQkFBaUI7OztLQUcxRCxJQUFNLFFBQVEsV0FBQTtLQUNkLElBQUk7S0FDSixJQUFJLE9BQU87U0FJVCxLQUFBLEdBQVEsT0FBQSxDQUFRLFFBQUEsQ0FBUyxJQUFJOztLQUUvQixJQUFJLGNBQWMsS0FBQSxJQUFTLE9BQU8sS0FBUCxLQUFpQjtLQUU1QyxJQUFJLFdBQUEsSUFBZSxpQkFBQSxDQUFrQixRQUFsQixDQUEyQixRQUFRO1NBQ3BELE9BQUEsQ0FBUSxJQUFSLENBQWEscUtBQXFLO1NBQ2xMLFdBQUEsR0FBYzs7S0FHaEIsSUFBSSxVQUFVLE9BQUEsQ0FBUSxPQUFSO0tBRWQsSUFBSSxhQUFhO1NBRWYsaUJBQUEsQ0FBa0IsSUFBbEIsQ0FBdUI7U0FFdkIsSUFBTSxlQUFlLFFBQUEsQ0FBUztTQUM5QixJQUFJLGNBQWM7YUFDaEIsSUFBTSxtQkFBTztpQkFFWCxJQUFNLFdBQVcsV0FBQSxDQUFZLFlBQUEsQ0FBYSxTQUFTO2lCQUVuRCxZQUFBLENBQWEsT0FBYixDQUFxQixPQUFyQjtpQkFFQSxPQUFPOzthQUlULE9BQUEsR0FBVSxZQUFBLENBQWEsSUFBYixDQUFrQixJQUFsQixDQUF1QixLQUF2QixDQUE2QixLQUE3QixDQUFtQzs7O0tBSWpELE9BQU8sT0FBQSxDQUFRLElBQVIsV0FBYTtTQUNsQixJQUFNLFVBQVUsSUFBSSxhQUFKO1NBQ2hCLElBQUk7U0FDSixJQUFJLFFBQVE7YUFFVixRQUFBLEdBQVcsTUFBQSxDQUFPLE1BQVAsQ0FBYyxJQUFJLFVBQVU7YUFHdkMsT0FBQSxDQUFRLEtBQVIsQ0FBYzthQUdkLE9BQUEsQ0FBUSxLQUFSO2FBR0EsTUFBQSxHQUFTLE9BQUEsQ0FBUSxVQUFSLENBQW1CO2dCQUN2QjthQUNMLE1BQUEsR0FBUyxPQUFBLENBQVEsT0FBUixDQUFnQjs7U0FFM0IsSUFBSSxhQUFhO2FBQ2YsUUFBQSxDQUFTLE9BQU87aUJBQUUsTUFBTSxNQUFSOzBCQUFnQjs7O1NBRWxDLE9BQU87Ozs7Q0FLWCxZQUFBLENBQWEsWUFBYixHQUE0QjtDQUM1QixZQUFBLENBQWEsVUFBYixHQUEwQjs7Ozs7Ozs7Ozs7QUMxRzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNWhnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIi8vIE1hcmsgb3V0cHV0L2V4cG9ydCBhcyBlbmFibGVkIGZvciB0aGUgY2xpZW50IEFQSSBzY3JpcHRzLlxud2luZG93WydjYW52YXMtc2tldGNoLWNsaSddID0gd2luZG93WydjYW52YXMtc2tldGNoLWNsaSddIHx8IHt9O1xud2luZG93WydjYW52YXMtc2tldGNoLWNsaSddLm91dHB1dCA9IHRydWU7XG4iLCJjb25zdCBOQU1FU1BBQ0UgPSAnY2FudmFzLXNrZXRjaC1jbGknO1xuXG4vLyBHcmFiIHRoZSBDTEkgbmFtZXNwYWNlXG53aW5kb3dbTkFNRVNQQUNFXSA9IHdpbmRvd1tOQU1FU1BBQ0VdIHx8IHt9O1xuXG5pZiAoIXdpbmRvd1tOQU1FU1BBQ0VdLmluaXRpYWxpemVkKSB7XG4gIGluaXRpYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZSAoKSB7XG4gIC8vIEF3YWl0aW5nIGVuYWJsZS9kaXNhYmxlIGV2ZW50XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLmxpdmVSZWxvYWRFbmFibGVkID0gdW5kZWZpbmVkO1xuICB3aW5kb3dbTkFNRVNQQUNFXS5pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgY29uc3QgZGVmYXVsdFBvc3RPcHRpb25zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGNhY2hlOiAnbm8tY2FjaGUnLFxuICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gIH07XG5cbiAgLy8gRmlsZSBzYXZpbmcgdXRpbGl0eVxuICB3aW5kb3dbTkFNRVNQQUNFXS5zYXZlQmxvYiA9IChibG9iLCBvcHRzKSA9PiB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICBjb25zdCBmb3JtID0gbmV3IHdpbmRvdy5Gb3JtRGF0YSgpO1xuICAgIGZvcm0uYXBwZW5kKCdmaWxlJywgYmxvYiwgb3B0cy5maWxlbmFtZSk7XG4gICAgcmV0dXJuIHdpbmRvdy5mZXRjaCgnL2NhbnZhcy1za2V0Y2gtY2xpL3NhdmVCbG9iJywgT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBvc3RPcHRpb25zLCB7XG4gICAgICBib2R5OiBmb3JtXG4gICAgfSkpLnRoZW4ocmVzID0+IHtcbiAgICAgIGlmIChyZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzLnRleHQoKS50aGVuKHRleHQgPT4ge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgIC8vIFNvbWUgaXNzdWUsIGp1c3QgYmFpbCBvdXQgYW5kIHJldHVybiBuaWwgaGFzaFxuICAgICAgY29uc29sZS53YXJuKGBUaGVyZSB3YXMgYSBwcm9ibGVtIGV4cG9ydGluZyAke29wdHMuZmlsZW5hbWV9YCk7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICB9O1xuXG4gIGNvbnN0IHN0cmVhbSA9ICh1cmwsIG9wdHMpID0+IHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHJldHVybiB3aW5kb3cuZmV0Y2godXJsLCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UG9zdE9wdGlvbnMsIHtcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgc2F2ZTogb3B0cy5zYXZlLFxuICAgICAgICBlbmNvZGluZzogb3B0cy5lbmNvZGluZyxcbiAgICAgICAgdGltZVN0YW1wOiBvcHRzLnRpbWVTdGFtcCxcbiAgICAgICAgZnBzOiBvcHRzLmZwcyxcbiAgICAgICAgZmlsZW5hbWU6IG9wdHMuZmlsZW5hbWVcbiAgICAgIH0pXG4gICAgfSkpXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCkudGhlbih0ZXh0ID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0ZXh0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgLy8gU29tZSBpc3N1ZSwganVzdCBiYWlsIG91dCBhbmQgcmV0dXJuIG5pbCBoYXNoXG4gICAgICAgIGNvbnNvbGUud2FybihgVGhlcmUgd2FzIGEgcHJvYmxlbSBzdGFydGluZyB0aGUgc3RyZWFtIGV4cG9ydGApO1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KTtcbiAgfTtcblxuICAvLyBGaWxlIHN0cmVhbWluZyB1dGlsaXR5XG4gIHdpbmRvd1tOQU1FU1BBQ0VdLnN0cmVhbVN0YXJ0ID0gKG9wdHMpID0+IHtcbiAgICByZXR1cm4gc3RyZWFtKCcvY2FudmFzLXNrZXRjaC1jbGkvc3RyZWFtLXN0YXJ0Jywgb3B0cyk7XG4gIH07XG5cbiAgd2luZG93W05BTUVTUEFDRV0uc3RyZWFtRW5kID0gKG9wdHMpID0+IHtcbiAgICByZXR1cm4gc3RyZWFtKCcvY2FudmFzLXNrZXRjaC1jbGkvc3RyZWFtLWVuZCcsIG9wdHMpO1xuICB9O1xuXG4gIC8vIGdpdCBjb21taXQgdXRpbGl0eVxuICB3aW5kb3dbTkFNRVNQQUNFXS5jb21taXQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHdpbmRvdy5mZXRjaCgnL2NhbnZhcy1za2V0Y2gtY2xpL2NvbW1pdCcsIGRlZmF1bHRQb3N0T3B0aW9ucylcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdC5lcnJvci50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdub3QgYSBnaXQgcmVwb3NpdG9yeScpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7cmVzdWx0LmVycm9yfWApO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RpZnkgdXNlciBvZiBjaGFuZ2VzXG4gICAgICAgIGNvbnNvbGUubG9nKHJlc3VsdC5jaGFuZ2VkXG4gICAgICAgICAgPyBgW2dpdF0gJHtyZXN1bHQuaGFzaH0gQ29tbWl0dGVkIGNoYW5nZXNgXG4gICAgICAgICAgOiBgW2dpdF0gJHtyZXN1bHQuaGFzaH0gTm90aGluZyBjaGFuZ2VkYCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuaGFzaDtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgLy8gU29tZSBpc3N1ZSwganVzdCBiYWlsIG91dCBhbmQgcmV0dXJuIG5pbCBoYXNoXG4gICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGNvbW1pdCBjaGFuZ2VzIGFuZCBmZXRjaCBoYXNoJyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICB9O1xuXG4gIGlmICgnYnVkby1saXZlcmVsb2FkJyBpbiB3aW5kb3cpIHtcbiAgICBjb25zdCBjbGllbnQgPSB3aW5kb3dbJ2J1ZG8tbGl2ZXJlbG9hZCddO1xuICAgIGNsaWVudC5saXN0ZW4oZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS5ldmVudCA9PT0gJ2hvdC1yZWxvYWQnKSB7XG4gICAgICAgIHNldHVwTGl2ZVJlbG9hZChkYXRhLmVuYWJsZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gT24gZmlyc3QgbG9hZCwgY2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBzZXR1cCBsaXZlIHJlbG9hZCBvciBub3RcbiAgICBpZiAod2luZG93W05BTUVTUEFDRV0uaG90KSB7XG4gICAgICBzZXR1cExpdmVSZWxvYWQodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHVwTGl2ZVJlbG9hZChmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldHVwTGl2ZVJlbG9hZCAoaXNFbmFibGVkKSB7XG4gIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB3aW5kb3dbTkFNRVNQQUNFXS5saXZlUmVsb2FkRW5hYmxlZDtcbiAgaWYgKHR5cGVvZiBwcmV2aW91c1N0YXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc0VuYWJsZWQgIT09IHByZXZpb3VzU3RhdGUpIHtcbiAgICAvLyBXZSBuZWVkIHRvIHJlbG9hZCB0aGUgcGFnZSB0byBlbnN1cmUgdGhlIG5ldyBza2V0Y2ggZnVuY3Rpb24gaXNcbiAgICAvLyBuYW1lZCBmb3IgaG90IHJlbG9hZGluZywgYW5kL29yIGNsZWFuZWQgdXAgYWZ0ZXIgaG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZFxuICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQodHJ1ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGlzRW5hYmxlZCA9PT0gd2luZG93W05BTUVTUEFDRV0ubGl2ZVJlbG9hZEVuYWJsZWQpIHtcbiAgICAvLyBObyBjaGFuZ2UgaW4gc3RhdGVcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBNYXJrIG5ldyBzdGF0ZVxuICB3aW5kb3dbTkFNRVNQQUNFXS5saXZlUmVsb2FkRW5hYmxlZCA9IGlzRW5hYmxlZDtcblxuICBpZiAoaXNFbmFibGVkKSB7XG4gICAgaWYgKCdidWRvLWxpdmVyZWxvYWQnIGluIHdpbmRvdykge1xuICAgICAgY29uc29sZS5sb2coYCVjW2NhbnZhcy1za2V0Y2gtY2xpXSVjIOKcqCBIb3QgUmVsb2FkIEVuYWJsZWRgLCAnY29sb3I6ICM4ZThlOGU7JywgJ2NvbG9yOiBpbml0aWFsOycpO1xuICAgICAgY29uc3QgY2xpZW50ID0gd2luZG93WydidWRvLWxpdmVyZWxvYWQnXTtcbiAgICAgIGNsaWVudC5saXN0ZW4ob25DbGllbnREYXRhKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25DbGllbnREYXRhIChkYXRhKSB7XG4gIGNvbnN0IGNsaWVudCA9IHdpbmRvd1snYnVkby1saXZlcmVsb2FkJ107XG4gIGlmICghY2xpZW50KSByZXR1cm47XG5cbiAgaWYgKGRhdGEuZXZlbnQgPT09ICdldmFsJykge1xuICAgIGlmICghZGF0YS5lcnJvcikge1xuICAgICAgY2xpZW50LmNsZWFyRXJyb3IoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGV2YWwoZGF0YS5jb2RlKTtcbiAgICAgIGlmICghZGF0YS5lcnJvcikgY29uc29sZS5sb2coYCVjW2NhbnZhcy1za2V0Y2gtY2xpXSVjIOKcqCBIb3QgUmVsb2FkZWRgLCAnY29sb3I6ICM4ZThlOGU7JywgJ2NvbG9yOiBpbml0aWFsOycpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihgJWNbY2FudmFzLXNrZXRjaC1jbGldJWMg8J+aqCBIb3QgUmVsb2FkIGVycm9yYCwgJ2NvbG9yOiAjOGU4ZThlOycsICdjb2xvcjogaW5pdGlhbDsnKTtcbiAgICAgIGNsaWVudC5zaG93RXJyb3IoZXJyLnRvU3RyaW5nKCkpO1xuXG4gICAgICAvLyBUaGlzIHdpbGwgYWxzbyBsb2FkIHVwIHRoZSBwcm9ibGVtYXRpYyBzY3JpcHQgc28gdGhhdCBzdGFjayB0cmFjZXMgd2l0aFxuICAgICAgLy8gc291cmNlIG1hcHMgaXMgdmlzaWJsZVxuICAgICAgY29uc3Qgc2NyaXB0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWxlbWVudC5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2NyaXB0RWxlbWVudCk7XG4gICAgICB9O1xuICAgICAgc2NyaXB0RWxlbWVudC5zcmMgPSBkYXRhLnNyYztcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2NyaXB0RWxlbWVudCk7XG4gICAgfVxuICB9XG59IiwiY29uc3QgY2FudmFzU2tldGNoID0gcmVxdWlyZSgnY2FudmFzLXNrZXRjaCcpO1xyXG5jb25zdCBsb2FkID0gcmVxdWlyZSgnbG9hZC1hc3NldCcpO1xyXG5cclxuLy8gSW1wb3J0IFR3by5qcyAtIG1ha2Ugc3VyZSB0byBoYXZlIGdyZWF0ZXIgdGhhbiB2MC43LjAtYWxwaGEuMVxyXG4vLyBiZWNhdXNlIHByZXZpb3VzIHZlcnNpb25zIGRvbid0IHN1cHBvcnQgbW9kdWxlIGxvYWRpbmcgb3IgaGVhZGxlc3MgZW52aXJvbm1lbnRzXHJcbmNvbnN0IFR3byA9IHJlcXVpcmUoJ3R3by5qcycpO1xyXG5cclxuY29uc3Qgc2V0dGluZ3MgPSB7XHJcbiAgZGltZW5zaW9uczogWyAyMDQ4LCAyMDQ4IF0sXHJcbiAgLy8gTWFrZSB0aGUgbG9vcCBhbmltYXRlZFxyXG4gIGFuaW1hdGU6IHRydWVcclxufTtcclxuXHJcbmNvbnN0IHNrZXRjaCA9IGFzeW5jICh7IGNhbnZhcyB9KSA9PiB7XHJcbiAgLy8gQ3JlYXRlIHRoZSBpbnN0YW5jZSBvZiBUd28uanNcclxuICBjb25zdCB0d28gPSBuZXcgVHdvKHsgZG9tRWxlbWVudDogY2FudmFzIH0pO1xyXG5cclxuICAvLyBHZW5lcmF0ZSB0aGUgaW1hZ2UgYW5kIHdhaXQgZm9yIGxvYWQgdG8gZmluaXNoIGJlZm9yZVxyXG4gIC8vIG1vdmluZyBmb3J3YXJkIHdpdGggcmVuZGVyaW5nLlxyXG4gIGNvbnN0IGltYWdlID0gYXdhaXQgbG9hZCgnYXNzZXRzL2JhYm9vbi5qcGcnKTtcclxuXHJcbiAgLy8gR2V0IHRoZSBkaW1lbnNpb25zIG9mIHRoZSBiYWJvb24gaW1hZ2VcclxuICBjb25zdCBpbWFnZVdpZHRoID0gaW1hZ2Uud2lkdGg7XHJcbiAgY29uc3QgaW1hZ2VIZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XHJcblxyXG4gIC8vIEhvdyBtYW55IHN0cmlwcyB3aWxsIHRoZXJlIGJlP1xyXG4gIGNvbnN0IGFtb3VudCA9IDI1O1xyXG4gIC8vIFRoZSBoZWlnaHQgb2YgZWFjaCBzdHJpcCB3ZSB3aWxsIGNyZWF0ZVxyXG4gIGNvbnN0IHN0cmlwSGVpZ2h0ID0gTWF0aC5jZWlsKGltYWdlSGVpZ2h0IC8gYW1vdW50KTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xyXG4gICAgbGV0IHBjdCA9IGkgLyAoYW1vdW50IC0gMSk7XHJcbiAgICBsZXQgeSA9IGltYWdlSGVpZ2h0ICogKHBjdCAtIDAuNSk7XHJcbiAgICAvLyBDcmVhdGUgYSByZWN0YW5nbGUgc3RyaXAgdGhhdCByZXByZXNlbnRzIGEgc2xpY2Ugb2YgdGhlIGltYWdlXHJcbiAgICBsZXQgc3ByaXRlID0gbmV3IFR3by5SZWN0YW5nbGUoMCwgeSwgaW1hZ2VXaWR0aCwgc3RyaXBIZWlnaHQpO1xyXG5cclxuICAgIC8vIFNldCB0aGUgZmlsbCBvZiB0aGUgc3RyaXAgdG8gYmUgYSB0ZXh0dXJlXHJcbiAgICBzcHJpdGUuZmlsbCA9IG5ldyBUd28uVGV4dHVyZShpbWFnZSk7XHJcbiAgICAvLyBNYWtlIHRoZSB0ZXh0dXJlIHJlcGVhdCBpbiB0aGUgeCBkaXJlY3Rpb25cclxuICAgIHNwcml0ZS5maWxsLnJlcGVhdCA9ICdyZXBlYXQteCc7XHJcbiAgICAvLyBPZmZzZXQgdGhlIGltYWdlJ3MgeSBwb3NpdGlvbiBzbyB0aGF0IHdoZW4gYWxsIHN0cmlwcyBsaW5lIHVwXHJcbiAgICAvLyB0aGV5IHJvdWdobHkgY3JlYXRlIHRoZSByZWZlcmVuY2UgaW1hZ2UgaW4gZnVsbFxyXG4gICAgc3ByaXRlLmZpbGwub2Zmc2V0LnkgPSBpbWFnZUhlaWdodCAqICgoMSAtIHBjdCkgLSAwLjUpO1xyXG4gICAgLy8gU2V0IHRoZSBzdHJva2UgdG8gYmUgdGhlIGZpbGwgZW5zdXJpbmcgdGhhdCB0aGVyZSBpc24ndCBhbnlcclxuICAgIC8vIGxlZnRvdmVyIHdoaXRlIHNwYWNlIGJldHdlZW4gdGhlIHN0cmlwc1xyXG4gICAgc3ByaXRlLnN0cm9rZSA9IHNwcml0ZS5maWxsO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgc3ByaXRlIHRvIHRoZSBzY2VuZVxyXG4gICAgdHdvLmFkZChzcHJpdGUpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHJlc2l6ZSAoeyBwaXhlbFJhdGlvLCB3aWR0aCwgaGVpZ2h0IH0pIHtcclxuICAgICAgLy8gVXBkYXRlIHdpZHRoIGFuZCBoZWlnaHQgb2YgVHdvLmpzIHNjZW5lIGJhc2VkIG9uXHJcbiAgICAgIC8vIGNhbnZhcy1za2V0Y2ggYXV0byBjaGFuZ2luZyB2aWV3cG9ydCBwYXJhbWV0ZXJzXHJcbiAgICAgIHR3by53aWR0aCA9IHdpZHRoO1xyXG4gICAgICB0d28uaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICB0d28ucmF0aW8gPSBwaXhlbFJhdGlvO1xyXG5cclxuICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBwYXNzZWQgZG93biB0byB0aGUgcmVuZGVyZXIncyB3aWR0aCBhbmQgaGVpZ2h0IGFzIHdlbGxcclxuICAgICAgdHdvLnJlbmRlcmVyLndpZHRoID0gdHdvLndpZHRoO1xyXG4gICAgICB0d28ucmVuZGVyZXIuaGVpZ2h0ID0gdHdvLmhlaWdodDtcclxuXHJcbiAgICAgIC8vIFBvc2l0aW9uIHNjZW5lIHRvIGJlIGF0IHRoZSBjZW50ZXIgb2YgdGhlIGNhbnZhc1xyXG4gICAgICB0d28uc2NlbmUudHJhbnNsYXRpb24uc2V0KHR3by53aWR0aCAvIDIsIHR3by5oZWlnaHQgLyAyKTtcclxuXHJcbiAgICAgIC8vIFNjYWxlIHRoZSBzY2VuZSB0byBmaXQgdGhlIGNhbnZhc1xyXG4gICAgICB0d28uc2NlbmUuc2NhbGUgPSB0d28ud2lkdGggLyBpbWFnZVdpZHRoO1xyXG4gICAgfSxcclxuICAgIHJlbmRlciAoeyB0aW1lIH0pIHtcclxuICAgICAgLy8gRGVmaW5lIHRoZSBzcGVlZCBhdCB3aGljaCB0aGUgb2Zmc2V0IHNtZWFyIG9jY3Vyc1xyXG4gICAgICBjb25zdCBzcGVlZCA9ICgxICsgTWF0aC5zaW4odGltZSAqIDUpKSAvIDI7XHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gdHdvLnNjZW5lLmNoaWxkcmVuW2ldO1xyXG4gICAgICAgIC8vIFRoZSBub3JtYWxpemVkIHZhbHVlIG9mIHRoZSBzdHJpcCdzIGluZGV4XHJcbiAgICAgICAgY29uc3QgcGN0ID0gaSAvIGFtb3VudDtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSByZXBlYXRlZCBpbWFnZSBvZmZzZXRcclxuICAgICAgICBzcHJpdGUuZmlsbC5vZmZzZXQueCArPSBzcGVlZCAqIE1hdGguc2luKHBjdCAqIE1hdGguUEkgKiAzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXBkYXRlIHR3by5qcyB2aWEgdGhlIGByZW5kZXJgIG1ldGhvZCAtICpub3QqIHRoZSBgdXBkYXRlYCBtZXRob2QuXHJcbiAgICAgIHR3by5yZW5kZXIoKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuY2FudmFzU2tldGNoKHNrZXRjaCwgc2V0dGluZ3MpO1xyXG4iLCIvLyBzb3VyY2VkIGZyb206XG4vLyBodHRwOi8vd3d3LmxlYW5iYWNrcGxheWVyLmNvbS90ZXN0L2g1bXQuaHRtbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jyb29mYS9ub2RlLW1pbWUvYmxvYi9tYXN0ZXIvdHlwZXMuanNvblxudmFyIG1pbWVUeXBlcyA9IHJlcXVpcmUoJy4vbWltZS10eXBlcy5qc29uJylcblxudmFyIG1pbWVMb29rdXAgPSB7fVxuT2JqZWN0LmtleXMobWltZVR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIGV4dGVuc2lvbnMgPSBtaW1lVHlwZXNba2V5XVxuICBleHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGV4dCkge1xuICAgIG1pbWVMb29rdXBbZXh0XSA9IGtleVxuICB9KVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb29rdXAgKGV4dCkge1xuICBpZiAoIWV4dCkgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzcGVjaWZ5IGV4dGVuc2lvbiBzdHJpbmcnKVxuICBpZiAoZXh0LmluZGV4T2YoJy4nKSA9PT0gMCkge1xuICAgIGV4dCA9IGV4dC5zdWJzdHJpbmcoMSlcbiAgfVxuICByZXR1cm4gbWltZUxvb2t1cFtleHQudG9Mb3dlckNhc2UoKV1cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJhdWRpby9taWRpXCI6IFtcIm1pZFwiLCBcIm1pZGlcIiwgXCJrYXJcIiwgXCJybWlcIl0sXG4gIFwiYXVkaW8vbXA0XCI6IFtcIm1wNGFcIiwgXCJtNGFcIl0sXG4gIFwiYXVkaW8vbXBlZ1wiOiBbXCJtcGdhXCIsIFwibXAyXCIsIFwibXAyYVwiLCBcIm1wM1wiLCBcIm0yYVwiLCBcIm0zYVwiXSxcbiAgXCJhdWRpby9vZ2dcIjogW1wib2dhXCIsIFwib2dnXCIsIFwic3B4XCJdLFxuICBcImF1ZGlvL3dlYm1cIjogW1wid2ViYVwiXSxcbiAgXCJhdWRpby94LW1hdHJvc2thXCI6IFtcIm1rYVwiXSxcbiAgXCJhdWRpby94LW1wZWd1cmxcIjogW1wibTN1XCJdLFxuICBcImF1ZGlvL3dhdlwiOiBbXCJ3YXZcIl0sXG4gIFwidmlkZW8vM2dwcFwiOiBbXCIzZ3BcIl0sXG4gIFwidmlkZW8vM2dwcDJcIjogW1wiM2cyXCJdLFxuICBcInZpZGVvL21wNFwiOiBbXCJtcDRcIiwgXCJtcDR2XCIsIFwibXBnNFwiXSxcbiAgXCJ2aWRlby9tcGVnXCI6IFtcIm1wZWdcIiwgXCJtcGdcIiwgXCJtcGVcIiwgXCJtMXZcIiwgXCJtMnZcIl0sXG4gIFwidmlkZW8vb2dnXCI6IFtcIm9ndlwiXSxcbiAgXCJ2aWRlby9xdWlja3RpbWVcIjogW1wicXRcIiwgXCJtb3ZcIl0sXG4gIFwidmlkZW8vd2VibVwiOiBbXCJ3ZWJtXCJdLFxuICBcInZpZGVvL3gtZjR2XCI6IFtcImY0dlwiXSxcbiAgXCJ2aWRlby94LWZsaVwiOiBbXCJmbGlcIl0sXG4gIFwidmlkZW8veC1mbHZcIjogW1wiZmx2XCJdLFxuICBcInZpZGVvL3gtbTR2XCI6IFtcIm00dlwiXSxcbiAgXCJ2aWRlby94LW1hdHJvc2thXCI6IFtcIm1rdlwiLCBcIm1rM2RcIiwgXCJta3NcIl1cbn0iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPVxuICBnbG9iYWwucGVyZm9ybWFuY2UgJiZcbiAgZ2xvYmFsLnBlcmZvcm1hbmNlLm5vdyA/IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KClcbiAgfSA6IERhdGUubm93IHx8IGZ1bmN0aW9uIG5vdygpIHtcbiAgICByZXR1cm4gK25ldyBEYXRlXG4gIH1cbiIsIm1vZHVsZS5leHBvcnRzID0gaXNQcm9taXNlO1xuXG5mdW5jdGlvbiBpc1Byb21pc2Uob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIG9iai50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpc05vZGVcblxuZnVuY3Rpb24gaXNOb2RlICh2YWwpIHtcbiAgcmV0dXJuICghdmFsIHx8IHR5cGVvZiB2YWwgIT09ICdvYmplY3QnKVxuICAgID8gZmFsc2VcbiAgICA6ICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygd2luZG93Lk5vZGUgPT09ICdvYmplY3QnKVxuICAgICAgPyAodmFsIGluc3RhbmNlb2Ygd2luZG93Lk5vZGUpXG4gICAgICA6ICh0eXBlb2YgdmFsLm5vZGVUeXBlID09PSAnbnVtYmVyJykgJiZcbiAgICAgICAgKHR5cGVvZiB2YWwubm9kZU5hbWUgPT09ICdzdHJpbmcnKVxufVxuIiwiLy8gVE9ETzogV2UgY2FuIHJlbW92ZSBhIGh1Z2UgY2h1bmsgb2YgYnVuZGxlIHNpemUgYnkgdXNpbmcgYSBzbWFsbGVyXG4vLyB1dGlsaXR5IG1vZHVsZSBmb3IgY29udmVydGluZyB1bml0cy5cbmltcG9ydCBpc0RPTSBmcm9tICdpcy1kb20nO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2xpZW50QVBJICgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvd1snY2FudmFzLXNrZXRjaC1jbGknXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZWQgKCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnJvd3NlciAoKSB7XG4gIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNXZWJHTENvbnRleHQgKGN0eCkge1xuICByZXR1cm4gdHlwZW9mIGN0eC5jbGVhciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3R4LmNsZWFyQ29sb3IgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0eC5idWZmZXJEYXRhID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDYW52YXMgKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzRE9NKGVsZW1lbnQpICYmIC9jYW52YXMvaS50ZXN0KGVsZW1lbnQubm9kZU5hbWUpICYmIHR5cGVvZiBlbGVtZW50LmdldENvbnRleHQgPT09ICdmdW5jdGlvbic7XG59XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwidmFyIHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPSAoZnVuY3Rpb24oKXtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHMpXG59KSgpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID8gc3VwcG9ydGVkIDogdW5zdXBwb3J0ZWQ7XG5cbmV4cG9ydHMuc3VwcG9ydGVkID0gc3VwcG9ydGVkO1xuZnVuY3Rpb24gc3VwcG9ydGVkKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59O1xuXG5leHBvcnRzLnVuc3VwcG9ydGVkID0gdW5zdXBwb3J0ZWQ7XG5mdW5jdGlvbiB1bnN1cHBvcnRlZChvYmplY3Qpe1xuICByZXR1cm4gb2JqZWN0ICYmXG4gICAgdHlwZW9mIG9iamVjdCA9PSAnb2JqZWN0JyAmJlxuICAgIHR5cGVvZiBvYmplY3QubGVuZ3RoID09ICdudW1iZXInICYmXG4gICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpICYmXG4gICAgIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsICdjYWxsZWUnKSB8fFxuICAgIGZhbHNlO1xufTtcbiIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG4iLCIvKlxuICogRGF0ZSBGb3JtYXQgMS4yLjNcbiAqIChjKSAyMDA3LTIwMDkgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XG4gKiBNSVQgbGljZW5zZVxuICpcbiAqIEluY2x1ZGVzIGVuaGFuY2VtZW50cyBieSBTY290dCBUcmVuZGEgPHNjb3R0LnRyZW5kYS5uZXQ+XG4gKiBhbmQgS3JpcyBLb3dhbCA8Y2l4YXIuY29tL35rcmlzLmtvd2FsLz5cbiAqXG4gKiBBY2NlcHRzIGEgZGF0ZSwgYSBtYXNrLCBvciBhIGRhdGUgYW5kIGEgbWFzay5cbiAqIFJldHVybnMgYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gZGF0ZS5cbiAqIFRoZSBkYXRlIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRhdGUvdGltZS5cbiAqIFRoZSBtYXNrIGRlZmF1bHRzIHRvIGRhdGVGb3JtYXQubWFza3MuZGVmYXVsdC5cbiAqL1xuXG4oZnVuY3Rpb24oZ2xvYmFsKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgZGF0ZUZvcm1hdCA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b2tlbiA9IC9kezEsNH18bXsxLDR9fHl5KD86eXkpP3woW0hoTXNUdF0pXFwxP3xbTGxvU1pXTl18XCJbXlwiXSpcInwnW14nXSonL2c7XG4gICAgICB2YXIgdGltZXpvbmUgPSAvXFxiKD86W1BNQ0VBXVtTRFBdVHwoPzpQYWNpZmljfE1vdW50YWlufENlbnRyYWx8RWFzdGVybnxBdGxhbnRpYykgKD86U3RhbmRhcmR8RGF5bGlnaHR8UHJldmFpbGluZykgVGltZXwoPzpHTVR8VVRDKSg/OlstK11cXGR7NH0pPylcXGIvZztcbiAgICAgIHZhciB0aW1lem9uZUNsaXAgPSAvW14tK1xcZEEtWl0vZztcbiAgXG4gICAgICAvLyBSZWdleGVzIGFuZCBzdXBwb3J0aW5nIGZ1bmN0aW9ucyBhcmUgY2FjaGVkIHRocm91Z2ggY2xvc3VyZVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBtYXNrLCB1dGMsIGdtdCkge1xuICBcbiAgICAgICAgLy8gWW91IGNhbid0IHByb3ZpZGUgdXRjIGlmIHlvdSBza2lwIG90aGVyIGFyZ3MgKHVzZSB0aGUgJ1VUQzonIG1hc2sgcHJlZml4KVxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBraW5kT2YoZGF0ZSkgPT09ICdzdHJpbmcnICYmICEvXFxkLy50ZXN0KGRhdGUpKSB7XG4gICAgICAgICAgbWFzayA9IGRhdGU7XG4gICAgICAgICAgZGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICBcbiAgICAgICAgZGF0ZSA9IGRhdGUgfHwgbmV3IERhdGU7XG4gIFxuICAgICAgICBpZighKGRhdGUgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgaWYgKGlzTmFOKGRhdGUpKSB7XG4gICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIGRhdGUnKTtcbiAgICAgICAgfVxuICBcbiAgICAgICAgbWFzayA9IFN0cmluZyhkYXRlRm9ybWF0Lm1hc2tzW21hc2tdIHx8IG1hc2sgfHwgZGF0ZUZvcm1hdC5tYXNrc1snZGVmYXVsdCddKTtcbiAgXG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgdGhlIHV0Yy9nbXQgYXJndW1lbnQgdmlhIHRoZSBtYXNrXG4gICAgICAgIHZhciBtYXNrU2xpY2UgPSBtYXNrLnNsaWNlKDAsIDQpO1xuICAgICAgICBpZiAobWFza1NsaWNlID09PSAnVVRDOicgfHwgbWFza1NsaWNlID09PSAnR01UOicpIHtcbiAgICAgICAgICBtYXNrID0gbWFzay5zbGljZSg0KTtcbiAgICAgICAgICB1dGMgPSB0cnVlO1xuICAgICAgICAgIGlmIChtYXNrU2xpY2UgPT09ICdHTVQ6Jykge1xuICAgICAgICAgICAgZ210ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgXG4gICAgICAgIHZhciBfID0gdXRjID8gJ2dldFVUQycgOiAnZ2V0JztcbiAgICAgICAgdmFyIGQgPSBkYXRlW18gKyAnRGF0ZSddKCk7XG4gICAgICAgIHZhciBEID0gZGF0ZVtfICsgJ0RheSddKCk7XG4gICAgICAgIHZhciBtID0gZGF0ZVtfICsgJ01vbnRoJ10oKTtcbiAgICAgICAgdmFyIHkgPSBkYXRlW18gKyAnRnVsbFllYXInXSgpO1xuICAgICAgICB2YXIgSCA9IGRhdGVbXyArICdIb3VycyddKCk7XG4gICAgICAgIHZhciBNID0gZGF0ZVtfICsgJ01pbnV0ZXMnXSgpO1xuICAgICAgICB2YXIgcyA9IGRhdGVbXyArICdTZWNvbmRzJ10oKTtcbiAgICAgICAgdmFyIEwgPSBkYXRlW18gKyAnTWlsbGlzZWNvbmRzJ10oKTtcbiAgICAgICAgdmFyIG8gPSB1dGMgPyAwIDogZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgICAgICB2YXIgVyA9IGdldFdlZWsoZGF0ZSk7XG4gICAgICAgIHZhciBOID0gZ2V0RGF5T2ZXZWVrKGRhdGUpO1xuICAgICAgICB2YXIgZmxhZ3MgPSB7XG4gICAgICAgICAgZDogICAgZCxcbiAgICAgICAgICBkZDogICBwYWQoZCksXG4gICAgICAgICAgZGRkOiAgZGF0ZUZvcm1hdC5pMThuLmRheU5hbWVzW0RdLFxuICAgICAgICAgIGRkZGQ6IGRhdGVGb3JtYXQuaTE4bi5kYXlOYW1lc1tEICsgN10sXG4gICAgICAgICAgbTogICAgbSArIDEsXG4gICAgICAgICAgbW06ICAgcGFkKG0gKyAxKSxcbiAgICAgICAgICBtbW06ICBkYXRlRm9ybWF0LmkxOG4ubW9udGhOYW1lc1ttXSxcbiAgICAgICAgICBtbW1tOiBkYXRlRm9ybWF0LmkxOG4ubW9udGhOYW1lc1ttICsgMTJdLFxuICAgICAgICAgIHl5OiAgIFN0cmluZyh5KS5zbGljZSgyKSxcbiAgICAgICAgICB5eXl5OiB5LFxuICAgICAgICAgIGg6ICAgIEggJSAxMiB8fCAxMixcbiAgICAgICAgICBoaDogICBwYWQoSCAlIDEyIHx8IDEyKSxcbiAgICAgICAgICBIOiAgICBILFxuICAgICAgICAgIEhIOiAgIHBhZChIKSxcbiAgICAgICAgICBNOiAgICBNLFxuICAgICAgICAgIE1NOiAgIHBhZChNKSxcbiAgICAgICAgICBzOiAgICBzLFxuICAgICAgICAgIHNzOiAgIHBhZChzKSxcbiAgICAgICAgICBsOiAgICBwYWQoTCwgMyksXG4gICAgICAgICAgTDogICAgcGFkKE1hdGgucm91bmQoTCAvIDEwKSksXG4gICAgICAgICAgdDogICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1swXSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbMV0sXG4gICAgICAgICAgdHQ6ICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1syXSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbM10sXG4gICAgICAgICAgVDogICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1s0XSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbNV0sXG4gICAgICAgICAgVFQ6ICAgSCA8IDEyID8gZGF0ZUZvcm1hdC5pMThuLnRpbWVOYW1lc1s2XSA6IGRhdGVGb3JtYXQuaTE4bi50aW1lTmFtZXNbN10sXG4gICAgICAgICAgWjogICAgZ210ID8gJ0dNVCcgOiB1dGMgPyAnVVRDJyA6IChTdHJpbmcoZGF0ZSkubWF0Y2godGltZXpvbmUpIHx8IFsnJ10pLnBvcCgpLnJlcGxhY2UodGltZXpvbmVDbGlwLCAnJyksXG4gICAgICAgICAgbzogICAgKG8gPiAwID8gJy0nIDogJysnKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCksXG4gICAgICAgICAgUzogICAgWyd0aCcsICdzdCcsICduZCcsICdyZCddW2QgJSAxMCA+IDMgPyAwIDogKGQgJSAxMDAgLSBkICUgMTAgIT0gMTApICogZCAlIDEwXSxcbiAgICAgICAgICBXOiAgICBXLFxuICAgICAgICAgIE46ICAgIE5cbiAgICAgICAgfTtcbiAgXG4gICAgICAgIHJldHVybiBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgIGlmIChtYXRjaCBpbiBmbGFncykge1xuICAgICAgICAgICAgcmV0dXJuIGZsYWdzW21hdGNoXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG1hdGNoLnNsaWNlKDEsIG1hdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSkoKTtcblxuICBkYXRlRm9ybWF0Lm1hc2tzID0ge1xuICAgICdkZWZhdWx0JzogICAgICAgICAgICAgICAnZGRkIG1tbSBkZCB5eXl5IEhIOk1NOnNzJyxcbiAgICAnc2hvcnREYXRlJzogICAgICAgICAgICAgJ20vZC95eScsXG4gICAgJ21lZGl1bURhdGUnOiAgICAgICAgICAgICdtbW0gZCwgeXl5eScsXG4gICAgJ2xvbmdEYXRlJzogICAgICAgICAgICAgICdtbW1tIGQsIHl5eXknLFxuICAgICdmdWxsRGF0ZSc6ICAgICAgICAgICAgICAnZGRkZCwgbW1tbSBkLCB5eXl5JyxcbiAgICAnc2hvcnRUaW1lJzogICAgICAgICAgICAgJ2g6TU0gVFQnLFxuICAgICdtZWRpdW1UaW1lJzogICAgICAgICAgICAnaDpNTTpzcyBUVCcsXG4gICAgJ2xvbmdUaW1lJzogICAgICAgICAgICAgICdoOk1NOnNzIFRUIFonLFxuICAgICdpc29EYXRlJzogICAgICAgICAgICAgICAneXl5eS1tbS1kZCcsXG4gICAgJ2lzb1RpbWUnOiAgICAgICAgICAgICAgICdISDpNTTpzcycsXG4gICAgJ2lzb0RhdGVUaW1lJzogICAgICAgICAgICd5eXl5LW1tLWRkXFwnVFxcJ0hIOk1NOnNzbycsXG4gICAgJ2lzb1V0Y0RhdGVUaW1lJzogICAgICAgICdVVEM6eXl5eS1tbS1kZFxcJ1RcXCdISDpNTTpzc1xcJ1pcXCcnLFxuICAgICdleHBpcmVzSGVhZGVyRm9ybWF0JzogICAnZGRkLCBkZCBtbW0geXl5eSBISDpNTTpzcyBaJ1xuICB9O1xuXG4gIC8vIEludGVybmF0aW9uYWxpemF0aW9uIHN0cmluZ3NcbiAgZGF0ZUZvcm1hdC5pMThuID0ge1xuICAgIGRheU5hbWVzOiBbXG4gICAgICAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0JyxcbiAgICAgICdTdW5kYXknLCAnTW9uZGF5JywgJ1R1ZXNkYXknLCAnV2VkbmVzZGF5JywgJ1RodXJzZGF5JywgJ0ZyaWRheScsICdTYXR1cmRheSdcbiAgICBdLFxuICAgIG1vbnRoTmFtZXM6IFtcbiAgICAgICdKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsICdPY3QnLCAnTm92JywgJ0RlYycsXG4gICAgICAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcbiAgICBdLFxuICAgIHRpbWVOYW1lczogW1xuICAgICAgJ2EnLCAncCcsICdhbScsICdwbScsICdBJywgJ1AnLCAnQU0nLCAnUE0nXG4gICAgXVxuICB9O1xuXG5mdW5jdGlvbiBwYWQodmFsLCBsZW4pIHtcbiAgdmFsID0gU3RyaW5nKHZhbCk7XG4gIGxlbiA9IGxlbiB8fCAyO1xuICB3aGlsZSAodmFsLmxlbmd0aCA8IGxlbikge1xuICAgIHZhbCA9ICcwJyArIHZhbDtcbiAgfVxuICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIEdldCB0aGUgSVNPIDg2MDEgd2VlayBudW1iZXJcbiAqIEJhc2VkIG9uIGNvbW1lbnRzIGZyb21cbiAqIGh0dHA6Ly90ZWNoYmxvZy5wcm9jdXJpb3Mubmwvay9uNjE4L25ld3Mvdmlldy8zMzc5Ni8xNDg2My9DYWxjdWxhdGUtSVNPLTg2MDEtd2Vlay1hbmQteWVhci1pbi1qYXZhc2NyaXB0Lmh0bWxcbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGBkYXRlYFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRXZWVrKGRhdGUpIHtcbiAgLy8gUmVtb3ZlIHRpbWUgY29tcG9uZW50cyBvZiBkYXRlXG4gIHZhciB0YXJnZXRUaHVyc2RheSA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpLCBkYXRlLmdldERhdGUoKSk7XG5cbiAgLy8gQ2hhbmdlIGRhdGUgdG8gVGh1cnNkYXkgc2FtZSB3ZWVrXG4gIHRhcmdldFRodXJzZGF5LnNldERhdGUodGFyZ2V0VGh1cnNkYXkuZ2V0RGF0ZSgpIC0gKCh0YXJnZXRUaHVyc2RheS5nZXREYXkoKSArIDYpICUgNykgKyAzKTtcblxuICAvLyBUYWtlIEphbnVhcnkgNHRoIGFzIGl0IGlzIGFsd2F5cyBpbiB3ZWVrIDEgKHNlZSBJU08gODYwMSlcbiAgdmFyIGZpcnN0VGh1cnNkYXkgPSBuZXcgRGF0ZSh0YXJnZXRUaHVyc2RheS5nZXRGdWxsWWVhcigpLCAwLCA0KTtcblxuICAvLyBDaGFuZ2UgZGF0ZSB0byBUaHVyc2RheSBzYW1lIHdlZWtcbiAgZmlyc3RUaHVyc2RheS5zZXREYXRlKGZpcnN0VGh1cnNkYXkuZ2V0RGF0ZSgpIC0gKChmaXJzdFRodXJzZGF5LmdldERheSgpICsgNikgJSA3KSArIDMpO1xuXG4gIC8vIENoZWNrIGlmIGRheWxpZ2h0LXNhdmluZy10aW1lLXN3aXRjaCBvY2N1cnJlZCBhbmQgY29ycmVjdCBmb3IgaXRcbiAgdmFyIGRzID0gdGFyZ2V0VGh1cnNkYXkuZ2V0VGltZXpvbmVPZmZzZXQoKSAtIGZpcnN0VGh1cnNkYXkuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgdGFyZ2V0VGh1cnNkYXkuc2V0SG91cnModGFyZ2V0VGh1cnNkYXkuZ2V0SG91cnMoKSAtIGRzKTtcblxuICAvLyBOdW1iZXIgb2Ygd2Vla3MgYmV0d2VlbiB0YXJnZXQgVGh1cnNkYXkgYW5kIGZpcnN0IFRodXJzZGF5XG4gIHZhciB3ZWVrRGlmZiA9ICh0YXJnZXRUaHVyc2RheSAtIGZpcnN0VGh1cnNkYXkpIC8gKDg2NDAwMDAwKjcpO1xuICByZXR1cm4gMSArIE1hdGguZmxvb3Iod2Vla0RpZmYpO1xufVxuXG4vKipcbiAqIEdldCBJU08tODYwMSBudW1lcmljIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXkgb2YgdGhlIHdlZWtcbiAqIDEgKGZvciBNb25kYXkpIHRocm91Z2ggNyAoZm9yIFN1bmRheSlcbiAqIFxuICogQHBhcmFtICB7T2JqZWN0fSBgZGF0ZWBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0RGF5T2ZXZWVrKGRhdGUpIHtcbiAgdmFyIGRvdyA9IGRhdGUuZ2V0RGF5KCk7XG4gIGlmKGRvdyA9PT0gMCkge1xuICAgIGRvdyA9IDc7XG4gIH1cbiAgcmV0dXJuIGRvdztcbn1cblxuLyoqXG4gKiBraW5kLW9mIHNob3J0Y3V0XG4gKiBAcGFyYW0gIHsqfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24ga2luZE9mKHZhbCkge1xuICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcmV0dXJuICdudWxsJztcbiAgfVxuXG4gIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB0eXBlb2YgdmFsO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiAnYXJyYXknO1xuICB9XG5cbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwodmFsKVxuICAgIC5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbn07XG5cblxuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRhdGVGb3JtYXQ7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBkYXRlRm9ybWF0O1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5kYXRlRm9ybWF0ID0gZGF0ZUZvcm1hdDtcbiAgfVxufSkodGhpcyk7XG4iLCIvKiFcbiAqIHJlcGVhdC1zdHJpbmcgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3JlcGVhdC1zdHJpbmc+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZXN1bHRzIGNhY2hlXG4gKi9cblxudmFyIHJlcyA9ICcnO1xudmFyIGNhY2hlO1xuXG4vKipcbiAqIEV4cG9zZSBgcmVwZWF0YFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuXG4vKipcbiAqIFJlcGVhdCB0aGUgZ2l2ZW4gYHN0cmluZ2AgdGhlIHNwZWNpZmllZCBgbnVtYmVyYFxuICogb2YgdGltZXMuXG4gKlxuICogKipFeGFtcGxlOioqXG4gKlxuICogYGBganNcbiAqIHZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG4gKiByZXBlYXQoJ0EnLCA1KTtcbiAqIC8vPT4gQUFBQUFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBgc3RyaW5nYCBUaGUgc3RyaW5nIHRvIHJlcGVhdFxuICogQHBhcmFtIHtOdW1iZXJ9IGBudW1iZXJgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IHRoZSBzdHJpbmdcbiAqIEByZXR1cm4ge1N0cmluZ30gUmVwZWF0ZWQgc3RyaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHJlcGVhdChzdHIsIG51bSkge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHBlY3RlZCBhIHN0cmluZycpO1xuICB9XG5cbiAgLy8gY292ZXIgY29tbW9uLCBxdWljayB1c2UgY2FzZXNcbiAgaWYgKG51bSA9PT0gMSkgcmV0dXJuIHN0cjtcbiAgaWYgKG51bSA9PT0gMikgcmV0dXJuIHN0ciArIHN0cjtcblxuICB2YXIgbWF4ID0gc3RyLmxlbmd0aCAqIG51bTtcbiAgaWYgKGNhY2hlICE9PSBzdHIgfHwgdHlwZW9mIGNhY2hlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNhY2hlID0gc3RyO1xuICAgIHJlcyA9ICcnO1xuICB9IGVsc2UgaWYgKHJlcy5sZW5ndGggPj0gbWF4KSB7XG4gICAgcmV0dXJuIHJlcy5zdWJzdHIoMCwgbWF4KTtcbiAgfVxuXG4gIHdoaWxlIChtYXggPiByZXMubGVuZ3RoICYmIG51bSA+IDEpIHtcbiAgICBpZiAobnVtICYgMSkge1xuICAgICAgcmVzICs9IHN0cjtcbiAgICB9XG5cbiAgICBudW0gPj49IDE7XG4gICAgc3RyICs9IHN0cjtcbiAgfVxuXG4gIHJlcyArPSBzdHI7XG4gIHJlcyA9IHJlcy5zdWJzdHIoMCwgbWF4KTtcbiAgcmV0dXJuIHJlcztcbn1cbiIsIi8qIVxuICogcGFkLWxlZnQgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L3BhZC1sZWZ0PlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFkTGVmdChzdHIsIG51bSwgY2gpIHtcbiAgc3RyID0gc3RyLnRvU3RyaW5nKCk7XG5cbiAgaWYgKHR5cGVvZiBudW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmIChjaCA9PT0gMCkge1xuICAgIGNoID0gJzAnO1xuICB9IGVsc2UgaWYgKGNoKSB7XG4gICAgY2ggPSBjaC50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIGNoID0gJyAnO1xuICB9XG5cbiAgcmV0dXJuIHJlcGVhdChjaCwgbnVtIC0gc3RyLmxlbmd0aCkgKyBzdHI7XG59O1xuIiwiaW1wb3J0IGRhdGVmb3JtYXQgZnJvbSAnZGF0ZWZvcm1hdCc7XG5pbXBvcnQgYXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuaW1wb3J0IHBhZExlZnQgZnJvbSAncGFkLWxlZnQnO1xuaW1wb3J0IHsgZ2V0Q2xpZW50QVBJIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xubGV0IGxpbms7XG5sZXQgZGVmYXVsdEV4dHMgPSB7IGV4dGVuc2lvbjogJycsIHByZWZpeDogJycsIHN1ZmZpeDogJycgfTtcblxuLy8gQWx0ZXJuYXRpdmUgc29sdXRpb24gZm9yIHNhdmluZyBmaWxlcyxcbi8vIGEgYml0IHNsb3dlciBhbmQgZG9lcyBub3Qgd29yayBpbiBTYWZhcmlcbi8vIGZ1bmN0aW9uIGZldGNoQmxvYkZyb21EYXRhVVJMIChkYXRhVVJMKSB7XG4vLyAgIHJldHVybiB3aW5kb3cuZmV0Y2goZGF0YVVSTCkudGhlbihyZXMgPT4gcmVzLmJsb2IoKSk7XG4vLyB9XG5cbmNvbnN0IHN1cHBvcnRlZEVuY29kaW5ncyA9IFtcbiAgJ2ltYWdlL3BuZycsXG4gICdpbWFnZS9qcGVnJyxcbiAgJ2ltYWdlL3dlYnAnXG5dO1xuXG5mdW5jdGlvbiBzdHJlYW0gKGlzU3RhcnQsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIG9wdHMgPSBhc3NpZ24oe30sIGRlZmF1bHRFeHRzLCBvcHRzKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IHJlc29sdmVGaWxlbmFtZShPYmplY3QuYXNzaWduKHt9LCBvcHRzLCB7XG4gICAgICBleHRlbnNpb246ICcnLFxuICAgICAgZnJhbWU6IHVuZGVmaW5lZFxuICAgIH0pKTtcbiAgICBjb25zdCBmdW5jID0gaXNTdGFydCA/ICdzdHJlYW1TdGFydCcgOiAnc3RyZWFtRW5kJztcbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgICBpZiAoY2xpZW50ICYmIGNsaWVudC5vdXRwdXQgJiYgdHlwZW9mIGNsaWVudFtmdW5jXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNsaWVudFtmdW5jXShhc3NpZ24oe30sIG9wdHMsIHsgZmlsZW5hbWUgfSkpXG4gICAgICAgIC50aGVuKGV2ID0+IHJlc29sdmUoZXYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc29sdmUoeyBmaWxlbmFtZSwgY2xpZW50OiBmYWxzZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtU3RhcnQgKG9wdHMgPSB7fSkge1xuICByZXR1cm4gc3RyZWFtKHRydWUsIG9wdHMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtRW5kIChvcHRzID0ge30pIHtcbiAgcmV0dXJuIHN0cmVhbShmYWxzZSwgb3B0cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHBvcnRDYW52YXMgKGNhbnZhcywgb3B0ID0ge30pIHtcbiAgY29uc3QgZW5jb2RpbmcgPSBvcHQuZW5jb2RpbmcgfHwgJ2ltYWdlL3BuZyc7XG4gIGlmICghc3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKGVuY29kaW5nKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGNhbnZhcyBlbmNvZGluZyAke2VuY29kaW5nfWApO1xuICBsZXQgZXh0ZW5zaW9uID0gKGVuY29kaW5nLnNwbGl0KCcvJylbMV0gfHwgJycpLnJlcGxhY2UoL2pwZWcvaSwgJ2pwZycpO1xuICBpZiAoZXh0ZW5zaW9uKSBleHRlbnNpb24gPSBgLiR7ZXh0ZW5zaW9ufWAudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIHtcbiAgICBleHRlbnNpb24sXG4gICAgdHlwZTogZW5jb2RpbmcsXG4gICAgZGF0YVVSTDogY2FudmFzLnRvRGF0YVVSTChlbmNvZGluZywgb3B0LmVuY29kaW5nUXVhbGl0eSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmxvYkZyb21EYXRhVVJMIChkYXRhVVJMKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IHNwbGl0SW5kZXggPSBkYXRhVVJMLmluZGV4T2YoJywnKTtcbiAgICBpZiAoc3BsaXRJbmRleCA9PT0gLTEpIHtcbiAgICAgIHJlc29sdmUobmV3IHdpbmRvdy5CbG9iKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYXNlNjQgPSBkYXRhVVJMLnNsaWNlKHNwbGl0SW5kZXggKyAxKTtcbiAgICBjb25zdCBieXRlU3RyaW5nID0gd2luZG93LmF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCB0eXBlID0gZGF0YVVSTC5zbGljZSgwLCBzcGxpdEluZGV4KTtcbiAgICBjb25zdCBtaW1lTWF0Y2ggPSAvZGF0YTooW147XSspLy5leGVjKHR5cGUpO1xuICAgIGNvbnN0IG1pbWUgPSAobWltZU1hdGNoID8gbWltZU1hdGNoWzFdIDogJycpIHx8IHVuZGVmaW5lZDtcbiAgICBjb25zdCBhYiA9IG5ldyBBcnJheUJ1ZmZlcihieXRlU3RyaW5nLmxlbmd0aCk7XG4gICAgY29uc3QgaWEgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpYVtpXSA9IGJ5dGVTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmVzb2x2ZShuZXcgd2luZG93LkJsb2IoWyBhYiBdLCB7IHR5cGU6IG1pbWUgfSkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhdmVEYXRhVVJMIChkYXRhVVJMLCBvcHRzID0ge30pIHtcbiAgcmV0dXJuIGNyZWF0ZUJsb2JGcm9tRGF0YVVSTChkYXRhVVJMKVxuICAgIC50aGVuKGJsb2IgPT4gc2F2ZUJsb2IoYmxvYiwgb3B0cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUJsb2IgKGJsb2IsIG9wdHMgPSB7fSkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgb3B0cyA9IGFzc2lnbih7fSwgZGVmYXVsdEV4dHMsIG9wdHMpO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gb3B0cy5maWxlbmFtZTtcblxuICAgIGNvbnN0IGNsaWVudCA9IGdldENsaWVudEFQSSgpO1xuICAgIGlmIChjbGllbnQgJiYgdHlwZW9mIGNsaWVudC5zYXZlQmxvYiA9PT0gJ2Z1bmN0aW9uJyAmJiBjbGllbnQub3V0cHV0KSB7XG4gICAgICAvLyBuYXRpdmUgc2F2aW5nIHVzaW5nIGEgQ0xJIHRvb2xcbiAgICAgIHJldHVybiBjbGllbnQuc2F2ZUJsb2IoYmxvYiwgYXNzaWduKHt9LCBvcHRzLCB7IGZpbGVuYW1lIH0pKVxuICAgICAgICAudGhlbihldiA9PiByZXNvbHZlKGV2KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvcmNlIGRvd25sb2FkXG4gICAgICBpZiAoIWxpbmspIHtcbiAgICAgICAgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgbGluay5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIGxpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICB9XG4gICAgICBsaW5rLmRvd25sb2FkID0gZmlsZW5hbWU7XG4gICAgICBsaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgIGxpbmsub25jbGljayA9IG5vb3A7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHdpbmRvdy5VUkwucmV2b2tlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgIGlmIChsaW5rLnBhcmVudEVsZW1lbnQpIGxpbmsucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgICBsaW5rLnJlbW92ZUF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICAgIHJlc29sdmUoeyBmaWxlbmFtZSwgY2xpZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgbGluay5jbGljaygpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXZlRmlsZSAoZGF0YSwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHBhcnRzID0gQXJyYXkuaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbIGRhdGEgXTtcbiAgY29uc3QgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihwYXJ0cywgeyB0eXBlOiBvcHRzLnR5cGUgfHwgJycgfSk7XG4gIHJldHVybiBzYXZlQmxvYihibG9iLCBvcHRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWVTdGFtcCAoKSB7XG4gIGNvbnN0IGRhdGVGb3JtYXRTdHIgPSBgeXl5eS5tbS5kZC1ISC5NTS5zc2A7XG4gIHJldHVybiBkYXRlZm9ybWF0KG5ldyBEYXRlKCksIGRhdGVGb3JtYXRTdHIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGVmYXVsdEZpbGUgKHByZWZpeCA9ICcnLCBzdWZmaXggPSAnJywgZXh0KSB7XG4gIC8vIGNvbnN0IGRhdGVGb3JtYXRTdHIgPSBgeXl5eS5tbS5kZC1ISC5NTS5zc2A7XG4gIGNvbnN0IGRhdGVGb3JtYXRTdHIgPSBgeXl5eS1tbS1kZCAnYXQnIGguTU0uc3MgVFRgO1xuICByZXR1cm4gYCR7cHJlZml4fSR7ZGF0ZWZvcm1hdChuZXcgRGF0ZSgpLCBkYXRlRm9ybWF0U3RyKX0ke3N1ZmZpeH0ke2V4dH1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZUZpbGVuYW1lIChvcHQgPSB7fSkge1xuICBvcHQgPSBhc3NpZ24oe30sIG9wdCk7XG5cbiAgLy8gQ3VzdG9tIGZpbGVuYW1lIGZ1bmN0aW9uXG4gIGlmICh0eXBlb2Ygb3B0LmZpbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0LmZpbGUob3B0KTtcbiAgfSBlbHNlIGlmIChvcHQuZmlsZSkge1xuICAgIHJldHVybiBvcHQuZmlsZTtcbiAgfVxuXG4gIGxldCBmcmFtZSA9IG51bGw7XG4gIGxldCBleHRlbnNpb24gPSAnJztcbiAgaWYgKHR5cGVvZiBvcHQuZXh0ZW5zaW9uID09PSAnc3RyaW5nJykgZXh0ZW5zaW9uID0gb3B0LmV4dGVuc2lvbjtcblxuICBpZiAodHlwZW9mIG9wdC5mcmFtZSA9PT0gJ251bWJlcicpIHtcbiAgICBsZXQgdG90YWxGcmFtZXM7XG4gICAgaWYgKHR5cGVvZiBvcHQudG90YWxGcmFtZXMgPT09ICdudW1iZXInKSB7XG4gICAgICB0b3RhbEZyYW1lcyA9IG9wdC50b3RhbEZyYW1lcztcbiAgICB9IGVsc2Uge1xuICAgICAgdG90YWxGcmFtZXMgPSBNYXRoLm1heCgxMDAwMCwgb3B0LmZyYW1lKTtcbiAgICB9XG4gICAgZnJhbWUgPSBwYWRMZWZ0KFN0cmluZyhvcHQuZnJhbWUpLCBTdHJpbmcodG90YWxGcmFtZXMpLmxlbmd0aCwgJzAnKTtcbiAgfVxuXG4gIGNvbnN0IGxheWVyU3RyID0gaXNGaW5pdGUob3B0LnRvdGFsTGF5ZXJzKSAmJiBpc0Zpbml0ZShvcHQubGF5ZXIpICYmIG9wdC50b3RhbExheWVycyA+IDEgPyBgJHtvcHQubGF5ZXJ9YCA6ICcnO1xuICBpZiAoZnJhbWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBbIGxheWVyU3RyLCBmcmFtZSBdLmZpbHRlcihCb29sZWFuKS5qb2luKCctJykgKyBleHRlbnNpb247XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZGVmYXVsdEZpbGVOYW1lID0gb3B0LnRpbWVTdGFtcDtcbiAgICByZXR1cm4gWyBvcHQucHJlZml4LCBvcHQubmFtZSB8fCBkZWZhdWx0RmlsZU5hbWUsIGxheWVyU3RyLCBvcHQuaGFzaCwgb3B0LnN1ZmZpeCBdLmZpbHRlcihCb29sZWFuKS5qb2luKCctJykgKyBleHRlbnNpb247XG4gIH1cbn1cbiIsIi8vIEhhbmRsZSBzb21lIGNvbW1vbiB0eXBvc1xuY29uc3QgY29tbW9uVHlwb3MgPSB7XG4gIGRpbWVuc2lvbjogJ2RpbWVuc2lvbnMnLFxuICBhbmltYXRlZDogJ2FuaW1hdGUnLFxuICBhbmltYXRpbmc6ICdhbmltYXRlJyxcbiAgdW5pdDogJ3VuaXRzJyxcbiAgUDU6ICdwNScsXG4gIHBpeGVsbGF0ZWQ6ICdwaXhlbGF0ZWQnLFxuICBsb29waW5nOiAnbG9vcCcsXG4gIHBpeGVsUGVySW5jaDogJ3BpeGVscydcbn07XG5cbi8vIEhhbmRsZSBhbGwgb3RoZXIgdHlwb3NcbmNvbnN0IGFsbEtleXMgPSBbXG4gICdkaW1lbnNpb25zJywgJ3VuaXRzJywgJ3BpeGVsc1BlckluY2gnLCAnb3JpZW50YXRpb24nLFxuICAnc2NhbGVUb0ZpdCcsICdzY2FsZVRvVmlldycsICdibGVlZCcsICdwaXhlbFJhdGlvJyxcbiAgJ2V4cG9ydFBpeGVsUmF0aW8nLCAnbWF4UGl4ZWxSYXRpbycsICdzY2FsZUNvbnRleHQnLFxuICAncmVzaXplQ2FudmFzJywgJ3N0eWxlQ2FudmFzJywgJ2NhbnZhcycsICdjb250ZXh0JywgJ2F0dHJpYnV0ZXMnLFxuICAncGFyZW50JywgJ2ZpbGUnLCAnbmFtZScsICdwcmVmaXgnLCAnc3VmZml4JywgJ2FuaW1hdGUnLCAncGxheWluZycsXG4gICdsb29wJywgJ2R1cmF0aW9uJywgJ3RvdGFsRnJhbWVzJywgJ2ZwcycsICdwbGF5YmFja1JhdGUnLCAndGltZVNjYWxlJyxcbiAgJ2ZyYW1lJywgJ3RpbWUnLCAnZmx1c2gnLCAncGl4ZWxhdGVkJywgJ2hvdGtleXMnLCAncDUnLCAnaWQnLFxuICAnc2NhbGVUb0ZpdFBhZGRpbmcnLCAnZGF0YScsICdwYXJhbXMnLCAnZW5jb2RpbmcnLCAnZW5jb2RpbmdRdWFsaXR5J1xuXTtcblxuLy8gVGhpcyBpcyBmYWlybHkgb3BpbmlvbmF0ZWQgYW5kIGZvcmNlcyB1c2VycyB0byB1c2UgdGhlICdkYXRhJyBwYXJhbWV0ZXJcbi8vIGlmIHRoZXkgd2FudCB0byBwYXNzIGFsb25nIG5vbi1zZXR0aW5nIG9iamVjdHMuLi5cbmV4cG9ydCBjb25zdCBjaGVja1NldHRpbmdzID0gKHNldHRpbmdzKSA9PiB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzZXR0aW5ncyk7XG4gIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChrZXkgaW4gY29tbW9uVHlwb3MpIHtcbiAgICAgIGNvbnN0IGFjdHVhbCA9IGNvbW1vblR5cG9zW2tleV07XG4gICAgICBjb25zb2xlLndhcm4oYFtjYW52YXMtc2tldGNoXSBDb3VsZCBub3QgcmVjb2duaXplIHRoZSBzZXR0aW5nIFwiJHtrZXl9XCIsIGRpZCB5b3UgbWVhbiBcIiR7YWN0dWFsfVwiP2ApO1xuICAgIH0gZWxzZSBpZiAoIWFsbEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgY29uc29sZS53YXJuKGBbY2FudmFzLXNrZXRjaF0gQ291bGQgbm90IHJlY29nbml6ZSB0aGUgc2V0dGluZyBcIiR7a2V5fVwiYCk7XG4gICAgfVxuICB9KTtcbn07XG4iLCJpbXBvcnQgeyBnZXRDbGllbnRBUEkgfSBmcm9tICcuLi91dGlsJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG9wdCA9IHt9KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBldiA9PiB7XG4gICAgaWYgKCFvcHQuZW5hYmxlZCgpKSByZXR1cm47XG5cbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gODMgJiYgIWV2LmFsdEtleSAmJiAoZXYubWV0YUtleSB8fCBldi5jdHJsS2V5KSkge1xuICAgICAgLy8gQ21kICsgU1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9wdC5zYXZlKGV2KTtcbiAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDMyKSB7XG4gICAgICAvLyBTcGFjZVxuICAgICAgLy8gVE9ETzogd2hhdCB0byBkbyB3aXRoIHRoaXM/IGtlZXAgaXQsIG9yIHJlbW92ZSBpdD9cbiAgICAgIG9wdC50b2dnbGVQbGF5KGV2KTtcbiAgICB9IGVsc2UgaWYgKGNsaWVudCAmJiAhZXYuYWx0S2V5ICYmIGV2LmtleUNvZGUgPT09IDc1ICYmIChldi5tZXRhS2V5IHx8IGV2LmN0cmxLZXkpKSB7XG4gICAgICAvLyBDbWQgKyBLLCBvbmx5IHdoZW4gY2FudmFzLXNrZXRjaC1jbGkgaXMgdXNlZFxuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgIG9wdC5jb21taXQoZXYpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBhdHRhY2ggPSAoKSA9PiB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgfTtcblxuICBjb25zdCBkZXRhY2ggPSAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGF0dGFjaCxcbiAgICBkZXRhY2hcbiAgfTtcbn1cbiIsImNvbnN0IGRlZmF1bHRVbml0cyA9ICdtbSc7XG5cbmNvbnN0IGRhdGEgPSBbXG4gIC8vIENvbW1vbiBQYXBlciBTaXplc1xuICAvLyAoTW9zdGx5IE5vcnRoLUFtZXJpY2FuIGJhc2VkKVxuICBbICdwb3N0Y2FyZCcsIDEwMS42LCAxNTIuNCBdLFxuICBbICdwb3N0ZXItc21hbGwnLCAyODAsIDQzMCBdLFxuICBbICdwb3N0ZXInLCA0NjAsIDYxMCBdLFxuICBbICdwb3N0ZXItbGFyZ2UnLCA2MTAsIDkxMCBdLFxuICBbICdidXNpbmVzcy1jYXJkJywgNTAuOCwgODguOSBdLFxuXG4gIC8vIFBob3RvZ3JhcGhpYyBQcmludCBQYXBlciBTaXplc1xuICBbICcycicsIDY0LCA4OSBdLFxuICBbICczcicsIDg5LCAxMjcgXSxcbiAgWyAnNHInLCAxMDIsIDE1MiBdLFxuICBbICc1cicsIDEyNywgMTc4IF0sIC8vIDXigLN4N+KAs1xuICBbICc2cicsIDE1MiwgMjAzIF0sIC8vIDbigLN4OOKAs1xuICBbICc4cicsIDIwMywgMjU0IF0sIC8vIDjigLN4MTDigLNcbiAgWyAnMTByJywgMjU0LCAzMDUgXSwgLy8gMTDigLN4MTLigLNcbiAgWyAnMTFyJywgMjc5LCAzNTYgXSwgLy8gMTHigLN4MTTigLNcbiAgWyAnMTJyJywgMzA1LCAzODEgXSxcblxuICAvLyBTdGFuZGFyZCBQYXBlciBTaXplc1xuICBbICdhMCcsIDg0MSwgMTE4OSBdLFxuICBbICdhMScsIDU5NCwgODQxIF0sXG4gIFsgJ2EyJywgNDIwLCA1OTQgXSxcbiAgWyAnYTMnLCAyOTcsIDQyMCBdLFxuICBbICdhNCcsIDIxMCwgMjk3IF0sXG4gIFsgJ2E1JywgMTQ4LCAyMTAgXSxcbiAgWyAnYTYnLCAxMDUsIDE0OCBdLFxuICBbICdhNycsIDc0LCAxMDUgXSxcbiAgWyAnYTgnLCA1MiwgNzQgXSxcbiAgWyAnYTknLCAzNywgNTIgXSxcbiAgWyAnYTEwJywgMjYsIDM3IF0sXG4gIFsgJzJhMCcsIDExODksIDE2ODIgXSxcbiAgWyAnNGEwJywgMTY4MiwgMjM3OCBdLFxuICBbICdiMCcsIDEwMDAsIDE0MTQgXSxcbiAgWyAnYjEnLCA3MDcsIDEwMDAgXSxcbiAgWyAnYjErJywgNzIwLCAxMDIwIF0sXG4gIFsgJ2IyJywgNTAwLCA3MDcgXSxcbiAgWyAnYjIrJywgNTIwLCA3MjAgXSxcbiAgWyAnYjMnLCAzNTMsIDUwMCBdLFxuICBbICdiNCcsIDI1MCwgMzUzIF0sXG4gIFsgJ2I1JywgMTc2LCAyNTAgXSxcbiAgWyAnYjYnLCAxMjUsIDE3NiBdLFxuICBbICdiNycsIDg4LCAxMjUgXSxcbiAgWyAnYjgnLCA2MiwgODggXSxcbiAgWyAnYjknLCA0NCwgNjIgXSxcbiAgWyAnYjEwJywgMzEsIDQ0IF0sXG4gIFsgJ2IxMScsIDIyLCAzMiBdLFxuICBbICdiMTInLCAxNiwgMjIgXSxcbiAgWyAnYzAnLCA5MTcsIDEyOTcgXSxcbiAgWyAnYzEnLCA2NDgsIDkxNyBdLFxuICBbICdjMicsIDQ1OCwgNjQ4IF0sXG4gIFsgJ2MzJywgMzI0LCA0NTggXSxcbiAgWyAnYzQnLCAyMjksIDMyNCBdLFxuICBbICdjNScsIDE2MiwgMjI5IF0sXG4gIFsgJ2M2JywgMTE0LCAxNjIgXSxcbiAgWyAnYzcnLCA4MSwgMTE0IF0sXG4gIFsgJ2M4JywgNTcsIDgxIF0sXG4gIFsgJ2M5JywgNDAsIDU3IF0sXG4gIFsgJ2MxMCcsIDI4LCA0MCBdLFxuICBbICdjMTEnLCAyMiwgMzIgXSxcbiAgWyAnYzEyJywgMTYsIDIyIF0sXG5cbiAgLy8gVXNlIGluY2hlcyBmb3IgTm9ydGggQW1lcmljYW4gc2l6ZXMsXG4gIC8vIGFzIGl0IHByb2R1Y2VzIGxlc3MgZmxvYXQgcHJlY2lzaW9uIGVycm9yc1xuICBbICdoYWxmLWxldHRlcicsIDUuNSwgOC41LCAnaW4nIF0sXG4gIFsgJ2xldHRlcicsIDguNSwgMTEsICdpbicgXSxcbiAgWyAnbGVnYWwnLCA4LjUsIDE0LCAnaW4nIF0sXG4gIFsgJ2p1bmlvci1sZWdhbCcsIDUsIDgsICdpbicgXSxcbiAgWyAnbGVkZ2VyJywgMTEsIDE3LCAnaW4nIF0sXG4gIFsgJ3RhYmxvaWQnLCAxMSwgMTcsICdpbicgXSxcbiAgWyAnYW5zaS1hJywgOC41LCAxMS4wLCAnaW4nIF0sXG4gIFsgJ2Fuc2ktYicsIDExLjAsIDE3LjAsICdpbicgXSxcbiAgWyAnYW5zaS1jJywgMTcuMCwgMjIuMCwgJ2luJyBdLFxuICBbICdhbnNpLWQnLCAyMi4wLCAzNC4wLCAnaW4nIF0sXG4gIFsgJ2Fuc2ktZScsIDM0LjAsIDQ0LjAsICdpbicgXSxcbiAgWyAnYXJjaC1hJywgOSwgMTIsICdpbicgXSxcbiAgWyAnYXJjaC1iJywgMTIsIDE4LCAnaW4nIF0sXG4gIFsgJ2FyY2gtYycsIDE4LCAyNCwgJ2luJyBdLFxuICBbICdhcmNoLWQnLCAyNCwgMzYsICdpbicgXSxcbiAgWyAnYXJjaC1lJywgMzYsIDQ4LCAnaW4nIF0sXG4gIFsgJ2FyY2gtZTEnLCAzMCwgNDIsICdpbicgXSxcbiAgWyAnYXJjaC1lMicsIDI2LCAzOCwgJ2luJyBdLFxuICBbICdhcmNoLWUzJywgMjcsIDM5LCAnaW4nIF1cbl07XG5cbmV4cG9ydCBkZWZhdWx0IGRhdGEucmVkdWNlKChkaWN0LCBwcmVzZXQpID0+IHtcbiAgY29uc3QgaXRlbSA9IHtcbiAgICB1bml0czogcHJlc2V0WzNdIHx8IGRlZmF1bHRVbml0cyxcbiAgICBkaW1lbnNpb25zOiBbIHByZXNldFsxXSwgcHJlc2V0WzJdIF1cbiAgfTtcbiAgZGljdFtwcmVzZXRbMF1dID0gaXRlbTtcbiAgZGljdFtwcmVzZXRbMF0ucmVwbGFjZSgvLS9nLCAnICcpXSA9IGl0ZW07XG4gIHJldHVybiBkaWN0O1xufSwge30pO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYXJndW1lbnRzW2ldO1xuICAgIH1cbn07XG4iLCJ2YXIgZGVmaW5lZCA9IHJlcXVpcmUoJ2RlZmluZWQnKTtcbnZhciB1bml0cyA9IFsgJ21tJywgJ2NtJywgJ20nLCAncGMnLCAncHQnLCAnaW4nLCAnZnQnLCAncHgnIF07XG5cbnZhciBjb252ZXJzaW9ucyA9IHtcbiAgLy8gbWV0cmljXG4gIG06IHtcbiAgICBzeXN0ZW06ICdtZXRyaWMnLFxuICAgIGZhY3RvcjogMVxuICB9LFxuICBjbToge1xuICAgIHN5c3RlbTogJ21ldHJpYycsXG4gICAgZmFjdG9yOiAxIC8gMTAwXG4gIH0sXG4gIG1tOiB7XG4gICAgc3lzdGVtOiAnbWV0cmljJyxcbiAgICBmYWN0b3I6IDEgLyAxMDAwXG4gIH0sXG4gIC8vIGltcGVyaWFsXG4gIHB0OiB7XG4gICAgc3lzdGVtOiAnaW1wZXJpYWwnLFxuICAgIGZhY3RvcjogMSAvIDcyXG4gIH0sXG4gIHBjOiB7XG4gICAgc3lzdGVtOiAnaW1wZXJpYWwnLFxuICAgIGZhY3RvcjogMSAvIDZcbiAgfSxcbiAgaW46IHtcbiAgICBzeXN0ZW06ICdpbXBlcmlhbCcsXG4gICAgZmFjdG9yOiAxXG4gIH0sXG4gIGZ0OiB7XG4gICAgc3lzdGVtOiAnaW1wZXJpYWwnLFxuICAgIGZhY3RvcjogMTJcbiAgfVxufTtcblxuY29uc3QgYW5jaG9ycyA9IHtcbiAgbWV0cmljOiB7XG4gICAgdW5pdDogJ20nLFxuICAgIHJhdGlvOiAxIC8gMC4wMjU0XG4gIH0sXG4gIGltcGVyaWFsOiB7XG4gICAgdW5pdDogJ2luJyxcbiAgICByYXRpbzogMC4wMjU0XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJvdW5kICh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgcmV0dXJuIE51bWJlcihNYXRoLnJvdW5kKHZhbHVlICsgJ2UnICsgZGVjaW1hbHMpICsgJ2UtJyArIGRlY2ltYWxzKTtcbn1cblxuZnVuY3Rpb24gY29udmVydERpc3RhbmNlICh2YWx1ZSwgZnJvbVVuaXQsIHRvVW5pdCwgb3B0cykge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCAhaXNGaW5pdGUodmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyJyk7XG4gIGlmICghZnJvbVVuaXQgfHwgIXRvVW5pdCkgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgZnJvbSBhbmQgdG8gdW5pdHMnKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdmFyIHBpeGVsc1BlckluY2ggPSBkZWZpbmVkKG9wdHMucGl4ZWxzUGVySW5jaCwgOTYpO1xuICB2YXIgcHJlY2lzaW9uID0gb3B0cy5wcmVjaXNpb247XG4gIHZhciByb3VuZFBpeGVsID0gb3B0cy5yb3VuZFBpeGVsICE9PSBmYWxzZTtcblxuICBmcm9tVW5pdCA9IGZyb21Vbml0LnRvTG93ZXJDYXNlKCk7XG4gIHRvVW5pdCA9IHRvVW5pdC50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmICh1bml0cy5pbmRleE9mKGZyb21Vbml0KSA9PT0gLTEpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmcm9tIHVuaXQgXCInICsgZnJvbVVuaXQgKyAnXCIsIG11c3QgYmUgb25lIG9mOiAnICsgdW5pdHMuam9pbignLCAnKSk7XG4gIGlmICh1bml0cy5pbmRleE9mKHRvVW5pdCkgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZnJvbSB1bml0IFwiJyArIHRvVW5pdCArICdcIiwgbXVzdCBiZSBvbmUgb2Y6ICcgKyB1bml0cy5qb2luKCcsICcpKTtcblxuICBpZiAoZnJvbVVuaXQgPT09IHRvVW5pdCkge1xuICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY29udmVydCBmcm9tIEEgdG8gQiBzaW5jZSB0aGV5IGFyZSB0aGUgc2FtZSBhbHJlYWR5XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIHRvRmFjdG9yID0gMTtcbiAgdmFyIGZyb21GYWN0b3IgPSAxO1xuICB2YXIgaXNUb1BpeGVsID0gZmFsc2U7XG5cbiAgaWYgKGZyb21Vbml0ID09PSAncHgnKSB7XG4gICAgZnJvbUZhY3RvciA9IDEgLyBwaXhlbHNQZXJJbmNoO1xuICAgIGZyb21Vbml0ID0gJ2luJztcbiAgfVxuICBpZiAodG9Vbml0ID09PSAncHgnKSB7XG4gICAgaXNUb1BpeGVsID0gdHJ1ZTtcbiAgICB0b0ZhY3RvciA9IHBpeGVsc1BlckluY2g7XG4gICAgdG9Vbml0ID0gJ2luJztcbiAgfVxuXG4gIHZhciBmcm9tVW5pdERhdGEgPSBjb252ZXJzaW9uc1tmcm9tVW5pdF07XG4gIHZhciB0b1VuaXREYXRhID0gY29udmVyc2lvbnNbdG9Vbml0XTtcblxuICAvLyBzb3VyY2UgdG8gYW5jaG9yIGluc2lkZSBzb3VyY2UncyBzeXN0ZW1cbiAgdmFyIGFuY2hvciA9IHZhbHVlICogZnJvbVVuaXREYXRhLmZhY3RvciAqIGZyb21GYWN0b3I7XG5cbiAgLy8gaWYgc3lzdGVtcyBkaWZmZXIsIGNvbnZlcnQgb25lIHRvIGFub3RoZXJcbiAgaWYgKGZyb21Vbml0RGF0YS5zeXN0ZW0gIT09IHRvVW5pdERhdGEuc3lzdGVtKSB7XG4gICAgLy8gcmVndWxhciAnbScgdG8gJ2luJyBhbmQgc28gZm9ydGhcbiAgICBhbmNob3IgKj0gYW5jaG9yc1tmcm9tVW5pdERhdGEuc3lzdGVtXS5yYXRpbztcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBhbmNob3IgLyB0b1VuaXREYXRhLmZhY3RvciAqIHRvRmFjdG9yO1xuICBpZiAoaXNUb1BpeGVsICYmIHJvdW5kUGl4ZWwpIHtcbiAgICByZXN1bHQgPSBNYXRoLnJvdW5kKHJlc3VsdCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByZWNpc2lvbiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUocHJlY2lzaW9uKSkge1xuICAgIHJlc3VsdCA9IHJvdW5kKHJlc3VsdCwgcHJlY2lzaW9uKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnREaXN0YW5jZTtcbm1vZHVsZS5leHBvcnRzLnVuaXRzID0gdW5pdHM7XG4iLCJpbXBvcnQgcGFwZXJTaXplcyBmcm9tICcuL3BhcGVyLXNpemVzJztcbmltcG9ydCBjb252ZXJ0TGVuZ3RoIGZyb20gJ2NvbnZlcnQtbGVuZ3RoJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpbWVuc2lvbnNGcm9tUHJlc2V0IChkaW1lbnNpb25zLCB1bml0c1RvID0gJ3B4JywgcGl4ZWxzUGVySW5jaCA9IDcyKSB7XG4gIGlmICh0eXBlb2YgZGltZW5zaW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBrZXkgPSBkaW1lbnNpb25zLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKCEoa2V5IGluIHBhcGVyU2l6ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBkaW1lbnNpb24gcHJlc2V0IFwiJHtkaW1lbnNpb25zfVwiIGlzIG5vdCBzdXBwb3J0ZWQgb3IgY291bGQgbm90IGJlIGZvdW5kOyB0cnkgdXNpbmcgYTQsIGEzLCBwb3N0Y2FyZCwgbGV0dGVyLCBldGMuYClcbiAgICB9XG4gICAgY29uc3QgcHJlc2V0ID0gcGFwZXJTaXplc1trZXldO1xuICAgIHJldHVybiBwcmVzZXQuZGltZW5zaW9ucy5tYXAoZCA9PiB7XG4gICAgICByZXR1cm4gY29udmVydERpc3RhbmNlKGQsIHByZXNldC51bml0cywgdW5pdHNUbywgcGl4ZWxzUGVySW5jaCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvbnM7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREaXN0YW5jZSAoZGltZW5zaW9uLCB1bml0c0Zyb20gPSAncHgnLCB1bml0c1RvID0gJ3B4JywgcGl4ZWxzUGVySW5jaCA9IDcyKSB7XG4gIHJldHVybiBjb252ZXJ0TGVuZ3RoKGRpbWVuc2lvbiwgdW5pdHNGcm9tLCB1bml0c1RvLCB7XG4gICAgcGl4ZWxzUGVySW5jaCxcbiAgICBwcmVjaXNpb246IDQsXG4gICAgcm91bmRQaXhlbDogdHJ1ZVxuICB9KTtcbn1cbiIsImltcG9ydCB7IGdldERpbWVuc2lvbnNGcm9tUHJlc2V0LCBjb252ZXJ0RGlzdGFuY2UgfSBmcm9tICcuLi9kaXN0YW5jZXMnO1xuaW1wb3J0IHsgaXNCcm93c2VyLCBkZWZpbmVkIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmZ1bmN0aW9uIGNoZWNrSWZIYXNEaW1lbnNpb25zIChzZXR0aW5ncykge1xuICBpZiAoIXNldHRpbmdzLmRpbWVuc2lvbnMpIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5kaW1lbnNpb25zID09PSAnc3RyaW5nJykgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHNldHRpbmdzLmRpbWVuc2lvbnMpICYmIHNldHRpbmdzLmRpbWVuc2lvbnMubGVuZ3RoID49IDIpIHJldHVybiB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmVudFNpemUgKHByb3BzLCBzZXR0aW5ncykge1xuICAvLyBXaGVuIG5vIHsgZGltZW5zaW9uIH0gaXMgcGFzc2VkIGluIG5vZGUsIHdlIGRlZmF1bHQgdG8gSFRNTCBjYW52YXMgc2l6ZVxuICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgcmV0dXJuIFsgMzAwLCAxNTAgXTtcbiAgfVxuXG4gIGxldCBlbGVtZW50ID0gc2V0dGluZ3MucGFyZW50IHx8IHdpbmRvdztcblxuICBpZiAoZWxlbWVudCA9PT0gd2luZG93IHx8XG4gICAgICBlbGVtZW50ID09PSBkb2N1bWVudCB8fFxuICAgICAgZWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBbIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQgXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIFsgd2lkdGgsIGhlaWdodCBdO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc2l6ZUNhbnZhcyAocHJvcHMsIHNldHRpbmdzKSB7XG4gIGxldCB3aWR0aCwgaGVpZ2h0O1xuICBsZXQgc3R5bGVXaWR0aCwgc3R5bGVIZWlnaHQ7XG4gIGxldCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0O1xuXG4gIGNvbnN0IGJyb3dzZXIgPSBpc0Jyb3dzZXIoKTtcbiAgY29uc3QgZGltZW5zaW9ucyA9IHNldHRpbmdzLmRpbWVuc2lvbnM7XG4gIGNvbnN0IGhhc0RpbWVuc2lvbnMgPSBjaGVja0lmSGFzRGltZW5zaW9ucyhzZXR0aW5ncyk7XG4gIGNvbnN0IGV4cG9ydGluZyA9IHByb3BzLmV4cG9ydGluZztcbiAgbGV0IHNjYWxlVG9GaXQgPSBoYXNEaW1lbnNpb25zID8gc2V0dGluZ3Muc2NhbGVUb0ZpdCAhPT0gZmFsc2UgOiBmYWxzZTtcbiAgbGV0IHNjYWxlVG9WaWV3ID0gKCFleHBvcnRpbmcgJiYgaGFzRGltZW5zaW9ucykgPyBzZXR0aW5ncy5zY2FsZVRvVmlldyA6IHRydWU7XG4gIC8vIGluIG5vZGUsIGNhbmNlbCBib3RoIG9mIHRoZXNlIG9wdGlvbnNcbiAgaWYgKCFicm93c2VyKSBzY2FsZVRvRml0ID0gc2NhbGVUb1ZpZXcgPSBmYWxzZTtcbiAgY29uc3QgdW5pdHMgPSBzZXR0aW5ncy51bml0cztcbiAgY29uc3QgcGl4ZWxzUGVySW5jaCA9ICh0eXBlb2Ygc2V0dGluZ3MucGl4ZWxzUGVySW5jaCA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoc2V0dGluZ3MucGl4ZWxzUGVySW5jaCkpID8gc2V0dGluZ3MucGl4ZWxzUGVySW5jaCA6IDcyO1xuICBjb25zdCBibGVlZCA9IGRlZmluZWQoc2V0dGluZ3MuYmxlZWQsIDApO1xuXG4gIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBicm93c2VyID8gd2luZG93LmRldmljZVBpeGVsUmF0aW8gOiAxO1xuICBjb25zdCBiYXNlUGl4ZWxSYXRpbyA9IHNjYWxlVG9WaWV3ID8gZGV2aWNlUGl4ZWxSYXRpbyA6IDE7XG5cbiAgbGV0IHBpeGVsUmF0aW8sIGV4cG9ydFBpeGVsUmF0aW87XG5cbiAgLy8gSWYgYSBwaXhlbCByYXRpbyBpcyBzcGVjaWZpZWQsIHdlIHdpbGwgdXNlIGl0LlxuICAvLyBPdGhlcndpc2U6XG4gIC8vICAtPiBJZiBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCB1c2UgYmFzZSByYXRpbyAoaS5lLiBzaXplIGZvciBleHBvcnQpXG4gIC8vICAtPiBJZiBubyBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCB1c2UgZGV2aWNlIHJhdGlvIChpLmUuIHNpemUgZm9yIHNjcmVlbilcbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5waXhlbFJhdGlvID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzZXR0aW5ncy5waXhlbFJhdGlvKSkge1xuICAgIC8vIFdoZW4geyBwaXhlbFJhdGlvIH0gaXMgc3BlY2lmaWVkLCBpdCdzIGFsc28gdXNlZCBhcyBkZWZhdWx0IGV4cG9ydFBpeGVsUmF0aW8uXG4gICAgcGl4ZWxSYXRpbyA9IHNldHRpbmdzLnBpeGVsUmF0aW87XG4gICAgZXhwb3J0UGl4ZWxSYXRpbyA9IGRlZmluZWQoc2V0dGluZ3MuZXhwb3J0UGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhhc0RpbWVuc2lvbnMpIHtcbiAgICAgIC8vIFdoZW4gYSBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCB1c2UgdGhlIGJhc2UgcmF0aW8gcmF0aGVyIHRoYW4gc2NyZWVuIHJhdGlvXG4gICAgICBwaXhlbFJhdGlvID0gYmFzZVBpeGVsUmF0aW87XG4gICAgICAvLyBEZWZhdWx0IHRvIGEgcGl4ZWwgcmF0aW8gb2YgMSBzbyB0aGF0IHlvdSBlbmQgdXAgd2l0aCB0aGUgc2FtZSBkaW1lbnNpb25cbiAgICAgIC8vIHlvdSBzcGVjaWZpZWQsIGkuZS4gWyA1MDAsIDUwMCBdIGlzIGV4cG9ydGVkIGFzIDUwMHg1MDAgcHhcbiAgICAgIGV4cG9ydFBpeGVsUmF0aW8gPSBkZWZpbmVkKHNldHRpbmdzLmV4cG9ydFBpeGVsUmF0aW8sIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBkaW1lbnNpb24gaXMgc3BlY2lmaWVkLCBhc3N1bWUgZnVsbC1zY3JlZW4gcmV0aW5hIHNpemluZ1xuICAgICAgcGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87XG4gICAgICAvLyBEZWZhdWx0IHRvIHNjcmVlbiBwaXhlbCByYXRpbywgc28gdGhhdCBpdCdzIGxpa2UgdGFraW5nIGEgZGV2aWNlIHNjcmVlbnNob3RcbiAgICAgIGV4cG9ydFBpeGVsUmF0aW8gPSBkZWZpbmVkKHNldHRpbmdzLmV4cG9ydFBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsYW1wIHBpeGVsIHJhdGlvXG4gIGlmICh0eXBlb2Ygc2V0dGluZ3MubWF4UGl4ZWxSYXRpbyA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoc2V0dGluZ3MubWF4UGl4ZWxSYXRpbykpIHtcbiAgICBwaXhlbFJhdGlvID0gTWF0aC5taW4oc2V0dGluZ3MubWF4UGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gIH1cblxuICAvLyBIYW5kbGUgZXhwb3J0IHBpeGVsIHJhdGlvXG4gIGlmIChleHBvcnRpbmcpIHtcbiAgICBwaXhlbFJhdGlvID0gZXhwb3J0UGl4ZWxSYXRpbztcbiAgfVxuXG4gIC8vIHBhcmVudFdpZHRoID0gdHlwZW9mIHBhcmVudFdpZHRoID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHROb2RlU2l6ZVswXSA6IHBhcmVudFdpZHRoO1xuICAvLyBwYXJlbnRIZWlnaHQgPSB0eXBlb2YgcGFyZW50SGVpZ2h0ID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHROb2RlU2l6ZVsxXSA6IHBhcmVudEhlaWdodDtcblxuICBsZXQgWyBwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0IF0gPSBnZXRQYXJlbnRTaXplKHByb3BzLCBzZXR0aW5ncyk7XG4gIGxldCB0cmltV2lkdGgsIHRyaW1IZWlnaHQ7XG5cbiAgLy8gWW91IGNhbiBzcGVjaWZ5IGEgZGltZW5zaW9ucyBpbiBwaXhlbHMgb3IgY20vbS9pbi9ldGNcbiAgaWYgKGhhc0RpbWVuc2lvbnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBnZXREaW1lbnNpb25zRnJvbVByZXNldChkaW1lbnNpb25zLCB1bml0cywgcGl4ZWxzUGVySW5jaCk7XG4gICAgY29uc3QgaGlnaGVzdCA9IE1hdGgubWF4KHJlc3VsdFswXSwgcmVzdWx0WzFdKTtcbiAgICBjb25zdCBsb3dlc3QgPSBNYXRoLm1pbihyZXN1bHRbMF0sIHJlc3VsdFsxXSk7XG4gICAgaWYgKHNldHRpbmdzLm9yaWVudGF0aW9uKSB7XG4gICAgICBjb25zdCBsYW5kc2NhcGUgPSBzZXR0aW5ncy5vcmllbnRhdGlvbiA9PT0gJ2xhbmRzY2FwZSc7XG4gICAgICB3aWR0aCA9IGxhbmRzY2FwZSA/IGhpZ2hlc3QgOiBsb3dlc3Q7XG4gICAgICBoZWlnaHQgPSBsYW5kc2NhcGUgPyBsb3dlc3QgOiBoaWdoZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IHJlc3VsdFswXTtcbiAgICAgIGhlaWdodCA9IHJlc3VsdFsxXTtcbiAgICB9XG5cbiAgICB0cmltV2lkdGggPSB3aWR0aDtcbiAgICB0cmltSGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgLy8gQXBwbHkgYmxlZWQgd2hpY2ggaXMgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSB1bml0c1xuICAgIHdpZHRoICs9IGJsZWVkICogMjtcbiAgICBoZWlnaHQgKz0gYmxlZWQgKiAyO1xuICB9IGVsc2Uge1xuICAgIHdpZHRoID0gcGFyZW50V2lkdGg7XG4gICAgaGVpZ2h0ID0gcGFyZW50SGVpZ2h0O1xuICAgIHRyaW1XaWR0aCA9IHdpZHRoO1xuICAgIHRyaW1IZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICAvLyBSZWFsIHNpemUgaW4gcGl4ZWxzIGFmdGVyIFBQSSBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgbGV0IHJlYWxXaWR0aCA9IHdpZHRoO1xuICBsZXQgcmVhbEhlaWdodCA9IGhlaWdodDtcbiAgaWYgKGhhc0RpbWVuc2lvbnMgJiYgdW5pdHMpIHtcbiAgICAvLyBDb252ZXJ0IHRvIGRpZ2l0YWwvcGl4ZWwgdW5pdHMgaWYgbmVjZXNzYXJ5XG4gICAgcmVhbFdpZHRoID0gY29udmVydERpc3RhbmNlKHdpZHRoLCB1bml0cywgJ3B4JywgcGl4ZWxzUGVySW5jaCk7XG4gICAgcmVhbEhlaWdodCA9IGNvbnZlcnREaXN0YW5jZShoZWlnaHQsIHVuaXRzLCAncHgnLCBwaXhlbHNQZXJJbmNoKTtcbiAgfVxuXG4gIC8vIEhvdyBiaWcgdG8gc2V0IHRoZSAndmlldycgb2YgdGhlIGNhbnZhcyBpbiB0aGUgYnJvd3NlciAoaS5lLiBzdHlsZSlcbiAgc3R5bGVXaWR0aCA9IE1hdGgucm91bmQocmVhbFdpZHRoKTtcbiAgc3R5bGVIZWlnaHQgPSBNYXRoLnJvdW5kKHJlYWxIZWlnaHQpO1xuXG4gIC8vIElmIHdlIHdpc2ggdG8gc2NhbGUgdGhlIHZpZXcgdG8gdGhlIGJyb3dzZXIgd2luZG93XG4gIGlmIChzY2FsZVRvRml0ICYmICFleHBvcnRpbmcgJiYgaGFzRGltZW5zaW9ucykge1xuICAgIGNvbnN0IGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IHdpbmRvd0FzcGVjdCA9IHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlVG9GaXRQYWRkaW5nID0gZGVmaW5lZChzZXR0aW5ncy5zY2FsZVRvRml0UGFkZGluZywgNDApO1xuICAgIGNvbnN0IG1heFdpZHRoID0gTWF0aC5yb3VuZChwYXJlbnRXaWR0aCAtIHNjYWxlVG9GaXRQYWRkaW5nICogMik7XG4gICAgY29uc3QgbWF4SGVpZ2h0ID0gTWF0aC5yb3VuZChwYXJlbnRIZWlnaHQgLSBzY2FsZVRvRml0UGFkZGluZyAqIDIpO1xuICAgIGlmIChzdHlsZVdpZHRoID4gbWF4V2lkdGggfHwgc3R5bGVIZWlnaHQgPiBtYXhIZWlnaHQpIHtcbiAgICAgIGlmICh3aW5kb3dBc3BlY3QgPiBhc3BlY3QpIHtcbiAgICAgICAgc3R5bGVIZWlnaHQgPSBtYXhIZWlnaHQ7XG4gICAgICAgIHN0eWxlV2lkdGggPSBNYXRoLnJvdW5kKHN0eWxlSGVpZ2h0ICogYXNwZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0eWxlV2lkdGggPSBtYXhXaWR0aDtcbiAgICAgICAgc3R5bGVIZWlnaHQgPSBNYXRoLnJvdW5kKHN0eWxlV2lkdGggLyBhc3BlY3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNhbnZhc1dpZHRoID0gc2NhbGVUb1ZpZXcgPyBNYXRoLnJvdW5kKHBpeGVsUmF0aW8gKiBzdHlsZVdpZHRoKSA6IE1hdGgucm91bmQocGl4ZWxSYXRpbyAqIHJlYWxXaWR0aCk7XG4gIGNhbnZhc0hlaWdodCA9IHNjYWxlVG9WaWV3ID8gTWF0aC5yb3VuZChwaXhlbFJhdGlvICogc3R5bGVIZWlnaHQpIDogTWF0aC5yb3VuZChwaXhlbFJhdGlvICogcmVhbEhlaWdodCk7XG5cbiAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IHNjYWxlVG9WaWV3ID8gTWF0aC5yb3VuZChzdHlsZVdpZHRoKSA6IE1hdGgucm91bmQocmVhbFdpZHRoKTtcbiAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBzY2FsZVRvVmlldyA/IE1hdGgucm91bmQoc3R5bGVIZWlnaHQpIDogTWF0aC5yb3VuZChyZWFsSGVpZ2h0KTtcblxuICBjb25zdCBzY2FsZVggPSBjYW52YXNXaWR0aCAvIHdpZHRoO1xuICBjb25zdCBzY2FsZVkgPSBjYW52YXNIZWlnaHQgLyBoZWlnaHQ7XG5cbiAgLy8gQXNzaWduIHRvIGN1cnJlbnQgcHJvcHNcbiAgcmV0dXJuIHtcbiAgICBibGVlZCxcbiAgICBwaXhlbFJhdGlvLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBkaW1lbnNpb25zOiBbIHdpZHRoLCBoZWlnaHQgXSxcbiAgICB1bml0czogdW5pdHMgfHwgJ3B4JyxcbiAgICBzY2FsZVgsXG4gICAgc2NhbGVZLFxuICAgIHBpeGVsc1BlckluY2gsXG4gICAgdmlld3BvcnRXaWR0aCxcbiAgICB2aWV3cG9ydEhlaWdodCxcbiAgICBjYW52YXNXaWR0aCxcbiAgICBjYW52YXNIZWlnaHQsXG4gICAgdHJpbVdpZHRoLFxuICAgIHRyaW1IZWlnaHQsXG4gICAgc3R5bGVXaWR0aCxcbiAgICBzdHlsZUhlaWdodFxuICB9O1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBnZXRDYW52YXNDb250ZXh0XG5mdW5jdGlvbiBnZXRDYW52YXNDb250ZXh0ICh0eXBlLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHNwZWNpZnkgdHlwZSBzdHJpbmcnKVxuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyAmJiAhb3B0cy5jYW52YXMpIHtcbiAgICByZXR1cm4gbnVsbCAvLyBjaGVjayBmb3IgTm9kZVxuICB9XG5cbiAgdmFyIGNhbnZhcyA9IG9wdHMuY2FudmFzIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gIGlmICh0eXBlb2Ygb3B0cy53aWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICBjYW52YXMud2lkdGggPSBvcHRzLndpZHRoXG4gIH1cbiAgaWYgKHR5cGVvZiBvcHRzLmhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICBjYW52YXMuaGVpZ2h0ID0gb3B0cy5oZWlnaHRcbiAgfVxuXG4gIHZhciBhdHRyaWJzID0gb3B0c1xuICB2YXIgZ2xcbiAgdHJ5IHtcbiAgICB2YXIgbmFtZXMgPSBbIHR5cGUgXVxuICAgIC8vIHByZWZpeCBHTCBjb250ZXh0c1xuICAgIGlmICh0eXBlLmluZGV4T2YoJ3dlYmdsJykgPT09IDApIHtcbiAgICAgIG5hbWVzLnB1c2goJ2V4cGVyaW1lbnRhbC0nICsgdHlwZSlcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KG5hbWVzW2ldLCBhdHRyaWJzKVxuICAgICAgaWYgKGdsKSByZXR1cm4gZ2xcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBnbCA9IG51bGxcbiAgfVxuICByZXR1cm4gKGdsIHx8IG51bGwpIC8vIGVuc3VyZSBudWxsIG9uIGZhaWxcbn1cbiIsImltcG9ydCBhc3NpZ24gZnJvbSAnb2JqZWN0LWFzc2lnbic7XG5pbXBvcnQgZ2V0Q2FudmFzQ29udGV4dCBmcm9tICdnZXQtY2FudmFzLWNvbnRleHQnO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi4vdXRpbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0VsZW1lbnQgKCkge1xuICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJdCBhcHBlYXJzIHlvdSBhcmUgcnVuaW5nIGZyb20gTm9kZS5qcyBvciBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiBUcnkgcGFzc2luZyBpbiBhbiBleGlzdGluZyB7IGNhbnZhcyB9IGludGVyZmFjZSBpbnN0ZWFkLicpO1xuICB9XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlQ2FudmFzIChzZXR0aW5ncyA9IHt9KSB7XG4gIGxldCBjb250ZXh0LCBjYW52YXM7XG4gIGxldCBvd25zQ2FudmFzID0gZmFsc2U7XG4gIGlmIChzZXR0aW5ncy5jYW52YXMgIT09IGZhbHNlKSB7XG4gICAgLy8gRGV0ZXJtaW5lIHRoZSBjYW52YXMgYW5kIGNvbnRleHQgdG8gY3JlYXRlXG4gICAgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHQ7XG4gICAgaWYgKCFjb250ZXh0IHx8IHR5cGVvZiBjb250ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgbGV0IG5ld0NhbnZhcyA9IHNldHRpbmdzLmNhbnZhcztcbiAgICAgIGlmICghbmV3Q2FudmFzKSB7XG4gICAgICAgIG5ld0NhbnZhcyA9IGNyZWF0ZUNhbnZhc0VsZW1lbnQoKTtcbiAgICAgICAgb3duc0NhbnZhcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCB0eXBlID0gY29udGV4dCB8fCAnMmQnO1xuICAgICAgaWYgKHR5cGVvZiBuZXdDYW52YXMuZ2V0Q29udGV4dCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzcGVjaWZpZWQgeyBjYW52YXMgfSBlbGVtZW50IGRvZXMgbm90IGhhdmUgYSBnZXRDb250ZXh0KCkgZnVuY3Rpb24sIG1heWJlIGl0IGlzIG5vdCBhIDxjYW52YXM+IHRhZz9gKTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQgPSBnZXRDYW52YXNDb250ZXh0KHR5cGUsIGFzc2lnbih7fSwgc2V0dGluZ3MuYXR0cmlidXRlcywgeyBjYW52YXM6IG5ld0NhbnZhcyB9KSk7XG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgYXQgY2FudmFzLmdldENvbnRleHQoJyR7dHlwZX0nKSAtIHRoZSBicm93c2VyIG1heSBub3Qgc3VwcG9ydCB0aGlzIGNvbnRleHQsIG9yIGEgZGlmZmVyZW50IGNvbnRleHQgbWF5IGFscmVhZHkgYmUgaW4gdXNlIHdpdGggdGhpcyBjYW52YXMuYCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgLy8gRW5zdXJlIGNvbnRleHQgbWF0Y2hlcyB1c2VyJ3MgY2FudmFzIGV4cGVjdGF0aW9uc1xuICAgIGlmIChzZXR0aW5ncy5jYW52YXMgJiYgY2FudmFzICE9PSBzZXR0aW5ncy5jYW52YXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHsgY2FudmFzIH0gYW5kIHsgY29udGV4dCB9IHNldHRpbmdzIG11c3QgcG9pbnQgdG8gdGhlIHNhbWUgdW5kZXJseWluZyBjYW52YXMgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIC8vIEFwcGx5IHBpeGVsYXRpb24gdG8gY2FudmFzIGlmIG5lY2Vzc2FyeSwgdGhpcyBpcyBtb3N0bHkgYSBjb252ZW5pZW5jZSB1dGlsaXR5XG4gICAgaWYgKHNldHRpbmdzLnBpeGVsYXRlZCkge1xuICAgICAgY29udGV4dC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0Lm9JbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnRleHQud2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBjb250ZXh0Lm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICBjYW52YXMuc3R5bGVbJ2ltYWdlLXJlbmRlcmluZyddID0gJ3BpeGVsYXRlZCc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGNhbnZhcywgY29udGV4dCwgb3duc0NhbnZhcyB9O1xufVxuIiwiaW1wb3J0IGFzc2lnbiBmcm9tICdvYmplY3QtYXNzaWduJztcbmltcG9ydCByaWdodE5vdyBmcm9tICdyaWdodC1ub3cnO1xuaW1wb3J0IGlzUHJvbWlzZSBmcm9tICdpcy1wcm9taXNlJztcbmltcG9ydCB7IGlzQnJvd3NlciwgZGVmaW5lZCwgaXNXZWJHTENvbnRleHQsIGlzQ2FudmFzLCBnZXRDbGllbnRBUEkgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBkZWVwRXF1YWwgZnJvbSAnZGVlcC1lcXVhbCc7XG5pbXBvcnQge1xuICByZXNvbHZlRmlsZW5hbWUsXG4gIHNhdmVGaWxlLFxuICBzYXZlRGF0YVVSTCxcbiAgZ2V0VGltZVN0YW1wLFxuICBleHBvcnRDYW52YXMsXG4gIHN0cmVhbVN0YXJ0LFxuICBzdHJlYW1FbmRcbn0gZnJvbSAnLi4vc2F2ZSc7XG5pbXBvcnQgeyBjaGVja1NldHRpbmdzIH0gZnJvbSAnLi4vYWNjZXNzaWJpbGl0eSc7XG5cbmltcG9ydCBrZXlib2FyZFNob3J0Y3V0cyBmcm9tICcuL2tleWJvYXJkU2hvcnRjdXRzJztcbmltcG9ydCByZXNpemVDYW52YXMgZnJvbSAnLi9yZXNpemVDYW52YXMnO1xuaW1wb3J0IGNyZWF0ZUNhbnZhcyBmcm9tICcuL2NyZWF0ZUNhbnZhcyc7XG5cbmNsYXNzIFNrZXRjaE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5fc2V0dGluZ3MgPSB7fTtcbiAgICB0aGlzLl9wcm9wcyA9IHt9O1xuICAgIHRoaXMuX3NrZXRjaCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9yYWYgPSBudWxsO1xuICAgIHRoaXMuX3JlY29yZFRpbWVvdXQgPSBudWxsO1xuXG4gICAgLy8gU29tZSBoYWNreSB0aGluZ3MgcmVxdWlyZWQgdG8gZ2V0IGFyb3VuZCBwNS5qcyBzdHJ1Y3R1cmVcbiAgICB0aGlzLl9sYXN0UmVkcmF3UmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2lzUDVSZXNpemluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fa2V5Ym9hcmRTaG9ydGN1dHMgPSBrZXlib2FyZFNob3J0Y3V0cyh7XG4gICAgICBlbmFibGVkOiAoKSA9PiB0aGlzLnNldHRpbmdzLmhvdGtleXMgIT09IGZhbHNlLFxuICAgICAgc2F2ZTogKGV2KSA9PiB7XG4gICAgICAgIGlmIChldi5zaGlmdEtleSkge1xuICAgICAgICAgIGlmICh0aGlzLnByb3BzLnJlY29yZGluZykge1xuICAgICAgICAgICAgdGhpcy5lbmRSZWNvcmQoKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgICAgfSBlbHNlIHRoaXMucmVjb3JkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucHJvcHMucmVjb3JkaW5nKSB7XG4gICAgICAgICAgdGhpcy5leHBvcnRGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9nZ2xlUGxheTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9wcy5wbGF5aW5nKSB0aGlzLnBhdXNlKCk7XG4gICAgICAgIGVsc2UgdGhpcy5wbGF5KCk7XG4gICAgICB9LFxuICAgICAgY29tbWl0OiAoZXYpID0+IHtcbiAgICAgICAgdGhpcy5leHBvcnRGcmFtZSh7IGNvbW1pdDogdHJ1ZSB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuX2FuaW1hdGVIYW5kbGVyID0gKCkgPT4gdGhpcy5hbmltYXRlKCk7XG5cbiAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMucmVzaXplKCk7XG4gICAgICAvLyBPbmx5IHJlLXJlbmRlciB3aGVuIHNpemUgYWN0dWFsbHkgY2hhbmdlc1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZ2V0IHNrZXRjaCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NrZXRjaDtcbiAgfVxuXG4gIGdldCBzZXR0aW5ncyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldHRpbmdzO1xuICB9XG5cbiAgZ2V0IHByb3BzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHM7XG4gIH1cblxuICBfY29tcHV0ZVBsYXloZWFkIChjdXJyZW50VGltZSwgZHVyYXRpb24pIHtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoZHVyYXRpb24pO1xuICAgIHJldHVybiBoYXNEdXJhdGlvbiA/IGN1cnJlbnRUaW1lIC8gZHVyYXRpb24gOiAwO1xuICB9XG5cbiAgX2NvbXB1dGVGcmFtZSAocGxheWhlYWQsIHRpbWUsIHRvdGFsRnJhbWVzLCBmcHMpIHtcbiAgICByZXR1cm4gKGlzRmluaXRlKHRvdGFsRnJhbWVzKSAmJiB0b3RhbEZyYW1lcyA+IDEpXG4gICAgICA/IE1hdGguZmxvb3IocGxheWhlYWQgKiAodG90YWxGcmFtZXMgLSAxKSlcbiAgICAgIDogTWF0aC5mbG9vcihmcHMgKiB0aW1lKTtcbiAgfVxuXG4gIF9jb21wdXRlQ3VycmVudEZyYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcHV0ZUZyYW1lKFxuICAgICAgdGhpcy5wcm9wcy5wbGF5aGVhZCwgdGhpcy5wcm9wcy50aW1lLFxuICAgICAgdGhpcy5wcm9wcy50b3RhbEZyYW1lcywgdGhpcy5wcm9wcy5mcHNcbiAgICApO1xuICB9XG5cbiAgX2dldFNpemVQcm9wcyAoKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogcHJvcHMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHByb3BzLmhlaWdodCxcbiAgICAgIHBpeGVsUmF0aW86IHByb3BzLnBpeGVsUmF0aW8sXG4gICAgICBjYW52YXNXaWR0aDogcHJvcHMuY2FudmFzV2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQ6IHByb3BzLmNhbnZhc0hlaWdodCxcbiAgICAgIHZpZXdwb3J0V2lkdGg6IHByb3BzLnZpZXdwb3J0V2lkdGgsXG4gICAgICB2aWV3cG9ydEhlaWdodDogcHJvcHMudmlld3BvcnRIZWlnaHRcbiAgICB9O1xuICB9XG5cbiAgcnVuICgpIHtcbiAgICBpZiAoIXRoaXMuc2tldGNoKSB0aHJvdyBuZXcgRXJyb3IoJ3Nob3VsZCB3YWl0IHVudGlsIHNrZXRjaCBpcyBsb2FkZWQgYmVmb3JlIHRyeWluZyB0byBwbGF5KCknKTtcblxuICAgIC8vIFN0YXJ0IGFuIGFuaW1hdGlvbiBmcmFtZSBsb29wIGlmIG5lY2Vzc2FyeVxuICAgIGlmICh0aGlzLnNldHRpbmdzLnBsYXlpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9XG5cbiAgICAvLyBMZXQncyBsZXQgdGhpcyB3YXJuaW5nIGhhbmcgYXJvdW5kIGZvciBhIGZldyB2ZXJzaW9ucy4uLlxuICAgIGlmICh0eXBlb2YgdGhpcy5za2V0Y2guZGlzcG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc29sZS53YXJuKCdJbiBjYW52YXMtc2tldGNoQDAuMC4yMyB0aGUgZGlzcG9zZSgpIGV2ZW50IGhhcyBiZWVuIHJlbmFtZWQgdG8gdW5sb2FkKCknKTtcbiAgICB9XG5cbiAgICAvLyBJbiBjYXNlIHdlIGFyZW4ndCBwbGF5aW5nIG9yIGFuaW1hdGVkLCBtYWtlIHN1cmUgd2Ugc3RpbGwgdHJpZ2dlciBiZWdpbiBtZXNzYWdlLi4uXG4gICAgaWYgKCF0aGlzLnByb3BzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuX3NpZ25hbEJlZ2luKCk7XG4gICAgICB0aGlzLnByb3BzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIFJlbmRlciBhbiBpbml0aWFsIGZyYW1lXG4gICAgdGhpcy50aWNrKCk7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9jYW5jZWxUaW1lb3V0cyAoKSB7XG4gICAgaWYgKHRoaXMuX3JhZiAhPSBudWxsICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9yYWYpO1xuICAgICAgdGhpcy5fcmFmID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlY29yZFRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlY29yZFRpbWVvdXQpO1xuICAgICAgdGhpcy5fcmVjb3JkVGltZW91dCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcGxheSAoKSB7XG4gICAgbGV0IGFuaW1hdGUgPSB0aGlzLnNldHRpbmdzLmFuaW1hdGU7XG4gICAgaWYgKCdhbmltYXRpb24nIGluIHRoaXMuc2V0dGluZ3MpIHtcbiAgICAgIGFuaW1hdGUgPSB0cnVlO1xuICAgICAgY29uc29sZS53YXJuKCdbY2FudmFzLXNrZXRjaF0geyBhbmltYXRpb24gfSBoYXMgYmVlbiByZW5hbWVkIHRvIHsgYW5pbWF0ZSB9Jyk7XG4gICAgfVxuICAgIGlmICghYW5pbWF0ZSkgcmV0dXJuO1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYW52YXMtc2tldGNoXSBXQVJOOiBVc2luZyB7IGFuaW1hdGUgfSBpbiBOb2RlLmpzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLnBsYXlpbmcpIHJldHVybjtcbiAgICBpZiAoIXRoaXMucHJvcHMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fc2lnbmFsQmVnaW4oKTtcbiAgICAgIHRoaXMucHJvcHMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3BsYXknLCB0aGlzLnByb3BzLnRpbWUpXG5cbiAgICAvLyBTdGFydCBhIHJlbmRlciBsb29wXG4gICAgdGhpcy5wcm9wcy5wbGF5aW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0cygpO1xuICAgIHRoaXMuX2xhc3RUaW1lID0gcmlnaHROb3coKTtcbiAgICB0aGlzLl9yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGVIYW5kbGVyKTtcbiAgfVxuXG4gIHBhdXNlICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5yZWNvcmRpbmcpIHRoaXMuZW5kUmVjb3JkKCk7XG4gICAgdGhpcy5wcm9wcy5wbGF5aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0cygpO1xuICB9XG5cbiAgdG9nZ2xlUGxheSAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMucGxheWluZykgdGhpcy5wYXVzZSgpO1xuICAgIGVsc2UgdGhpcy5wbGF5KCk7XG4gIH1cblxuICAvLyBTdG9wIGFuZCByZXNldCB0byBmcmFtZSB6ZXJvXG4gIHN0b3AgKCkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLnByb3BzLmZyYW1lID0gMDtcbiAgICB0aGlzLnByb3BzLnBsYXloZWFkID0gMDtcbiAgICB0aGlzLnByb3BzLnRpbWUgPSAwO1xuICAgIHRoaXMucHJvcHMuZGVsdGFUaW1lID0gMDtcbiAgICB0aGlzLnByb3BzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgcmVjb3JkICgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5yZWNvcmRpbmcpIHJldHVybjtcbiAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdbY2FudmFzLXNrZXRjaF0gV0FSTjogUmVjb3JkaW5nIGZyb20gTm9kZS5qcyBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMucHJvcHMucGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5wcm9wcy5yZWNvcmRpbmcgPSB0cnVlO1xuXG4gICAgY29uc3QgZXhwb3J0T3B0cyA9IHRoaXMuX2NyZWF0ZUV4cG9ydE9wdGlvbnMoeyBzZXF1ZW5jZTogdHJ1ZSB9KTtcblxuICAgIGNvbnN0IGZyYW1lSW50ZXJ2YWwgPSAxIC8gdGhpcy5wcm9wcy5mcHM7XG4gICAgLy8gUmVuZGVyIGVhY2ggZnJhbWUgaW4gdGhlIHNlcXVlbmNlXG4gICAgdGhpcy5fY2FuY2VsVGltZW91dHMoKTtcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnByb3BzLnJlY29yZGluZykgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSBmcmFtZUludGVydmFsO1xuICAgICAgdGhpcy50aWNrKCk7XG4gICAgICByZXR1cm4gdGhpcy5leHBvcnRGcmFtZShleHBvcnRPcHRzKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLnByb3BzLnJlY29yZGluZykgcmV0dXJuOyAvLyB3YXMgY2FuY2VsbGVkIGJlZm9yZVxuICAgICAgICAgIHRoaXMucHJvcHMuZGVsdGFUaW1lID0gMDtcbiAgICAgICAgICB0aGlzLnByb3BzLmZyYW1lKys7XG4gICAgICAgICAgaWYgKHRoaXMucHJvcHMuZnJhbWUgPCB0aGlzLnByb3BzLnRvdGFsRnJhbWVzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLnRpbWUgKz0gZnJhbWVJbnRlcnZhbDtcbiAgICAgICAgICAgIHRoaXMucHJvcHMucGxheWhlYWQgPSB0aGlzLl9jb21wdXRlUGxheWhlYWQodGhpcy5wcm9wcy50aW1lLCB0aGlzLnByb3BzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29yZFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRpY2ssIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmluaXNoZWQgcmVjb3JkaW5nJyk7XG4gICAgICAgICAgICB0aGlzLl9zaWduYWxFbmQoKTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVjb3JkKCk7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIHRoaXMucnVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gVHJpZ2dlciBhIHN0YXJ0IGV2ZW50IGJlZm9yZSB3ZSBiZWdpbiByZWNvcmRpbmdcbiAgICBpZiAoIXRoaXMucHJvcHMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5fc2lnbmFsQmVnaW4oKTtcbiAgICAgIHRoaXMucHJvcHMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVHJpZ2dlciAnYmVnaW4gcmVjb3JkJyBldmVudFxuICAgIGlmICh0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2guYmVnaW5SZWNvcmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3dyYXBDb250ZXh0U2NhbGUocHJvcHMgPT4gdGhpcy5za2V0Y2guYmVnaW5SZWNvcmQocHJvcHMpKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWF0ZSBhIHN0cmVhbWluZyBzdGFydCBpZiBuZWNlc3NhcnlcbiAgICBzdHJlYW1TdGFydChleHBvcnRPcHRzKVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICAgIHRoaXMuX3JhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgICB9KTtcbiAgfVxuXG4gIF9zaWduYWxCZWdpbiAoKSB7XG4gICAgaWYgKHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC5iZWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JhcENvbnRleHRTY2FsZShwcm9wcyA9PiB0aGlzLnNrZXRjaC5iZWdpbihwcm9wcykpO1xuICAgIH1cbiAgfVxuXG4gIF9zaWduYWxFbmQgKCkge1xuICAgIGlmICh0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2guZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93cmFwQ29udGV4dFNjYWxlKHByb3BzID0+IHRoaXMuc2tldGNoLmVuZChwcm9wcykpO1xuICAgIH1cbiAgfVxuXG4gIGVuZFJlY29yZCAoKSB7XG4gICAgY29uc3Qgd2FzUmVjb3JkaW5nID0gdGhpcy5wcm9wcy5yZWNvcmRpbmc7XG5cbiAgICB0aGlzLl9jYW5jZWxUaW1lb3V0cygpO1xuICAgIHRoaXMucHJvcHMucmVjb3JkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSAwO1xuICAgIHRoaXMucHJvcHMucGxheWluZyA9IGZhbHNlO1xuXG4gICAgLy8gdGVsbCBDTEkgdGhhdCBzdHJlYW0gaGFzIGZpbmlzaGVkXG4gICAgcmV0dXJuIHN0cmVhbUVuZCgpXG4gICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgLy8gVHJpZ2dlciAnZW5kIHJlY29yZCcgZXZlbnRcbiAgICAgICAgaWYgKHdhc1JlY29yZGluZyAmJiB0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2guZW5kUmVjb3JkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhpcy5fd3JhcENvbnRleHRTY2FsZShwcm9wcyA9PiB0aGlzLnNrZXRjaC5lbmRSZWNvcmQocHJvcHMpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBfY3JlYXRlRXhwb3J0T3B0aW9ucyAob3B0ID0ge30pIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2VxdWVuY2U6IG9wdC5zZXF1ZW5jZSxcbiAgICAgIHNhdmU6IG9wdC5zYXZlLFxuICAgICAgZnBzOiB0aGlzLnByb3BzLmZwcyxcbiAgICAgIGZyYW1lOiBvcHQuc2VxdWVuY2UgPyB0aGlzLnByb3BzLmZyYW1lIDogdW5kZWZpbmVkLFxuICAgICAgZmlsZTogdGhpcy5zZXR0aW5ncy5maWxlLFxuICAgICAgbmFtZTogdGhpcy5zZXR0aW5ncy5uYW1lLFxuICAgICAgcHJlZml4OiB0aGlzLnNldHRpbmdzLnByZWZpeCxcbiAgICAgIHN1ZmZpeDogdGhpcy5zZXR0aW5ncy5zdWZmaXgsXG4gICAgICBlbmNvZGluZzogdGhpcy5zZXR0aW5ncy5lbmNvZGluZyxcbiAgICAgIGVuY29kaW5nUXVhbGl0eTogdGhpcy5zZXR0aW5ncy5lbmNvZGluZ1F1YWxpdHksXG4gICAgICB0aW1lU3RhbXA6IG9wdC50aW1lU3RhbXAgfHwgZ2V0VGltZVN0YW1wKCksXG4gICAgICB0b3RhbEZyYW1lczogaXNGaW5pdGUodGhpcy5wcm9wcy50b3RhbEZyYW1lcykgPyBNYXRoLm1heCgwLCB0aGlzLnByb3BzLnRvdGFsRnJhbWVzKSA6IDEwMDBcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0RnJhbWUgKG9wdCA9IHt9KSB7XG4gICAgaWYgKCF0aGlzLnNrZXRjaCkgcmV0dXJuIFByb21pc2UuYWxsKFtdKTtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2tldGNoLnByZUV4cG9ydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5za2V0Y2gucHJlRXhwb3J0KCk7XG4gICAgfVxuXG4gICAgLy8gT3B0aW9ucyBmb3IgZXhwb3J0IGZ1bmN0aW9uXG4gICAgbGV0IGV4cG9ydE9wdHMgPSB0aGlzLl9jcmVhdGVFeHBvcnRPcHRpb25zKG9wdCk7XG5cbiAgICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgICBsZXQgcCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChjbGllbnQgJiYgb3B0LmNvbW1pdCAmJiB0eXBlb2YgY2xpZW50LmNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3QgY29tbWl0T3B0cyA9IGFzc2lnbih7fSwgZXhwb3J0T3B0cyk7XG4gICAgICBjb25zdCBoYXNoID0gY2xpZW50LmNvbW1pdChjb21taXRPcHRzKTtcbiAgICAgIGlmIChpc1Byb21pc2UoaGFzaCkpIHAgPSBoYXNoO1xuICAgICAgZWxzZSBwID0gUHJvbWlzZS5yZXNvbHZlKGhhc2gpO1xuICAgIH1cblxuICAgIHJldHVybiBwLnRoZW4oaGFzaCA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fZG9FeHBvcnRGcmFtZShhc3NpZ24oe30sIGV4cG9ydE9wdHMsIHsgaGFzaDogaGFzaCB8fCAnJyB9KSk7XG4gICAgfSkudGhlbihyZXN1bHQgPT4ge1xuICAgICAgLy8gTW9zdCBjb21tb24gdXNlY2FzZSBpcyB0byBleHBvcnQgYSBzaW5nbGUgbGF5ZXIsXG4gICAgICAvLyBzbyBsZXQncyBvcHRpbWl6ZSB0aGUgdXNlciBleHBlcmllbmNlIGZvciB0aGF0LlxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDEpIHJldHVybiByZXN1bHRbMF07XG4gICAgICBlbHNlIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICBfZG9FeHBvcnRGcmFtZSAoZXhwb3J0T3B0cyA9IHt9KSB7XG4gICAgdGhpcy5fcHJvcHMuZXhwb3J0aW5nID0gdHJ1ZTtcblxuICAgIC8vIFJlc2l6ZSB0byBvdXRwdXQgcmVzb2x1dGlvblxuICAgIHRoaXMucmVzaXplKCk7XG5cbiAgICAvLyBEcmF3IGF0IHRoaXMgb3V0cHV0IHJlc29sdXRpb25cbiAgICBsZXQgZHJhd1Jlc3VsdCA9IHRoaXMucmVuZGVyKCk7XG5cbiAgICAvLyBUaGUgc2VsZiBvd25lZCBjYW52YXMgKG1heSBiZSB1bmRlZmluZWQuLi4hKVxuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMucHJvcHMuY2FudmFzO1xuXG4gICAgLy8gR2V0IGxpc3Qgb2YgcmVzdWx0cyBmcm9tIHJlbmRlclxuICAgIGlmICh0eXBlb2YgZHJhd1Jlc3VsdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRyYXdSZXN1bHQgPSBbIGNhbnZhcyBdO1xuICAgIH1cbiAgICBkcmF3UmVzdWx0ID0gW10uY29uY2F0KGRyYXdSZXN1bHQpLmZpbHRlcihCb29sZWFuKTtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgY2FudmFzL2ZpbGUgZGVzY3JpcHRvcnMgaW50byBhIGNvbnNpc3RlbnQgZm9ybWF0LFxuICAgIC8vIGFuZCBwdWxsIG91dCBhbnkgZGF0YSBVUkxzIGZyb20gY2FudmFzIGVsZW1lbnRzXG4gICAgZHJhd1Jlc3VsdCA9IGRyYXdSZXN1bHQubWFwKHJlc3VsdCA9PiB7XG4gICAgICBjb25zdCBoYXNEYXRhT2JqZWN0ID0gdHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmICgnZGF0YScgaW4gcmVzdWx0IHx8ICdkYXRhVVJMJyBpbiByZXN1bHQpO1xuICAgICAgY29uc3QgZGF0YSA9IGhhc0RhdGFPYmplY3QgPyByZXN1bHQuZGF0YSA6IHJlc3VsdDtcbiAgICAgIGNvbnN0IG9wdHMgPSBoYXNEYXRhT2JqZWN0ID8gYXNzaWduKHt9LCByZXN1bHQsIHsgZGF0YSB9KSA6IHsgZGF0YSB9O1xuICAgICAgaWYgKGlzQ2FudmFzKGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCBleHBvcnRPcHRzLmVuY29kaW5nO1xuICAgICAgICBjb25zdCBlbmNvZGluZ1F1YWxpdHkgPSBkZWZpbmVkKG9wdHMuZW5jb2RpbmdRdWFsaXR5LCBleHBvcnRPcHRzLmVuY29kaW5nUXVhbGl0eSwgMC45NSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YVVSTCwgZXh0ZW5zaW9uLCB0eXBlIH0gPSBleHBvcnRDYW52YXMoZGF0YSwgeyBlbmNvZGluZywgZW5jb2RpbmdRdWFsaXR5IH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihvcHRzLCB7IGRhdGFVUkwsIGV4dGVuc2lvbiwgdHlwZSB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcHRzO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTm93IHJldHVybiB0byByZWd1bGFyIHJlbmRlcmluZyBtb2RlXG4gICAgdGhpcy5fcHJvcHMuZXhwb3J0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZXNpemUoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgLy8gQW5kIG5vdyB3ZSBjYW4gc2F2ZSBlYWNoIHJlc3VsdFxuICAgIHJldHVybiBQcm9taXNlLmFsbChkcmF3UmVzdWx0Lm1hcCgocmVzdWx0LCBpLCBsYXllckxpc3QpID0+IHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGlmIHJlbmRlcmluZyBtdWx0aXBsZSBsYXllcnMgd2Ugd2lsbCBnaXZlIHRoZW0gaW5kaWNlc1xuICAgICAgY29uc3QgY3VyT3B0ID0gYXNzaWduKHtcbiAgICAgICAgZXh0ZW5zaW9uOiAnJyxcbiAgICAgICAgcHJlZml4OiAnJyxcbiAgICAgICAgc3VmZml4OiAnJ1xuICAgICAgfSwgZXhwb3J0T3B0cywgcmVzdWx0LCB7XG4gICAgICAgIGxheWVyOiBpLFxuICAgICAgICB0b3RhbExheWVyczogbGF5ZXJMaXN0Lmxlbmd0aFxuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIGV4cG9ydCBpcyBleHBsaWNpdGx5IG5vdCBzYXZpbmcsIG1ha2Ugc3VyZSBub3RoaW5nIHNhdmVzXG4gICAgICAvLyBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgbGF5ZXIgc2F2ZSBvcHRpb24sIG9yIGZhbGxiYWNrIHRvIHRydWVcbiAgICAgIGNvbnN0IHNhdmVQYXJhbSA9IGV4cG9ydE9wdHMuc2F2ZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHJlc3VsdC5zYXZlO1xuICAgICAgY3VyT3B0LnNhdmUgPSBzYXZlUGFyYW0gIT09IGZhbHNlO1xuXG4gICAgICAvLyBSZXNvbHZlIGEgZnVsbCBmaWxlbmFtZSBmcm9tIGFsbCB0aGUgb3B0aW9uc1xuICAgICAgY3VyT3B0LmZpbGVuYW1lID0gcmVzb2x2ZUZpbGVuYW1lKGN1ck9wdCk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHNvbWUgcGFyYW1ldGVycyB0aGF0IG1heSBiZSBhbWJpZ3VvdXMgdG8gdGhlIHVzZXJcbiAgICAgIGRlbGV0ZSBjdXJPcHQuZW5jb2Rpbmc7XG4gICAgICBkZWxldGUgY3VyT3B0LmVuY29kaW5nUXVhbGl0eTtcblxuICAgICAgLy8gQ2xlYW4gaXQgdXAgZnVydGhlciBieSBqdXN0IHJlbW92aW5nIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgIGZvciAobGV0IGsgaW4gY3VyT3B0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgY3VyT3B0W2tdID09PSAndW5kZWZpbmVkJykgZGVsZXRlIGN1ck9wdFtrXTtcbiAgICAgIH1cblxuICAgICAgbGV0IHNhdmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgIGlmIChjdXJPcHQuc2F2ZSkge1xuICAgICAgICAvLyBXaGV0aGVyIHRvIGFjdHVhbGx5IHNhdmUgKGRvd25sb2FkKSB0aGlzIGZyYWdtZW50XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdXJPcHQuZGF0YTtcbiAgICAgICAgaWYgKGN1ck9wdC5kYXRhVVJMKSB7XG4gICAgICAgICAgY29uc3QgZGF0YVVSTCA9IGN1ck9wdC5kYXRhVVJMO1xuICAgICAgICAgIHNhdmVQcm9taXNlID0gc2F2ZURhdGFVUkwoZGF0YVVSTCwgY3VyT3B0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYXZlUHJvbWlzZSA9IHNhdmVGaWxlKGRhdGEsIGN1ck9wdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzYXZlUHJvbWlzZS50aGVuKHNhdmVSZXN1bHQgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY3VyT3B0LCBzYXZlUmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pKS50aGVuKGV2ID0+IHtcbiAgICAgIGNvbnN0IHNhdmVkRXZlbnRzID0gZXYuZmlsdGVyKGUgPT4gZS5zYXZlKTtcbiAgICAgIGlmIChzYXZlZEV2ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIExvZyB0aGUgc2F2ZWQgZXhwb3J0c1xuICAgICAgICBjb25zdCBldmVudFdpdGhPdXRwdXQgPSBzYXZlZEV2ZW50cy5maW5kKGUgPT4gZS5vdXRwdXROYW1lKTtcbiAgICAgICAgY29uc3QgaXNDbGllbnQgPSBzYXZlZEV2ZW50cy5zb21lKGUgPT4gZS5jbGllbnQpO1xuICAgICAgICBjb25zdCBpc1N0cmVhbWluZyA9IHNhdmVkRXZlbnRzLnNvbWUoZSA9PiBlLnN0cmVhbSk7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICAvLyBtYW55IGZpbGVzLCBqdXN0IGxvZyBob3cgbWFueSB3ZXJlIGV4cG9ydGVkXG4gICAgICAgIGlmIChzYXZlZEV2ZW50cy5sZW5ndGggPiAxKSBpdGVtID0gc2F2ZWRFdmVudHMubGVuZ3RoO1xuICAgICAgICAvLyBpbiBDTEksIHdlIGtub3cgZXhhY3QgcGF0aCBkaXJuYW1lXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50V2l0aE91dHB1dCkgaXRlbSA9IGAke2V2ZW50V2l0aE91dHB1dC5vdXRwdXROYW1lfS8ke3NhdmVkRXZlbnRzWzBdLmZpbGVuYW1lfWA7XG4gICAgICAgIC8vIGluIGJyb3dzZXIsIHdlIGNhbiBvbmx5IGtub3cgaXQgd2VudCB0byBcImJyb3dzZXIgZG93bmxvYWQgZm9sZGVyXCJcbiAgICAgICAgZWxzZSBpdGVtID0gYCR7c2F2ZWRFdmVudHNbMF0uZmlsZW5hbWV9YDtcbiAgICAgICAgbGV0IG9mU2VxID0gJyc7XG4gICAgICAgIGlmIChleHBvcnRPcHRzLnNlcXVlbmNlKSB7XG4gICAgICAgICAgY29uc3QgaGFzVG90YWxGcmFtZXMgPSBpc0Zpbml0ZSh0aGlzLnByb3BzLnRvdGFsRnJhbWVzKTtcbiAgICAgICAgICBvZlNlcSA9IGhhc1RvdGFsRnJhbWVzID8gYCAoZnJhbWUgJHtleHBvcnRPcHRzLmZyYW1lICsgMX0gLyAke3RoaXMucHJvcHMudG90YWxGcmFtZXN9KWAgOiBgIChmcmFtZSAke2V4cG9ydE9wdHMuZnJhbWV9KWA7XG4gICAgICAgIH0gZWxzZSBpZiAoc2F2ZWRFdmVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIG9mU2VxID0gYCBmaWxlc2A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50ID0gaXNDbGllbnQgPyAnY2FudmFzLXNrZXRjaC1jbGknIDogJ2NhbnZhcy1za2V0Y2gnO1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBpc1N0cmVhbWluZyA/ICdTdHJlYW1pbmcgaW50bycgOiAnRXhwb3J0ZWQnO1xuICAgICAgICBjb25zb2xlLmxvZyhgJWNbJHtjbGllbnR9XSVjICR7YWN0aW9ufSAlYyR7aXRlbX0lYyR7b2ZTZXF9YCwgJ2NvbG9yOiAjOGU4ZThlOycsICdjb2xvcjogaW5pdGlhbDsnLCAnZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2ZvbnQtd2VpZ2h0OiBpbml0aWFsOycpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB0aGlzLnNrZXRjaC5wb3N0RXhwb3J0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuc2tldGNoLnBvc3RFeHBvcnQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBldjtcbiAgICB9KTtcbiAgfVxuXG4gIF93cmFwQ29udGV4dFNjYWxlIChjYikge1xuICAgIHRoaXMuX3ByZVJlbmRlcigpO1xuICAgIGNiKHRoaXMucHJvcHMpO1xuICAgIHRoaXMuX3Bvc3RSZW5kZXIoKTtcbiAgfVxuXG4gIF9wcmVSZW5kZXIgKCkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFNjYWxlIGNvbnRleHQgZm9yIHVuaXQgc2l6aW5nXG4gICAgaWYgKCF0aGlzLnByb3BzLmdsICYmIHByb3BzLmNvbnRleHQgJiYgIXByb3BzLnA1KSB7XG4gICAgICBwcm9wcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnNjYWxlQ29udGV4dCAhPT0gZmFsc2UpIHtcbiAgICAgICAgcHJvcHMuY29udGV4dC5zY2FsZShwcm9wcy5zY2FsZVgsIHByb3BzLnNjYWxlWSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wcy5wNSkge1xuICAgICAgcHJvcHMucDUuc2NhbGUocHJvcHMuc2NhbGVYIC8gcHJvcHMucGl4ZWxSYXRpbywgcHJvcHMuc2NhbGVZIC8gcHJvcHMucGl4ZWxSYXRpbyk7XG4gICAgfVxuICB9XG5cbiAgX3Bvc3RSZW5kZXIgKCkge1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIGlmICghdGhpcy5wcm9wcy5nbCAmJiBwcm9wcy5jb250ZXh0ICYmICFwcm9wcy5wNSkge1xuICAgICAgcHJvcHMuY29udGV4dC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgLy8gRmx1c2ggYnkgZGVmYXVsdCwgdGhpcyBtYXkgYmUgcmV2aXNpdGVkIGF0IGEgbGF0ZXIgcG9pbnQuXG4gICAgLy8gV2UgZG8gdGhpcyB0byBlbnN1cmUgdG9EYXRhVVJMIGNhbiBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgLy8gTW9zdCBsaWtlbHkgYnJvd3NlcnMgYWxyZWFkeSBoYW5kbGUgdGhpcywgc28gd2UgbWF5IHJldmlzaXQgdGhpcyBhbmRcbiAgICAvLyByZW1vdmUgaXQgaWYgaXQgaW1wcm92ZXMgcGVyZm9ybWFuY2Ugd2l0aG91dCBhbnkgdXNhYmlsaXR5IGlzc3Vlcy5cbiAgICBpZiAocHJvcHMuZ2wgJiYgdGhpcy5zZXR0aW5ncy5mbHVzaCAhPT0gZmFsc2UgJiYgIXByb3BzLnA1KSB7XG4gICAgICBwcm9wcy5nbC5mbHVzaCgpO1xuICAgIH1cbiAgfVxuXG4gIHRpY2sgKCkge1xuICAgIGlmICh0aGlzLnNrZXRjaCAmJiB0eXBlb2YgdGhpcy5za2V0Y2gudGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fcHJlUmVuZGVyKCk7XG4gICAgICB0aGlzLnNrZXRjaC50aWNrKHRoaXMucHJvcHMpO1xuICAgICAgdGhpcy5fcG9zdFJlbmRlcigpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlciAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMucDUpIHtcbiAgICAgIHRoaXMuX2xhc3RSZWRyYXdSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnByb3BzLnA1LnJlZHJhdygpO1xuICAgICAgcmV0dXJuIHRoaXMuX2xhc3RSZWRyYXdSZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnN1Ym1pdERyYXdDYWxsKCk7XG4gICAgfVxuICB9XG5cbiAgc3VibWl0RHJhd0NhbGwgKCkge1xuICAgIGlmICghdGhpcy5za2V0Y2gpIHJldHVybjtcblxuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcbiAgICB0aGlzLl9wcmVSZW5kZXIoKTtcblxuICAgIGxldCBkcmF3UmVzdWx0O1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLnNrZXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZHJhd1Jlc3VsdCA9IHRoaXMuc2tldGNoKHByb3BzKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLnNrZXRjaC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRyYXdSZXN1bHQgPSB0aGlzLnNrZXRjaC5yZW5kZXIocHJvcHMpO1xuICAgIH1cblxuICAgIHRoaXMuX3Bvc3RSZW5kZXIoKTtcblxuICAgIHJldHVybiBkcmF3UmVzdWx0O1xuICB9XG5cbiAgdXBkYXRlIChvcHQgPSB7fSkge1xuICAgIC8vIEN1cnJlbnRseSB1cGRhdGUoKSBpcyBvbmx5IGZvY3VzZWQgb24gcmVzaXppbmcsXG4gICAgLy8gYnV0IGxhdGVyIHdlIHdpbGwgc3VwcG9ydCBvdGhlciBvcHRpb25zIGxpa2Ugc3dpdGNoaW5nXG4gICAgLy8gZnJhbWVzIGFuZCBzdWNoLlxuICAgIGNvbnN0IG5vdFlldFN1cHBvcnRlZCA9IFtcbiAgICAgICdhbmltYXRlJ1xuICAgIF07XG5cbiAgICBPYmplY3Qua2V5cyhvcHQpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChub3RZZXRTdXBwb3J0ZWQuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTb3JyeSwgdGhlIHsgJHtrZXl9IH0gb3B0aW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIHdpdGggdXBkYXRlKCkuYCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbGRDYW52YXMgPSB0aGlzLl9zZXR0aW5ncy5jYW52YXM7XG4gICAgY29uc3Qgb2xkQ29udGV4dCA9IHRoaXMuX3NldHRpbmdzLmNvbnRleHQ7XG5cbiAgICAvLyBNZXJnZSBuZXcgb3B0aW9ucyBpbnRvIHNldHRpbmdzXG4gICAgZm9yIChsZXQga2V5IGluIG9wdCkge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRba2V5XTtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7IC8vIGlnbm9yZSB1bmRlZmluZWRcbiAgICAgICAgdGhpcy5fc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1lcmdlIGluIHRpbWUgcHJvcHNcbiAgICBjb25zdCB0aW1lT3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX3NldHRpbmdzLCBvcHQpO1xuICAgIGlmICgndGltZScgaW4gb3B0ICYmICdmcmFtZScgaW4gb3B0KSB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzaG91bGQgc3BlY2lmeSB7IHRpbWUgfSBvciB7IGZyYW1lIH0gYnV0IG5vdCBib3RoJyk7XG4gICAgZWxzZSBpZiAoJ3RpbWUnIGluIG9wdCkgZGVsZXRlIHRpbWVPcHRzLmZyYW1lO1xuICAgIGVsc2UgaWYgKCdmcmFtZScgaW4gb3B0KSBkZWxldGUgdGltZU9wdHMudGltZTtcbiAgICBpZiAoJ2R1cmF0aW9uJyBpbiBvcHQgJiYgJ3RvdGFsRnJhbWVzJyBpbiBvcHQpIHRocm93IG5ldyBFcnJvcignWW91IHNob3VsZCBzcGVjaWZ5IHsgZHVyYXRpb24gfSBvciB7IHRvdGFsRnJhbWVzIH0gYnV0IG5vdCBib3RoJyk7XG4gICAgZWxzZSBpZiAoJ2R1cmF0aW9uJyBpbiBvcHQpIGRlbGV0ZSB0aW1lT3B0cy50b3RhbEZyYW1lcztcbiAgICBlbHNlIGlmICgndG90YWxGcmFtZXMnIGluIG9wdCkgZGVsZXRlIHRpbWVPcHRzLmR1cmF0aW9uO1xuXG4gICAgLy8gTWVyZ2UgaW4gdXNlciBkYXRhIHdpdGhvdXQgY29weWluZ1xuICAgIGlmICgnZGF0YScgaW4gb3B0KSB0aGlzLl9wcm9wcy5kYXRhID0gb3B0LmRhdGE7XG5cbiAgICBjb25zdCB0aW1lUHJvcHMgPSB0aGlzLmdldFRpbWVQcm9wcyh0aW1lT3B0cyk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcm9wcywgdGltZVByb3BzKTtcblxuICAgIC8vIElmIGVpdGhlciBjYW52YXMgb3IgY29udGV4dCBpcyBjaGFuZ2VkLCB3ZSBzaG91bGQgcmUtdXBkYXRlXG4gICAgaWYgKG9sZENhbnZhcyAhPT0gdGhpcy5fc2V0dGluZ3MuY2FudmFzIHx8IG9sZENvbnRleHQgIT09IHRoaXMuX3NldHRpbmdzLmNvbnRleHQpIHtcbiAgICAgIGNvbnN0IHsgY2FudmFzLCBjb250ZXh0IH0gPSBjcmVhdGVDYW52YXModGhpcy5fc2V0dGluZ3MpO1xuXG4gICAgICB0aGlzLnByb3BzLmNhbnZhcyA9IGNhbnZhcztcbiAgICAgIHRoaXMucHJvcHMuY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgIC8vIERlbGV0ZSBvciBhZGQgYSAnZ2wnIHByb3AgZm9yIGNvbnZlbmllbmNlXG4gICAgICB0aGlzLl9zZXR1cEdMS2V5KCk7XG5cbiAgICAgIC8vIFJlLW1vdW50IHRoZSBuZXcgY2FudmFzIGlmIGl0IGhhcyBubyBwYXJlbnRcbiAgICAgIHRoaXMuX2FwcGVuZENhbnZhc0lmTmVlZGVkKCk7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHRvIHN1cHBvcnQgUDUuanNcbiAgICBpZiAob3B0LnA1ICYmIHR5cGVvZiBvcHQucDUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMucHJvcHMucDUgPSBvcHQucDU7XG4gICAgICB0aGlzLnByb3BzLnA1LmRyYXcgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc1A1UmVzaXppbmcpIHJldHVybjtcbiAgICAgICAgdGhpcy5fbGFzdFJlZHJhd1Jlc3VsdCA9IHRoaXMuc3VibWl0RHJhd0NhbGwoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHBsYXlpbmcgc3RhdGUgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKCdwbGF5aW5nJyBpbiBvcHQpIHtcbiAgICAgIGlmIChvcHQucGxheWluZykgdGhpcy5wbGF5KCk7XG4gICAgICBlbHNlIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICBjaGVja1NldHRpbmdzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIC8vIERyYXcgbmV3IGZyYW1lXG4gICAgdGhpcy5yZXNpemUoKTtcbiAgICB0aGlzLnJlbmRlcigpO1xuICAgIHJldHVybiB0aGlzLnByb3BzO1xuICB9XG5cbiAgcmVzaXplICgpIHtcbiAgICBjb25zdCBvbGRTaXplcyA9IHRoaXMuX2dldFNpemVQcm9wcygpO1xuXG4gICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgIGNvbnN0IHByb3BzID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFJlY29tcHV0ZSBuZXcgcHJvcGVydGllcyBiYXNlZCBvbiBjdXJyZW50IHNldHVwXG4gICAgY29uc3QgbmV3UHJvcHMgPSByZXNpemVDYW52YXMocHJvcHMsIHNldHRpbmdzKTtcblxuICAgIC8vIEFzc2lnbiB0byBjdXJyZW50IHByb3BzXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcm9wcywgbmV3UHJvcHMpO1xuXG4gICAgLy8gTm93IHdlIGFjdHVhbGx5IHVwZGF0ZSB0aGUgY2FudmFzIHdpZHRoL2hlaWdodCBhbmQgc3R5bGUgcHJvcHNcbiAgICBjb25zdCB7XG4gICAgICBwaXhlbFJhdGlvLFxuICAgICAgY2FudmFzV2lkdGgsXG4gICAgICBjYW52YXNIZWlnaHQsXG4gICAgICBzdHlsZVdpZHRoLFxuICAgICAgc3R5bGVIZWlnaHRcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIC8vIFVwZGF0ZSBjYW52YXMgc2V0dGluZ3NcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnByb3BzLmNhbnZhcztcbiAgICBpZiAoY2FudmFzICYmIHNldHRpbmdzLnJlc2l6ZUNhbnZhcyAhPT0gZmFsc2UpIHtcbiAgICAgIGlmIChwcm9wcy5wNSkge1xuICAgICAgICAvLyBQNS5qcyBzcGVjaWZpYyBlZGdlIGNhc2VcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5faXNQNVJlc2l6aW5nID0gdHJ1ZTtcbiAgICAgICAgICAvLyBUaGlzIGNhdXNlcyBhIHJlLWRyYXcgOlxcIHNvIHdlIGlnbm9yZSBkcmF3cyBpbiB0aGUgbWVhbiB0aW1lLi4uIHNvcnRhIGhhY2t5XG4gICAgICAgICAgcHJvcHMucDUucGl4ZWxEZW5zaXR5KHBpeGVsUmF0aW8pO1xuICAgICAgICAgIHByb3BzLnA1LnJlc2l6ZUNhbnZhcyhjYW52YXNXaWR0aCAvIHBpeGVsUmF0aW8sIGNhbnZhc0hlaWdodCAvIHBpeGVsUmF0aW8sIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLl9pc1A1UmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yY2UgY2FudmFzIHNpemVcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGgpIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICBpZiAoY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGNhbnZhcyBzdHlsZVxuICAgICAgaWYgKGlzQnJvd3NlcigpICYmIHNldHRpbmdzLnN0eWxlQ2FudmFzICE9PSBmYWxzZSkge1xuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHtzdHlsZVdpZHRofXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke3N0eWxlSGVpZ2h0fXB4YDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBuZXdTaXplcyA9IHRoaXMuX2dldFNpemVQcm9wcygpO1xuICAgIGxldCBjaGFuZ2VkID0gIWRlZXBFcXVhbChvbGRTaXplcywgbmV3U2l6ZXMpO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9zaXplQ2hhbmdlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIF9zaXplQ2hhbmdlZCAoKSB7XG4gICAgLy8gU2VuZCByZXNpemUgZXZlbnQgdG8gc2tldGNoXG4gICAgaWYgKHRoaXMuc2tldGNoICYmIHR5cGVvZiB0aGlzLnNrZXRjaC5yZXNpemUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuc2tldGNoLnJlc2l6ZSh0aGlzLnByb3BzKTtcbiAgICB9XG4gIH1cblxuICBhbmltYXRlICgpIHtcbiAgICBpZiAoIXRoaXMucHJvcHMucGxheWluZykgcmV0dXJuO1xuICAgIGlmICghaXNCcm93c2VyKCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tjYW52YXMtc2tldGNoXSBXQVJOOiBBbmltYXRpb24gaW4gTm9kZS5qcyBpcyBub3QgeWV0IHN1cHBvcnRlZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2FuaW1hdGVIYW5kbGVyKTtcblxuICAgIGxldCBub3cgPSByaWdodE5vdygpO1xuXG4gICAgY29uc3QgZnBzID0gdGhpcy5wcm9wcy5mcHM7XG4gICAgY29uc3QgZnJhbWVJbnRlcnZhbE1TID0gMTAwMCAvIGZwcztcbiAgICBsZXQgZGVsdGFUaW1lTVMgPSBub3cgLSB0aGlzLl9sYXN0VGltZTtcblxuICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5wcm9wcy5kdXJhdGlvbjtcbiAgICBjb25zdCBoYXNEdXJhdGlvbiA9IHR5cGVvZiBkdXJhdGlvbiA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUoZHVyYXRpb24pO1xuXG4gICAgbGV0IGlzTmV3RnJhbWUgPSB0cnVlO1xuICAgIGNvbnN0IHBsYXliYWNrUmF0ZSA9IHRoaXMuc2V0dGluZ3MucGxheWJhY2tSYXRlO1xuICAgIGlmIChwbGF5YmFja1JhdGUgPT09ICdmaXhlZCcpIHtcbiAgICAgIGRlbHRhVGltZU1TID0gZnJhbWVJbnRlcnZhbE1TO1xuICAgIH0gZWxzZSBpZiAocGxheWJhY2tSYXRlID09PSAndGhyb3R0bGUnKSB7XG4gICAgICBpZiAoZGVsdGFUaW1lTVMgPiBmcmFtZUludGVydmFsTVMpIHtcbiAgICAgICAgbm93ID0gbm93IC0gKGRlbHRhVGltZU1TICUgZnJhbWVJbnRlcnZhbE1TKTtcbiAgICAgICAgdGhpcy5fbGFzdFRpbWUgPSBub3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc05ld0ZyYW1lID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3RUaW1lID0gbm93O1xuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhVGltZSA9IGRlbHRhVGltZU1TIC8gMTAwMDtcbiAgICBsZXQgbmV3VGltZSA9IHRoaXMucHJvcHMudGltZSArIGRlbHRhVGltZSAqIHRoaXMucHJvcHMudGltZVNjYWxlO1xuXG4gICAgLy8gSGFuZGxlIHJldmVyc2UgdGltZSBzY2FsZVxuICAgIGlmIChuZXdUaW1lIDwgMCAmJiBoYXNEdXJhdGlvbikge1xuICAgICAgbmV3VGltZSA9IGR1cmF0aW9uICsgbmV3VGltZTtcbiAgICB9XG5cbiAgICAvLyBSZS1zdGFydCBhbmltYXRpb25cbiAgICBsZXQgaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIGxldCBpc0xvb3BTdGFydCA9IGZhbHNlO1xuXG4gICAgY29uc3QgbG9vcGluZyA9IHRoaXMuc2V0dGluZ3MubG9vcCAhPT0gZmFsc2U7XG5cbiAgICBpZiAoaGFzRHVyYXRpb24gJiYgbmV3VGltZSA+PSBkdXJhdGlvbikge1xuICAgICAgLy8gUmUtc3RhcnQgYW5pbWF0aW9uXG4gICAgICBpZiAobG9vcGluZykge1xuICAgICAgICBpc05ld0ZyYW1lID0gdHJ1ZTtcbiAgICAgICAgbmV3VGltZSA9IG5ld1RpbWUgJSBkdXJhdGlvbjtcbiAgICAgICAgaXNMb29wU3RhcnQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNOZXdGcmFtZSA9IGZhbHNlO1xuICAgICAgICBuZXdUaW1lID0gZHVyYXRpb247XG4gICAgICAgIGlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zaWduYWxFbmQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNOZXdGcmFtZSkge1xuICAgICAgdGhpcy5wcm9wcy5kZWx0YVRpbWUgPSBkZWx0YVRpbWU7XG4gICAgICB0aGlzLnByb3BzLnRpbWUgPSBuZXdUaW1lO1xuICAgICAgdGhpcy5wcm9wcy5wbGF5aGVhZCA9IHRoaXMuX2NvbXB1dGVQbGF5aGVhZChuZXdUaW1lLCBkdXJhdGlvbik7XG4gICAgICBjb25zdCBsYXN0RnJhbWUgPSB0aGlzLnByb3BzLmZyYW1lO1xuICAgICAgdGhpcy5wcm9wcy5mcmFtZSA9IHRoaXMuX2NvbXB1dGVDdXJyZW50RnJhbWUoKTtcbiAgICAgIGlmIChpc0xvb3BTdGFydCkgdGhpcy5fc2lnbmFsQmVnaW4oKTtcbiAgICAgIGlmIChsYXN0RnJhbWUgIT09IHRoaXMucHJvcHMuZnJhbWUpIHRoaXMudGljaygpO1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIHRoaXMucHJvcHMuZGVsdGFUaW1lID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNGaW5pc2hlZCkge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRpc3BhdGNoIChjYikge1xuICAgIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignbXVzdCBwYXNzIGZ1bmN0aW9uIGludG8gZGlzcGF0Y2goKScpO1xuICAgIGNiKHRoaXMucHJvcHMpO1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICBtb3VudCAoKSB7XG4gICAgdGhpcy5fYXBwZW5kQ2FudmFzSWZOZWVkZWQoKTtcbiAgfVxuXG4gIHVubW91bnQgKCkge1xuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xuICAgICAgdGhpcy5fa2V5Ym9hcmRTaG9ydGN1dHMuZGV0YWNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnByb3BzLmNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLnByb3BzLmNhbnZhcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMucHJvcHMuY2FudmFzKTtcbiAgICB9XG4gIH1cblxuICBfYXBwZW5kQ2FudmFzSWZOZWVkZWQgKCkge1xuICAgIGlmICghaXNCcm93c2VyKCkpIHJldHVybjtcbiAgICBpZiAodGhpcy5zZXR0aW5ncy5wYXJlbnQgIT09IGZhbHNlICYmICh0aGlzLnByb3BzLmNhbnZhcyAmJiAhdGhpcy5wcm9wcy5jYW52YXMucGFyZW50RWxlbWVudCkpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRQYXJlbnQgPSB0aGlzLnNldHRpbmdzLnBhcmVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgICAgZGVmYXVsdFBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLnByb3BzLmNhbnZhcyk7XG4gICAgfVxuICB9XG5cbiAgX3NldHVwR0xLZXkgKCkge1xuICAgIGlmICh0aGlzLnByb3BzLmNvbnRleHQpIHtcbiAgICAgIGlmIChpc1dlYkdMQ29udGV4dCh0aGlzLnByb3BzLmNvbnRleHQpKSB7XG4gICAgICAgIHRoaXMuX3Byb3BzLmdsID0gdGhpcy5wcm9wcy5jb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3Byb3BzLmdsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldFRpbWVQcm9wcyAoc2V0dGluZ3MgPSB7fSkge1xuICAgIC8vIEdldCB0aW1pbmcgZGF0YVxuICAgIGxldCBkdXJhdGlvbiA9IHNldHRpbmdzLmR1cmF0aW9uO1xuICAgIGxldCB0b3RhbEZyYW1lcyA9IHNldHRpbmdzLnRvdGFsRnJhbWVzO1xuICAgIGNvbnN0IHRpbWVTY2FsZSA9IGRlZmluZWQoc2V0dGluZ3MudGltZVNjYWxlLCAxKTtcbiAgICBjb25zdCBmcHMgPSBkZWZpbmVkKHNldHRpbmdzLmZwcywgMjQpO1xuICAgIGNvbnN0IGhhc0R1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShkdXJhdGlvbik7XG4gICAgY29uc3QgaGFzVG90YWxGcmFtZXMgPSB0eXBlb2YgdG90YWxGcmFtZXMgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHRvdGFsRnJhbWVzKTtcblxuICAgIGNvbnN0IHRvdGFsRnJhbWVzRnJvbUR1cmF0aW9uID0gaGFzRHVyYXRpb24gPyBNYXRoLmZsb29yKGZwcyAqIGR1cmF0aW9uKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBkdXJhdGlvbkZyb21Ub3RhbEZyYW1lcyA9IGhhc1RvdGFsRnJhbWVzID8gKHRvdGFsRnJhbWVzIC8gZnBzKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoaGFzRHVyYXRpb24gJiYgaGFzVG90YWxGcmFtZXMgJiYgdG90YWxGcmFtZXNGcm9tRHVyYXRpb24gIT09IHRvdGFsRnJhbWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzaG91bGQgc3BlY2lmeSBlaXRoZXIgZHVyYXRpb24gb3IgdG90YWxGcmFtZXMsIGJ1dCBub3QgYm90aC4gT3IsIHRoZXkgbXVzdCBtYXRjaCBleGFjdGx5LicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuZGltZW5zaW9ucyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNldHRpbmdzLnVuaXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKGBZb3UndmUgc3BlY2lmaWVkIGEgeyB1bml0cyB9IHNldHRpbmcgYnV0IG5vIHsgZGltZW5zaW9uIH0sIHNvIHRoZSB1bml0cyB3aWxsIGJlIGlnbm9yZWQuYCk7XG4gICAgfVxuXG4gICAgdG90YWxGcmFtZXMgPSBkZWZpbmVkKHRvdGFsRnJhbWVzLCB0b3RhbEZyYW1lc0Zyb21EdXJhdGlvbiwgSW5maW5pdHkpO1xuICAgIGR1cmF0aW9uID0gZGVmaW5lZChkdXJhdGlvbiwgZHVyYXRpb25Gcm9tVG90YWxGcmFtZXMsIEluZmluaXR5KTtcblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHNldHRpbmdzLnRpbWU7XG4gICAgY29uc3Qgc3RhcnRGcmFtZSA9IHNldHRpbmdzLmZyYW1lO1xuICAgIGNvbnN0IGhhc1N0YXJ0VGltZSA9IHR5cGVvZiBzdGFydFRpbWUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHN0YXJ0VGltZSk7XG4gICAgY29uc3QgaGFzU3RhcnRGcmFtZSA9IHR5cGVvZiBzdGFydEZyYW1lID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZShzdGFydEZyYW1lKTtcblxuICAgIC8vIHN0YXJ0IGF0IHplcm8gdW5sZXNzIHVzZXIgc3BlY2lmaWVzIGZyYW1lIG9yIHRpbWUgKGJ1dCBub3QgYm90aCBtaXNtYXRjaGVkKVxuICAgIGxldCB0aW1lID0gMDtcbiAgICBsZXQgZnJhbWUgPSAwO1xuICAgIGxldCBwbGF5aGVhZCA9IDA7XG4gICAgaWYgKGhhc1N0YXJ0VGltZSAmJiBoYXNTdGFydEZyYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBzaG91bGQgc3BlY2lmeSBlaXRoZXIgc3RhcnQgZnJhbWUgb3IgdGltZSwgYnV0IG5vdCBib3RoLicpO1xuICAgIH0gZWxzZSBpZiAoaGFzU3RhcnRUaW1lKSB7XG4gICAgICAvLyBVc2VyIHNwZWNpZmllcyB0aW1lLCB3ZSBpbmZlciBmcmFtZXMgZnJvbSBGUFNcbiAgICAgIHRpbWUgPSBzdGFydFRpbWU7XG4gICAgICBwbGF5aGVhZCA9IHRoaXMuX2NvbXB1dGVQbGF5aGVhZCh0aW1lLCBkdXJhdGlvbik7XG4gICAgICBmcmFtZSA9IHRoaXMuX2NvbXB1dGVGcmFtZShcbiAgICAgICAgcGxheWhlYWQsIHRpbWUsXG4gICAgICAgIHRvdGFsRnJhbWVzLCBmcHNcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChoYXNTdGFydEZyYW1lKSB7XG4gICAgICAvLyBVc2VyIHNwZWNpZmllcyBmcmFtZSBudW1iZXIsIHdlIGluZmVyIHRpbWUgZnJvbSBGUFNcbiAgICAgIGZyYW1lID0gc3RhcnRGcmFtZTtcbiAgICAgIHRpbWUgPSBmcmFtZSAvIGZwcztcbiAgICAgIHBsYXloZWFkID0gdGhpcy5fY29tcHV0ZVBsYXloZWFkKHRpbWUsIGR1cmF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGxheWhlYWQsXG4gICAgICB0aW1lLFxuICAgICAgZnJhbWUsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRvdGFsRnJhbWVzLFxuICAgICAgZnBzLFxuICAgICAgdGltZVNjYWxlXG4gICAgfTtcbiAgfVxuXG4gIHNldHVwIChzZXR0aW5ncyA9IHt9KSB7XG4gICAgaWYgKHRoaXMuc2tldGNoKSB0aHJvdyBuZXcgRXJyb3IoJ011bHRpcGxlIHNldHVwKCkgY2FsbHMgbm90IHlldCBzdXBwb3J0ZWQuJyk7XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLCB0aGlzLl9zZXR0aW5ncyk7XG5cbiAgICBjaGVja1NldHRpbmdzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIC8vIEdldCBpbml0aWFsIGNhbnZhcyAmIGNvbnRleHRcbiAgICBjb25zdCB7IGNvbnRleHQsIGNhbnZhcyB9ID0gY3JlYXRlQ2FudmFzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIGNvbnN0IHRpbWVQcm9wcyA9IHRoaXMuZ2V0VGltZVByb3BzKHRoaXMuX3NldHRpbmdzKTtcblxuICAgIC8vIEluaXRpYWwgcmVuZGVyIHN0YXRlIGZlYXR1cmVzXG4gICAgdGhpcy5fcHJvcHMgPSB7XG4gICAgICAuLi50aW1lUHJvcHMsXG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0LFxuICAgICAgZGVsdGFUaW1lOiAwLFxuICAgICAgc3RhcnRlZDogZmFsc2UsXG4gICAgICBleHBvcnRpbmc6IGZhbHNlLFxuICAgICAgcGxheWluZzogZmFsc2UsXG4gICAgICByZWNvcmRpbmc6IGZhbHNlLFxuICAgICAgc2V0dGluZ3M6IHRoaXMuc2V0dGluZ3MsXG4gICAgICBkYXRhOiB0aGlzLnNldHRpbmdzLmRhdGEsXG5cbiAgICAgIC8vIEV4cG9ydCBzb21lIHNwZWNpZmljIGFjdGlvbnMgdG8gdGhlIHNrZXRjaFxuICAgICAgcmVuZGVyOiAoKSA9PiB0aGlzLnJlbmRlcigpLFxuICAgICAgdG9nZ2xlUGxheTogKCkgPT4gdGhpcy50b2dnbGVQbGF5KCksXG4gICAgICBkaXNwYXRjaDogKGNiKSA9PiB0aGlzLmRpc3BhdGNoKGNiKSxcbiAgICAgIHRpY2s6ICgpID0+IHRoaXMudGljaygpLFxuICAgICAgcmVzaXplOiAoKSA9PiB0aGlzLnJlc2l6ZSgpLFxuICAgICAgdXBkYXRlOiAob3B0KSA9PiB0aGlzLnVwZGF0ZShvcHQpLFxuICAgICAgZXhwb3J0RnJhbWU6IG9wdCA9PiB0aGlzLmV4cG9ydEZyYW1lKG9wdCksXG4gICAgICByZWNvcmQ6ICgpID0+IHRoaXMucmVjb3JkKCksXG4gICAgICBwbGF5OiAoKSA9PiB0aGlzLnBsYXkoKSxcbiAgICAgIHBhdXNlOiAoKSA9PiB0aGlzLnBhdXNlKCksXG4gICAgICBzdG9wOiAoKSA9PiB0aGlzLnN0b3AoKVxuICAgIH07XG5cbiAgICAvLyBGb3IgV2ViR0wgc2tldGNoZXMsIGEgZ2wgdmFyaWFibGUgcmVhZHMgYSBiaXQgYmV0dGVyXG4gICAgdGhpcy5fc2V0dXBHTEtleSgpO1xuXG4gICAgLy8gVHJpZ2dlciBpbml0aWFsIHJlc2l6ZSBub3cgc28gdGhhdCBjYW52YXMgaXMgYWxyZWFkeSBzaXplZFxuICAgIC8vIGJ5IHRoZSB0aW1lIHdlIGxvYWQgdGhlIHNrZXRjaFxuICAgIHRoaXMucmVzaXplKCk7XG4gIH1cblxuICBsb2FkQW5kUnVuIChjYW52YXNTa2V0Y2gsIG5ld1NldHRpbmdzKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZChjYW52YXNTa2V0Y2gsIG5ld1NldHRpbmdzKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMucnVuKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KTtcbiAgfVxuXG4gIHVubG9hZCAoKSB7XG4gICAgdGhpcy5wYXVzZSgpO1xuICAgIGlmICghdGhpcy5za2V0Y2gpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRoaXMuc2tldGNoLnVubG9hZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd3JhcENvbnRleHRTY2FsZShwcm9wcyA9PiB0aGlzLnNrZXRjaC51bmxvYWQocHJvcHMpKTtcbiAgICB9XG4gICAgdGhpcy5fc2tldGNoID0gbnVsbDtcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMudW5sb2FkKCk7XG4gICAgdGhpcy51bm1vdW50KCk7XG4gIH1cblxuICBsb2FkIChjcmVhdGVTa2V0Y2gsIG5ld1NldHRpbmdzKSB7XG4gICAgLy8gVXNlciBkaWRuJ3Qgc3BlY2lmeSBhIGZ1bmN0aW9uXG4gICAgaWYgKHR5cGVvZiBjcmVhdGVTa2V0Y2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGZ1bmN0aW9uIG11c3QgdGFrZSBpbiBhIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIuIEV4YW1wbGU6XFxuICBjYW52YXNTa2V0Y2hlcigoKSA9PiB7IC4uLiB9LCBzZXR0aW5ncyknKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5za2V0Y2gpIHtcbiAgICAgIHRoaXMudW5sb2FkKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdTZXR0aW5ncyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudXBkYXRlKG5ld1NldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgdHJpY2t5IGNhc2U7IHdlIHNldCB1cCB0aGUgYXV0by1zY2FsaW5nIGhlcmVcbiAgICAvLyBpbiBjYXNlIHRoZSB1c2VyIGRlY2lkZXMgdG8gcmVuZGVyIGFueXRoaW5nIHRvIHRoZSBjb250ZXh0ICpiZWZvcmUqIHRoZVxuICAgIC8vIHJlbmRlcigpIGZ1bmN0aW9uLi4uIEhvd2V2ZXIsIHVzZXJzIHNob3VsZCBpbnN0ZWFkIHVzZSBiZWdpbigpIGZ1bmN0aW9uIGZvciB0aGF0LlxuICAgIHRoaXMuX3ByZVJlbmRlcigpO1xuXG4gICAgbGV0IHByZWxvYWQgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgIC8vIEJlY2F1c2Ugb2YgUDUuanMncyB1bnVzdWFsIHN0cnVjdHVyZSwgd2UgaGF2ZSB0byBkbyBhIGJpdCBvZlxuICAgIC8vIGxpYnJhcnktc3BlY2lmaWMgY2hhbmdlcyB0byBzdXBwb3J0IGl0IHByb3Blcmx5LlxuICAgIGlmICh0aGlzLnNldHRpbmdzLnA1KSB7XG4gICAgICBpZiAoIWlzQnJvd3NlcigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignW2NhbnZhcy1za2V0Y2hdIEVSUk9SOiBVc2luZyBwNS5qcyBpbiBOb2RlLmpzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgIH1cbiAgICAgIHByZWxvYWQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgbGV0IFA1Q29uc3RydWN0b3IgPSB0aGlzLnNldHRpbmdzLnA1O1xuICAgICAgICBsZXQgcHJlbG9hZDtcbiAgICAgICAgaWYgKFA1Q29uc3RydWN0b3IucDUpIHtcbiAgICAgICAgICBwcmVsb2FkID0gUDVDb25zdHJ1Y3Rvci5wcmVsb2FkO1xuICAgICAgICAgIFA1Q29uc3RydWN0b3IgPSBQNUNvbnN0cnVjdG9yLnA1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHNrZXRjaCBzZXR1cDsgZGlzYWJsZSBsb29wLCBzZXQgc2l6aW5nLCBldGMuXG4gICAgICAgIGNvbnN0IHA1U2tldGNoID0gcDUgPT4ge1xuICAgICAgICAgIC8vIEhvb2sgaW4gcHJlbG9hZCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiAocHJlbG9hZCkgcDUucHJlbG9hZCA9ICgpID0+IHByZWxvYWQocDUpO1xuICAgICAgICAgIHA1LnNldHVwID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgaXNHTCA9IHRoaXMuc2V0dGluZ3MuY29udGV4dCA9PT0gJ3dlYmdsJztcbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVyID0gaXNHTCA/IHA1LldFQkdMIDogcDUuUDJEO1xuICAgICAgICAgICAgcDUubm9Mb29wKCk7XG4gICAgICAgICAgICBwNS5waXhlbERlbnNpdHkocHJvcHMucGl4ZWxSYXRpbyk7XG4gICAgICAgICAgICBwNS5jcmVhdGVDYW52YXMocHJvcHMudmlld3BvcnRXaWR0aCwgcHJvcHMudmlld3BvcnRIZWlnaHQsIHJlbmRlcmVyKTtcbiAgICAgICAgICAgIGlmIChpc0dMICYmIHRoaXMuc2V0dGluZ3MuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICBwNS5zZXRBdHRyaWJ1dGVzKHRoaXMuc2V0dGluZ3MuYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgcDUsIGNhbnZhczogcDUuY2FudmFzLCBjb250ZXh0OiBwNS5fcmVuZGVyZXIuZHJhd2luZ0NvbnRleHQgfSk7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBTdXBwb3J0IGdsb2JhbCBhbmQgaW5zdGFuY2UgUDUuanMgbW9kZXNcbiAgICAgICAgaWYgKHR5cGVvZiBQNUNvbnN0cnVjdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbmV3IFA1Q29uc3RydWN0b3IocDVTa2V0Y2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93LmNyZWF0ZUNhbnZhcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieyBwNSB9IHNldHRpbmcgaXMgcGFzc2VkIGJ1dCBjYW4ndCBmaW5kIHA1LmpzIGluIGdsb2JhbCAod2luZG93KSBzY29wZS4gTWF5YmUgeW91IGRpZCBub3QgY3JlYXRlIGl0IGdsb2JhbGx5P1xcbm5ldyBwNSgpOyAvLyA8LS0gYXR0YWNoZXMgdG8gZ2xvYmFsIHNjb3BlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwNVNrZXRjaCh3aW5kb3cpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlbG9hZC50aGVuKCgpID0+IHtcbiAgICAgIC8vIExvYWQgdGhlIHVzZXIncyBza2V0Y2hcbiAgICAgIGxldCBsb2FkZXIgPSBjcmVhdGVTa2V0Y2godGhpcy5wcm9wcyk7XG4gICAgICBpZiAoIWlzUHJvbWlzZShsb2FkZXIpKSB7XG4gICAgICAgIGxvYWRlciA9IFByb21pc2UucmVzb2x2ZShsb2FkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxvYWRlcjtcbiAgICB9KS50aGVuKHNrZXRjaCA9PiB7XG4gICAgICBpZiAoIXNrZXRjaCkgc2tldGNoID0ge307XG4gICAgICB0aGlzLl9za2V0Y2ggPSBza2V0Y2g7XG5cbiAgICAgIC8vIE9uY2UgdGhlIHNrZXRjaCBpcyBsb2FkZWQgd2UgY2FuIGFkZCB0aGUgZXZlbnRzXG4gICAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgdGhpcy5fa2V5Ym9hcmRTaG9ydGN1dHMuYXR0YWNoKCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcG9zdFJlbmRlcigpO1xuXG4gICAgICAvLyBUaGUgaW5pdGlhbCByZXNpemUoKSBpbiB0aGUgY29uc3RydWN0b3Igd2lsbCBub3QgaGF2ZVxuICAgICAgLy8gdHJpZ2dlcmVkIGEgcmVzaXplKCkgZXZlbnQgb24gdGhlIHNrZXRjaCwgc2luY2UgaXQgd2FzIGJlZm9yZVxuICAgICAgLy8gdGhlIHNrZXRjaCB3YXMgbG9hZGVkLiBTbyB3ZSBzZW5kIHRoZSBzaWduYWwgaGVyZSwgYWxsb3dpbmdcbiAgICAgIC8vIHVzZXJzIHRvIHJlYWN0IHRvIHRoZSBpbml0aWFsIHNpemUgYmVmb3JlIGZpcnN0IHJlbmRlci5cbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3Qgc3RhcnQgc2tldGNoLCB0aGUgYXN5bmMgbG9hZGluZyBmdW5jdGlvbiByZWplY3RlZCB3aXRoIGFuIGVycm9yOlxcbiAgICBFcnJvcjogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBTa2V0Y2hNYW5hZ2VyO1xuIiwiaW1wb3J0IFNrZXRjaE1hbmFnZXIgZnJvbSAnLi9jb3JlL1NrZXRjaE1hbmFnZXInO1xuaW1wb3J0IFBhcGVyU2l6ZXMgZnJvbSAnLi9wYXBlci1zaXplcyc7XG5pbXBvcnQgeyBnZXRDbGllbnRBUEksIGRlZmluZWQgfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBDQUNIRSA9ICdob3QtaWQtY2FjaGUnO1xuY29uc3QgcnVudGltZUNvbGxpc2lvbnMgPSBbXTtcblxuZnVuY3Rpb24gaXNIb3RSZWxvYWQgKCkge1xuICBjb25zdCBjbGllbnQgPSBnZXRDbGllbnRBUEkoKTtcbiAgcmV0dXJuIGNsaWVudCAmJiBjbGllbnQuaG90O1xufVxuXG5mdW5jdGlvbiBjYWNoZUdldCAoaWQpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50QVBJKCk7XG4gIGlmICghY2xpZW50KSByZXR1cm4gdW5kZWZpbmVkO1xuICBjbGllbnRbQ0FDSEVdID0gY2xpZW50W0NBQ0hFXSB8fCB7fTtcbiAgcmV0dXJuIGNsaWVudFtDQUNIRV1baWRdO1xufVxuXG5mdW5jdGlvbiBjYWNoZVB1dCAoaWQsIGRhdGEpIHtcbiAgY29uc3QgY2xpZW50ID0gZ2V0Q2xpZW50QVBJKCk7XG4gIGlmICghY2xpZW50KSByZXR1cm4gdW5kZWZpbmVkO1xuICBjbGllbnRbQ0FDSEVdID0gY2xpZW50W0NBQ0hFXSB8fCB7fTtcbiAgY2xpZW50W0NBQ0hFXVtpZF0gPSBkYXRhO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lUHJvcCAob2xkTWFuYWdlciwgbmV3U2V0dGluZ3MpIHtcbiAgLy8gU3RhdGljIHNrZXRjaGVzIGlnbm9yZSB0aGUgdGltZSBwZXJzaXN0ZW5jeVxuICByZXR1cm4gbmV3U2V0dGluZ3MuYW5pbWF0ZSA/IHsgdGltZTogb2xkTWFuYWdlci5wcm9wcy50aW1lIH0gOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGNhbnZhc1NrZXRjaCAoc2tldGNoLCBzZXR0aW5ncyA9IHt9KSB7XG4gIGlmIChzZXR0aW5ncy5wNSkge1xuICAgIGlmIChzZXR0aW5ncy5jYW52YXMgfHwgKHNldHRpbmdzLmNvbnRleHQgJiYgdHlwZW9mIHNldHRpbmdzLmNvbnRleHQgIT09ICdzdHJpbmcnKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbiB7IHA1IH0gbW9kZSwgeW91IGNhbid0IHBhc3MgeW91ciBvd24gY2FudmFzIG9yIGNvbnRleHQsIHVubGVzcyB0aGUgY29udGV4dCBpcyBhIFwid2ViZ2xcIiBvciBcIjJkXCIgc3RyaW5nYCk7XG4gICAgfVxuXG4gICAgLy8gRG8gbm90IGNyZWF0ZSBhIGNhbnZhcyBvbiBzdGFydHVwLCBzaW5jZSBQNS5qcyBkb2VzIHRoYXQgZm9yIHVzXG4gICAgY29uc3QgY29udGV4dCA9IHR5cGVvZiBzZXR0aW5ncy5jb250ZXh0ID09PSAnc3RyaW5nJyA/IHNldHRpbmdzLmNvbnRleHQgOiBmYWxzZTtcbiAgICBzZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLCB7IGNhbnZhczogZmFsc2UsIGNvbnRleHQgfSk7XG4gIH1cblxuICBjb25zdCBpc0hvdCA9IGlzSG90UmVsb2FkKCk7XG4gIGxldCBob3RJRDtcbiAgaWYgKGlzSG90KSB7XG4gICAgLy8gVXNlIGEgbWFnaWMgbmFtZSBieSBkZWZhdWx0LCBmb3JjZSB1c2VyIHRvIGRlZmluZSBlYWNoIHNrZXRjaCBpZiB0aGV5XG4gICAgLy8gcmVxdWlyZSBtb3JlIHRoYW4gb25lIGluIGFuIGFwcGxpY2F0aW9uLiBPcGVuIHRvIG90aGVyIGlkZWFzIG9uIGhvdyB0byB0YWNrbGVcbiAgICAvLyB0aGlzIGFzIHdlbGwuLi5cbiAgICBob3RJRCA9IGRlZmluZWQoc2V0dGluZ3MuaWQsICckX19ERUZBVUxUX0NBTlZBU19TS0VUQ0hfSURfXyQnKTtcbiAgfVxuICBsZXQgaXNJbmplY3RpbmcgPSBpc0hvdCAmJiB0eXBlb2YgaG90SUQgPT09ICdzdHJpbmcnO1xuXG4gIGlmIChpc0luamVjdGluZyAmJiBydW50aW1lQ29sbGlzaW9ucy5pbmNsdWRlcyhob3RJRCkpIHtcbiAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6IFlvdSBoYXZlIG11bHRpcGxlIGNhbGxzIHRvIGNhbnZhc1NrZXRjaCgpIGluIC0taG90IG1vZGUuIFlvdSBtdXN0IHBhc3MgdW5pcXVlIHsgaWQgfSBzdHJpbmdzIGluIHNldHRpbmdzIHRvIGVuYWJsZSBob3QgcmVsb2FkIGFjcm9zcyBtdWx0aXBsZSBza2V0Y2hlcy4gYCwgaG90SUQpO1xuICAgIGlzSW5qZWN0aW5nID0gZmFsc2U7XG4gIH1cblxuICBsZXQgcHJlbG9hZCA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gIGlmIChpc0luamVjdGluZykge1xuICAgIC8vIE1hcmsgdGhpcyBhcyBhbHJlYWR5IHNwb3R0ZWQgaW4gdGhpcyBydW50aW1lIGluc3RhbmNlXG4gICAgcnVudGltZUNvbGxpc2lvbnMucHVzaChob3RJRCk7XG5cbiAgICBjb25zdCBwcmV2aW91c0RhdGEgPSBjYWNoZUdldChob3RJRCk7XG4gICAgaWYgKHByZXZpb3VzRGF0YSkge1xuICAgICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgICAgLy8gR3JhYiBuZXcgcHJvcHMgZnJvbSBvbGQgc2tldGNoIGluc3RhbmNlXG4gICAgICAgIGNvbnN0IG5ld1Byb3BzID0gZ2V0VGltZVByb3AocHJldmlvdXNEYXRhLm1hbmFnZXIsIHNldHRpbmdzKTtcbiAgICAgICAgLy8gRGVzdHJveSB0aGUgb2xkIGluc3RhbmNlXG4gICAgICAgIHByZXZpb3VzRGF0YS5tYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgLy8gUGFzcyBhbG9uZyBuZXcgcHJvcHNcbiAgICAgICAgcmV0dXJuIG5ld1Byb3BzO1xuICAgICAgfTtcblxuICAgICAgLy8gTW92ZSBhbG9uZyB0aGUgbmV4dCBkYXRhLi4uXG4gICAgICBwcmVsb2FkID0gcHJldmlvdXNEYXRhLmxvYWQudGhlbihuZXh0KS5jYXRjaChuZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJlbG9hZC50aGVuKG5ld1Byb3BzID0+IHtcbiAgICBjb25zdCBtYW5hZ2VyID0gbmV3IFNrZXRjaE1hbmFnZXIoKTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChza2V0Y2gpIHtcbiAgICAgIC8vIE1lcmdlIHdpdGggaW5jb21pbmcgZGF0YVxuICAgICAgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncywgbmV3UHJvcHMpO1xuXG4gICAgICAvLyBBcHBseSBzZXR0aW5ncyBhbmQgY3JlYXRlIGEgY2FudmFzXG4gICAgICBtYW5hZ2VyLnNldHVwKHNldHRpbmdzKTtcblxuICAgICAgLy8gTW91bnQgdG8gRE9NXG4gICAgICBtYW5hZ2VyLm1vdW50KCk7XG5cbiAgICAgIC8vIGxvYWQgdGhlIHNrZXRjaCBmaXJzdFxuICAgICAgcmVzdWx0ID0gbWFuYWdlci5sb2FkQW5kUnVuKHNrZXRjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFByb21pc2UucmVzb2x2ZShtYW5hZ2VyKTtcbiAgICB9XG4gICAgaWYgKGlzSW5qZWN0aW5nKSB7XG4gICAgICBjYWNoZVB1dChob3RJRCwgeyBsb2FkOiByZXN1bHQsIG1hbmFnZXIgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xufVxuXG4vLyBUT0RPOiBGaWd1cmUgb3V0IGEgbmljZSB3YXkgdG8gZXhwb3J0IHRoaW5ncy5cbmNhbnZhc1NrZXRjaC5jYW52YXNTa2V0Y2ggPSBjYW52YXNTa2V0Y2g7XG5jYW52YXNTa2V0Y2guUGFwZXJTaXplcyA9IFBhcGVyU2l6ZXM7XG5cbmV4cG9ydCBkZWZhdWx0IGNhbnZhc1NrZXRjaDtcbiIsInZhciB3aW47XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgd2luID0gZ2xvYmFsO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgd2luID0gc2VsZjtcbn0gZWxzZSB7XG4gICAgd2luID0ge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgaWYgKCFmbikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gaXNQcm9taXNlO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGlzUHJvbWlzZTtcblxuZnVuY3Rpb24gaXNQcm9taXNlKG9iaikge1xuICByZXR1cm4gISFvYmogJiYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnIHx8IHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiBvYmoudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbiIsInZhciBsb2FkZXJzID0gcmVxdWlyZSgnLi9sb2FkZXJzJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGlzUHJvbWlzZSA9IHJlcXVpcmUoJ2lzLXByb21pc2UnKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbm1vZHVsZS5leHBvcnRzID0gbG9hZEFzc2V0O1xuXG5tb2R1bGUuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbiBhbGwgKG9wdCwgcHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGxvYWRNdWx0aXBsZShvcHQsIHByb2dyZXNzLCBmYWxzZSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5hbnkgPSBmdW5jdGlvbiBhbnkgKG9wdCwgcHJvZ3Jlc3MpIHtcbiAgcmV0dXJuIGxvYWRNdWx0aXBsZShvcHQsIHByb2dyZXNzLCB0cnVlKTtcbn07XG5cbmZ1bmN0aW9uIGxvYWRNdWx0aXBsZSAob3B0LCBwcm9ncmVzcywgc2tpcE1pc3NpbmcpIHtcbiAgcHJvZ3Jlc3MgPSBwcm9ncmVzcyB8fCBub29wO1xuICBpZiAodHlwZW9mIHByb2dyZXNzICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVGhlIHNlY29uZCBhcmd1bWVudCB0byBsb2FkLmFsbCgpIGFuZCBsb2FkLmFueSgpIG11c3QgYmUgYSBmdW5jdGlvbiwgb3IgdW5kZWZpbmVkJykpO1xuICB9XG5cbiAgdmFyIHRvdGFsO1xuICB2YXIgY291bnQgPSAwO1xuICB2YXIgbG9hZDtcbiAgdmFyIGVtaXRQcm9ncmVzcyA9IGZ1bmN0aW9uIChpdGVtLCB2YWx1ZSwgY291bnQsIGVycm9yKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHRhcmdldDogaXRlbSxcbiAgICAgIHRvdGFsOiB0b3RhbCxcbiAgICAgIGNvdW50OiBjb3VudCxcbiAgICAgIHByb2dyZXNzOiBjb3VudCAvIHRvdGFsLFxuICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbiAgICBpZiAoZXJyb3IpIG9iai5lcnJvciA9IGVycm9yO1xuICAgIHByb2dyZXNzKG9iaik7XG4gIH07XG5cbiAgaWYgKHNraXBNaXNzaW5nKSB7XG4gICAgbG9hZCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHJldHVybiBsb2FkQXNzZXQob3B0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBudWxsLCBlcnJvcjogZXJyb3IgfTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKG9wdGlvbmFsKSB7XG4gICAgICAgIGVtaXRQcm9ncmVzcyhvcHQsIG9wdGlvbmFsLnZhbHVlLCArK2NvdW50LCBvcHRpb25hbC5lcnJvcik7XG4gICAgICAgIHJldHVybiBvcHRpb25hbC52YWx1ZTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgbG9hZCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHJldHVybiBsb2FkQXNzZXQob3B0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgZW1pdFByb2dyZXNzKG9wdCwgcmVzdWx0LCArK2NvdW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHQpKSB7XG4gICAgdG90YWwgPSBvcHQubGVuZ3RoO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChvcHQubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gbG9hZChpdGVtKTtcbiAgICB9KSk7XG4gIH0gZWxzZSBpZiAob3B0KSB7XG4gICAgdmFyIGVudHJpZXMgPSBPYmplY3Qua2V5cyhvcHQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4geyBrZXk6IGtleSwgdmFsdWU6IG9wdFtrZXldIH07XG4gICAgfSk7XG4gICAgdG90YWwgPSBlbnRyaWVzLmxlbmd0aDtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZW50cmllcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBrZXkgPSBpdGVtLmtleTtcbiAgICAgIHJldHVybiBsb2FkKGl0ZW0udmFsdWUpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwga2V5OiBrZXkgfTtcbiAgICAgIH0pO1xuICAgIH0pKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoZnVuY3Rpb24gKG9iaiwgaXRlbSkge1xuICAgICAgICBvYmpbaXRlbS5rZXldID0gaXRlbS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0sIHt9KTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdZb3UgbXVzdCBzcGVjaWZ5IGFuIGFycmF5IG9mIGFzc2V0cyBvciBvYmplY3QgZ3JvdXAgdG8gbG9hZCcpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2FkQXNzZXQgKG9wdCkge1xuICBpZiAoIW9wdCkgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIFVSTCBvciBkZXNjcmlwdG9yIG9mIHRoZSBhc3NldCB0byBsb2FkJykpO1xuICBpZiAodHlwZW9mIG9wdCA9PT0gJ3N0cmluZycpIHtcbiAgICBvcHQgPSB7IHVybDogb3B0IH07XG4gIH1cbiAgLy8gSWYgaXQncyBhIHByb21pc2UsIGFzc3VtZSBuZXN0ZWQgZmVhdHVyZXMuLi5cbiAgaWYgKGlzUHJvbWlzZShvcHQpKSByZXR1cm4gb3B0O1xuICByZXR1cm4gZ2V0TG9hZGVyKG9wdCkudGhlbihmdW5jdGlvbiAobG9hZGVyKSB7XG4gICAgb3B0ID0gYXNzaWduKHt9LCBvcHQpO1xuICAgIGRlbGV0ZSBvcHQudHlwZTtcbiAgICByZXR1cm4gbG9hZGVyKG9wdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRMb2FkZXIgKG9wdCkge1xuICB2YXIgaSwgbG9hZGVyO1xuICB2YXIgdHlwZSA9IG9wdC50eXBlID8gb3B0LnR5cGUgOiBudWxsO1xuICBpZiAodHlwZSkge1xuICAgIC8vIEFsbG93IHVzZXIgdG8gc3BlY2lmeSBjdXN0b20gdHlwZSBmdW5jdGlvblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgLy8gVXNlciBzcGVjaWZpZWQgYW4gZXhwbGljaXQgdHlwZSwgdXNlIHRoYXQuXG4gICAgaWYgKCFvcHQudXJsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXaGVuIHVzaW5nIGxvYWRBc3NldCgpLCB5b3UgbXVzdCBzcGVjaWZ5IGEgVVJMIG9yIGRlc2NyaXB0b3Igb2YgdGhlIGFzc2V0IHRvIGxvYWQnKSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBsb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2FkZXIgPSBsb2FkZXJzW2ldO1xuICAgICAgaWYgKGxvYWRlci5rZXkgPT09IHR5cGUpIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9hZGVyLmxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBhbiBhc3NldCBsb2FkZXIgYnkgdGhlIGtleSBcIicgKyBvcHQudHlwZSArICdcIicpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVc2VyIGRpZG4ndCBzcGVjaWZ5IHR5cGUsIHRyeSB0byBpbmZlciBmcm9tIGZpbGUgZXh0ZW5zaW9uXG4gICAgaWYgKCFvcHQudXJsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXaGVuIHVzaW5nIGxvYWRBc3NldCgpLCB5b3UgbXVzdCBzcGVjaWZ5IGEgVVJMIG9yIGRlc2NyaXB0b3Igb2YgdGhlIGFzc2V0IHRvIGxvYWQnKSk7XG4gICAgfVxuICAgIHZhciBleHQgPSBleHRuYW1lKG9wdC51cmwpO1xuICAgIGlmICghZXh0KSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdObyBleHRlbnNpb24gZm91bmQgZm9yIGlucHV0IFVSTCBcIicgKyBvcHQudXJsICsgJ1wiLCB0cnkgdG8gc3BlY2lmeSBhIHsgdHlwZSB9IHN1Y2ggYXMgXCJpbWFnZVwiIG9yIFwidGV4dFwiJykpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsb2FkZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsb2FkZXIgPSBsb2FkZXJzW2ldO1xuICAgICAgaWYgKCFsb2FkZXIubWF0Y2gpIGNvbnRpbnVlO1xuICAgICAgdmFyIGlzTWF0Y2ggPSB0eXBlb2YgbG9hZGVyLm1hdGNoID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gbG9hZGVyLm1hdGNoKGV4dClcbiAgICAgICAgOiBsb2FkZXIubWF0Y2gudGVzdChleHQpO1xuICAgICAgaWYgKGlzTWF0Y2gpIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9hZGVyLmxvYWQpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgaW5mZXIgYW4gYXNzZXQgbG9hZGVyIGZyb20gdGhlIGZpbGUgdHlwZSBcIicgKyBleHQgKyAnXCIsIHRyeSBzcGVjaWZ5aW5nIHsgdHlwZSB9IHN1Y2ggYXMgXCJpbWFnZVwiIG9yIFwidGV4dFwiJykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dG5hbWUgKHVybCkge1xuICBpZiAoIXVybCkgcmV0dXJuICcnO1xuICB2YXIgaWR4ID0gdXJsLmxhc3RJbmRleE9mKCcvJyk7XG4gIGlmIChpZHggIT09IC0xKSB1cmwgPSB1cmwuc3Vic3RyaW5nKGlkeCArIDEpOyAvLyBLZWVwIHBhdGggd2l0aG91dCBpdHMgc2VnbWVudHNcbiAgaWR4ID0gdXJsLmluZGV4T2YoJz8nKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHVybCA9IHVybC5zdWJzdHJpbmcoMCwgaWR4KTsgLy8gUmVtb3ZlIHF1ZXJ5XG4gIGlkeCA9IHVybC5pbmRleE9mKCcjJyk7XG4gIGlmIChpZHggIT09IC0xKSB1cmwgPSB1cmwuc3Vic3RyaW5nKDAsIGlkeCk7IC8vIFJlbW92ZSBmcmFnbWVudFxuICBpZHggPSB1cmwubGFzdEluZGV4T2YoJy4nKTtcbiAgcmV0dXJuIGlkeCAhPT0gLTEgPyB1cmwuc3Vic3RyaW5nKGlkeCkgOiAnJztcbn1cbiIsInZhciB4aHIgPSByZXF1aXJlKCd4aHInKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxvYWRGaWxlIChvcHQpIHtcbiAgICB2YXIgcDtcbiAgICBpZiAoJ2ZldGNoJyBpbiB3aW5kb3cpIHtcbiAgICAgIHAgPSB3aW5kb3cuZmV0Y2gob3B0LnVybCwgb3B0KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAoLzQwNC8udGVzdChyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc291cmNlIG5vdCBmb3VuZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIS9eMi8udGVzdChyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgSFRUUCBTdGF0dXMgQ29kZTogJyArIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2Ugbm90IE9LJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnanNvbicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYmluYXJ5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnYmxvYicpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcCA9IHhockZldGNoKHR5cGUsIG9wdCk7XG4gICAgfVxuICAgIHJldHVybiBwLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgZXJyLm1lc3NhZ2UgKyAnIHdoaWxlIGxvYWRpbmcgZmlsZSAnICsgb3B0LnVybFxuICAgICAgKTtcbiAgICB9KTtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIHhockZldGNoICh0eXBlLCBvcHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuICAgIGlmICh0eXBlID09PSAnanNvbicpIHJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcbiAgICBlbHNlIGlmICh0eXBlID09PSAnYmluYXJ5JykgcmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICBlbHNlIGlmICh0eXBlID09PSAnYmxvYicpIHJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICBvcHQgPSBhc3NpZ24oe30sIG9wdCwge1xuICAgICAganNvbjogZmFsc2UsXG4gICAgICByZXNwb25zZVR5cGU6IHJlc3BvbnNlVHlwZVxuICAgIH0pO1xuICAgIHhocihvcHQsIGZ1bmN0aW9uIChlcnIsIHJlcywgYm9keSkge1xuICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgaWYgKC80MDQvLnRlc3QocmVzLnN0YXR1c0NvZGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb3VyY2Ugbm90IGZvdW5kJyk7XG4gICAgICB9XG4gICAgICBpZiAoIS9eMi8udGVzdChyZXMuc3RhdHVzQ29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgSFRUUCBTdGF0dXMgQ29kZTogJyArIHJlcy5zdGF0dXNDb2RlKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2pzb24nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzb2x2ZShib2R5KTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJ2YXIgbWltZSA9IHJlcXVpcmUoJ2Jyb3dzZXItbWVkaWEtbWltZS10eXBlJyk7XG5cbmZ1bmN0aW9uIGdldE1lZGlhVHlwZSAoZXh0KSB7XG4gIHZhciByZXN1bHQgPSBtaW1lKGV4dCk7XG4gIGlmICghcmVzdWx0KSByZXR1cm4gbnVsbDtcbiAgaWYgKHJlc3VsdC5pbmRleE9mKCdhdWRpbycpID09PSAwKSByZXR1cm4gJ2F1ZGlvJztcbiAgaWYgKHJlc3VsdC5pbmRleE9mKCd2aWRlbycpID09PSAwKSByZXR1cm4gJ3ZpZGVvJztcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlTWVkaWFMb2FkZXIgKHR5cGUsIGNyZWF0ZUVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBrZXk6IHR5cGUsXG4gICAgbWF0Y2g6IGZ1bmN0aW9uIChleHQpIHtcbiAgICAgIHJldHVybiBnZXRNZWRpYVR5cGUoZXh0KSA9PT0gdHlwZTtcbiAgICB9LFxuICAgIGxvYWQ6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbWVkaWEgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgICAgIHZhciBvbkxvYWRlZCA9IGZ1bmN0aW9uIG9uTG9hZGVkICgpIHtcbiAgICAgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZShtZWRpYSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV2ZW50ID0gKG9wdC5ldmVudCB8fCAnY2FucGxheScpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChldmVudCA9PT0gJ2xvYWRlZG1ldGFkYXRhJykge1xuICAgICAgICAgIG1lZGlhLm9ubG9hZGVkbWV0YWRhdGEgPSBvbkxvYWRlZDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gJ2NhbnBsYXl0aHJvdWdoJykge1xuICAgICAgICAgIG1lZGlhLm9uY2FucGxheXRocm91Z2ggPSBvbkxvYWRlZDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudCA9PT0gJ2xvYWRlZGRhdGEnKSB7XG4gICAgICAgICAgbWVkaWEub25sb2FkZWRkYXRhID0gb25Mb2FkZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWVkaWEub25jYW5wbGF5ID0gb25Mb2FkZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYS5vbmVycm9yID0gZnVuY3Rpb24gb25FcnJvciAoZXIpIHtcbiAgICAgICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRXJyb3Igd2hpbGUgbG9hZGluZyAnICsgdHlwZSArICcgYXQgJyArIG9wdC51cmwpKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBwYXNzIHRocm91Z2ggbWVkaWEgcHJvcGVydGllcyBpZiBkZWZpbmVkXG4gICAgICAgIGlmIChvcHQuY3Jvc3NPcmlnaW4pIG1lZGlhLmNyb3NzT3JpZ2luID0gb3B0LmNyb3NzT3JpZ2luO1xuICAgICAgICBpZiAodHlwZW9mIG9wdC52b2x1bWUgIT09ICd1bmRlZmluZWQnKSBtZWRpYS52b2x1bWUgPSBvcHQudm9sdW1lO1xuICAgICAgICBpZiAodHlwZW9mIG9wdC5wcmVsb2FkICE9PSAndW5kZWZpbmVkJykgbWVkaWEucHJlbG9hZCA9IG9wdC52b2x1bWU7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0LnBsYXliYWNrUmF0ZSAhPT0gJ3VuZGVmaW5lZCcpIG1lZGlhLnBsYXliYWNrUmF0ZSA9IG9wdC52b2x1bWU7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0Lm11dGVkICE9PSAndW5kZWZpbmVkJykgbWVkaWEubXV0ZWQgPSBvcHQudm9sdW1lO1xuICAgICAgICBpZiAodHlwZW9mIG9wdC5jdXJyZW50VGltZSAhPT0gJ3VuZGVmaW5lZCcpIG1lZGlhLmN1cnJlbnRUaW1lID0gb3B0LnZvbHVtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQuY29udHJvbHMgIT09ICd1bmRlZmluZWQnKSBtZWRpYS5jb250cm9scyA9IG9wdC52b2x1bWU7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0LmF1dG9QbGF5ICE9PSAndW5kZWZpbmVkJykgbWVkaWEuYXV0b1BsYXkgPSBvcHQudm9sdW1lO1xuXG4gICAgICAgIG1lZGlhLnNyYyA9IG9wdC51cmw7XG5cbiAgICAgICAgaWYgKG1lZGlhLnJlYWR5U3RhdGUgPj0gbWVkaWEuSEFWRV9FTk9VR0hfREFUQSkge1xuICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtZWRpYSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYS5sb2FkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59O1xuIiwiY29uc3QgY3JlYXRlTWVkaWFMb2FkZXIgPSByZXF1aXJlKCcuL2NyZWF0ZU1lZGlhTG9hZGVyJyk7XG5jb25zdCBjcmVhdGVGaWxlTG9hZGVyID0gcmVxdWlyZSgnLi9jcmVhdGVGaWxlTG9hZGVyJyk7XG5jb25zdCBsb2FkSW1hZ2UgPSByZXF1aXJlKCcuL2xvYWRJbWFnZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgLy8ganNvblxuICB7XG4gICAga2V5OiAnanNvbicsXG4gICAgbWF0Y2g6IC9cXC5qc29uJC9pLFxuICAgIGxvYWQ6IGNyZWF0ZUZpbGVMb2FkZXIoJ2pzb24nKVxuICB9LFxuICAvLyB0ZXh0XG4gIHtcbiAgICBrZXk6ICd0ZXh0JyxcbiAgICBtYXRjaDogL1xcLnR4dCQvaSxcbiAgICBsb2FkOiBjcmVhdGVGaWxlTG9hZGVyKCd0ZXh0JylcbiAgfSxcbiAgLy8gaW1hZ2VcbiAge1xuICAgIGtleTogJ2ltYWdlJyxcbiAgICBtYXRjaDogL1xcLihqcGd8anBlZ3xzdmd8cG5nfGdpZnx3ZWJwfGJtcHx0Z2F8dGlmfGFwbmd8d2JwbXxpY28pJC9pLFxuICAgIGxvYWQ6IGxvYWRJbWFnZVxuICB9LFxuICAvLyBhdWRpb1xuICBjcmVhdGVNZWRpYUxvYWRlcignYXVkaW8nLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyB3aW5kb3cuQXVkaW8oKTtcbiAgfSksXG4gIC8vIHZpZGVvXG4gIGNyZWF0ZU1lZGlhTG9hZGVyKCd2aWRlbycsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndmlkZW8nKTtcbiAgfSksXG4gIC8vIGJpbmFyeVxuICB7XG4gICAga2V5OiAnYmluYXJ5JyxcbiAgICBtYXRjaDogL1xcLmJpbiQvaSxcbiAgICBsb2FkOiBjcmVhdGVGaWxlTG9hZGVyKCdiaW5hcnknKVxuICB9LFxuICAvLyBibG9iXG4gIHtcbiAgICBrZXk6ICdibG9iJyxcbiAgICBsb2FkOiBjcmVhdGVGaWxlTG9hZGVyKCdibG9iJylcbiAgfVxuXTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHZhciBpbWFnZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiBvbkxvYWRlZCAoKSB7XG4gICAgICBpZiAoZmluaXNoZWQpIHJldHVybjtcbiAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHJlc29sdmUoaW1hZ2UpO1xuICAgIH07XG4gICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uIG9uRXJyb3IgKCkge1xuICAgICAgaWYgKGZpbmlzaGVkKSByZXR1cm47XG4gICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICByZWplY3QobmV3IEVycm9yKCdFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIGF0ICcgKyBvcHQudXJsKSk7XG4gICAgfTtcbiAgICBpZiAob3B0LmNyb3NzT3JpZ2luKSBpbWFnZS5jcm9zc09yaWdpbiA9IG9wdC5jcm9zc09yaWdpbjtcbiAgICBpbWFnZS5zcmMgPSBvcHQudXJsO1xuICB9KTtcbn07XG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwidmFyIHRyaW0gPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG4gICwgaXNBcnJheSA9IGZ1bmN0aW9uKGFyZykge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgdmFyIGhlYWRlcnNBcnIgPSB0cmltKGhlYWRlcnMpLnNwbGl0KCdcXG4nKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyc0Fyci5sZW5ndGg7IGkrKykge1xuICAgIHZhciByb3cgPSBoZWFkZXJzQXJyW2ldXG4gICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuICAgICwga2V5ID0gdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXG4gICAgLCB2YWx1ZSA9IHRyaW0ocm93LnNsaWNlKGluZGV4ICsgMSkpXG5cbiAgICBpZiAodHlwZW9mKHJlc3VsdFtrZXldKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkocmVzdWx0W2tleV0pKSB7XG4gICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IFsgcmVzdWx0W2tleV0sIHZhbHVlIF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG4iLCIvKlxuTUlUIExpY2Vuc2VcblxuQ29weXJpZ2h0IChjKSAyMDEyIC0gMjAyMSBqb25vYnIxIC8gaHR0cDovL2pvbm9icjEuY29tXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG5jb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG5TT0ZUV0FSRS5cbiovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Ud28gPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5Db21tYW5kc1xuICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBNYXAgb2YgcG9zc2libGUgcGF0aCBjb21tYW5kcy4gVGFrZW4gZnJvbSB0aGUgU1ZHIHNwZWNpZmljYXRpb24uXG4gICAqL1xuICB2YXIgQ29tbWFuZHMgPSB7XG4gICAgbW92ZTogJ00nLFxuICAgIGxpbmU6ICdMJyxcbiAgICBjdXJ2ZTogJ0MnLFxuICAgIGFyYzogJ0EnLFxuICAgIGNsb3NlOiAnWidcbiAgfTtcblxuICB2YXIgcm9vdDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcm9vdCA9IHdpbmRvdztcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJvb3QgPSBnbG9iYWw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cblxuICB2YXIgcm9vdCQxID0gcm9vdDtcblxuICB2YXIgTWF0cml4JDE7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5kZWNvbXBvc2VNYXRyaXhcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7VHdvLk1hdHJpeH0gbWF0cml4IC0gVGhlIG1hdHJpeCB0byBkZWNvbXBvc2UuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHJlbGV2YW50IHNrZXcgdmFsdWVzLlxuICAgKiBAZGVzY3JpcHRpb24gRGVjb21wb3NlIGEgMkQgM3gzIE1hdHJpeCB0byBmaW5kIHRoZSBza2V3LlxuICAgKi9cbiAgdmFyIGRlY29tcG9zZU1hdHJpeCA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuXG4gICAgLy8gVE9ETzogSW5jbHVkZSBza2V3WCwgc2tld1lcbiAgICAvLyBodHRwczovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzIzNzM2OS9naXZlbi10aGlzLXRyYW5zZm9ybWF0aW9uLW1hdHJpeC1ob3ctZG8taS1kZWNvbXBvc2UtaXQtaW50by10cmFuc2xhdGlvbi1yb3RhdGkvNDE3ODEzXG4gICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDUxNTkzMTQvZGVjb21wb3NlLTJkLXRyYW5zZm9ybWF0aW9uLW1hdHJpeFxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNsYXRlWDogbWF0cml4LmUsXG4gICAgICAgIHRyYW5zbGF0ZVk6IG1hdHJpeC5mLFxuICAgICAgICBzY2FsZVg6IE1hdGguc3FydChtYXRyaXguYSAqIG1hdHJpeC5hICsgbWF0cml4LmIgKiBtYXRyaXguYiksXG4gICAgICAgIHNjYWxlWTogTWF0aC5zcXJ0KG1hdHJpeC5jICogbWF0cml4LmMgKyBtYXRyaXguZCAqIG1hdHJpeC5kKSxcbiAgICAgICAgcm90YXRpb246IDE4MCAqIE1hdGguYXRhbjIobWF0cml4LmIsIG1hdHJpeC5hKSAvIE1hdGguUElcbiAgICB9O1xuXG4gIH07XG5cbiAgdmFyIHNldE1hdHJpeCA9IGZ1bmN0aW9uKE0pIHtcbiAgICBNYXRyaXgkMSA9IE07XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5nZXRDb21wdXRlZE1hdHJpeFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtUd28uU2hhcGV9IG9iamVjdCAtIFRoZSBUd28uanMgb2JqZWN0IHRoYXQgaGFzIGEgbWF0cml4IHByb3BlcnR5IHRvIGNhbGN1bGF0ZSBmcm9tLlxuICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IFttYXRyaXhdIC0gVGhlIG1hdHJpeCB0byBhcHBseSBjYWxjdWxhdGVkIHRyYW5zZm9ybWF0aW9ucyB0byBpZiBhdmFpbGFibGUuXG4gICAqIEByZXR1cm5zIHtUd28uTWF0cml4fSBUaGUgY29tcHV0ZWQgbWF0cml4IG9mIGEgbmVzdGVkIG9iamVjdC4gSWYgbm8gYG1hdHJpeGAgd2FzIHBhc3NlZCBpbiBhcmd1bWVudHMgdGhlbiBhIGBuZXcgVHdvLk1hdHJpeGAgaXMgcmV0dXJuZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gZ2V0IHRoZSB3b3JsZCBzcGFjZSB0cmFuc2Zvcm1hdGlvbiBvZiBhIGdpdmVuIG9iamVjdCBpbiBhIFR3by5qcyBzY2VuZS5cbiAgICovXG4gIHZhciBnZXRDb21wdXRlZE1hdHJpeCA9IGZ1bmN0aW9uKG9iamVjdCwgbWF0cml4KSB7XG5cbiAgICBtYXRyaXggPSAobWF0cml4ICYmIG1hdHJpeC5pZGVudGl0eSgpKSB8fCBuZXcgTWF0cml4JDEoKTtcbiAgICB2YXIgcGFyZW50ID0gb2JqZWN0LCBtYXRyaWNlcyA9IFtdO1xuXG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX21hdHJpeCkge1xuICAgICAgbWF0cmljZXMucHVzaChwYXJlbnQuX21hdHJpeCk7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cblxuICAgIG1hdHJpY2VzLnJldmVyc2UoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0cmljZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgdmFyIG0gPSBtYXRyaWNlc1tpXTtcbiAgICAgIHZhciBlID0gbS5lbGVtZW50cztcbiAgICAgIG1hdHJpeC5tdWx0aXBseShcbiAgICAgICAgZVswXSwgZVsxXSwgZVsyXSwgZVszXSwgZVs0XSwgZVs1XSwgZVs2XSwgZVs3XSwgZVs4XSwgZVs5XSk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0cml4O1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5sZXJwXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gYSAtIFN0YXJ0IHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIEVuZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLSBaZXJvLXRvLW9uZSB2YWx1ZSBkZXNjcmliaW5nIHBlcmNlbnRhZ2UgYmV0d2VlbiBhIGFuZCBiLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKiBAZGVzY3JpcHRpb24gTGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmFsdWVzIGBhYCBhbmQgYGJgIGJ5IGFuIGFtb3VudCBgdGAuXG4gICAqL1xuICB2YXIgbGVycCA9IGZ1bmN0aW9uKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gdCAqIChiIC0gYSkgKyBhO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMubW9kXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge051bWJlcn0gdiAtIFRoZSB2YWx1ZSB0byBtb2R1bG9cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGwgLSBUaGUgdmFsdWUgdG8gbW9kdWxvIGJ5XG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqIEBkZXNjcmlwdGlvbiBNb2R1bG8gd2l0aCBhZGRlZCBmdW5jdGlvbmFsaXR5IHRvIGhhbmRsZSBuZWdhdGl2ZSB2YWx1ZXMgaW4gYSBwb3NpdGl2ZSBtYW5uZXIuXG4gICAqL1xuICB2YXIgbW9kID0gZnVuY3Rpb24odiwgbCkge1xuXG4gICAgd2hpbGUgKHYgPCAwKSB7XG4gICAgICB2ICs9IGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHYgJSBsO1xuXG4gIH07XG5cbiAgdmFyIE51bUFycmF5ID0gcm9vdCQxLkZsb2F0MzJBcnJheSB8fCBBcnJheTtcblxuICAvKipcbiAgKiBAbmFtZSBUd28uVXRpbHMudG9GaXhlZFxuICAqIEBmdW5jdGlvblxuICAqIEBwYXJhbSB7TnVtYmVyfSB2IC0gQW55IGZsb2F0XG4gICogQHJldHVybnMge051bWJlcn0gVGhhdCBmbG9hdCB0cmltbWVkIHRvIHRoZSB0aGlyZCBkZWNpbWFsIHBsYWNlLlxuICAqIEBkZXNjcmlwdGlvbiBBIHByZXR0eSBmYXN0IHRvRml4ZWQoMykgYWx0ZXJuYXRpdmUuXG4gICogQHNlZSB7QGxpbmsgaHR0cDovL2pzcGVyZi5jb20vcGFyc2VmbG9hdC10b2ZpeGVkLXZzLW1hdGgtcm91bmQvMTh9XG4gICovXG4gIHZhciB0b0ZpeGVkID0gZnVuY3Rpb24odikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKHYgKiAxMDAwMDAwKSAvIDEwMDAwMDA7XG4gIH07XG5cbiAgdmFyIG1hdGggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGRlY29tcG9zZU1hdHJpeDogZGVjb21wb3NlTWF0cml4LFxuICAgIGdldENvbXB1dGVkTWF0cml4OiBnZXRDb21wdXRlZE1hdHJpeCxcbiAgICBzZXRNYXRyaXg6IHNldE1hdHJpeCxcbiAgICBsZXJwOiBsZXJwLFxuICAgIG1vZDogbW9kLFxuICAgIE51bUFycmF5OiBOdW1BcnJheSxcbiAgICB0b0ZpeGVkOiB0b0ZpeGVkXG4gIH0pO1xuXG4gIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gPT09IG51bGwgfHwgY29sbGVjdGlvbiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgIC8vIEFycmF5cyBjYW5ub3QgaG9sZCBtb3JlIHRoYW4gMl4zMiAtIDEgaXRlbXNcbiAgICByZXR1cm4gKHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDwgNDI5NDk2NzI5Nik7XG4gIH07XG5cbiAgdmFyIF8gPSB7XG4gICAgaXNOYU46IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdudW1iZXInICYmIG9iaiAhPT0gK29iajtcbiAgICB9LFxuICAgIGlzRWxlbWVudDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gICAgfSxcbiAgICBpc09iamVjdDogZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgICB9LFxuICAgIGV4dGVuZDogZnVuY3Rpb24oYmFzZSkge1xuICAgICAgdmFyIHNvdXJjZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgYmFzZVtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfSxcbiAgICBkZWZhdWx0czogZnVuY3Rpb24oYmFzZSkge1xuICAgICAgdmFyIHNvdXJjZXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKGJhc2Vba10gPT09IHZvaWQgMCkge1xuICAgICAgICAgIGJhc2Vba10gPSBvYmpba107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9LFxuICAgIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjdHggPSBjb250ZXh0IHx8IHRoaXM7XG4gICAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIE9iamVjdC5rZXlzKG9iaik7XG4gICAgICB2YXIgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrID0ga2V5cyA/IGtleXNbaV0gOiBpO1xuICAgICAgICBpdGVyYXRlZS5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5VdGlscy5wZXJmb3JtYW5jZVxuICAgICAqIEBwcm9wZXJ0eSB7RGF0ZX0gLSBBIHNwZWNpYWwgYERhdGVgIGxpa2Ugb2JqZWN0IHRvIGdldCB0aGUgY3VycmVudCBtaWxsaXMgb2YgdGhlIHNlc3Npb24uIFVzZWQgaW50ZXJuYWxseSB0byBjYWxjdWxhdGUgdGltZSBiZXR3ZWVuIGZyYW1lcy5cbiAgICAgKiBlLmc6IGBVdGlscy5wZXJmb3JtYW5jZS5ub3coKSAvLyBtaWxsaXNlY29uZHMgc2luY2UgZXBvY2hgXG4gICAgICovXG4gICAgcGVyZm9ybWFuY2U6ICgocm9vdCQxLnBlcmZvcm1hbmNlICYmIHJvb3QkMS5wZXJmb3JtYW5jZS5ub3cpID8gcm9vdCQxLnBlcmZvcm1hbmNlIDogRGF0ZSksXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5FdmVudHNcbiAgICogQGNsYXNzXG4gICAqIEBkZXNjcmlwdGlvbiBPYmplY3QgaW5oZXJpdGVkIGJ5IG1hbnkgVHdvLmpzIG9iamVjdHMgaW4gb3JkZXIgdG8gZmFjaWxpdGF0ZSBjdXN0b20gZXZlbnRzLlxuICAgKi9cbiAgdmFyIEV2ZW50cyA9IHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FdmVudHMjb25cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW25hbWVdIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGJpbmQgYSBmdW5jdGlvbiB0by5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaGFuZGxlcl0gLSBUaGUgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBldmVudCBpcyBkaXNwYXRjaGVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIGFkZCBhIGxpc3RlbmVyIHRvIGEgc3BlY2lmaWMgZXZlbnQgbmFtZS5cbiAgICAgKi9cbiAgICBvbjogYWRkRXZlbnRMaXN0ZW5lcixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FdmVudHMjb2ZmXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCBpbnRlbmRlZCB0byBiZSByZW1vdmVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtoYW5kbGVyXSAtIFRoZSBoYW5kbGVyIGludGVuZGVkIHRvIGJlIHJlb212ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGwgdG8gcmVtb3ZlIGxpc3RlbmVycyBmcm9tIGEgc3BlY2lmaWMgZXZlbnQuIElmIG9ubHkgYG5hbWVgIGlzIHBhc3NlZCB0aGVuIGFsbCB0aGUgaGFuZGxlcnMgYXR0YWNoZWQgdG8gdGhhdCBgbmFtZWAgd2lsbCBiZSByZW1vdmVkLiBJZiBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aGVuIGFsbCBoYW5kbGVycyBmb3IgZXZlcnkgZXZlbnQgb24gdGhlIG9iZWpjdCBhcmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXIsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRXZlbnRzI3RyaWdnZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBkaXNwYXRjaC5cbiAgICAgKiBAcGFyYW0gYXJndW1lbnRzIC0gQW55dGhpbmcgY2FuIGJlIHBhc3NlZCBhZnRlciB0aGUgbmFtZSBhbmQgdGhvc2Ugd2lsbCBiZSBwYXNzZWQgb24gdG8gaGFuZGxlcnMgYXR0YWNoZWQgdG8gdGhlIGV2ZW50IGluIHRoZSBvcmRlciB0aGV5IGFyZSBwYXNzZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGwgdG8gdHJpZ2dlciBhIGN1c3RvbSBldmVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHBhc3NlZCBhZnRlciB0aGUgbmFtZSB3aWxsIGJlIHBhc3NlZCBhbG9uZyB0byB0aGUgYXR0YWNoZWQgaGFuZGxlcnMuXG4gICAgICovXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIHNjb3BlID0gdGhpcztcbiAgICAgIGlmICghc2NvcGUuX2V2ZW50cykgcmV0dXJuIHNjb3BlO1xuICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgdmFyIGV2ZW50cyA9IHNjb3BlLl9ldmVudHNbbmFtZV07XG4gICAgICBpZiAoZXZlbnRzKSBkaXNwYXRjaChzY29wZSwgZXZlbnRzLCBhcmdzKTtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9LFxuXG4gICAgbGlzdGVuOiBmdW5jdGlvbihvYmosIG5hbWUsIGhhbmRsZXIpIHtcblxuICAgICAgdmFyIGJvdW5kID0gdGhpcztcblxuICAgICAgaWYgKG9iaikge1xuXG4gICAgICAgIHZhciBldmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBoYW5kbGVyLmFwcGx5KGJvdW5kLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCByZWZlcmVuY2VzIGFib3V0IHRoZSBvYmplY3QgdGhhdCBhc3NpZ25lZCB0aGlzIGxpc3RlbmVyXG4gICAgICAgIGV2ZW50Lm9iaiA9IG9iajtcbiAgICAgICAgZXZlbnQubmFtZSA9IG5hbWU7XG4gICAgICAgIGV2ZW50LmhhbmRsZXIgPSBoYW5kbGVyO1xuXG4gICAgICAgIG9iai5vbihuYW1lLCBldmVudCk7XG5cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJvdW5kO1xuXG4gICAgfSxcblxuICAgIGlnbm9yZTogZnVuY3Rpb24ob2JqLCBuYW1lLCBoYW5kbGVyKSB7XG5cbiAgICAgIHZhciBzY29wZSA9IHRoaXM7XG4gICAgICBvYmoub2ZmKG5hbWUsIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuIHNjb3BlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FdmVudHMuVHlwZXNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBPYmplY3Qgb2YgZGlmZmVyZW50IHR5cGVzIG9mIFR3by5qcyBzcGVjaWZpYyBldmVudHMuXG4gICAgICovXG4gICAgVHlwZXM6IHtcbiAgICAgIHBsYXk6ICdwbGF5JyxcbiAgICAgIHBhdXNlOiAncGF1c2UnLFxuICAgICAgdXBkYXRlOiAndXBkYXRlJyxcbiAgICAgIHJlbmRlcjogJ3JlbmRlcicsXG4gICAgICByZXNpemU6ICdyZXNpemUnLFxuICAgICAgY2hhbmdlOiAnY2hhbmdlJyxcbiAgICAgIHJlbW92ZTogJ3JlbW92ZScsXG4gICAgICBpbnNlcnQ6ICdpbnNlcnQnLFxuICAgICAgb3JkZXI6ICdvcmRlcicsXG4gICAgICBsb2FkOiAnbG9hZCdcbiAgICB9XG5cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uRXZlbnRzLmJpbmRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5FdmVudHMub259LlxuICAgKi9cbiAgRXZlbnRzLmJpbmQgPSBhZGRFdmVudExpc3RlbmVyO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uRXZlbnRzLnVuYmluZFxuICAgKiBAZnVuY3Rpb25cbiAgICogQGRlc2NyaXB0aW9uIEFsaWFzIGZvciB7QGxpbmsgVHdvLkV2ZW50cy5vZmZ9LlxuICAgKi9cbiAgRXZlbnRzLnVuYmluZCA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtUd28uRXZlbnRzfSAtIFJldHVybnMgYW4gaW5zdGFuY2Ugb2Ygc2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBzY29wZS5fZXZlbnRzIHx8IChzY29wZS5fZXZlbnRzID0ge30pO1xuICAgIHZhciBsaXN0ID0gc2NvcGUuX2V2ZW50c1tuYW1lXSB8fCAoc2NvcGUuX2V2ZW50c1tuYW1lXSA9IFtdKTtcblxuICAgIGxpc3QucHVzaChoYW5kbGVyKTtcblxuICAgIHJldHVybiBzY29wZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm5zIHtUd28uRXZlbnRzfSAtIFJldHVybnMgYW4gaW5zdGFuY2Ugb2Ygc2VsZiBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcblxuICAgIHZhciBzY29wZSA9IHRoaXM7XG5cbiAgICBpZiAoIXNjb3BlLl9ldmVudHMpIHtcbiAgICAgIHJldHVybiBzY29wZTtcbiAgICB9XG4gICAgaWYgKCFuYW1lICYmICFoYW5kbGVyKSB7XG4gICAgICBzY29wZS5fZXZlbnRzID0ge307XG4gICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IE9iamVjdC5rZXlzKHNjb3BlLl9ldmVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cbiAgICAgIG5hbWUgPSBuYW1lc1tpXTtcbiAgICAgIHZhciBsaXN0ID0gc2NvcGUuX2V2ZW50c1tuYW1lXTtcblxuICAgICAgaWYgKGxpc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuICAgICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gbGlzdC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIHZhciBldiA9IGxpc3Rbal07XG4gICAgICAgICAgICBldiA9IGV2LmhhbmRsZXIgPyBldi5oYW5kbGVyIDogZXY7XG4gICAgICAgICAgICBpZiAoaGFuZGxlciAmJiBoYW5kbGVyICE9PSBldikge1xuICAgICAgICAgICAgICBldmVudHMucHVzaChldik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjb3BlLl9ldmVudHNbbmFtZV0gPSBldmVudHM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjb3BlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzcGF0Y2gob2JqLCBldmVudHMsIGFyZ3MpIHtcbiAgICB2YXIgbWV0aG9kO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6XG4gICAgICBtZXRob2QgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIGV2ZW50c1tpXS5jYWxsKG9iaiwgYXJnc1swXSk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgbWV0aG9kID0gZnVuY3Rpb24oaSkge1xuICAgICAgICBldmVudHNbaV0uY2FsbChvYmosIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgZXZlbnRzW2ldLmNhbGwob2JqLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBtZXRob2QgPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIGV2ZW50c1tpXS5jYWxsKG9iaiwgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgZXZlbnRzW2ldLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9O1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbWV0aG9kKGkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVmVjdG9yXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBBbnkgbnVtYmVyIHRvIHJlcHJlc2VudCB0aGUgaG9yaXpvbnRhbCB4LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBBbnkgbnVtYmVyIHRvIHJlcHJlc2VudCB0aGUgdmVydGljYWwgeS1jb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cbiAgICogQGRlc2NyaXB0aW9uIEEgY2xhc3MgdG8gc3RvcmUgeCAvIHkgY29tcG9uZW50IHZlY3RvciBkYXRhLiBJbiBhZGRpdGlvbiB0byBzdG9yaW5nIGRhdGEgYFR3by5WZWN0b3JgIGhhcyBzdXBlZCB1cCBtZXRob2RzIGZvciBjb21tb25wbGFjZSBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucy5cbiAgICovXG4gIGZ1bmN0aW9uIFZlY3Rvcih4LCB5KSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3hcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgaG9yaXpvbnRhbCB4LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxuICAgICAqL1xuICAgIHRoaXMueCA9IHggfHwgMDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjeVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB2ZXJ0aWNhbCB5LWNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLlxuICAgICAqL1xuICAgIHRoaXMueSA9IHkgfHwgMDtcblxuICB9XG5cbiAgXy5leHRlbmQoVmVjdG9yLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yLnplcm9cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gSGFuZHkgcmVmZXJlbmNlIHRvIGEgdmVjdG9yIHdpdGggY29tcG9uZW50IHZhbHVlcyAwLCAwIGF0IGFsbCB0aW1lcy5cbiAgICAgKi9cbiAgICB6ZXJvOiBuZXcgVmVjdG9yKCksXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yLmFkZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjFcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYyXG4gICAgICogQHJldHVybnMge1R3by5WZWN0b3J9XG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCB0d28gdmVjdG9ycyB0b2dldGhlci5cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodjEueCArIHYyLngsIHYxLnkgKyB2Mi55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5zdWJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYxXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MlxuICAgICAqIEByZXR1cm5zIHtUd28uVmVjdG9yfVxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJ0cmFjdCB0d28gdmVjdG9yczogYHYyYCBmcm9tIGB2MWAuXG4gICAgICovXG4gICAgc3ViOiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgIHJldHVybiBuZXcgVmVjdG9yKHYxLnggLSB2Mi54LCB2MS55IC0gdjIueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Iuc3VidHJhY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQWxpYXMgZm9yIHtAbGluayBUd28uVmVjdG9yLnN1Yn0uXG4gICAgICovXG4gICAgc3VidHJhY3Q6IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICAgcmV0dXJuIFZlY3Rvci5zdWIodjEsIHYyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5yYXRpb0JldHdlZW5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IEFcbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IEJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgcmF0aW8gYmV0d2VuIHR3byBwb2ludHMgYHYxYCBhbmQgYHYyYC5cbiAgICAgKi9cbiAgICByYXRpb0JldHdlZW46IGZ1bmN0aW9uKHYxLCB2Mikge1xuXG4gICAgICByZXR1cm4gKHYxLnggKiB2Mi54ICsgdjEueSAqIHYyLnkpIC8gKHYxLmxlbmd0aCgpICogdjIubGVuZ3RoKCkpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IuYW5nbGVCZXR3ZWVuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MVxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdjJcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgYmV0d2VlbiBwb2ludHMgYHYxYCBhbmQgYHYyYC5cbiAgICAgKi9cbiAgICBhbmdsZUJldHdlZW46IGZ1bmN0aW9uKHYxLCB2Mikge1xuXG4gICAgICB2YXIgZHgsIGR5O1xuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG5cbiAgICAgICAgZHggPSBhcmd1bWVudHNbMF0gLSBhcmd1bWVudHNbMl07XG4gICAgICAgIGR5ID0gYXJndW1lbnRzWzFdIC0gYXJndW1lbnRzWzNdO1xuXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKGR5LCBkeCk7XG5cbiAgICAgIH1cblxuICAgICAgZHggPSB2MS54IC0gdjIueDtcbiAgICAgIGR5ID0gdjEueSAtIHYyLnk7XG5cbiAgICAgIHJldHVybiBNYXRoLmF0YW4yKGR5LCBkeCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3Rvci5kaXN0YW5jZUJldHdlZW5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYxXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHBvaW50cyBgdjFgIGFuZCBgdjJgLiBEaXN0YW5jZSBpcyBhbHdheXMgcG9zaXRpdmUuXG4gICAgICovXG4gICAgZGlzdGFuY2VCZXR3ZWVuOiBmdW5jdGlvbih2MSwgdjIpIHtcblxuICAgICAgcmV0dXJuIE1hdGguc3FydChWZWN0b3IuZGlzdGFuY2VCZXR3ZWVuU3F1YXJlZCh2MSwgdjIpKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yLmRpc3RhbmNlQmV0d2VlblNxdWFyZWRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYxXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2MlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gcG9pbnRzIGB2MWAgYW5kIGB2MmAuXG4gICAgICovXG4gICAgZGlzdGFuY2VCZXR3ZWVuU3F1YXJlZDogZnVuY3Rpb24odjEsIHYyKSB7XG5cbiAgICAgIHZhciBkeCA9IHYxLnggLSB2Mi54O1xuICAgICAgdmFyIGR5ID0gdjEueSAtIHYyLnk7XG5cbiAgICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uVmVjdG9yfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5WZWN0b3J9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgLy8gLyoqXG4gICAgICAvLyAgKiBPdmVycmlkZSBCYWNrYm9uZSBiaW5kIC8gb24gaW4gb3JkZXIgdG8gYWRkIHByb3Blcmx5IGJyb2FkY2FzdGluZy5cbiAgICAgIC8vICAqIFRoaXMgYWxsb3dzIFR3by5WZWN0b3IgdG8gbm90IGJyb2FkY2FzdCBldmVudHMgdW5sZXNzIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgLy8gICogYXJlIGV4cGxpY2l0eSBib3VuZCB0byBpdC5cbiAgICAgIC8vICAqL1xuXG4gICAgICBvYmplY3QuYmluZCA9IG9iamVjdC5vbiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fYm91bmQpIHtcbiAgICAgICAgICB0aGlzLl94ID0gdGhpcy54O1xuICAgICAgICAgIHRoaXMuX3kgPSB0aGlzLnk7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd4JywgeGdzKTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3knLCB5Z3MpO1xuICAgICAgICAgIF8uZXh0ZW5kKHRoaXMsIEJvdW5kUHJvdG8pO1xuICAgICAgICAgIHRoaXMuX2JvdW5kID0gdHJ1ZTsgLy8gUmVzZXJ2ZWQgZm9yIGV2ZW50IGluaXRpYWxpemF0aW9uIGNoZWNrXG4gICAgICAgIH1cblxuICAgICAgICBFdmVudHMuYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICB9O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFZlY3Rvci5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgY29uc3RydWN0b3I6IFZlY3RvcixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIHggLyB5IGNvbXBvbmVudHMgb2YgYSB2ZWN0b3IgdG8gc3BlY2lmaWMgbnVtYmVyIHZhbHVlcy5cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjY29weVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb3B5IHRoZSB4IC8geSBjb21wb25lbnRzIG9mIGFub3RoZXIgb2JqZWN0IGB2YC5cbiAgICAgKi9cbiAgICBjb3B5OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLnggPSB2Lng7XG4gICAgICB0aGlzLnkgPSB2Lnk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNjbGVhclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxuICAgICAqL1xuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IHZlY3RvciBhbmQgY29weSB0aGUgZXhpc3RpbmcgdmFsdWVzIG9udG8gdGhlIG5ld2x5IGNyZWF0ZWQgaW5zdGFuY2UuXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2FkZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYW4gb2JqZWN0IHdpdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyB0byB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjYWRkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIHRoZSAqKnNhbWUqKiBudW1iZXIgdG8gYm90aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIG9mIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNhZGRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCBgeGAgLyBgeWAgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgY29tcG9uZW50IHZhbHVlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLnggKz0geDtcbiAgICAgICAgICB0aGlzLnkgKz0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4LnggPT09ICdudW1iZXInICYmIHR5cGVvZiB4LnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy54ICs9IHgueDtcbiAgICAgICAgICB0aGlzLnkgKz0geC55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggKz0geDtcbiAgICAgICAgdGhpcy55ICs9IHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNhZGRTZWxmXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFsaWFzIGZvciB7QGxpbmsgVHdvLlZlY3Rvci5hZGR9LlxuICAgICAqL1xuICAgIGFkZFNlbGY6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3N1YlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdlxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJ0cmFjdCBhbiBvYmplY3Qgd2l0aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzdWJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdlxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJ0cmFjdCB0aGUgKipzYW1lKiogbnVtYmVyIHRvIGJvdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyBvZiB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc3ViXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJ0cmFjdCBgeGAgLyBgeWAgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgY29tcG9uZW50IHZhbHVlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuICAgIHN1YjogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLnggLT0geDtcbiAgICAgICAgICB0aGlzLnkgLT0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4LnggPT09ICdudW1iZXInICYmIHR5cGVvZiB4LnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy54IC09IHgueDtcbiAgICAgICAgICB0aGlzLnkgLT0geC55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggLT0geDtcbiAgICAgICAgdGhpcy55IC09IHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzdWJ0cmFjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5WZWN0b3Iuc3VifS5cbiAgICAgKi9cbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdWIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNzdWJTZWxmXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFsaWFzIGZvciB7QGxpbmsgVHdvLlZlY3Rvci5zdWJ9LlxuICAgICAqL1xuICAgIHN1YlNlbGY6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI3N1YnRyYWN0U2VsZlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5WZWN0b3Iuc3VifS5cbiAgICAgKi9cbiAgICBzdWJ0cmFjdFNlbGY6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnN1Yi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI211bHRpcGx5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2XG4gICAgICogQGRlc2NyaXB0aW9uIE11bHRpcGx5IGFuIG9iamVjdCB3aXRoIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgdG8gdGhlIGluc3RhbmNlLlxuICAgICAqIEBvdmVybG9hZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI211bHRpcGx5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsdGlwbHkgdGhlICoqc2FtZSoqIG51bWJlciB0byBib3RoIHggLyB5IGNvbXBvbmVudCB2YWx1ZXMgb2YgdGhlIGluc3RhbmNlLlxuICAgICAqIEBvdmVybG9hZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI211bHRpcGx5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBgeGAgLyBgeWAgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgY29tcG9uZW50IHZhbHVlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMueCAqPSB4O1xuICAgICAgICAgIHRoaXMueSAqPSB4O1xuICAgICAgICB9IGVsc2UgaWYgKHggJiYgdHlwZW9mIHgueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHgueSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLnggKj0geC54O1xuICAgICAgICAgIHRoaXMueSAqPSB4Lnk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueCAqPSB4O1xuICAgICAgICB0aGlzLnkgKj0geTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI211bHRpcGx5U2VsZlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGlhcyBmb3Ige0BsaW5rIFR3by5WZWN0b3IubXVsdGlwbHl9LlxuICAgICAqL1xuICAgIG11bHRpcGx5U2VsZjogZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNtdWx0aXBseVNjYWxhclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzIC0gVGhlIHNjYWxhciB0byBtdWx0aXBseSBieS5cbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsaXRpcGx5IHRoZSB2ZWN0b3IgYnkgYSBzaW5nbGUgbnVtYmVyLiBTaG9ydGhhbmQgdG8gY2FsbCB7QGxpbmsgVHdvLlZlY3RvciNtdWx0aXBseX0gZGlyZWN0bHkuXG4gICAgICovXG4gICAgbXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2RpdmlkZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlZlY3Rvcn0gdlxuICAgICAqIEBkZXNjcmlwdGlvbiBEaXZpZGUgYW4gb2JqZWN0IHdpdGggeCAvIHkgY29tcG9uZW50IHZhbHVlcyB0byB0aGUgaW5zdGFuY2UuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjZGl2aWRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAgICAgKiBAZGVzY3JpcHRpb24gRGl2aWRlIHRoZSAqKnNhbWUqKiBudW1iZXIgdG8gYm90aCB4IC8geSBjb21wb25lbnQgdmFsdWVzIG9mIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXZpZGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQGRlc2NyaXB0aW9uIERpdmlkZSBgeGAgLyBgeWAgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgY29tcG9uZW50IHZhbHVlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuICAgIGRpdmlkZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLnggLz0geDtcbiAgICAgICAgICB0aGlzLnkgLz0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4LnggPT09ICdudW1iZXInICYmIHR5cGVvZiB4LnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy54IC89IHgueDtcbiAgICAgICAgICB0aGlzLnkgLz0geC55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggLz0geDtcbiAgICAgICAgdGhpcy55IC89IHk7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc05hTih0aGlzLngpKSB7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc05hTih0aGlzLnkpKSB7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXZpZGVTZWxmXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFsaWFzIGZvciB7QGxpbmsgVHdvLlZlY3Rvci5kaXZpZGV9LlxuICAgICAqL1xuICAgIGRpdmlkZVNlbGY6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2RpdmlkZVNjYWxhclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzIC0gVGhlIHNjYWxhciB0byBkaXZpZGUgYnkuXG4gICAgICogQGRlc2NyaXB0aW9uIERpdmlkZSB0aGUgdmVjdG9yIGJ5IGEgc2luZ2xlIG51bWJlci4gU2hvcnRoYW5kIHRvIGNhbGwge0BsaW5rIFR3by5WZWN0b3IjZGl2aWRlfSBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdmlkZShzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNuZWdhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gSW52ZXJ0IGVhY2ggY29tcG9uZW50J3Mgc2lnbiB2YWx1ZS5cbiAgICAgKi9cbiAgICBuZWdhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI25lZ2F0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgW2RvdCBwcm9kdWN0XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Eb3RfcHJvZHVjdCkgb2YgdGhlIHZlY3Rvci5cbiAgICAgKi9cbiAgICBkb3Q6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3IjbGVuZ3RoXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gICAgICovXG4gICAgbGVuZ3RoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2xlbmd0aFNxdWFyZWRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yIHRvIHRoZSBwb3dlciBvZiB0d28uIFdpZGVseSB1c2VkIGFzIGxlc3MgZXhwZW5zaXZlIHRoYW4ge0BsaW5rIFR3by5WZWN0b3IjbGVuZ3RofSwgYmVjYXVzZSBpdCBpc24ndCBzcXVhcmUtcm9vdGluZyBhbnkgbnVtYmVycy5cbiAgICAgKi9cbiAgICBsZW5ndGhTcXVhcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijbm9ybWFsaXplXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIE5vcm1hbGl6ZSB0aGUgdmVjdG9yIGZyb20gbmVnYXRpdmUgb25lIHRvIG9uZS5cbiAgICAgKi9cbiAgICBub3JtYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKHRoaXMubGVuZ3RoKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVmVjdG9yI2Rpc3RhbmNlVG9cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlY3RvcnMuXG4gICAgICovXG4gICAgZGlzdGFuY2VUbzogZnVuY3Rpb24odikge1xuICAgICAgcmV0dXJuIE1hdGguc3FydCh0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKHYpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNkaXN0YW5jZVRvU3F1YXJlZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjdG9ycyB0byB0aGUgcG93ZXIgb2YgdHdvLiBXaWRlbHkgdXNlZCBhcyBsZXNzIGV4cGVuc2l2ZSB0aGFuIHtAbGluayBUd28uVmVjdG9yI2Rpc3RhbmNlVG99LCBiZWNhdXNlIGl0IGlzbid0IHNxdWFyZS1yb290aW5nIGFueSBudW1iZXJzLlxuICAgICAqL1xuICAgIGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgZHggPSB0aGlzLnggLSB2LngsXG4gICAgICAgICAgZHkgPSB0aGlzLnkgLSB2Lnk7XG4gICAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZWN0b3Ijc2V0TGVuZ3RoXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGwgLSBsZW5ndGggdG8gc2V0IHZlY3RvciB0by5cbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IuXG4gICAgICovXG4gICAgc2V0TGVuZ3RoOiBmdW5jdGlvbihsKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhcihsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNlcXVhbHNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5WZWN0b3J9IHYgLSBUaGUgdmVjdG9yIHRvIGNvbXBhcmUgYWdhaW5zdC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Vwcz0wLjAwMDFdIC0gQW4gb3B0aW9ucyBlcHNpbG9uIGZvciBwcmVjaXNpb24uXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICogQGRlc2NyaXB0aW9uIFF1YWxpZnkgaWYgb25lIHZlY3RvciByb3VnaGx5IGVxdWFsIGFub3RoZXIuIFdpdGggYSBtYXJnaW4gb2YgZXJyb3IgZGVmaW5lZCBieSBlcHNpbG9uLlxuICAgICAqL1xuICAgIGVxdWFsczogZnVuY3Rpb24odiwgZXBzKSB7XG4gICAgICBlcHMgPSAodHlwZW9mIGVwcyA9PT0gJ3VuZGVmaW5lZCcpID8gIDAuMDAwMSA6IGVwcztcbiAgICAgIHJldHVybiAodGhpcy5kaXN0YW5jZVRvKHYpIDwgZXBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNsZXJwXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSB2IC0gVGhlIGRlc3RpbmF0aW9uIHZlY3RvciB0byBzdGVwIHRvd2FyZHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLSBUaGUgemVybyB0byBvbmUgdmFsdWUgb2YgaG93IGNsb3NlIHRoZSBjdXJyZW50IHZlY3RvciBnZXRzIHRvIHRoZSBkZXN0aW5hdGlvbiB2ZWN0b3IuXG4gICAgICogQGRlc2NyaXB0aW9uIExpbmVhciBpbnRlcnBvbGF0ZSBvbmUgdmVjdG9yIHRvIGFub3RoZXIgYnkgYW4gYW1vdW50IGB0YCBkZWZpbmVkIGFzIGEgemVybyB0byBvbmUgbnVtYmVyLlxuICAgICAqIEBzZWUgW01hdHQgRGVzTGF1cmllcnNdKGh0dHBzOi8vdHdpdHRlci5jb20vbWF0dGRlc2wvc3RhdHVzLzEwMzEzMDUyNzkyMjc0NzgwMTYpIGhhcyBhIGdvb2QgdGhyZWFkIGFib3V0IHRoaXMuXG4gICAgICovXG4gICAgbGVycDogZnVuY3Rpb24odiwgdCkge1xuICAgICAgdmFyIHggPSAodi54IC0gdGhpcy54KSAqIHQgKyB0aGlzLng7XG4gICAgICB2YXIgeSA9ICh2LnkgLSB0aGlzLnkpICogdCArIHRoaXMueTtcbiAgICAgIHJldHVybiB0aGlzLnNldCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNpc1plcm9cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Vwcz0wLjAwMDFdIC0gT3B0aW9uYWwgcHJlY2lzaW9uIGFtb3VudCB0byBjaGVjayBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGVjayB0byBzZWUgaWYgdmVjdG9yIGlzIHJvdWdobHkgemVybywgYmFzZWQgb24gdGhlIGBlcHNpbG9uYCBwcmVjaXNpb24gdmFsdWUuXG4gICAgICovXG4gICAgaXNaZXJvOiBmdW5jdGlvbihlcHMpIHtcbiAgICAgIGVwcyA9ICh0eXBlb2YgZXBzID09PSAndW5kZWZpbmVkJykgPyAgMC4wMDAxIDogZXBzO1xuICAgICAgcmV0dXJuICh0aGlzLmxlbmd0aCgpIDwgZXBzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciN0b1N0cmluZ1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgb2YgeCwgeSB2YWx1ZS4gR3JlYXQgZm9yIHN0b3JpbmcgaW4gYSBkYXRhYmFzZS5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy54ICsgJywgJyArIHRoaXMueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSB2ZWN0b3IuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgeDogdGhpcy54LCB5OiB0aGlzLnkgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlZlY3RvciNyb3RhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gTnVtYmVyIC0gVGhlIGFtb3VuIHRvIHJvdGF0ZSB0aGUgdmVjdG9yIGJ5LlxuICAgICAqIEBkZXNjcmlwdGlvbiBSb3RhdGUgYSB2ZWN0b3IuXG4gICAgICovXG4gICAgcm90YXRlOiBmdW5jdGlvbihOdW1iZXIpIHtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhOdW1iZXIpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKE51bWJlcik7XG4gICAgICB0aGlzLnggPSB0aGlzLnggKiBjb3MgLSB0aGlzLnkgKiBzaW47XG4gICAgICB0aGlzLnkgPSB0aGlzLnggKiBzaW4gKyB0aGlzLnkgKiBjb3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVGhlIHNhbWUgc2V0IG9mIHByb3RvdHlwaWNhbCBmdW5jdGlvbnMsIGJ1dCB1c2luZyB0aGUgdW5kZXJseWluZ1xuICAvLyBnZXR0ZXIgb3Igc2V0dGVyIGZvciBgeGAgYW5kIGB5YCB2YWx1ZXMuIFRoaXMgc2V0IG9mIGZ1bmN0aW9uc1xuICAvLyBpcyB1c2VkIGluc3RlYWQgb2YgdGhlIHByZXZpb3VzbHkgZG9jdW1lbnRlZCBvbmVzIGFib3ZlIHdoZW5cbiAgLy8gVHdvLlZlY3RvciNiaW5kIGlzIGludm9rZWQgYW5kIHRoZXJlIGlzIGV2ZW50IGRpc3BhdGNoaW5nIHByb2Nlc3NlZFxuICAvLyBvbiB4IC8geSBwcm9wZXJ0eSBjaGFuZ2VzLlxuICB2YXIgQm91bmRQcm90byA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBWZWN0b3IsXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMuX3ggPSB4O1xuICAgICAgdGhpcy5feSA9IHk7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl94ID0gdi54O1xuICAgICAgdGhpcy5feSA9IHYueTtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgdGhpcy5feSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLl94LCB0aGlzLl95KTtcbiAgICB9LFxuXG4gICAgYWRkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3ggKz0geDtcbiAgICAgICAgICB0aGlzLl95ICs9IHg7XG4gICAgICAgIH0gIGVsc2UgaWYgKHggJiYgdHlwZW9mIHgueCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHgueSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aGlzLl94ICs9IHgueDtcbiAgICAgICAgICB0aGlzLl95ICs9IHgueTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5feCArPSB4O1xuICAgICAgICB0aGlzLl95ICs9IHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBzdWI6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5feCAtPSB4O1xuICAgICAgICAgIHRoaXMuX3kgLT0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4LnggPT09ICdudW1iZXInICYmIHR5cGVvZiB4LnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5feCAtPSB4Lng7XG4gICAgICAgICAgdGhpcy5feSAtPSB4Lnk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ggLT0geDtcbiAgICAgICAgdGhpcy5feSAtPSB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICB9LFxuXG4gICAgbXVsdGlwbHk6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgICBpZiAodHlwZW9mIHggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5feCAqPSB4O1xuICAgICAgICAgIHRoaXMuX3kgKj0geDtcbiAgICAgICAgfSBlbHNlIGlmICh4ICYmIHR5cGVvZiB4LnggPT09ICdudW1iZXInICYmIHR5cGVvZiB4LnkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhpcy5feCAqPSB4Lng7XG4gICAgICAgICAgdGhpcy5feSAqPSB4Lnk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ggKj0geDtcbiAgICAgICAgdGhpcy5feSAqPSB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICB9LFxuXG4gICAgZGl2aWRlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3ggLz0geDtcbiAgICAgICAgICB0aGlzLl95IC89IHg7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAmJiB0eXBlb2YgeC54ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgeC55ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3ggLz0geC54O1xuICAgICAgICAgIHRoaXMuX3kgLz0geC55O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl94IC89IHg7XG4gICAgICAgIHRoaXMuX3kgLz0geTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmlzTmFOKHRoaXMuX3gpKSB7XG4gICAgICAgIHRoaXMuX3ggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNOYU4odGhpcy5feSkpIHtcbiAgICAgICAgdGhpcy5feSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuICAgIH0sXG5cbiAgICBkb3Q6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHJldHVybiB0aGlzLl94ICogdi54ICsgdGhpcy5feSAqIHYueTtcbiAgICB9LFxuXG4gICAgbGVuZ3RoU3F1YXJlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feTtcbiAgICB9LFxuXG4gICAgZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciBkeCA9IHRoaXMuX3ggLSB2LngsXG4gICAgICAgICAgZHkgPSB0aGlzLl95IC0gdi55O1xuICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH0sXG5cbiAgICBsZXJwOiBmdW5jdGlvbih2LCB0KSB7XG4gICAgICB2YXIgeCA9ICh2LnggLSB0aGlzLl94KSAqIHQgKyB0aGlzLl94O1xuICAgICAgdmFyIHkgPSAodi55IC0gdGhpcy5feSkgKiB0ICsgdGhpcy5feTtcbiAgICAgIHJldHVybiB0aGlzLnNldCh4LCB5KTtcbiAgICB9LFxuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ggKyAnLCAnICsgdGhpcy5feTtcbiAgICB9LFxuXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgeDogdGhpcy5feCwgeTogdGhpcy5feSB9O1xuICAgIH0sXG5cbiAgICByb3RhdGU6IGZ1bmN0aW9uIChOdW1iZXIpIHtcbiAgICAgIHZhciBjb3MgPSBNYXRoLmNvcyhOdW1iZXIpO1xuICAgICAgdmFyIHNpbiA9IE1hdGguc2luKE51bWJlcik7XG4gICAgICB0aGlzLl94ID0gdGhpcy5feCAqIGNvcyAtIHRoaXMuX3kgKiBzaW47XG4gICAgICB0aGlzLl95ID0gdGhpcy5feCAqIHNpbiArIHRoaXMuX3kgKiBjb3M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgfTtcblxuICB2YXIgeGdzID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl94O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl94ID0gdjtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlLCAneCcpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgeWdzID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl95O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLl95ID0gdjtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlLCAneScpO1xuICAgIH1cbiAgfTtcblxuICBWZWN0b3IuTWFrZU9ic2VydmFibGUoVmVjdG9yLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBAbmFtZSBUd28uQW5jaG9yXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSByb290IGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHJvb3QgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2x4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGxlZnQgaGFuZGxlIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2x5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGxlZnQgaGFuZGxlIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3J4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHJpZ2h0IGhhbmRsZSBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSByaWdodCBoYW5kbGUgcG9pbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbY29tbWFuZD1Ud28uQ29tbWFuZHMubW92ZV0gLSBUaGUgY29tbWFuZCB0byBkZXNjcmliZSBob3cgdG8gcmVuZGVyLiBBcHBsaWNhYmxlIGNvbW1hbmRzIGFyZSB7QGxpbmsgVHdvLkNvbW1hbmRzfVxuICAgKiBAZXh0ZW5kcyBUd28uVmVjdG9yXG4gICAqIEBkZXNjcmlwdGlvbiBBbiBvYmplY3QgdGhhdCBob2xkcyAzIHtAbGluayBUd28uVmVjdG9yfXMsIHRoZSBhbmNob3IgcG9pbnQgYW5kIGl0cyBjb3JyZXNwb25kaW5nIGhhbmRsZXM6IGBsZWZ0YCBhbmQgYHJpZ2h0YC4gSW4gb3JkZXIgdG8gcHJvcGVybHkgZGVzY3JpYmUgdGhlIGJlemllciBjdXJ2ZSBhYm91dCB0aGUgcG9pbnQgdGhlcmUgaXMgYWxzbyBhIGNvbW1hbmQgcHJvcGVydHkgdG8gZGVzY3JpYmUgd2hhdCB0eXBlIG9mIGRyYXdpbmcgc2hvdWxkIG9jY3VyIHdoZW4gVHdvLmpzIHJlbmRlcnMgdGhlIGFuY2hvcnMuXG4gICAqL1xuICBmdW5jdGlvbiBBbmNob3IoeCwgeSwgbHgsIGx5LCByeCwgcnksIGNvbW1hbmQpIHtcblxuICAgIFZlY3Rvci5jYWxsKHRoaXMsIHgsIHkpO1xuXG4gICAgdGhpcy5fYnJvYWRjYXN0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9jb21tYW5kID0gY29tbWFuZCB8fCBDb21tYW5kcy5tb3ZlO1xuICAgIHRoaXMuX3JlbGF0aXZlID0gdHJ1ZTtcblxuICAgIHZhciBpbHggPSB0eXBlb2YgbHggPT09ICdudW1iZXInO1xuICAgIHZhciBpbHkgPSB0eXBlb2YgbHkgPT09ICdudW1iZXInO1xuICAgIHZhciBpcnggPSB0eXBlb2YgcnggPT09ICdudW1iZXInO1xuICAgIHZhciBpcnkgPSB0eXBlb2YgcnkgPT09ICdudW1iZXInO1xuXG4gICAgLy8gQXBwZW5kIHRoZSBgY29udHJvbHNgIG9iamVjdCBvbmx5IGlmIGNvbnRyb2wgcG9pbnRzIGFyZSBzcGVjaWZpZWQsXG4gICAgLy8ga2VlcGluZyB0aGUgVHdvLkFuY2hvciBpbmxpbmUgd2l0aCBhIFR3by5WZWN0b3IgdW50aWwgaXQgbmVlZHMgdG9cbiAgICAvLyBldm9sdmUgYmV5b25kIHRob3NlIGZ1bmN0aW9ucyAtIGUuZzogYSBzaW1wbGUgMiBjb21wb25lbnQgdmVjdG9yLlxuICAgIGlmIChpbHggfHwgaWx5IHx8IGlyeCB8fCBpcnkpIHtcbiAgICAgIEFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXModGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKGlseCkge1xuICAgICAgdGhpcy5jb250cm9scy5sZWZ0LnggPSBseDtcbiAgICB9XG4gICAgaWYgKGlseSkge1xuICAgICAgdGhpcy5jb250cm9scy5sZWZ0LnkgPSBseTtcbiAgICB9XG4gICAgaWYgKGlyeCkge1xuICAgICAgdGhpcy5jb250cm9scy5yaWdodC54ID0gcng7XG4gICAgfVxuICAgIGlmIChpcnkpIHtcbiAgICAgIHRoaXMuY29udHJvbHMucmlnaHQueSA9IHJ5O1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoQW5jaG9yLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkFuY2hvcn0gYW5jaG9yIC0gVGhlIGluc3RhbmNlIHRvIGFwcGVuZCB0aGUgYGNvbnRyb2xgb2JqZWN0IHRvLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGRzIHRoZSBgY29udHJvbHNgIHByb3BlcnR5IGFzIGFuIG9iamVjdCB3aXRoIGBsZWZ0YCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzIHRvIGFjY2VzcyB0aGUgYmV6aWVyIGNvbnRyb2wgaGFuZGxlcyB0aGF0IGRlZmluZSBob3cgdGhlIGN1cnZlIGlzIGRyYXduLiBJdCBhbHNvIHNldHMgdGhlIGByZWxhdGl2ZWAgcHJvcGVydHkgdG8gYHRydWVgIG1ha2luZyB2ZWN0b3JzIGluIHRoZSBgY29udHJvbHNgIG9iamVjdCByZWxhdGl2ZSB0byB0aGVpciBjb3JyZXNwb25kaW5nIHJvb3QgYW5jaG9yIHBvaW50LlxuICAgICAqL1xuICAgIEFwcGVuZEN1cnZlUHJvcGVydGllczogZnVuY3Rpb24oYW5jaG9yKSB7XG5cbiAgICAgIGFuY2hvci5yZWxhdGl2ZSA9IHRydWU7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgVHdvLkFuY2hvciNjb250cm9sc1xuICAgICAgICogQHByb3BlcnR5IHtPYmplY3R9IGNvbnRyb2xzXG4gICAgICAgKiBAZGVzY3JpcHRpb24gQW4gcGxhaW4gb2JqZWN0IHRoYXQgaG9sZHMgdGhlIGNvbnRyb2xzIGhhbmRsZXMgZm9yIGEge0BsaW5rIFR3by5BbmNob3J9LlxuICAgICAgICovXG4gICAgICBhbmNob3IuY29udHJvbHMgPSB7fTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBUd28uQW5jaG9yI2NvbnRyb2xzI2xlZnRcbiAgICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gbGVmdFxuICAgICAgICogQGRlc2NyaXB0aW9uIFRoZSBcImxlZnRcIiBjb250cm9sIHBvaW50IHRvIGRlZmluZSBoYW5kbGVzIG9uIGEgYmV6aWVyIGN1cnZlLlxuICAgICAgICovXG4gICAgICBhbmNob3IuY29udHJvbHMubGVmdCA9IG5ldyBWZWN0b3IoMCwgMCk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgVHdvLkFuY2hvciNjb250cm9scyNyaWdodFxuICAgICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSByaWdodFxuICAgICAgICogQGRlc2NyaXB0aW9uIFRoZSBcImxlZnRcIiBjb250cm9sIHBvaW50IHRvIGRlZmluZSBoYW5kbGVzIG9uIGEgYmV6aWVyIGN1cnZlLlxuICAgICAgICovXG4gICAgICBhbmNob3IuY29udHJvbHMucmlnaHQgPSBuZXcgVmVjdG9yKDAsIDApO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BbmNob3IuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5BbmNob3J9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLkFuY2hvcn0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lIFR3by5BbmNob3IjY29tbWFuZFxuICAgICAgICogQHByb3BlcnR5IHtUd28uQ29tbWFuZHN9XG4gICAgICAgKiBAZGVzY3JpcHRpb24gQSBkcmF3IGNvbW1hbmQgYXNzb2NpYXRlZCB3aXRoIHRoZSBhbmNob3IgcG9pbnQuXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjb21tYW5kJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICB0aGlzLl9jb21tYW5kID0gYztcbiAgICAgICAgICBpZiAodGhpcy5fY29tbWFuZCA9PT0gQ29tbWFuZHMuY3VydmUgJiYgIV8uaXNPYmplY3QodGhpcy5jb250cm9scykpIHtcbiAgICAgICAgICAgIEFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBUd28uQW5jaG9yI3JlbGF0aXZlXG4gICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59XG4gICAgICAgKiBAZGVzY3JpcHRpb24gQSBib29sZWFuIHRvIHJlbmRlciBjb250cm9sIHBvaW50cyByZWxhdGl2ZSB0byB0aGUgcm9vdCBhbmNob3IgcG9pbnQgb3IgaW4gZ2xvYmFsIGNvb3JkaW5hdGUtc3BhY2UgdG8gdGhlIHJlc3Qgb2YgdGhlIHNjZW5lLlxuICAgICAgICovXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncmVsYXRpdmUnLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxhdGl2ZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICBpZiAodGhpcy5fcmVsYXRpdmUgIT0gYikge1xuICAgICAgICAgICAgdGhpcy5fcmVsYXRpdmUgPSAhIWI7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBfLmV4dGVuZChvYmplY3QsIFZlY3Rvci5wcm90b3R5cGUsIEFuY2hvclByb3RvKTtcblxuICAgICAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBiaW5kIGFuZCBzdGlsbCBoYXZlIHRoZSBBbmNob3Igc3BlY2lmaWNcbiAgICAgIC8vIGluaGVyaXRhbmNlIGZyb20gVHdvLlZlY3Rvci4gSW4gdGhpcyBjYXNlIHJlbHlpbmcgb24gYFR3by5WZWN0b3JgXG4gICAgICAvLyB0byBkbyBtdWNoIG9mIHRoZSBoZWF2eSBldmVudC1saXN0ZW5lciBiaW5kaW5nIC8gdW5iaW5kaW5nLlxuICAgICAgb2JqZWN0LmJpbmQgPSBvYmplY3Qub24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGJvdW5kID0gdGhpcy5fYm91bmQ7XG4gICAgICAgIFZlY3Rvci5wcm90b3R5cGUuYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICBpZiAoIWJvdW5kKSB7XG4gICAgICAgICAgXy5leHRlbmQodGhpcywgQW5jaG9yUHJvdG8pO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIHZhciBBbmNob3JQcm90byA9IHtcblxuICAgIGNvbnN0cnVjdG9yOiBBbmNob3IsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yI2xpc3RlblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgdXNlZCBtYWlubHkgYnkge0BsaW5rIFR3by5QYXRoI3ZlcnRpY2VzfSB0byBsaXN0ZW4gYW5kIHByb3BhZ2F0ZSBjaGFuZ2VzIGZyb20gY29udHJvbCBwb2ludHMgdXAgdG8gdGhlaXIgcmVzcGVjdGl2ZSBhbmNob3JzIGFuZCBmdXJ0aGVyIGlmIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBsaXN0ZW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIV8uaXNPYmplY3QodGhpcy5jb250cm9scykpIHtcbiAgICAgICAgQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250cm9scy5sZWZ0LmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fYnJvYWRjYXN0KTtcbiAgICAgIHRoaXMuY29udHJvbHMucmlnaHQuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9icm9hZGNhc3QpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQW5jaG9yI2lnbm9yZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgdXNlZCBtYWlubHkgYnkge0BsaW5rIFR3by5QYXRoI3ZlcnRpY2VzfSB0byBpZ25vcmUgY2hhbmdlcyBmcm9tIGEgc3BlY2lmaWMgYW5jaG9yJ3MgY29udHJvbCBwb2ludHMuXG4gICAgICovXG4gICAgaWdub3JlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5jb250cm9scy5sZWZ0LnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9icm9hZGNhc3QpO1xuICAgICAgdGhpcy5jb250cm9scy5yaWdodC51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fYnJvYWRjYXN0KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFuY2hvciNjb3B5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uQW5jaG9yfSB2IC0gVGhlIGFuY2hvciB0byBhcHBseSB2YWx1ZXMgdG8uXG4gICAgICogQGRlc2NyaXB0aW9uIENvcHkgdGhlIHByb3BlcnRpZXMgb2Ygb25lIHtAbGluayBUd28uQW5jaG9yfSBvbnRvIGFub3RoZXIuXG4gICAgICovXG4gICAgY29weTogZnVuY3Rpb24odikge1xuXG4gICAgICB0aGlzLnggPSB2Lng7XG4gICAgICB0aGlzLnkgPSB2Lnk7XG5cbiAgICAgIGlmICh0eXBlb2Ygdi5jb21tYW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLmNvbW1hbmQgPSB2LmNvbW1hbmQ7XG4gICAgICB9XG4gICAgICBpZiAoXy5pc09iamVjdCh2LmNvbnRyb2xzKSkge1xuICAgICAgICBpZiAoIV8uaXNPYmplY3QodGhpcy5jb250cm9scykpIHtcbiAgICAgICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IERvIHdlIG5lZWQgdG8gbGlzdGVuIGhlcmU/XG4gICAgICAgIHRoaXMuY29udHJvbHMubGVmdC5jb3B5KHYuY29udHJvbHMubGVmdCk7XG4gICAgICAgIHRoaXMuY29udHJvbHMucmlnaHQuY29weSh2LmNvbnRyb2xzLnJpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygdi5yZWxhdGl2ZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHRoaXMucmVsYXRpdmUgPSB2LnJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBIYWNrIGZvciBgVHdvLkNvbW1hbmRzLmFyY2BcbiAgICAgIGlmICh0aGlzLmNvbW1hbmQgPT09IENvbW1hbmRzLmFyYykge1xuICAgICAgICB0aGlzLnJ4ID0gdi5yeDtcbiAgICAgICAgdGhpcy5yeSA9IHYucnk7XG4gICAgICAgIHRoaXMueEF4aXNSb3RhdGlvbiA9IHYueEF4aXNSb3RhdGlvbjtcbiAgICAgICAgdGhpcy5sYXJnZUFyY0ZsYWcgPSB2LmxhcmdlQXJjRmxhZztcbiAgICAgICAgdGhpcy5zd2VlcEZsYWcgPSB2LnN3ZWVwRmxhZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFuY2hvciNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtUd28uQW5jaG9yfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcge0BsaW5rIFR3by5BbmNob3J9LCBzZXQgYWxsIGl0cyB2YWx1ZXMgdG8gdGhlIGN1cnJlbnQgaW5zdGFuY2UgYW5kIHJldHVybiBpdCBmb3IgdXNlLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIGNvbnRyb2xzID0gdGhpcy5jb250cm9scztcblxuICAgICAgdmFyIGNsb25lID0gbmV3IEFuY2hvcihcbiAgICAgICAgdGhpcy54LFxuICAgICAgICB0aGlzLnksXG4gICAgICAgIGNvbnRyb2xzICYmIGNvbnRyb2xzLmxlZnQueCxcbiAgICAgICAgY29udHJvbHMgJiYgY29udHJvbHMubGVmdC55LFxuICAgICAgICBjb250cm9scyAmJiBjb250cm9scy5yaWdodC54LFxuICAgICAgICBjb250cm9scyAmJiBjb250cm9scy5yaWdodC55LFxuICAgICAgICB0aGlzLmNvbW1hbmRcbiAgICAgICk7XG4gICAgICBjbG9uZS5yZWxhdGl2ZSA9IHRoaXMuX3JlbGF0aXZlO1xuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BbmNob3IjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIEFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZmlsbGVkIG91dCB0byBtaXJyb3Ige0BsaW5rIFR3by5BbmNob3J9LlxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLiBJbnRlbmRlZCBmb3IgdXNlIHdpdGggc3RvcmluZyB2YWx1ZXMgaW4gYSBkYXRhYmFzZS5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbyA9IHtcbiAgICAgICAgeDogdGhpcy54LFxuICAgICAgICB5OiB0aGlzLnlcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5fY29tbWFuZCkge1xuICAgICAgICBvLmNvbW1hbmQgPSB0aGlzLl9jb21tYW5kO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3JlbGF0aXZlKSB7XG4gICAgICAgIG8ucmVsYXRpdmUgPSB0aGlzLl9yZWxhdGl2ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRyb2xzKSB7XG4gICAgICAgIG8uY29udHJvbHMgPSB7XG4gICAgICAgICAgbGVmdDogdGhpcy5jb250cm9scy5sZWZ0LnRvT2JqZWN0KCksXG4gICAgICAgICAgcmlnaHQ6IHRoaXMuY29udHJvbHMucmlnaHQudG9PYmplY3QoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BbmNob3IjdG9TdHJpbmdcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIEEgU3RyaW5nIHdpdGggY29tbWEtc2VwYXJhdGVkIHZhbHVlcyByZWZsZWN0aW5nIHRoZSB2YXJpb3VzIHZhbHVlcyBvbiB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgc3RyaW5nIGZvcm0gb2YgdGhlIGN1cnJlbnQgaW5zdGFuY2UuIEludGVuZGVkIGZvciB1c2Ugd2l0aCBzdG9yaW5nIHZhbHVlcyBpbiBhIGRhdGFiYXNlLiBUaGlzIGlzIGxpZ2h0ZXIgdG8gc3RvcmUgdGhhbiB0aGUgSlNPTiBjb21wYXRpYmxlIHtAbGluayBUd28uQW5jaG9yI3RvT2JqZWN0fS5cbiAgICAgKi9cbiAgICB0b1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udHJvbHMpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLl94LCB0aGlzLl95XS5qb2luKCcsICcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt0aGlzLl94LCB0aGlzLl95LCB0aGlzLmNvbnRyb2xzLmxlZnQueCwgdGhpcy5jb250cm9scy5sZWZ0LnksXG4gICAgICAgIHRoaXMuY29udHJvbHMucmlnaHQueCwgdGhpcy5jb250cm9scy5yaWdodC55LCB0aGlzLl9jb21tYW5kLFxuICAgICAgICB0aGlzLl9yZWxhdGl2ZSA/IDEgOiAwXS5qb2luKCcsICcpO1xuICAgIH1cblxuICB9O1xuXG4gIEFuY2hvci5NYWtlT2JzZXJ2YWJsZShBbmNob3IucHJvdG90eXBlKTtcblxuICB2YXIgY291bnQgPSAwO1xuXG4gIHZhciBDb25zdGFudHMgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28ubmV4dEZyYW1lSURcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIGlkIG9mIHRoZSBuZXh0IHJlcXVlc3RBbmltYXRpb25GcmFtZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBuZXh0RnJhbWVJRDogbnVsbCxcblxuICAgIC8vIFByaW1pdGl2ZVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlR5cGVzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gVGhlIGRpZmZlcmVudCByZW5kZXJpbmcgdHlwZXMgYXZhaWxhYmxlIGluIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIFR5cGVzOiB7XG4gICAgICB3ZWJnbDogJ1dlYkdMUmVuZGVyZXInLFxuICAgICAgc3ZnOiAnU1ZHUmVuZGVyZXInLFxuICAgICAgY2FudmFzOiAnQ2FudmFzUmVuZGVyZXInXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5WZXJzaW9uXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gVGhlIGN1cnJlbnQgd29ya2luZyB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5LlxuICAgICAqL1xuICAgIFZlcnNpb246ICd2MC43LjgnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlB1Ymxpc2hEYXRlXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gVGhlIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIHB1Ymxpc2ggZGF0ZSBpbiB0aGUgYnVpbGQgcHJvY2VzcyB0byB2ZXJpZnkgdmVyc2lvbiByZWxlYXNlIGNhbmRpZGF0ZXMuXG4gICAgICovXG4gICAgUHVibGlzaERhdGU6ICcyMDIxLTA3LTE0VDAyOjE1OjIzLjY5N1onLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLklkZW50aWZpZXJcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBTdHJpbmcgcHJlZml4IGZvciBhbGwgVHdvLmpzIG9iamVjdCdzIGlkcy4gVGhpcyB0cmlja2xlcyBkb3duIHRvIFNWRyBpZHMuXG4gICAgICovXG4gICAgSWRlbnRpZmllcjogJ3R3by0nLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlc29sdXRpb25cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBEZWZhdWx0IGFtb3VudCBvZiB2ZXJ0aWNlcyB0byBiZSB1c2VkIGZvciBpbnRlcnByZXRpbmcgQXJjcyBhbmQgQXJjU2VnbWVudHMuXG4gICAgICovXG4gICAgUmVzb2x1dGlvbjogMTIsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXV0b0NhbGN1bGF0ZUltcG9ydGVkTWF0cmljZXNcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gV2hlbiBpbXBvcnRpbmcgU1ZHcyB0aHJvdWdoIHRoZSB7QGxpbmsgdHdvI2ludGVycHJldH0gYW5kIHtAbGluayB0d28jbG9hZH0sIHRoaXMgYm9vbGVhbiBkZXRlcm1pbmVzIHdoZXRoZXIgVHdvLmpzIGluZmVycyBhbmQgdGhlbiBvdmVycmlkZXMgdGhlIGV4YWN0IHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgcmVmZXJlbmNlIFNWRy5cbiAgICAgKiBAbm90YS1iZW5lIGBmYWxzZWAgY29waWVzIHRoZSBleGFjdCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggdmFsdWVzLCBidXQgYWxzbyBzZXRzIHRoZSBwYXRoJ3MgYG1hdHJpeC5tYW51YWwgPSB0cnVlYC5cbiAgICAgKi9cbiAgICBBdXRvQ2FsY3VsYXRlSW1wb3J0ZWRNYXRyaWNlczogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbnN0YW5jZXNcbiAgICAgKiBAcHJvcGVydHkge1R3b1tdfSAtIFJlZ2lzdGVyZWQgbGlzdCBvZiBhbGwgVHdvLmpzIGluc3RhbmNlcyBpbiB0aGUgY3VycmVudCBzZXNzaW9uLlxuICAgICAqL1xuICAgIEluc3RhbmNlczogW10sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb24gVHdvLnVuaXF1ZUlkXG4gICAgICogQGRlc2NyaXB0aW9uIFNpbXBsZSBtZXRob2QgdG8gYWNjZXNzIGFuIGluY3JlbWVudGluZyB2YWx1ZS4gVXNlZCBmb3IgYGlkYCBhbGxvY2F0aW9uIG9uIGFsbCBUd28uanMgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfSBFdmVyIGluY3JlYXNpbmcgTnVtYmVyLlxuICAgICAqL1xuICAgIHVuaXF1ZUlkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb3VudCsrO1xuICAgIH1cblxuICB9O1xuXG4gIHZhciBIQUxGX1BJJDMgPSBNYXRoLlBJIC8gMjtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLkN1cnZlXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIEFkZGl0aW9uYWwgdXRpbGl0eSBjb25zdGFudCB2YXJpYWJsZXMgcmVsYXRlZCB0byBjdXJ2ZSBtYXRoIGFuZCBjYWxjdWxhdGlvbnMuXG4gICAqL1xuICB2YXIgQ3VydmUgPSB7XG5cbiAgICBDb2xsaW5lYXJpdHlFcHNpbG9uOiBNYXRoLnBvdygxMCwgLTMwKSxcblxuICAgIFJlY3Vyc2lvbkxpbWl0OiAxNixcblxuICAgIEN1c3BMaW1pdDogMCxcblxuICAgIFRvbGVyYW5jZToge1xuICAgICAgZGlzdGFuY2U6IDAuMjUsXG4gICAgICBhbmdsZTogMCxcbiAgICAgIGVwc2lsb246IE51bWJlci5FUFNJTE9OXG4gICAgfSxcblxuICAgIC8vIExvb2t1cCB0YWJsZXMgZm9yIGFic2Npc3NhcyBhbmQgd2VpZ2h0cyB3aXRoIHZhbHVlcyBmb3IgbiA9IDIgLi4gMTYuXG4gICAgLy8gQXMgdmFsdWVzIGFyZSBzeW1tZXRyaWMsIG9ubHkgc3RvcmUgaGFsZiBvZiB0aGVtIGFuZCBhZGFwdCBhbGdvcml0aG1cbiAgICAvLyB0byBmYWN0b3IgaW4gc3ltbWV0cnkuXG4gICAgYWJzY2lzc2FzOiBbXG4gICAgICBbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuICAgICAgWzAsMC43NzQ1OTY2NjkyNDE0ODMzNzcwMzU4NTMxXSxcbiAgICAgIFsgIDAuMzM5OTgxMDQzNTg0ODU2MjY0ODAyNjY1OCwwLjg2MTEzNjMxMTU5NDA1MjU3NTIyMzk0NjVdLFxuICAgICAgWzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG4gICAgICBbICAwLjIzODYxOTE4NjA4MzE5NjkwODYzMDUwMTcsMC42NjEyMDkzODY0NjYyNjQ1MTM2NjEzOTk2LDAuOTMyNDY5NTE0MjAzMTUyMDI3ODEyMzAxNl0sXG4gICAgICBbMCwwLjQwNTg0NTE1MTM3NzM5NzE2NjkwNjYwNjQsMC43NDE1MzExODU1OTkzOTQ0Mzk4NjM4NjQ4LDAuOTQ5MTA3OTEyMzQyNzU4NTI0NTI2MTg5N10sXG4gICAgICBbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuICAgICAgWzAsMC4zMjQyNTM0MjM0MDM4MDg5MjkwMzg1MzgwLDAuNjEzMzcxNDMyNzAwNTkwMzk3MzA4NzAyMCwwLjgzNjAzMTEwNzMyNjYzNTc5NDI5OTQyOTgsMC45NjgxNjAyMzk1MDc2MjYwODk4MzU1NzYyXSxcbiAgICAgIFsgIDAuMTQ4ODc0MzM4OTgxNjMxMjEwODg0ODI2MCwwLjQzMzM5NTM5NDEyOTI0NzE5MDc5OTI2NTksMC42Nzk0MDk1NjgyOTkwMjQ0MDYyMzQzMjc0LDAuODY1MDYzMzY2Njg4OTg0NTEwNzMyMDk2NywwLjk3MzkwNjUyODUxNzE3MTcyMDA3Nzk2NDBdLFxuICAgICAgWzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG4gICAgICBbICAwLjEyNTIzMzQwODUxMTQ2ODkxNTQ3MjQ0MTQsMC4zNjc4MzE0OTg5OTgxODAxOTM3NTI2OTE1LDAuNTg3MzE3OTU0Mjg2NjE3NDQ3Mjk2NzAyNCwwLjc2OTkwMjY3NDE5NDMwNDY4NzAzNjg5MzgsMC45MDQxMTcyNTYzNzA0NzQ4NTY2Nzg0NjU5LDAuOTgxNTYwNjM0MjQ2NzE5MjUwNjkwNTQ5MV0sXG4gICAgICBbMCwwLjIzMDQ1ODMxNTk1NTEzNDc5NDA2NTUyODEsMC40NDg0OTI3NTEwMzY0NDY4NTI4Nzc5MTI5LDAuNjQyMzQ5MzM5NDQwMzQwMjIwNjQzOTg0NiwwLjgwMTU3ODA5MDczMzMwOTkxMjc5NDIwNjUsMC45MTc1OTgzOTkyMjI5Nzc5NjUyMDY1NDc4LDAuOTg0MTgzMDU0NzE4NTg4MTQ5NDcyODI5NF0sXG4gICAgICBbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuICAgICAgWzAsMC4yMDExOTQwOTM5OTc0MzQ1MjIzMDA2MjgzLDAuMzk0MTUxMzQ3MDc3NTYzMzY5ODk3MjA3NCwwLjU3MDk3MjE3MjYwODUzODg0NzUzNzIyNjcsMC43MjQ0MTc3MzEzNjAxNzAwNDc0MTYxODYxLDAuODQ4MjA2NTgzNDEwNDI3MjE2MjAwNjQ4MywwLjkzNzI3MzM5MjQwMDcwNTkwNDMwNzc1ODksMC45ODc5OTI1MTgwMjA0ODU0Mjg0ODk1NjU3XSxcbiAgICAgIFsgIDAuMDk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MywwLjI4MTYwMzU1MDc3OTI1ODkxMzIzMDQ2MDUsMC40NTgwMTY3Nzc2NTcyMjczODYzNDI0MTk0LDAuNjE3ODc2MjQ0NDAyNjQzNzQ4NDQ2NjcxOCwwLjc1NTQwNDQwODM1NTAwMzAzMzg5NTEwMTIsMC44NjU2MzEyMDIzODc4MzE3NDM4ODA0Njc5LDAuOTQ0NTc1MDIzMDczMjMyNTc2MDc3OTg4NCwwLjk4OTQwMDkzNDk5MTY0OTkzMjU5NjE1NDJdXG4gICAgXSxcblxuICAgIHdlaWdodHM6IFtcbiAgICAgIFsxXSxcbiAgICAgIFswLjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC41NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU2XSxcbiAgICAgIFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcbiAgICAgIFswLjU2ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC40Nzg2Mjg2NzA0OTkzNjY0NjgwNDEyOTE1LDAuMjM2OTI2ODg1MDU2MTg5MDg3NTE0MjY0MF0sXG4gICAgICBbMC40Njc5MTM5MzQ1NzI2OTEwNDczODk4NzAzLDAuMzYwNzYxNTczMDQ4MTM4NjA3NTY5ODMzNSwwLjE3MTMyNDQ5MjM3OTE3MDM0NTA0MDI5NjFdLFxuICAgICAgWzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG4gICAgICBbMC4zNjI2ODM3ODMzNzgzNjE5ODI5NjUxNTA0LDAuMzEzNzA2NjQ1ODc3ODg3Mjg3MzM3OTYyMiwwLjIyMjM4MTAzNDQ1MzM3NDQ3MDU0NDM1NjAsMC4xMDEyMjg1MzYyOTAzNzYyNTkxNTI1MzE0XSxcbiAgICAgIFswLjMzMDIzOTM1NTAwMTI1OTc2MzE2NDUyNTEsMC4zMTIzNDcwNzcwNDAwMDI4NDAwNjg2MzA0LDAuMjYwNjEwNjk2NDAyOTM1NDYyMzE4NzQyOSwwLjE4MDY0ODE2MDY5NDg1NzQwNDA1ODQ3MjAsMC4wODEyNzQzODgzNjE1NzQ0MTE5NzE4OTIyXSxcbiAgICAgIFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcbiAgICAgIFswLjI3MjkyNTA4Njc3NzkwMDYzMDcxNDQ4MzUsMC4yNjI4MDQ1NDQ1MTAyNDY2NjIxODA2ODg5LDAuMjMzMTkzNzY0NTkxOTkwNDc5OTE4NTIzNywwLjE4NjI5MDIxMDkyNzczNDI1MTQyNjA5NzYsMC4xMjU1ODAzNjk0NjQ5MDQ2MjQ2MzQ2OTQzLDAuMDU1NjY4NTY3MTE2MTczNjY2NDgyNzUzN10sXG4gICAgICBbMC4yNDkxNDcwNDU4MTM0MDI3ODUwMDA1NjI0LDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5OSwwLjIwMzE2NzQyNjcyMzA2NTkyMTc0OTA2NDUsMC4xNjAwNzgzMjg1NDMzNDYyMjYzMzQ2NTI1LDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NywwLjA0NzE3NTMzNjM4NjUxMTgyNzE5NDYxNjBdLFxuICAgICAgWzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG4gICAgICBbMC4yMTUyNjM4NTM0NjMxNTc3OTAxOTU4NzY0LDAuMjA1MTk4NDYzNzIxMjk1NjAzOTY1OTI0MSwwLjE4NTUzODM5NzQ3NzkzNzgxMzc0MTcxNjYsMC4xNTcyMDMxNjcxNTgxOTM1MzQ1Njk2MDE5LDAuMTIxNTE4NTcwNjg3OTAzMTg0Njg5NDE0OCwwLjA4MDE1ODA4NzE1OTc2MDIwOTgwNTYzMzMsMC4wMzUxMTk0NjAzMzE3NTE4NjMwMzE4MzI5XSxcbiAgICAgIFswLjIwMjU3ODI0MTkyNTU2MTI3Mjg4MDYyMDIsMC4xOTg0MzE0ODUzMjcxMTE1NzY0NTYxMTgzLDAuMTg2MTYxMDAwMDE1NTYyMjExMDI2ODAwNiwwLjE2NjI2OTIwNTgxNjk5MzkzMzU1MzIwMDksMC4xMzk1NzA2Nzc5MjYxNTQzMTQ0NDc4MDQ4LDAuMTA3MTU5MjIwNDY3MTcxOTM1MDExODY5NSwwLjA3MDM2NjA0NzQ4ODEwODEyNDcwOTI2NzQsMC4wMzA3NTMyNDE5OTYxMTcyNjgzNTQ2Mjg0XSxcbiAgICAgIFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuICAgIF1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q29tcG9uZW50T25DdWJpY0JlemllclxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHQgLSBaZXJvLXRvLW9uZSB2YWx1ZSBkZXNjcmliaW5nIHdoYXQgcGVyY2VudGFnZSB0byBjYWxjdWxhdGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gVGhlIGZpcnQgcG9pbnQncyBjb21wb25lbnQgdmFsdWUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBiIC0gVGhlIGZpcnN0IHBvaW50J3MgYmV6aWVyIGNvbXBvbmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGMgLSBUaGUgc2Vjb25kIHBvaW50J3MgYmV6aWVyIGNvbXBvbmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGQgLSBUaGUgc2Vjb25kIHBvaW50J3MgY29tcG9uZW50IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgY29vcmRpbmF0ZSB2YWx1ZSBmb3IgYSBzcGVjaWZpYyBjb21wb25lbnQgYWxvbmcgYSBjdWJpYyBiZXppZXIgY3VydmUgYnkgYHRgLlxuICAgKi9cbiAgdmFyIGdldENvbXBvbmVudE9uQ3ViaWNCZXppZXIgPSBmdW5jdGlvbih0LCBhLCBiLCBjLCBkKSB7XG4gICAgdmFyIGsgPSAxIC0gdDtcbiAgICByZXR1cm4gKGsgKiBrICogayAqIGEpICsgKDMgKiBrICogayAqIHQgKiBiKSArICgzICogayAqIHQgKiB0ICogYykgK1xuICAgICAgICAodCAqIHQgKiB0ICogZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5zdWJkaXZpZGVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4MSAtIHggcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTEgLSB5IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgyIC0geCBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkyIC0geSBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQncyBcInJpZ2h0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgzIC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHkzIC0geSBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50J3MgXCJsZWZ0XCIgYmV6aWVyIGhhbmRsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHg0IC0geCBwb3NpdGlvbiBvZiBzZWNvbmQgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geTQgLSB5IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbGltaXQ9VHdvLlV0aWxzLkN1cnZlLlJlY3Vyc2lvbkxpbWl0XSAtIFRoZSBhbW91bnQgb2YgdmVydGljZXMgdG8gY3JlYXRlIGJ5IHN1YmRpdmlkaW5nLlxuICAgKiBAcmV0dXJucyB7QW5jaG9yW119IEEgbGlzdCBvZiBhbmNob3IgcG9pbnRzIG9yZGVyZWQgaW4gYmV0d2VlbiBgeDFgLCBgeTFgIGFuZCBgeDRgLCBgeTRgXG4gICAqIEBkZXNjcmlwdGlvbiBHaXZlbiAyIHBvaW50cyAoYSwgYikgYW5kIGNvcnJlc3BvbmRpbmcgY29udHJvbCBwb2ludCBmb3IgZWFjaCByZXR1cm4gYW4gYXJyYXkgb2YgcG9pbnRzIHRoYXQgcmVwcmVzZW50IHBvaW50cyBwbG90dGVkIGFsb25nIHRoZSBjdXJ2ZS4gVGhlIG51bWJlciBvZiByZXR1cm5lZCBwb2ludHMgaXMgZGV0ZXJtaW5lZCBieSBgbGltaXRgLlxuICAgKi9cbiAgdmFyIHN1YmRpdmlkZSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGltaXQpIHtcblxuICAgIGxpbWl0ID0gbGltaXQgfHwgQ3VydmUuUmVjdXJzaW9uTGltaXQ7XG4gICAgdmFyIGFtb3VudCA9IGxpbWl0ICsgMTtcblxuICAgIC8vIFRPRE86IEFic3RyYWN0IDAuMDAxIHRvIGEgbGltaXRpbmcgdmFyaWFibGVcbiAgICAvLyBEb24ndCByZWN1cnNlIGlmIHRoZSBlbmQgcG9pbnRzIGFyZSBpZGVudGljYWxcbiAgICBpZiAoTWF0aC5hYnMoeDEgLSB4NCkgPCAwLjAwMSAmJiBNYXRoLmFicyh5MSAtIHk0KSA8IDAuMDAxKSB7XG4gICAgICByZXR1cm4gW25ldyBBbmNob3IoeDQsIHk0KV07XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgdmFyIHQgPSBpIC8gYW1vdW50O1xuICAgICAgdmFyIHggPSBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyKHQsIHgxLCB4MiwgeDMsIHg0KTtcbiAgICAgIHZhciB5ID0gZ2V0Q29tcG9uZW50T25DdWJpY0Jlemllcih0LCB5MSwgeTIsIHkzLCB5NCk7XG4gICAgICByZXN1bHQucHVzaChuZXcgQW5jaG9yKHgsIHkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5nZXRDdXJ2ZUxlbmd0aFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIC0geCBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MSAtIHkgcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgLSB4IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludCdzIFwicmlnaHRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geTIgLSB5IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludCdzIFwicmlnaHRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geDMgLSB4IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQncyBcImxlZnRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geTMgLSB5IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQncyBcImxlZnRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geDQgLSB4IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5NCAtIHkgcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtsaW1pdD1Ud28uVXRpbHMuQ3VydmUuUmVjdXJzaW9uTGltaXRdIC0gVGhlIGFtb3VudCBvZiB2ZXJ0aWNlcyB0byBjcmVhdGUgYnkgc3ViZGl2aWRpbmcuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBsZW5ndGggb2YgYSBjdXJ2ZS5cbiAgICogQGRlc2NyaXB0aW9uIEdpdmVuIDIgcG9pbnRzIChhLCBiKSBhbmQgY29ycmVzcG9uZGluZyBjb250cm9sIHBvaW50IGZvciBlYWNoLCByZXR1cm4gYSBmbG9hdCB0aGF0IHJlcHJlc2VudHMgdGhlIGxlbmd0aCBvZiB0aGUgY3VydmUgdXNpbmcgR2F1c3MtTGVnZW5kcmUgYWxnb3JpdGhtLiBMaW1pdCBpdGVyYXRpb25zIG9mIGNhbGN1bGF0aW9uIGJ5IGBsaW1pdGAuXG4gICAqL1xuICB2YXIgZ2V0Q3VydmVMZW5ndGgkMSA9IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGltaXQpIHtcblxuICAgIC8vIFRPRE86IEJldHRlciAvIGZ1enppZXIgZXF1YWxpdHkgY2hlY2tcbiAgICAvLyBMaW5lYXIgY2FsY3VsYXRpb25cbiAgICBpZiAoeDEgPT09IHgyICYmIHkxID09PSB5MiAmJiB4MyA9PT0geDQgJiYgeTMgPT09IHk0KSB7XG4gICAgICB2YXIgZHggPSB4NCAtIHgxO1xuICAgICAgdmFyIGR5ID0geTQgLSB5MTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29lZmZpY2llbnRzIG9mIGEgQmV6aWVyIGRlcml2YXRpdmUuXG4gICAgdmFyIGF4ID0gOSAqICh4MiAtIHgzKSArIDMgKiAoeDQgLSB4MSksXG4gICAgICBieCA9IDYgKiAoeDEgKyB4MykgLSAxMiAqIHgyLFxuICAgICAgY3ggPSAzICogKHgyIC0geDEpLFxuXG4gICAgICBheSA9IDkgKiAoeTIgLSB5MykgKyAzICogKHk0IC0geTEpLFxuICAgICAgYnkgPSA2ICogKHkxICsgeTMpIC0gMTIgKiB5MixcbiAgICAgIGN5ID0gMyAqICh5MiAtIHkxKTtcblxuICAgIHZhciBpbnRlZ3JhbmQgPSBmdW5jdGlvbih0KSB7XG4gICAgICAvLyBDYWxjdWxhdGUgcXVhZHJhdGljIGVxdWF0aW9ucyBvZiBkZXJpdmF0aXZlcyBmb3IgeCBhbmQgeVxuICAgICAgdmFyIGR4ID0gKGF4ICogdCArIGJ4KSAqIHQgKyBjeCxcbiAgICAgICAgZHkgPSAoYXkgKiB0ICsgYnkpICogdCArIGN5O1xuICAgICAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfTtcblxuICAgIHJldHVybiBpbnRlZ3JhdGUoXG4gICAgICBpbnRlZ3JhbmQsIDAsIDEsIGxpbWl0IHx8IEN1cnZlLlJlY3Vyc2lvbkxpbWl0XG4gICAgKTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q3VydmVCb3VuZGluZ0JveFxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHgxIC0geCBwb3NpdGlvbiBvZiBmaXJzdCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5MSAtIHkgcG9zaXRpb24gb2YgZmlyc3QgYW5jaG9yIHBvaW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0geDIgLSB4IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludCdzIFwicmlnaHRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geTIgLSB5IHBvc2l0aW9uIG9mIGZpcnN0IGFuY2hvciBwb2ludCdzIFwicmlnaHRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geDMgLSB4IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQncyBcImxlZnRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geTMgLSB5IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQncyBcImxlZnRcIiBiZXppZXIgaGFuZGxlLlxuICAgKiBAcGFyYW0ge051bWJlcn0geDQgLSB4IHBvc2l0aW9uIG9mIHNlY29uZCBhbmNob3IgcG9pbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5NCAtIHkgcG9zaXRpb24gb2Ygc2Vjb25kIGFuY2hvciBwb2ludC5cbiAgICogQHJldHVybnMge09iamVjdH0gT2JqZWN0IGNvbnRhaW5zIG1pbiBhbmQgbWF4IGB4YCAvIGB5YCBib3VuZHMuXG4gICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9hZG9iZS13ZWJwbGF0Zm9ybS9TbmFwLnN2Zy9ibG9iL21hc3Rlci9zcmMvcGF0aC5qcyNMODU2fVxuICAgKi9cbiAgdmFyIGdldEN1cnZlQm91bmRpbmdCb3ggPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQpIHtcblxuICAgIHZhciB0dmFsdWVzID0gW107XG4gICAgdmFyIGJvdW5kcyA9IFtbXSwgW11dO1xuICAgIHZhciBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPT0gMCkge1xuICAgICAgICAgIGIgPSA2ICogeDEgLSAxMiAqIHgyICsgNiAqIHgzO1xuICAgICAgICAgIGEgPSAtMyAqIHgxICsgOSAqIHgyIC0gOSAqIHgzICsgMyAqIHg0O1xuICAgICAgICAgIGMgPSAzICogeDIgLSAzICogeDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYiA9IDYgKiB5MSAtIDEyICogeTIgKyA2ICogeTM7XG4gICAgICAgICAgYSA9IC0zICogeTEgKyA5ICogeTIgLSA5ICogeTMgKyAzICogeTQ7XG4gICAgICAgICAgYyA9IDMgKiB5MiAtIDMgKiB5MTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgICAgIGlmIChNYXRoLmFicyhiKSA8IDFlLTEyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdCA9IC1jIC8gYjtcbiAgICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgICBzcXJ0YjJhYyA9IE1hdGguc3FydChiMmFjKTtcbiAgICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICAgIHR2YWx1ZXMucHVzaCh0MSk7XG4gICAgICAgIH1cbiAgICAgICAgdDIgPSAoLWIgLSBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgICBpZiAoMCA8IHQyICYmIHQyIDwgMSkge1xuICAgICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaiA9IHR2YWx1ZXMubGVuZ3RoO1xuICAgIHZhciBqbGVuID0gajtcbiAgICB2YXIgbXQ7XG5cbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgIG10ID0gMSAtIHQ7XG4gICAgICBib3VuZHNbMF1bal0gPSBtdCAqIG10ICogbXQgKiB4MSArIDMgKiBtdCAqIG10ICogdCAqIHgyICsgMyAqIG10ICogdCAqIHQgKiB4MyArIHQgKiB0ICogdCAqIHg0O1xuICAgICAgYm91bmRzWzFdW2pdID0gbXQgKiBtdCAqIG10ICogeTEgKyAzICogbXQgKiBtdCAqIHQgKiB5MiArIDMgKiBtdCAqIHQgKiB0ICogeTMgKyB0ICogdCAqIHQgKiB5NDtcbiAgICB9XG5cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MTtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MTtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDQ7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHk0O1xuICAgIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluOiB7IHg6IE1hdGgubWluLmFwcGx5KDAsIGJvdW5kc1swXSksIHk6IE1hdGgubWluLmFwcGx5KDAsIGJvdW5kc1sxXSkgfSxcbiAgICAgIG1heDogeyB4OiBNYXRoLm1heC5hcHBseSgwLCBib3VuZHNbMF0pLCB5OiBNYXRoLm1heC5hcHBseSgwLCBib3VuZHNbMV0pIH1cbiAgICB9O1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5pbnRlZ3JhdGVcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGFcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICogQGRlc2NyaXB0aW9uIEludGVncmF0aW9uIGZvciBgZ2V0Q3VydmVMZW5ndGhgIGNhbGN1bGF0aW9ucy5cbiAgICogQHNlZSBbUGFwZXIuanNdKEBsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlcmpzL3BhcGVyLmpzL2Jsb2IvbWFzdGVyL3NyYy91dGlsL051bWVyaWNhbC5qcyNMMTAxKVxuICAgKi9cbiAgdmFyIGludGVncmF0ZSA9IGZ1bmN0aW9uKGYsIGEsIGIsIG4pIHtcbiAgICB2YXIgeCA9IEN1cnZlLmFic2Npc3Nhc1tuIC0gMl0sXG4gICAgICB3ID0gQ3VydmUud2VpZ2h0c1tuIC0gMl0sXG4gICAgICBBID0gMC41ICogKGIgLSBhKSxcbiAgICAgIEIgPSBBICsgYSxcbiAgICAgIGkgPSAwLFxuICAgICAgbSA9IChuICsgMSkgPj4gMSxcbiAgICAgIHN1bSA9IG4gJiAxID8gd1tpKytdICogZihCKSA6IDA7IC8vIEhhbmRsZSBvZGQgblxuICAgIHdoaWxlIChpIDwgbSkge1xuICAgICAgdmFyIEF4ID0gQSAqIHhbaV07XG4gICAgICBzdW0gKz0gd1tpKytdICogKGYoQiArIEF4KSArIGYoQiAtIEF4KSk7XG4gICAgfVxuICAgIHJldHVybiBBICogc3VtO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q3VydmVGcm9tUG9pbnRzXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FuY2hvcltdfSBwb2ludHNcbiAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZWRcbiAgICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIGJlemllciBoYW5kbGVzIG9uIHtAbGluayBBbmNob3J9cyBpbiB0aGUgYHBvaW50c2AgbGlzdCB3aXRoIGVzdGltYXRlZCB2YWx1ZXMgdG8gY3JlYXRlIGEgY2F0bXVsbC1yb20gbGlrZSBjdXJ2ZS4gVXNlZCBieSB7QGxpbmsgVHdvLlBhdGgjcGxvdH0uXG4gICAqL1xuICB2YXIgZ2V0Q3VydmVGcm9tUG9pbnRzID0gZnVuY3Rpb24ocG9pbnRzLCBjbG9zZWQpIHtcblxuICAgIHZhciBsID0gcG9pbnRzLmxlbmd0aCwgbGFzdCA9IGwgLSAxO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblxuICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICBpZiAoIV8uaXNPYmplY3QocG9pbnQuY29udHJvbHMpKSB7XG4gICAgICAgIEFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXMocG9pbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldiA9IGNsb3NlZCA/IG1vZChpIC0gMSwgbCkgOiBNYXRoLm1heChpIC0gMSwgMCk7XG4gICAgICB2YXIgbmV4dCA9IGNsb3NlZCA/IG1vZChpICsgMSwgbCkgOiBNYXRoLm1pbihpICsgMSwgbGFzdCk7XG5cbiAgICAgIHZhciBhID0gcG9pbnRzW3ByZXZdO1xuICAgICAgdmFyIGIgPSBwb2ludDtcbiAgICAgIHZhciBjID0gcG9pbnRzW25leHRdO1xuICAgICAgZ2V0Q29udHJvbFBvaW50cyhhLCBiLCBjKTtcblxuICAgICAgYi5jb21tYW5kID0gaSA9PT0gMCA/IENvbW1hbmRzLm1vdmUgOiBDb21tYW5kcy5jdXJ2ZTtcblxuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0Q29udHJvbFBvaW50c1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtBbmNob3J9IGFcbiAgICogQHBhcmFtIHtBbmNob3J9IGJcbiAgICogQHBhcmFtIHtBbmNob3J9IGNcbiAgICogQHJldHVybnMge0FuY2hvcn0gUmV0dXJucyB0aGUgcGFzc2VkIG1pZGRsZSBwb2ludCBgYmAuXG4gICAqIEBkZXNjcmlwdGlvbiBHaXZlbiB0aHJlZSBjb29yZGluYXRlcyBzZXQgdGhlIGNvbnRyb2wgcG9pbnRzIGZvciB0aGUgbWlkZGxlLCBiLCB2ZXJ0ZXggYmFzZWQgb24gaXRzIHBvc2l0aW9uIHdpdGggdGhlIGFkamFjZW50IHBvaW50cy5cbiAgICovXG4gIHZhciBnZXRDb250cm9sUG9pbnRzID0gZnVuY3Rpb24oYSwgYiwgYykge1xuXG4gICAgdmFyIGExID0gVmVjdG9yLmFuZ2xlQmV0d2VlbihhLCBiKTtcbiAgICB2YXIgYTIgPSBWZWN0b3IuYW5nbGVCZXR3ZWVuKGMsIGIpO1xuXG4gICAgdmFyIGQxID0gVmVjdG9yLmRpc3RhbmNlQmV0d2VlbihhLCBiKTtcbiAgICB2YXIgZDIgPSBWZWN0b3IuZGlzdGFuY2VCZXR3ZWVuKGMsIGIpO1xuXG4gICAgdmFyIG1pZCA9IChhMSArIGEyKSAvIDI7XG5cbiAgICAvLyBUT0RPOiBJc3N1ZSA3M1xuICAgIGlmIChkMSA8IDAuMDAwMSB8fCBkMiA8IDAuMDAwMSkge1xuICAgICAgaWYgKHR5cGVvZiBiLnJlbGF0aXZlID09PSAnYm9vbGVhbicgJiYgIWIucmVsYXRpdmUpIHtcbiAgICAgICAgYi5jb250cm9scy5sZWZ0LmNvcHkoYik7XG4gICAgICAgIGIuY29udHJvbHMucmlnaHQuY29weShiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiO1xuICAgIH1cblxuICAgIGQxICo9IDAuMzM7IC8vIFdoeSAwLjMzP1xuICAgIGQyICo9IDAuMzM7XG5cbiAgICBpZiAoYTIgPCBhMSkge1xuICAgICAgbWlkICs9IEhBTEZfUEkkMztcbiAgICB9IGVsc2Uge1xuICAgICAgbWlkIC09IEhBTEZfUEkkMztcbiAgICB9XG5cbiAgICBiLmNvbnRyb2xzLmxlZnQueCA9IE1hdGguY29zKG1pZCkgKiBkMTtcbiAgICBiLmNvbnRyb2xzLmxlZnQueSA9IE1hdGguc2luKG1pZCkgKiBkMTtcblxuICAgIG1pZCAtPSBNYXRoLlBJO1xuXG4gICAgYi5jb250cm9scy5yaWdodC54ID0gTWF0aC5jb3MobWlkKSAqIGQyO1xuICAgIGIuY29udHJvbHMucmlnaHQueSA9IE1hdGguc2luKG1pZCkgKiBkMjtcblxuICAgIGlmICh0eXBlb2YgYi5yZWxhdGl2ZSA9PT0gJ2Jvb2xlYW4nICYmICFiLnJlbGF0aXZlKSB7XG4gICAgICBiLmNvbnRyb2xzLmxlZnQueCArPSBiLng7XG4gICAgICBiLmNvbnRyb2xzLmxlZnQueSArPSBiLnk7XG4gICAgICBiLmNvbnRyb2xzLnJpZ2h0LnggKz0gYi54O1xuICAgICAgYi5jb250cm9scy5yaWdodC55ICs9IGIueTtcbiAgICB9XG5cbiAgICByZXR1cm4gYjtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0UmVmbGVjdGlvblxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtWZWN0b3J9IGFcbiAgICogQHBhcmFtIHtWZWN0b3J9IGJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdXG4gICAqIEByZXR1cm5zIHtWZWN0b3J9IE5ldyB7QGxpbmsgVmVjdG9yfSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlZmxlY3Rpb24gcG9pbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIHJlZmxlY3Rpb24gb2YgYSBwb2ludCBgYmAgYWJvdXQgcG9pbnQgYGFgLiBXaGVyZSBgYWAgaXMgaW4gYWJzb2x1dGUgc3BhY2UgYW5kIGBiYCBpcyByZWxhdGl2ZSB0byBgYWAuXG4gICAqIEBzZWUge0BsaW5rIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjUGF0aEVsZW1lbnRJbXBsZW1lbnRhdGlvbk5vdGVzfVxuICAgKi9cbiAgdmFyIGdldFJlZmxlY3Rpb24gPSBmdW5jdGlvbihhLCBiLCByZWxhdGl2ZSkge1xuXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IoXG4gICAgICAyICogYS54IC0gKGIueCArIGEueCkgLSAocmVsYXRpdmUgPyBhLnggOiAwKSxcbiAgICAgIDIgKiBhLnkgLSAoYi55ICsgYS55KSAtIChyZWxhdGl2ZSA/IGEueSA6IDApXG4gICAgKTtcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0QW5jaG9yc0Zyb21BcmNEYXRhXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1ZlY3Rvcn0gY2VudGVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4QXhpc1JvdGF0aW9uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeCAtIHggcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSByeSAtIHkgcmFkaXVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0c1xuICAgKiBAcGFyYW0ge051bWJlcn0gdGRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY2N3PWZhbHNlXSAtIFNldCBwYXRoIHRyYXZlcnNhbCB0byBjb3VudGVyLWNsb2Nrd2lzZVxuICAgKi9cbiAgdmFyIGdldEFuY2hvcnNGcm9tQXJjRGF0YSA9IGZ1bmN0aW9uKGNlbnRlciwgeEF4aXNSb3RhdGlvbiwgcngsIHJ5LCB0cywgdGQsIGNjdykge1xuXG4gICAgdmFyIHJlc29sdXRpb24gPSBDb25zdGFudHMuUmVzb2x1dGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzb2x1dGlvbjsgaSsrKSB7XG4gICAgICB2YXIgcGN0ID0gKGkgKyAxKSAvIHJlc29sdXRpb247XG4gICAgICBpZiAoY2N3KSB7XG4gICAgICAgIHBjdCA9IDEgLSBwY3Q7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGV0YSA9IHBjdCAqIHRkICsgdHM7XG4gICAgICB2YXIgeCA9IHJ4ICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgdmFyIHkgPSByeSAqIE1hdGguc2luKHRoZXRhKTtcblxuICAgICAgLy8geCArPSBjZW50ZXIueDtcbiAgICAgIC8vIHkgKz0gY2VudGVyLnk7XG5cbiAgICAgIHZhciBhbmNob3IgPSBuZXcgQW5jaG9yKHgsIHkpO1xuICAgICAgQW5jaG9yLkFwcGVuZEN1cnZlUHJvcGVydGllcyhhbmNob3IpO1xuICAgICAgYW5jaG9yLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuICAgIH1cblxuICB9O1xuXG4gIHZhciBDdXJ2ZXMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEN1cnZlOiBDdXJ2ZSxcbiAgICBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyOiBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyLFxuICAgIHN1YmRpdmlkZTogc3ViZGl2aWRlLFxuICAgIGdldEN1cnZlTGVuZ3RoOiBnZXRDdXJ2ZUxlbmd0aCQxLFxuICAgIGdldEN1cnZlQm91bmRpbmdCb3g6IGdldEN1cnZlQm91bmRpbmdCb3gsXG4gICAgaW50ZWdyYXRlOiBpbnRlZ3JhdGUsXG4gICAgZ2V0Q3VydmVGcm9tUG9pbnRzOiBnZXRDdXJ2ZUZyb21Qb2ludHMsXG4gICAgZ2V0Q29udHJvbFBvaW50czogZ2V0Q29udHJvbFBvaW50cyxcbiAgICBnZXRSZWZsZWN0aW9uOiBnZXRSZWZsZWN0aW9uLFxuICAgIGdldEFuY2hvcnNGcm9tQXJjRGF0YTogZ2V0QW5jaG9yc0Zyb21BcmNEYXRhXG4gIH0pO1xuXG4gIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gcm9vdCQxLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblxuICB2YXIgZ2V0QmFja2luZ1N0b3JlUmF0aW8gPSBmdW5jdGlvbihjdHgpIHtcbiAgICByZXR1cm4gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjdHgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgIGN0eC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICBjdHguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0UmF0aW9cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICogQHJldHVybnMge051bWJlcn0gVGhlIHJhdGlvIG9mIGEgdW5pdCBpbiBUd28uanMgdG8gdGhlIHBpeGVsIGRlbnNpdHkgb2YgYSBzZXNzaW9uJ3Mgc2NyZWVuLlxuICAgKiBAc2VlIFtIaWdoIERQSSBSZW5kZXJpbmddKGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9oaWRwaS8pXG4gICAqL1xuICB2YXIgZ2V0UmF0aW8gPSBmdW5jdGlvbihjdHgpIHtcbiAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbyAvIGdldEJhY2tpbmdTdG9yZVJhdGlvKGN0eCk7XG4gIH07XG5cbiAgLy8gQ29uc3RhbnRzXG5cbiAgdmFyIGNvcyQ1ID0gTWF0aC5jb3MsIHNpbiQ1ID0gTWF0aC5zaW4sIHRhbiA9IE1hdGgudGFuO1xuICB2YXIgYXJyYXkgPSBbXTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLk1hdHJpeFxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFthPTFdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIGZpcnN0IHJvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtiPTBdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBmaXJzdCByb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbYz0wXSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCBmaXJzdCByb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZD0wXSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCBzZWNvbmQgcm93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2U9MV0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHNlY29uZCByb3cuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZj0wXSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCBzZWNvbmQgcm93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2c9MF0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgdGhpcmQgcm93LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2g9MF0gLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpPTFdIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cbiAgICogQGRlc2NyaXB0aW9uIEEgY2xhc3MgdG8gc3RvcmUgMyB4IDMgdHJhbnNmb3JtYXRpb24gbWF0cml4IGluZm9ybWF0aW9uLiBJbiBhZGRpdGlvbiB0byBzdG9yaW5nIGRhdGEgYFR3by5NYXRyaXhgIGhhcyBzdXBlZCB1cCBtZXRob2RzIGZvciBjb21tb25wbGFjZSBtYXRoZW1hdGljYWwgb3BlcmF0aW9ucy5cbiAgICogQG5vdGEtYmVuZSBPcmRlciBpcyBiYXNlZCBvbiBob3cgdG8gY29uc3RydWN0IHRyYW5zZm9ybWF0aW9uIHN0cmluZ3MgZm9yIHRoZSBicm93c2VyLlxuICAgKi9cbiAgZnVuY3Rpb24gTWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjZWxlbWVudHNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcltdfSAtIFRoZSB1bmRlcmx5aW5nIGRhdGEgc3RvcmVkIGFzIGFuIGFycmF5LlxuICAgICAqL1xuICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgTnVtQXJyYXkoOSk7XG5cbiAgICB2YXIgZWxlbWVudHMgPSBhO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgIGVsZW1lbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSBlbGVtZW50cyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgIHRoaXMuaWRlbnRpdHkoKTtcblxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnNldChlbGVtZW50cyk7XG4gICAgfVxuXG4gIH1cblxuICBzZXRNYXRyaXgoTWF0cml4KTtcblxuICBfLmV4dGVuZChNYXRyaXgsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXguSWRlbnRpdHlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcltdfSAtIEEgc3RvcmVkIHJlZmVyZW5jZSB0byB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIDMgeCAzIG1hdHJpeC5cbiAgICAgKi9cbiAgICBJZGVudGl0eTogW1xuICAgICAgMSwgMCwgMCxcbiAgICAgIDAsIDEsIDAsXG4gICAgICAwLCAwLCAxXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXguTXVsdGlwbHlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IEFcbiAgICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IEJcbiAgICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IFtDXSAtIEFuIG9wdGlvbmFsIG1hdHJpeCB0byBhcHBseSB0aGUgbXVsdGlwbGljYXRpb24gdG8uXG4gICAgICogQHJldHVybnMge1R3by5NYXRyaXh9IC0gSWYgYW4gb3B0aW9uYWwgYENgIG1hdHJpeCBpc24ndCBwYXNzZWQgdGhlbiBhIG5ldyBvbmUgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIE11bHRpcGx5IHR3byBtYXRyaWNlcyB0b2dldGhlciBhbmQgcmV0dXJuIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgTXVsdGlwbHk6IGZ1bmN0aW9uKEEsIEIsIEMpIHtcblxuICAgICAgaWYgKEIubGVuZ3RoIDw9IDMpIHsgLy8gTXVsdGlwbHkgVmVjdG9yXG5cbiAgICAgICAgdmFyIHgsIHksIHosIGUgPSBBO1xuXG4gICAgICAgIHZhciBhID0gQlswXSB8fCAwLFxuICAgICAgICAgICAgYiA9IEJbMV0gfHwgMCxcbiAgICAgICAgICAgIGMgPSBCWzJdIHx8IDA7XG5cbiAgICAgICAgLy8gR28gZG93biByb3dzIGZpcnN0XG4gICAgICAgIC8vIGEsIGQsIGcsIGIsIGUsIGgsIGMsIGYsIGlcblxuICAgICAgICB4ID0gZVswXSAqIGEgKyBlWzFdICogYiArIGVbMl0gKiBjO1xuICAgICAgICB5ID0gZVszXSAqIGEgKyBlWzRdICogYiArIGVbNV0gKiBjO1xuICAgICAgICB6ID0gZVs2XSAqIGEgKyBlWzddICogYiArIGVbOF0gKiBjO1xuXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHksIHo6IHogfTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgQTAgPSBBWzBdLCBBMSA9IEFbMV0sIEEyID0gQVsyXTtcbiAgICAgIHZhciBBMyA9IEFbM10sIEE0ID0gQVs0XSwgQTUgPSBBWzVdO1xuICAgICAgdmFyIEE2ID0gQVs2XSwgQTcgPSBBWzddLCBBOCA9IEFbOF07XG5cbiAgICAgIHZhciBCMCA9IEJbMF0sIEIxID0gQlsxXSwgQjIgPSBCWzJdO1xuICAgICAgdmFyIEIzID0gQlszXSwgQjQgPSBCWzRdLCBCNSA9IEJbNV07XG4gICAgICB2YXIgQjYgPSBCWzZdLCBCNyA9IEJbN10sIEI4ID0gQls4XTtcblxuICAgICAgQyA9IEMgfHwgbmV3IE51bUFycmF5KDkpO1xuXG4gICAgICBDWzBdID0gQTAgKiBCMCArIEExICogQjMgKyBBMiAqIEI2O1xuICAgICAgQ1sxXSA9IEEwICogQjEgKyBBMSAqIEI0ICsgQTIgKiBCNztcbiAgICAgIENbMl0gPSBBMCAqIEIyICsgQTEgKiBCNSArIEEyICogQjg7XG4gICAgICBDWzNdID0gQTMgKiBCMCArIEE0ICogQjMgKyBBNSAqIEI2O1xuICAgICAgQ1s0XSA9IEEzICogQjEgKyBBNCAqIEI0ICsgQTUgKiBCNztcbiAgICAgIENbNV0gPSBBMyAqIEIyICsgQTQgKiBCNSArIEE1ICogQjg7XG4gICAgICBDWzZdID0gQTYgKiBCMCArIEE3ICogQjMgKyBBOCAqIEI2O1xuICAgICAgQ1s3XSA9IEE2ICogQjEgKyBBNyAqIEI0ICsgQTggKiBCNztcbiAgICAgIENbOF0gPSBBNiAqIEIyICsgQTcgKiBCNSArIEE4ICogQjg7XG5cbiAgICAgIHJldHVybiBDO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKE1hdHJpeC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgY29uc3RydWN0b3I6IE1hdHJpeCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjbWFudWFsXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBUd28uanMgYXV0b21hdGljYWxseSBjYWxjdWxhdGVzIHRoZSB2YWx1ZXMgZm9yIHRoZSBtYXRyaXggb3IgaWYgdGhlIGRldmVsb3BlciBpbnRlbmRzIHRvIG1hbmFnZSB0aGUgbWF0cml4LlxuICAgICAqIEBub3RhLWJlbmUgLSBTZXR0aW5nIHRvIGB0cnVlYCBudWxsaWZpZXMge0BsaW5rIFR3by5TaGFwZSN0cmFuc2xhdGlvbn0sIHtAbGluayBUd28uU2hhcGUjcm90YXRpb259LCBhbmQge0BsaW5rIFR3by5TaGFwZSNzY2FsZX0uXG4gICAgICovXG4gICAgbWFudWFsOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgZmlyc3Qgcm93LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBmaXJzdCByb3cuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGMgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgZmlyc3Qgcm93LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkIC0gVGhlIHZhbHVlIGZvciBlbGVtZW50IGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIHNlY29uZCByb3cuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGUgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHNlY29uZCByb3cuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGYgLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgc2Vjb25kIHJvdy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZyAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCB0aGlyZCByb3cuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGggLSBUaGUgdmFsdWUgZm9yIGVsZW1lbnQgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHRoaXJkIHJvdy5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaSAtIFRoZSB2YWx1ZSBmb3IgZWxlbWVudCBhdCB0aGUgdGhpcmQgY29sdW1uIGFuZCB0aGlyZCByb3cuXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCBhbiBhcnJheSBvZiB2YWx1ZXMgb250byB0aGUgbWF0cml4LiBPcmRlciBkZXNjcmliZWQgaW4ge0BsaW5rIFR3by5NYXRyaXh9LlxuICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICogQG5hbWUgVHdvLk1hdHJpeCNzZXRcbiAgICAgICogQGZ1bmN0aW9uXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyW119IGEgLSBUaGUgYXJyYXkgb2YgZWxlbWVudHMgdG8gYXBwbHkuXG4gICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgYW4gYXJyYXkgb2YgdmFsdWVzIG9udG8gdGhlIG1hdHJpeC4gT3JkZXIgZGVzY3JpYmVkIGluIHtAbGluayBUd28uTWF0cml4fS5cbiAgICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKSB7XG5cbiAgICAgIHZhciBlbGVtZW50cztcblxuICAgICAgaWYgKHR5cGVvZiBiID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlbGVtZW50cyA9IGE7XG4gICAgICAgIGEgPSBlbGVtZW50c1swXTtcbiAgICAgICAgYiA9IGVsZW1lbnRzWzFdO1xuICAgICAgICBjID0gZWxlbWVudHNbMl07XG4gICAgICAgIGQgPSBlbGVtZW50c1szXTtcbiAgICAgICAgZSA9IGVsZW1lbnRzWzRdO1xuICAgICAgICBmID0gZWxlbWVudHNbNV07XG4gICAgICAgIGcgPSBlbGVtZW50c1s2XTtcbiAgICAgICAgaCA9IGVsZW1lbnRzWzddO1xuICAgICAgICBpID0gZWxlbWVudHNbOF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSBhO1xuICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IGI7XG4gICAgICB0aGlzLmVsZW1lbnRzWzJdID0gYztcbiAgICAgIHRoaXMuZWxlbWVudHNbM10gPSBkO1xuICAgICAgdGhpcy5lbGVtZW50c1s0XSA9IGU7XG4gICAgICB0aGlzLmVsZW1lbnRzWzVdID0gZjtcbiAgICAgIHRoaXMuZWxlbWVudHNbNl0gPSBnO1xuICAgICAgdGhpcy5lbGVtZW50c1s3XSA9IGg7XG4gICAgICB0aGlzLmVsZW1lbnRzWzhdID0gaTtcblxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I2NvcHlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29weSB0aGUgbWF0cml4IG9mIG9uZSB0byB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBjb3B5OiBmdW5jdGlvbihtKSB7XG5cbiAgICAgIHRoaXMuZWxlbWVudHNbMF0gPSBtLmVsZW1lbnRzWzBdO1xuICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IG0uZWxlbWVudHNbMV07XG4gICAgICB0aGlzLmVsZW1lbnRzWzJdID0gbS5lbGVtZW50c1syXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbM10gPSBtLmVsZW1lbnRzWzNdO1xuICAgICAgdGhpcy5lbGVtZW50c1s0XSA9IG0uZWxlbWVudHNbNF07XG4gICAgICB0aGlzLmVsZW1lbnRzWzVdID0gbS5lbGVtZW50c1s1XTtcbiAgICAgIHRoaXMuZWxlbWVudHNbNl0gPSBtLmVsZW1lbnRzWzZdO1xuICAgICAgdGhpcy5lbGVtZW50c1s3XSA9IG0uZWxlbWVudHNbN107XG4gICAgICB0aGlzLmVsZW1lbnRzWzhdID0gbS5lbGVtZW50c1s4XTtcblxuICAgICAgdGhpcy5tYW51YWwgPSBtLm1hbnVhbDtcblxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I2lkZW50aXR5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFR1cm4gbWF0cml4IHRvIHRoZSBpZGVudGl0eSwgbGlrZSByZXNldHRpbmcuXG4gICAgICovXG4gICAgaWRlbnRpdHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLmVsZW1lbnRzWzBdID0gTWF0cml4LklkZW50aXR5WzBdO1xuICAgICAgdGhpcy5lbGVtZW50c1sxXSA9IE1hdHJpeC5JZGVudGl0eVsxXTtcbiAgICAgIHRoaXMuZWxlbWVudHNbMl0gPSBNYXRyaXguSWRlbnRpdHlbMl07XG4gICAgICB0aGlzLmVsZW1lbnRzWzNdID0gTWF0cml4LklkZW50aXR5WzNdO1xuICAgICAgdGhpcy5lbGVtZW50c1s0XSA9IE1hdHJpeC5JZGVudGl0eVs0XTtcbiAgICAgIHRoaXMuZWxlbWVudHNbNV0gPSBNYXRyaXguSWRlbnRpdHlbNV07XG4gICAgICB0aGlzLmVsZW1lbnRzWzZdID0gTWF0cml4LklkZW50aXR5WzZdO1xuICAgICAgdGhpcy5lbGVtZW50c1s3XSA9IE1hdHJpeC5JZGVudGl0eVs3XTtcbiAgICAgIHRoaXMuZWxlbWVudHNbOF0gPSBNYXRyaXguSWRlbnRpdHlbOF07XG5cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNtdWx0aXBseVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhIC0gVGhlIHNjYWxhciB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBNdWx0aXBseSBhbGwgY29tcG9uZW50cyBvZiB0aGUgbWF0cml4IGFnYWluc3QgYSBzaW5nbGUgc2NhbGFyIHZhbHVlLlxuICAgICAqIEBvdmVybG9hZGVkXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I211bHRpcGx5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGEgLSBUaGUgeCBjb21wb25lbnQgdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYiAtIFRoZSB5IGNvbXBvbmVudCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIC0gVGhlIHogY29tcG9uZW50IHRvIGJlIG11bHRpcGxpZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIE11bHRpcGx5IGFsbCBjb21wb25lbnRzIG9mIGEgbWF0cml4IGFnYWluc3QgYSAzIGNvbXBvbmVudCB2ZWN0b3IuXG4gICAgICogQG92ZXJsb2FkZWRcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjbXVsdGlwbHlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYSAtIFRoZSB2YWx1ZSBhdCB0aGUgZmlyc3QgY29sdW1uIGFuZCBmaXJzdCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiIC0gVGhlIHZhbHVlIGF0IHRoZSBzZWNvbmQgY29sdW1uIGFuZCBmaXJzdCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBjIC0gVGhlIHZhbHVlIGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIGZpcnN0IHJvdyBvZiB0aGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGQgLSBUaGUgdmFsdWUgYXQgdGhlIGZpcnN0IGNvbHVtbiBhbmQgc2Vjb25kIHJvdyBvZiB0aGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGUgLSBUaGUgdmFsdWUgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHNlY29uZCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBmIC0gVGhlIHZhbHVlIGF0IHRoZSB0aGlyZCBjb2x1bW4gYW5kIHNlY29uZCByb3cgb2YgdGhlIG1hdHJpeCB0byBiZSBtdWx0aXBsaWVkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBnIC0gVGhlIHZhbHVlIGF0IHRoZSBmaXJzdCBjb2x1bW4gYW5kIHRoaXJkIHJvdyBvZiB0aGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGggLSBUaGUgdmFsdWUgYXQgdGhlIHNlY29uZCBjb2x1bW4gYW5kIHRoaXJkIHJvdyBvZiB0aGUgbWF0cml4IHRvIGJlIG11bHRpcGxpZWQuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGkgLSBUaGUgdmFsdWUgYXQgdGhlIHRoaXJkIGNvbHVtbiBhbmQgdGhpcmQgcm93IG9mIHRoZSBtYXRyaXggdG8gYmUgbXVsdGlwbGllZC5cbiAgICAgKiBAZGVzY3JpcHRpb24gTXVsdGlwbHkgYWxsIGNvbXBvbmVudHMgb2YgYSBtYXRyaXggYWdhaW5zdCBhbm90aGVyIG1hdHJpeC5cbiAgICAgKiBAb3ZlcmxvYWRlZFxuICAgICAqL1xuICAgIG11bHRpcGx5OiBmdW5jdGlvbihhLCBiLCBjLCBkLCBlLCBmLCBnLCBoLCBpKSB7XG5cbiAgICAgIC8vIE11bHRpcGx5IHNjYWxhclxuXG4gICAgICBpZiAodHlwZW9mIGIgPT09ICd1bmRlZmluZWQnKSB7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50c1swXSAqPSBhO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzFdICo9IGE7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbMl0gKj0gYTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1szXSAqPSBhO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzRdICo9IGE7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbNV0gKj0gYTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1s2XSAqPSBhO1xuICAgICAgICB0aGlzLmVsZW1lbnRzWzddICo9IGE7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbOF0gKj0gYTtcblxuICAgICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5jaGFuZ2UpO1xuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ3VuZGVmaW5lZCcpIHsgLy8gTXVsdGlwbHkgVmVjdG9yXG5cbiAgICAgICAgdmFyIHgsIHksIHo7XG4gICAgICAgIGEgPSBhIHx8IDA7XG4gICAgICAgIGIgPSBiIHx8IDA7XG4gICAgICAgIGMgPSBjIHx8IDA7XG4gICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgIC8vIEdvIGRvd24gcm93cyBmaXJzdFxuICAgICAgICAvLyBhLCBkLCBnLCBiLCBlLCBoLCBjLCBmLCBpXG5cbiAgICAgICAgeCA9IGVbMF0gKiBhICsgZVsxXSAqIGIgKyBlWzJdICogYztcbiAgICAgICAgeSA9IGVbM10gKiBhICsgZVs0XSAqIGIgKyBlWzVdICogYztcbiAgICAgICAgeiA9IGVbNl0gKiBhICsgZVs3XSAqIGIgKyBlWzhdICogYztcblxuICAgICAgICByZXR1cm4geyB4OiB4LCB5OiB5LCB6OiB6IH07XG5cbiAgICAgIH1cblxuICAgICAgLy8gTXVsdGlwbGUgbWF0cml4XG5cbiAgICAgIHZhciBBID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciBCID0gW2EsIGIsIGMsIGQsIGUsIGYsIGcsIGgsIGldO1xuXG4gICAgICB2YXIgQTAgPSBBWzBdLCBBMSA9IEFbMV0sIEEyID0gQVsyXTtcbiAgICAgIHZhciBBMyA9IEFbM10sIEE0ID0gQVs0XSwgQTUgPSBBWzVdO1xuICAgICAgdmFyIEE2ID0gQVs2XSwgQTcgPSBBWzddLCBBOCA9IEFbOF07XG5cbiAgICAgIHZhciBCMCA9IEJbMF0sIEIxID0gQlsxXSwgQjIgPSBCWzJdO1xuICAgICAgdmFyIEIzID0gQlszXSwgQjQgPSBCWzRdLCBCNSA9IEJbNV07XG4gICAgICB2YXIgQjYgPSBCWzZdLCBCNyA9IEJbN10sIEI4ID0gQls4XTtcblxuICAgICAgdGhpcy5lbGVtZW50c1swXSA9IEEwICogQjAgKyBBMSAqIEIzICsgQTIgKiBCNjtcbiAgICAgIHRoaXMuZWxlbWVudHNbMV0gPSBBMCAqIEIxICsgQTEgKiBCNCArIEEyICogQjc7XG4gICAgICB0aGlzLmVsZW1lbnRzWzJdID0gQTAgKiBCMiArIEExICogQjUgKyBBMiAqIEI4O1xuXG4gICAgICB0aGlzLmVsZW1lbnRzWzNdID0gQTMgKiBCMCArIEE0ICogQjMgKyBBNSAqIEI2O1xuICAgICAgdGhpcy5lbGVtZW50c1s0XSA9IEEzICogQjEgKyBBNCAqIEI0ICsgQTUgKiBCNztcbiAgICAgIHRoaXMuZWxlbWVudHNbNV0gPSBBMyAqIEIyICsgQTQgKiBCNSArIEE1ICogQjg7XG5cbiAgICAgIHRoaXMuZWxlbWVudHNbNl0gPSBBNiAqIEIwICsgQTcgKiBCMyArIEE4ICogQjY7XG4gICAgICB0aGlzLmVsZW1lbnRzWzddID0gQTYgKiBCMSArIEE3ICogQjQgKyBBOCAqIEI3O1xuICAgICAgdGhpcy5lbGVtZW50c1s4XSA9IEE2ICogQjIgKyBBNyAqIEI1ICsgQTggKiBCODtcblxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I2ludmVyc2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5NYXRyaXh9IFtvdXRdIC0gVGhlIG9wdGlvbmFsIG1hdHJpeCB0byBhcHBseSB0aGUgaW52ZXJzaW9uIHRvLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGUgbWF0cml4LiBJZiBubyBvcHRpb25hbCBvbmUgaXMgcGFzc2VkIGEgbmV3IG1hdHJpeCBpcyBjcmVhdGVkIGFuZCByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBpbnZlcnNlOiBmdW5jdGlvbihvdXQpIHtcblxuICAgICAgdmFyIGEgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgb3V0ID0gb3V0IHx8IG5ldyBNYXRyaXgoKTtcblxuICAgICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl07XG4gICAgICB2YXIgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XTtcbiAgICAgIHZhciBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdO1xuXG4gICAgICB2YXIgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxO1xuICAgICAgdmFyIGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7XG4gICAgICB2YXIgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICB2YXIgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gICAgICBpZiAoIWRldCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgICBvdXQuZWxlbWVudHNbMF0gPSBiMDEgKiBkZXQ7XG4gICAgICBvdXQuZWxlbWVudHNbMV0gPSAoLWEyMiAqIGEwMSArIGEwMiAqIGEyMSkgKiBkZXQ7XG4gICAgICBvdXQuZWxlbWVudHNbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgICAgIG91dC5lbGVtZW50c1szXSA9IGIxMSAqIGRldDtcbiAgICAgIG91dC5lbGVtZW50c1s0XSA9IChhMjIgKiBhMDAgLSBhMDIgKiBhMjApICogZGV0O1xuICAgICAgb3V0LmVsZW1lbnRzWzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICAgICAgb3V0LmVsZW1lbnRzWzZdID0gYjIxICogZGV0O1xuICAgICAgb3V0LmVsZW1lbnRzWzddID0gKC1hMjEgKiBhMDAgKyBhMDEgKiBhMjApICogZGV0O1xuICAgICAgb3V0LmVsZW1lbnRzWzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG5cbiAgICAgIHJldHVybiBvdXQ7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNzY2FsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAtIFRoZSBvbmUgZGltZW5zaW9uYWwgc2NhbGUgdG8gYXBwbHkgdG8gdGhlIG1hdHJpeC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVW5pZm9ybWx5IHNjYWxlIHRoZSB0cmFuc2Zvcm1hdGlvbiBtYXRyaXguXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3NjYWxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHN4IC0gVGhlIGhvcml6b250YWwgc2NhbGUgZmFjdG9yLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzeSAtIFRoZSB2ZXJ0aWNhbCBzY2FsZSBmYWN0b3JcbiAgICAgKiBAZGVzY3JpcHRpb24gU2NhbGUgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBpbiB0d28gZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBzY2FsZTogZnVuY3Rpb24oc3gsIHN5KSB7XG5cbiAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsIDw9IDEpIHtcbiAgICAgICAgc3kgPSBzeDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoc3gsIDAsIDAsIDAsIHN5LCAwLCAwLCAwLCAxKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3JvdGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBOdW1iZXIgLSBUaGUgYW1vdW50IHRvIHJvdGF0ZSBpbiBOdW1iZXIuXG4gICAgICogQGRlc2NyaXB0aW9uIFJvdGF0ZSB0aGUgbWF0cml4LlxuICAgICAqL1xuICAgIHJvdGF0ZTogZnVuY3Rpb24oTnVtYmVyKSB7XG5cbiAgICAgIHZhciBjID0gY29zJDUoTnVtYmVyKTtcbiAgICAgIHZhciBzID0gc2luJDUoTnVtYmVyKTtcblxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoYywgLXMsIDAsIHMsIGMsIDAsIDAsIDAsIDEpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjdHJhbnNsYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCB0cmFuc2xhdGlvbiB2YWx1ZSB0byBhcHBseS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCB0cmFuc2xhdGlvbiB2YWx1ZSB0byBhcHBseS5cbiAgICAgKiBAZGVzY3JpcHRpb24gVHJhbnNsYXRlIHRoZSBtYXRyaXguXG4gICAgICovXG4gICAgdHJhbnNsYXRlOiBmdW5jdGlvbih4LCB5KSB7XG5cbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KDEsIDAsIHgsIDAsIDEsIHksIDAsIDAsIDEpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5NYXRyaXgjc2tld1hcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gTnVtYmVyIC0gVGhlIGFtb3VudCB0byBza2V3IGluIE51bWJlci5cbiAgICAgKiBAZGVzY3JpcHRpb24gU2tldyB0aGUgbWF0cml4IGJ5IGFuIGFuZ2xlIGluIHRoZSB4IGF4aXMgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHNrZXdYOiBmdW5jdGlvbihOdW1iZXIpIHtcblxuICAgICAgdmFyIGEgPSB0YW4oTnVtYmVyKTtcblxuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoMSwgYSwgMCwgMCwgMSwgMCwgMCwgMCwgMSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCNza2V3WVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBOdW1iZXIgLSBUaGUgYW1vdW50IHRvIHNrZXcgaW4gTnVtYmVyLlxuICAgICAqIEBkZXNjcmlwdGlvbiBTa2V3IHRoZSBtYXRyaXggYnkgYW4gYW5nbGUgaW4gdGhlIHkgYXhpcyBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgc2tld1k6IGZ1bmN0aW9uKE51bWJlcikge1xuXG4gICAgICB2YXIgYSA9IHRhbihOdW1iZXIpO1xuXG4gICAgICByZXR1cm4gdGhpcy5tdWx0aXBseSgxLCAwLCAwLCBhLCAxLCAwLCAwLCAwLCAxKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RvU3RyaW5nXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZnVsbE1hdHJpeD1mYWxzZV0gLSBSZXR1cm4gdGhlIGZ1bGwgOSBlbGVtZW50cyBvZiB0aGUgbWF0cml4IG9yIGp1c3QgNiBmb3IgMkQgdHJhbnNmb3JtYXRpb25zLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBhcyBhIDYgY29tcG9uZW50IHN0cmluZyBzZXBhcmF0ZWQgYnkgc3BhY2VzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSB0cmFuc2Zvcm0gc3RyaW5nLiBVc2VkIGZvciB0aGUgVHdvLmpzIHJlbmRlcmluZyBBUElzLlxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbihmdWxsTWF0cml4KSB7XG5cbiAgICAgIGFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnRvVHJhbnNmb3JtQXJyYXkoZnVsbE1hdHJpeCwgYXJyYXkpO1xuXG4gICAgICByZXR1cm4gYXJyYXkubWFwKHRvRml4ZWQpLmpvaW4oJyAnKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RvVHJhbnNmb3JtQXJyYXlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtmdWxsTWF0cml4PWZhbHNlXSAtIFJldHVybiB0aGUgZnVsbCA5IGVsZW1lbnRzIG9mIHRoZSBtYXRyaXggb3IganVzdCA2IGluIHRoZSBmb3JtYXQgZm9yIDJEIHRyYW5zZm9ybWF0aW9ucy5cbiAgICAgKiBAcGFyYW0ge051bWJlcltdfSBbb3V0cHV0XSAtIEFuIGFycmF5IGVtcHR5IG9yIG90aGVyd2lzZSB0byBhcHBseSB0aGUgdmFsdWVzIHRvLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSB0cmFuc2Zvcm0gYXJyYXkuIFVzZWQgZm9yIHRoZSBUd28uanMgcmVuZGVyaW5nIEFQSXMuXG4gICAgICovXG4gICAgdG9UcmFuc2Zvcm1BcnJheTogZnVuY3Rpb24oZnVsbE1hdHJpeCwgb3V0cHV0KSB7XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgICB2YXIgaGFzT3V0cHV0ID0gISFvdXRwdXQ7XG5cbiAgICAgIHZhciBhID0gZWxlbWVudHNbMF07XG4gICAgICB2YXIgYiA9IGVsZW1lbnRzWzFdO1xuICAgICAgdmFyIGMgPSBlbGVtZW50c1syXTtcbiAgICAgIHZhciBkID0gZWxlbWVudHNbM107XG4gICAgICB2YXIgZSA9IGVsZW1lbnRzWzRdO1xuICAgICAgdmFyIGYgPSBlbGVtZW50c1s1XTtcblxuICAgICAgaWYgKGZ1bGxNYXRyaXgpIHtcblxuICAgICAgICB2YXIgZyA9IGVsZW1lbnRzWzZdO1xuICAgICAgICB2YXIgaCA9IGVsZW1lbnRzWzddO1xuICAgICAgICB2YXIgaSA9IGVsZW1lbnRzWzhdO1xuXG4gICAgICAgIGlmIChoYXNPdXRwdXQpIHtcbiAgICAgICAgICBvdXRwdXRbMF0gPSBhO1xuICAgICAgICAgIG91dHB1dFsxXSA9IGQ7XG4gICAgICAgICAgb3V0cHV0WzJdID0gZztcbiAgICAgICAgICBvdXRwdXRbM10gPSBiO1xuICAgICAgICAgIG91dHB1dFs0XSA9IGU7XG4gICAgICAgICAgb3V0cHV0WzVdID0gaDtcbiAgICAgICAgICBvdXRwdXRbNl0gPSBjO1xuICAgICAgICAgIG91dHB1dFs3XSA9IGY7XG4gICAgICAgICAgb3V0cHV0WzhdID0gaTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGEsIGQsIGcsIGIsIGUsIGgsIGMsIGYsIGlcbiAgICAgICAgXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc091dHB1dCkge1xuICAgICAgICBvdXRwdXRbMF0gPSBhO1xuICAgICAgICBvdXRwdXRbMV0gPSBkO1xuICAgICAgICBvdXRwdXRbMl0gPSBiO1xuICAgICAgICBvdXRwdXRbM10gPSBlO1xuICAgICAgICBvdXRwdXRbNF0gPSBjO1xuICAgICAgICBvdXRwdXRbNV0gPSBmO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgIGEsIGQsIGIsIGUsIGMsIGYgIC8vIFNwZWNpZmljIGZvcm1hdCBzZWUgTE46MTlcbiAgICAgIF07XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLk1hdHJpeCN0b0FycmF5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZnVsbE1hdHJpeD1mYWxzZV0gLSBSZXR1cm4gdGhlIGZ1bGwgOSBlbGVtZW50cyBvZiB0aGUgbWF0cml4IG9yIGp1c3QgNiBmb3IgMkQgdHJhbnNmb3JtYXRpb25zLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyW119IFtvdXRwdXRdIC0gQW4gYXJyYXkgZW1wdHkgb3Igb3RoZXJ3aXNlIHRvIGFwcGx5IHRoZSB2YWx1ZXMgdG8uXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIHRyYW5zZm9ybSBhcnJheS4gVXNlZCBmb3IgdGhlIFR3by5qcyByZW5kZXJpbmcgQVBJcy5cbiAgICAgKi9cbiAgICB0b0FycmF5OiBmdW5jdGlvbihmdWxsTWF0cml4LCBvdXRwdXQpIHtcblxuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cztcbiAgICAgIHZhciBoYXNPdXRwdXQgPSAhIW91dHB1dDtcblxuICAgICAgdmFyIGEgPSBlbGVtZW50c1swXTtcbiAgICAgIHZhciBiID0gZWxlbWVudHNbMV07XG4gICAgICB2YXIgYyA9IGVsZW1lbnRzWzJdO1xuICAgICAgdmFyIGQgPSBlbGVtZW50c1szXTtcbiAgICAgIHZhciBlID0gZWxlbWVudHNbNF07XG4gICAgICB2YXIgZiA9IGVsZW1lbnRzWzVdO1xuXG4gICAgICBpZiAoZnVsbE1hdHJpeCkge1xuXG4gICAgICAgIHZhciBnID0gZWxlbWVudHNbNl07XG4gICAgICAgIHZhciBoID0gZWxlbWVudHNbN107XG4gICAgICAgIHZhciBpID0gZWxlbWVudHNbOF07XG5cbiAgICAgICAgaWYgKGhhc091dHB1dCkge1xuICAgICAgICAgIG91dHB1dFswXSA9IGE7XG4gICAgICAgICAgb3V0cHV0WzFdID0gYjtcbiAgICAgICAgICBvdXRwdXRbMl0gPSBjO1xuICAgICAgICAgIG91dHB1dFszXSA9IGQ7XG4gICAgICAgICAgb3V0cHV0WzRdID0gZTtcbiAgICAgICAgICBvdXRwdXRbNV0gPSBmO1xuICAgICAgICAgIG91dHB1dFs2XSA9IGc7XG4gICAgICAgICAgb3V0cHV0WzddID0gaDtcbiAgICAgICAgICBvdXRwdXRbOF0gPSBpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaVxuICAgICAgICBdO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzT3V0cHV0KSB7XG4gICAgICAgIG91dHB1dFswXSA9IGE7XG4gICAgICAgIG91dHB1dFsxXSA9IGI7XG4gICAgICAgIG91dHB1dFsyXSA9IGM7XG4gICAgICAgIG91dHB1dFszXSA9IGQ7XG4gICAgICAgIG91dHB1dFs0XSA9IGU7XG4gICAgICAgIG91dHB1dFs1XSA9IGY7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYSwgYiwgYywgZCwgZSwgZlxuICAgICAgXTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIEpTT04gY29tcGF0aWJsZSBvYmplY3QgdGhhdCByZXByZXNlbnRzIGluZm9ybWF0aW9uIG9mIHRoZSBtYXRyaXguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudHM6IHRoaXMudG9BcnJheSh0cnVlKSxcbiAgICAgICAgbWFudWFsOiAhIXRoaXMubWFudWFsXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTWF0cml4I2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENsb25lIHRoZSBjdXJyZW50IG1hdHJpeC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHJldHVybiBuZXcgTWF0cml4KCkuY29weSh0aGlzKTtcblxuICAgIH1cblxuICB9KTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlNoYXBlXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uRXZlbnRzXG4gICAqIEBkZXNjcmlwdGlvbiBUaGUgZm91bmRhdGlvbmFsIHRyYW5zZm9ybWF0aW9uIG9iamVjdCBmb3IgdGhlIFR3by5qcyBzY2VuZWdyYXBoLlxuICAgKi9cbiAgZnVuY3Rpb24gU2hhcGUoKSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjcmVuZGVyZXJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gT2JqZWN0IGFjY2VzcyB0byBzdG9yZSByZWxldmFudCByZW5kZXJlciBzcGVjaWZpYyB2YXJpYWJsZXMuIFdhcm5pbmc6IG1hbmlwdWxhdGluZyB0aGlzIG9iamVjdCBjYW4gY3JlYXRlIHVuaW50ZW5kZWQgY29uc2VxdWVuY2VzLlxuICAgICAqIEBub3RhLWJlbmUgV2l0aCB0aGUge0BsaW5rIFR3by5TdmdSZW5kZXJlcn0geW91IGNhbiBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgU1ZHIGVsZW1lbnQgY3JlYXRlZCB2aWEgYHNoYXBlLnJlbmRlcmVyLmVsZW1gLlxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnTWF0cml4ID0gU2hhcGUuRmxhZ01hdHJpeC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaXNTaGFwZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjaWRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBTZXNzaW9uIHNwZWNpZmljIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqIEBub3RhLWJlbmUgSW4gdGhlIHtAbGluayBUd28uU3ZnUmVuZGVyZXJ9IGNoYW5nZSB0aGlzIHRvIGNoYW5nZSB0aGUgdW5kZXJseWluZyBTVkcgZWxlbWVudCdzIGlkIHRvby5cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gQ29uc3RhbnRzLklkZW50aWZpZXIgKyBDb25zdGFudHMudW5pcXVlSWQoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNjbGFzc0xpc3RcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfVxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGxpc3Qgb2YgY2xhc3Mgc3RyaW5ncyBzdG9yZWQgaWYgaW1wb3J0ZWQgLyBpbnRlcnByZXRlZCAgZnJvbSBhbiBTVkcgZWxlbWVudC5cbiAgICAgKi9cbiAgICB0aGlzLmNsYXNzTGlzdCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI21hdHJpeFxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLk1hdHJpeH1cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvZiB0aGUgc2hhcGUuXG4gICAgICogQG5vdGEtYmVuZSB7QGxpbmsgVHdvLlNoYXBlI3RyYW5zbGF0aW9ufSwge0BsaW5rIFR3by5TaGFwZSNyb3RhdGlvbn0sIHtAbGluayBUd28uU2hhcGUjc2NhbGV9LCB7QGxpbmsgVHdvLlNoYXBlI3NrZXdYfSwgYW5kIHtAbGluayBUd28uU2hhcGUjc2tld1l9IGFwcGx5IHRoZWlyIHZhbHVlcyB0byB0aGUgbWF0cml4IHdoZW4gY2hhbmdlZC4gVGhlIG1hdHJpeCBpcyB3aGF0IGlzIHNlbnQgdG8gdGhlIHJlbmRlcmVyIHRvIGJlIGRyYXduLlxuICAgICAqL1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI3RyYW5zbGF0aW9uXG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIFRoZSB4IGFuZCB5IHZhbHVlIGZvciB3aGVyZSB0aGUgc2hhcGUgaXMgcGxhY2VkIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAgICovXG4gICAgdGhpcy50cmFuc2xhdGlvbiA9IG5ldyBWZWN0b3IoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNyb3RhdGlvblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB2YWx1ZSBpbiBOdW1iZXIgZm9yIGhvdyBtdWNoIHRoZSBzaGFwZSBpcyByb3RhdGVkIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjc2NhbGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdmFsdWUgZm9yIGhvdyBtdWNoIHRoZSBzaGFwZSBpcyBzY2FsZWQgcmVsYXRpdmUgdG8gaXRzIHBhcmVudC5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgdmFsdWUgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSB7QGxpbmsgVHdvLlZlY3Rvcn0gdG8gZG8gbm9uLXVuaWZvcm0gc2NhbGluZy4gZS5nOiBgc2hhcGUuc2NhbGUgPSBuZXcgVHdvLlZlY3RvcigyLCAxKTtgXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjc2tld1hcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgdmFsdWUgaW4gTnVtYmVyIGZvciBob3cgbXVjaCB0aGUgc2hhcGUgaXMgc2tld2VkIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gICAgICogQGRlc2NyaXB0aW9uIFNrZXcgdGhlIHNoYXBlIGJ5IGFuIGFuZ2xlIGluIHRoZSB4IGF4aXMgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHRoaXMuc2tld1ggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI3NrZXdZXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHZhbHVlIGluIE51bWJlciBmb3IgaG93IG11Y2ggdGhlIHNoYXBlIGlzIHNrZXdlZCByZWxhdGl2ZSB0byBpdHMgcGFyZW50LlxuICAgICAqIEBkZXNjcmlwdGlvbiBTa2V3IHRoZSBzaGFwZSBieSBhbiBhbmdsZSBpbiB0aGUgeSBheGlzIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLnNrZXdZID0gMDtcblxuICB9XG5cbiAgXy5leHRlbmQoU2hhcGUsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZS5GbGFnTWF0cml4XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFV0aWxpdHkgZnVuY3Rpb24gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGhhbmRsZXJzIHRvIHVwZGF0ZSB0aGUgZmxhZ01hdHJpeCBvZiBhIHNoYXBlLlxuICAgICAqL1xuICAgIEZsYWdNYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZS5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlNoYXBlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5TaGFwZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICB2YXIgdHJhbnNsYXRpb24gPSB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2xhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3RyYW5zbGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbi51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ01hdHJpeCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3RyYW5zbGF0aW9uID0gdjtcbiAgICAgICAgICB0aGlzLl90cmFuc2xhdGlvbi5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdNYXRyaXgpO1xuICAgICAgICAgIFNoYXBlLkZsYWdNYXRyaXguY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3RyYW5zbGF0aW9uJywgdHJhbnNsYXRpb24pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3Bvc2l0aW9uJywgdHJhbnNsYXRpb24pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncm90YXRpb24nLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JvdGF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2NhbGUnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGUudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdNYXRyaXgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NjYWxlID0gdjtcblxuICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGUuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnTWF0cml4KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9mbGFnTWF0cml4ID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9mbGFnU2NhbGUgPSB0cnVlO1xuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2tld1gnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NrZXdYO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9za2V3WCA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc2tld1knLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NrZXdZO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9za2V3WSA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnbWF0cml4Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXRyaXg7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX21hdHJpeCA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnaWQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgaWQgPSB0aGlzLl9pZDtcbiAgICAgICAgICBpZiAodiA9PT0gdGhpcy5faWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5faWQgPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdJZCA9IHRydWU7XG4gICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5wYXJlbnQuY2hpbGRyZW4uaWRzW2lkXTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmNoaWxkcmVuLmlkc1t0aGlzLl9pZF0gPSB0aGlzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjbGFzc05hbWUnLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jbGFzc05hbWU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgICB0aGlzLl9mbGFnQ2xhc3NOYW1lID0gdGhpcy5fY2xhc3NOYW1lICE9PSB2O1xuXG4gICAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGFzc05hbWUpIHtcblxuICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLl9jbGFzc05hbWUuc3BsaXQoL1xccys/Lyk7XG4gICAgICAgICAgICB2YXIgZGVzdCA9IHYuc3BsaXQoL1xccys/Lyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gcHJldltpXTtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLmNsYXNzTGlzdCwgY2xhc3NOYW1lKTtcbiAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0ID0gdGhpcy5jbGFzc0xpc3QuY29uY2F0KGRlc3QpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY2xhc3NOYW1lID0gdjtcblxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncmVuZGVyZXInLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG9iajtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChTaGFwZS5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgY29uc3RydWN0b3I6IFNoYXBlLFxuXG4gICAgLy8gRmxhZ3NcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfaWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGlkIG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSWQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX2ZsYWdNYXRyaXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1hdHJpeCBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ01hdHJpeDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfZmxhZ1NjYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzY2FsZSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1NjYWxlOiBmYWxzZSxcblxuICAgIC8vIF9mbGFnTWFzazogZmFsc2UsXG4gICAgLy8gX2ZsYWdDbGlwOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfZmxhZ0NsYXNzTmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNjbGFzc05hbWV9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdDbGFzc05hbWU6IGZhbHNlLFxuXG4gICAgLy8gVW5kZXJseWluZyBQcm9wZXJ0aWVzXG5cbiAgICBfaWQ6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI190cmFuc2xhdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIFRoZSB0cmFuc2xhdGlvbiB2YWx1ZXMgYXMgYSB7QGxpbmsgVHdvLlZlY3Rvcn0uXG4gICAgICovXG4gICAgX3RyYW5zbGF0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI19yb3RhdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHJvdGF0aW9uIHZhbHVlIGluIE51bWJlci5cbiAgICAgKi9cbiAgICBfcm90YXRpb246IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX3RyYW5zbGF0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gVGhlIHRyYW5zbGF0aW9uIHZhbHVlcyBhcyBhIHtAbGluayBUd28uVmVjdG9yfS5cbiAgICAgKi9cbiAgICBfc2NhbGU6IDEsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX3NrZXdYXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgcm90YXRpb24gdmFsdWUgaW4gTnVtYmVyLlxuICAgICAqL1xuICAgIF9za2V3WDogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNfc2tld1lcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSByb3RhdGlvbiB2YWx1ZSBpbiBOdW1iZXIuXG4gICAgICovXG4gICAgX3NrZXdZOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNoYXBlI2NsYXNzTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIEEgY2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudCB0byBiZSBjb21wYXRpYmxlIHdpdGggQ1NTIHN0eWxpbmcuXG4gICAgICogQG5vdGEtYmVuZSBPbmx5IGF2YWlsYWJsZSBmb3IgdGhlIFNWRyByZW5kZXJlci5cbiAgICAgKi9cbiAgICBfY2xhc3NOYW1lOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TaGFwZSNhZGRUb1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBncm91cCAtIFRoZSBwYXJlbnQgdGhlIHNoYXBlIGFkZHMgaXRzZWxmIHRvLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWRkIGl0c2VsZiB0byB0aGUgc2NlbmVncmFwaC5cbiAgICAgKi9cbiAgICBhZGRUbzogZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgIGdyb3VwLmFkZCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBPcHRpb25hbCBhcmd1bWVudCB0byBhdXRvbWF0aWNhbGx5IGFkZCB0aGUgc2hhcGUgdG8gYSBzY2VuZWdyYXBoLlxuICAgICAqIEByZXR1cm5zIHtUd28uU2hhcGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyB7QGxpbmsgVHdvLlNoYXBlfSB3aXRoIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgY3VycmVudCBzaGFwZS5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBTaGFwZSgpO1xuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgY2xvbmUuc2tld1kgPSB0aGlzLnNrZXdZO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lLl91cGRhdGUoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKGJ1YmJsZXMpIHtcblxuICAgICAgaWYgKCF0aGlzLl9tYXRyaXgubWFudWFsICYmIHRoaXMuX2ZsYWdNYXRyaXgpIHtcblxuICAgICAgICB0aGlzLl9tYXRyaXhcbiAgICAgICAgICAuaWRlbnRpdHkoKVxuICAgICAgICAgIC50cmFuc2xhdGUodGhpcy50cmFuc2xhdGlvbi54LCB0aGlzLnRyYW5zbGF0aW9uLnkpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXRyaXguc2NhbGUodGhpcy5fc2NhbGUueCwgdGhpcy5fc2NhbGUueSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hdHJpeC5zY2FsZSh0aGlzLl9zY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWF0cml4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgICB0aGlzLl9tYXRyaXguc2tld1godGhpcy5za2V3WCk7XG4gICAgICAgICAgdGhpcy5fbWF0cml4LnNrZXdZKHRoaXMuc2tld1kpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYnViYmxlcykge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuX3VwZGF0ZSkge1xuICAgICAgICAgIHRoaXMucGFyZW50Ll91cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU2hhcGUjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnSWQgPSB0aGlzLl9mbGFnTWF0cml4ID0gdGhpcy5fZmxhZ1NjYWxlID1cbiAgICAgICAgdGhpcy5fZmxhZ0NsYXNzTmFtZSA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBTaGFwZS5NYWtlT2JzZXJ2YWJsZShTaGFwZS5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uQ29sbGVjdGlvblxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLkV2ZW50c1xuICAgKiBAZGVzY3JpcHRpb24gQW4gYEFycmF5YCBsaWtlIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgZXZlbnQgcHJvcGFnYXRpb24gb24gYWN0aW9ucy4gYHBvcGAsIGBzaGlmdGAsIGFuZCBgc3BsaWNlYCB0cmlnZ2VyIGByZW1vdmVkYCBldmVudHMuIGBwdXNoYCwgYHVuc2hpZnRgLCBhbmQgYHNwbGljZWAgd2l0aCBtb3JlIHRoYW4gMiBhcmd1bWVudHMgdHJpZ2dlciAnaW5zZXJ0ZWQnLiBGaW5hbGx5LCBgc29ydGAgYW5kIGByZXZlcnNlYCB0cmlnZ2VyIGBvcmRlcmAgZXZlbnRzLlxuICAgKi9cbiAgZnVuY3Rpb24gQ29sbGVjdGlvbigpIHtcblxuICAgIEFycmF5LmNhbGwodGhpcyk7XG5cbiAgICBpZiAoYXJndW1lbnRzWzBdICYmIEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1swXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgfVxuXG4gIENvbGxlY3Rpb24ucHJvdG90eXBlID0gbmV3IEFycmF5KCk7XG5cbiAgXy5leHRlbmQoQ29sbGVjdGlvbi5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgY29uc3RydWN0b3I6IENvbGxlY3Rpb24sXG5cbiAgICBwb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvcHBlZCA9IEFycmF5LnByb3RvdHlwZS5wb3AuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMucmVtb3ZlLCBbcG9wcGVkXSk7XG4gICAgICByZXR1cm4gcG9wcGVkO1xuICAgIH0sXG5cbiAgICBzaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2hpZnRlZCA9IEFycmF5LnByb3RvdHlwZS5zaGlmdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5yZW1vdmUsIFtzaGlmdGVkXSk7XG4gICAgICByZXR1cm4gc2hpZnRlZDtcbiAgICB9LFxuXG4gICAgcHVzaDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcHVzaGVkID0gQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuaW5zZXJ0LCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHB1c2hlZDtcbiAgICB9LFxuXG4gICAgdW5zaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdW5zaGlmdGVkID0gQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuaW5zZXJ0LCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHVuc2hpZnRlZDtcbiAgICB9LFxuXG4gICAgc3BsaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzcGxpY2VkID0gQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgdmFyIGluc2VydGVkO1xuXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnJlbW92ZSwgc3BsaWNlZCk7XG5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgICBpbnNlcnRlZCA9IHRoaXMuc2xpY2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMF0gKyBhcmd1bWVudHMubGVuZ3RoIC0gMik7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuaW5zZXJ0LCBpbnNlcnRlZCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMub3JkZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwbGljZWQ7XG4gICAgfSxcblxuICAgIHNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnNvcnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMub3JkZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgQXJyYXkucHJvdG90eXBlLnJldmVyc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMub3JkZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluZGV4T2Y6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQG5hbWUgVHdvLkdyb3VwLkNoaWxkcmVuXG4gICAqIEBleHRlbmRzIFR3by5Db2xsZWN0aW9uXG4gICAqIEBkZXNjcmlwdGlvbiBBIGNoaWxkcmVuIGNvbGxlY3Rpb24gd2hpY2ggaXMgYWNjZXNpYmxlIGJvdGggYnkgaW5kZXggYW5kIGJ5IG9iamVjdCBgaWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gQ2hpbGRyZW4oY2hpbGRyZW4pIHtcblxuICAgIENvbGxlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2V2ZW50cycsIHtcbiAgICAgIHZhbHVlIDoge30sXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLkNoaWxkcmVuI2lkc1xuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSAtIE1hcCBvZiBhbGwgZWxlbWVudHMgaW4gdGhlIGxpc3Qga2V5ZWQgYnkgYGlkYHMuXG4gICAgICovXG4gICAgdGhpcy5pZHMgPSB7fTtcblxuICAgIHRoaXMuYXR0YWNoKFxuICAgICAgQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICApO1xuXG4gICAgdGhpcy5vbihFdmVudHMuVHlwZXMuaW5zZXJ0LCB0aGlzLmF0dGFjaCk7XG4gICAgdGhpcy5vbihFdmVudHMuVHlwZXMucmVtb3ZlLCB0aGlzLmRldGFjaCk7XG5cbiAgfVxuXG4gIENoaWxkcmVuLnByb3RvdHlwZSA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cbiAgXy5leHRlbmQoQ2hpbGRyZW4ucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogQ2hpbGRyZW4sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuQ2hpbGRyZW4jYXR0YWNoXG4gICAgICogQHBhcmFtIHtUd28uU2hhcGVbXX0gY2hpbGRyZW4gLSBUaGUgb2JqZWN0cyB3aGljaCBleHRlbmQge0BsaW5rIFR3by5TaGFwZX0gdG8gYmUgYWRkZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZHMgZWxlbWVudHMgdG8gdGhlIGBpZHNgIG1hcC5cbiAgICAgKi9cbiAgICBhdHRhY2g6IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQgJiYgY2hpbGQuaWQpIHtcbiAgICAgICAgICB0aGlzLmlkc1tjaGlsZC5pZF0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5DaGlsZHJlbiNkZXRhY2hcbiAgICAgKiBAcGFyYW0ge1R3by5TaGFwZVtdfSBjaGlsZHJlbiAtIFRoZSBvYmplY3RzIHdoaWNoIGV4dGVuZCB7QGxpbmsgVHdvLlNoYXBlfSB0byBiZSByZW1vdmVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGVsZW1lbnRzIHRvIHRoZSBgaWRzYCBtYXAuXG4gICAgICovXG4gICAgZGV0YWNoOiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhpcy5pZHNbY2hpbGRyZW5baV0uaWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8vIENvbnN0YW50c1xuXG4gIHZhciBtaW4kMyA9IE1hdGgubWluLCBtYXgkMyA9IE1hdGgubWF4O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uR3JvdXBcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5TaGFwZVxuICAgKiBAcGFyYW0ge1R3by5TaGFwZVtdfSBbY2hpbGRyZW5dIC0gQSBsaXN0IG9mIG9iamVjdHMgdGhhdCBpbmhlcml0IHtAbGluayBUd28uU2hhcGV9LiBGb3IgaW5zdGFuY2UsIHRoZSBhcnJheSBjb3VsZCBiZSBhIHtAbGluayBUd28uUGF0aH0sIHtAbGluayBUd28uVGV4dH0sIGFuZCB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGV9LlxuICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyB0aGUgcHJpbWFyeSBjbGFzcyBmb3IgZ3JvdXBpbmcgb2JqZWN0cyB0aGF0IGFyZSB0aGVuIGRyYXduIGluIFR3by5qcy4gSW4gSWxsdXN0cmF0b3IgdGhpcyBpcyBhIGdyb3VwLCBpbiBBZnRlciBFZmZlY3RzIGl0IHdvdWxkIGJlIGEgTnVsbCBPYmplY3QuIFdoaWNoZXZlciB0aGUgY2FzZSwgdGhlIGBUd28uR3JvdXBgIGNvbnRhaW5zIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGFuZCBjb21tYW5kcyB0byBzdHlsZSBpdHMgY2hpbGRyZW4sIGJ1dCBpdCBieSBpdHNlbGYgZG9lc24ndCByZW5kZXIgdG8gdGhlIHNjcmVlbi5cbiAgICogQG5vdGEtYmVuZSBUaGUge0BsaW5rIFR3byNzY2VuZX0gaXMgYW4gaW5zdGFuY2Ugb2YgYFR3by5Hcm91cGAuXG4gICAqL1xuICBmdW5jdGlvbiBHcm91cChjaGlsZHJlbikge1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzLCB0cnVlKTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLnR5cGUgPSAnZ3JvdXAnO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2FkZGl0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlNoYXBlW119XG4gICAgICogQGRlc2NyaXB0aW9uIEFuIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCBsaXN0IG9mIGNoaWxkcmVuIHRoYXQgbmVlZCB0byBiZSBhcHBlbmRlZCB0byB0aGUgcmVuZGVyZXIncyBzY2VuZWdyYXBoLlxuICAgICAqL1xuICAgIHRoaXMuYWRkaXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjc3VidHJhY3Rpb25zXG4gICAgICogQHByb3BlcnR5IHtUd28uU2hhcGVbXX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQW4gYXV0b21hdGljYWxseSB1cGRhdGVkIGxpc3Qgb2YgY2hpbGRyZW4gdGhhdCBuZWVkIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgcmVuZGVyZXIncyBzY2VuZWdyYXBoLlxuICAgICAqL1xuICAgIHRoaXMuc3VidHJhY3Rpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY2hpbGRyZW5cbiAgICAgKiBAcHJvcGVydHkge1R3by5Hcm91cC5DaGlsZHJlbn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQSBsaXN0IG9mIGFsbCB0aGUgY2hpbGRyZW4gaW4gdGhlIHNjZW5lZ3JhcGguXG4gICAgICogQG5vdGEtYmVuZSBUaGVyIG9yZGVyIG9mIHRoaXMgbGlzdCBpbmRpY2F0ZXMgdGhlIG9yZGVyIGVhY2ggZWxlbWVudCBpcyByZW5kZXJlZCB0byB0aGUgc2NyZWVuLlxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRyZW4gPSBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICB9XG5cbiAgXy5leHRlbmQoR3JvdXAsIHtcblxuICAgIENoaWxkcmVuOiBDaGlsZHJlbixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5JbnNlcnRDaGlsZHJlblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlNoYXBlW119IGNoaWxkcmVuIC0gVGhlIG9iamVjdHMgdG8gYmUgaW5zZXJ0ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IGNoaWxkcmVuIGhhdmUgYmVlbiBhZGRlZCB0byBhIHtAbGluayBUd28uR3JvdXB9LlxuICAgICAqL1xuICAgIEluc2VydENoaWxkcmVuOiBmdW5jdGlvbihjaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXBsYWNlUGFyZW50LmNhbGwodGhpcywgY2hpbGRyZW5baV0sIHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuUmVtb3ZlQ2hpbGRyZW5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5TaGFwZVtdfSBjaGlsZHJlbiAtIFRoZSBvYmplY3RzIHRvIGJlIHJlbW92ZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IGNoaWxkcmVuIGhhdmUgYmVlbiByZW1vdmVkIGZyb20gYSB7QGxpbmsgVHdvLkdyb3VwfS5cbiAgICAgKi9cbiAgICBSZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVwbGFjZVBhcmVudC5jYWxsKHRoaXMsIGNoaWxkcmVuW2ldKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLk9yZGVyQ2hpbGRyZW5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgb3JkZXIgaGFzIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uR3JvdXB9LlxuICAgICAqL1xuICAgIE9yZGVyQ2hpbGRyZW46IGZ1bmN0aW9uKGNoaWxkcmVuKSB7XG4gICAgICB0aGlzLl9mbGFnT3JkZXIgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAuUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5Hcm91cH0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogW1xuICAgICAgJ2ZpbGwnLFxuICAgICAgJ3N0cm9rZScsXG4gICAgICAnbGluZXdpZHRoJyxcbiAgICAgICdjYXAnLFxuICAgICAgJ2pvaW4nLFxuICAgICAgJ21pdGVyJyxcblxuICAgICAgJ2Nsb3NlZCcsXG4gICAgICAnY3VydmVkJyxcbiAgICAgICdhdXRvbWF0aWMnXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkdyb3VwfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5Hcm91cH0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICB2YXIgcHJvcGVydGllcyA9IEdyb3VwLlByb3BlcnRpZXM7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICd2aXNpYmxlJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9mbGFnVmlzaWJsZSA9IHRoaXMuX3Zpc2libGUgIT09IHYgfHwgdGhpcy5fZmxhZ1Zpc2libGU7XG4gICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHY7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdvcGFjaXR5Jywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb3BhY2l0eTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9mbGFnT3BhY2l0eSA9IHRoaXMuX29wYWNpdHkgIT09IHYgfHwgdGhpcy5fZmxhZ09wYWNpdHk7XG4gICAgICAgICAgdGhpcy5fb3BhY2l0eSA9IHY7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdiZWdpbm5pbmcnLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9iZWdpbm5pbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fZmxhZ0JlZ2lubmluZyA9IHRoaXMuX2JlZ2lubmluZyAhPT0gdiB8fCB0aGlzLl9mbGFnQmVnaW5uaW5nO1xuICAgICAgICAgIHRoaXMuX2JlZ2lubmluZyA9IHY7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdlbmRpbmcnLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9lbmRpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fZmxhZ0VuZGluZyA9IHRoaXMuX2VuZGluZyAhPT0gdiB8fCB0aGlzLl9mbGFnRW5kaW5nO1xuICAgICAgICAgIHRoaXMuX2VuZGluZyA9IHY7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdsZW5ndGgnLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9mbGFnTGVuZ3RoIHx8IHRoaXMuX2xlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgdGhpcy5fbGVuZ3RoICs9IGNoaWxkLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgU2hhcGUuTWFrZU9ic2VydmFibGUob2JqZWN0KTtcbiAgICAgIEdyb3VwLk1ha2VHZXR0ZXJTZXR0ZXJzKG9iamVjdCwgcHJvcGVydGllcyk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjaGlsZHJlbicsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24oY2hpbGRyZW4pIHtcblxuICAgICAgICAgIHZhciBpbnNlcnRDaGlsZHJlbiA9IEdyb3VwLkluc2VydENoaWxkcmVuLmJpbmQodGhpcyk7XG4gICAgICAgICAgdmFyIHJlbW92ZUNoaWxkcmVuID0gR3JvdXAuUmVtb3ZlQ2hpbGRyZW4uYmluZCh0aGlzKTtcbiAgICAgICAgICB2YXIgb3JkZXJDaGlsZHJlbiA9IEdyb3VwLk9yZGVyQ2hpbGRyZW4uYmluZCh0aGlzKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4udW5iaW5kKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByZW1vdmVDaGlsZHJlbih0aGlzLl9jaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBuZXcgQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmJpbmQoRXZlbnRzLlR5cGVzLmluc2VydCwgaW5zZXJ0Q2hpbGRyZW4pO1xuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmJpbmQoRXZlbnRzLlR5cGVzLnJlbW92ZSwgcmVtb3ZlQ2hpbGRyZW4pO1xuICAgICAgICAgIHRoaXMuX2NoaWxkcmVuLmJpbmQoRXZlbnRzLlR5cGVzLm9yZGVyLCBvcmRlckNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpbnNlcnRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdtYXNrJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9tYXNrID0gdjtcbiAgICAgICAgICB0aGlzLl9mbGFnTWFzayA9IHRydWU7XG4gICAgICAgICAgaWYgKCF2LmNsaXApIHtcbiAgICAgICAgICAgIHYuY2xpcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cC5NYWtlR2V0dGVyU2V0dGVyc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBncm91cCAtIFRoZSBncm91cCB0byBhcHBseSBnZXR0ZXJzIGFuZCBzZXR0ZXJzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gQSBrZXkgLyB2YWx1ZSBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHRvIGluaGVyaXQuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIG1ldGhvZCB0byBhcHBseSBnZXR0ZXIgLyBzZXR0ZXIgbG9naWMgb24gYW4gYXJyYXkgb2YgcHJvcGVydGllcy4gVXNlZCBpbiB7QGxpbmsgVHdvLkdyb3VwLk1ha2VPYnNlcnZhYmxlfS5cbiAgICAgKi9cbiAgICBNYWtlR2V0dGVyU2V0dGVyczogZnVuY3Rpb24oZ3JvdXAsIHByb3BlcnRpZXMpIHtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICAgIHByb3BlcnRpZXMgPSBbcHJvcGVydGllc107XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIEdyb3VwLk1ha2VHZXR0ZXJTZXR0ZXIoZ3JvdXAsIGspO1xuICAgICAgfSk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwLk1ha2VHZXR0ZXJTZXR0ZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gZ3JvdXAgLSBUaGUgZ3JvdXAgdG8gYXBwbHkgZ2V0dGVycyBhbmQgc2V0dGVycy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gVGhlIGtleSB3aGljaCB3aWxsIGJlY29tZSBhIHByb3BlcnR5IG9uIHRoZSBncm91cC5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFwcGx5IGdldHRlciAvIHNldHRlciBsb2dpYyBzcGVjaWZpYyB0byBob3cgYFR3by5Hcm91cGBzIHRyaWNrbGUgZG93biBzdHlsZXMgdG8gdGhlaXIgY2hpbGRyZW4uIFVzZWQgaW4ge0BsaW5rIFR3by5Hcm91cC5NYWtlT2JzZXJ2YWJsZX0uXG4gICAgICovXG4gICAgTWFrZUdldHRlclNldHRlcjogZnVuY3Rpb24oZ3JvdXAsIGtleSkge1xuXG4gICAgICB2YXIgc2VjcmV0ID0gJ18nICsga2V5O1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXAsIGtleSwge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tzZWNyZXRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXNbc2VjcmV0XSA9IHY7XG4gICAgICAgICAgLy8gVHJpY2tsZSBkb3duIHN0eWxlc1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNoaWxkW2tleV0gPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChHcm91cC5wcm90b3R5cGUsIFNoYXBlLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IEdyb3VwLFxuXG4gICAgLy8gRmxhZ3NcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZsYWdcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ0FkZGl0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNhZGRpdGlvbnN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQWRkaXRpb25zOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ1N1YnRyYWN0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNzdWJ0cmFjdGlvbnN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU3VidHJhY3Rpb25zOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ09yZGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI29yZGVyfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ09yZGVyOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ1Zpc2libGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjdmlzaWJsZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX2ZsYWdPcGFjaXR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkdyb3VwI29wYWNpdHl9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnT3BhY2l0eTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ0JlZ2lubmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNiZWdpbm5pbmd9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQmVnaW5uaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ0VuZGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNlbmRpbmd9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnRW5kaW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ0xlbmd0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Hcm91cCNsZW5ndGh9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTGVuZ3RoOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNfZmxhZ01hc2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JvdXAjbWFza30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdNYXNrOiBmYWxzZSxcblxuICAgIC8vIFVuZGVybHlpbmcgUHJvcGVydGllc1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2ZpbGxcbiAgICAgKiBAcHJvcGVydHkgeyhTdHJpbmd8VHdvLkdyYWRpZW50fFR3by5UZXh0dXJlKX0gLSBUaGUgdmFsdWUgb2Ygd2hhdCBhbGwgY2hpbGQgc2hhcGVzIHNob3VsZCBiZSBmaWxsZWQgaW4gd2l0aC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENTUydzIGNvbG9ycyBhcyBgU3RyaW5nYC5cbiAgICAgKi9cbiAgICBfZmlsbDogJyNmZmYnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI3N0cm9rZVxuICAgICAqIEBwcm9wZXJ0eSB7KFN0cmluZ3xUd28uR3JhZGllbnR8VHdvLlRleHR1cmUpfSAtIFRoZSB2YWx1ZSBvZiB3aGF0IGFsbCBjaGlsZCBzaGFwZXMgc2hvdWxkIGJlIG91dGxpbmVkIGluIHdpdGguXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2NvbG9yX3ZhbHVlfSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiBDU1MncyBjb2xvcnMgYXMgYFN0cmluZ2AuXG4gICAgICovXG4gICAgX3N0cm9rZTogJyMwMDAnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2xpbmV3aWR0aFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB0aGlja25lc3MgaW4gcGl4ZWxzIG9mIHRoZSBzdHJva2UgZm9yIGFsbCBjaGlsZCBzaGFwZXMuXG4gICAgICovXG4gICAgX2xpbmV3aWR0aDogMS4wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI29wYWNpdHlcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgb3BhcXVlbmVzcyBvZiBhbGwgY2hpbGQgc2hhcGVzLlxuICAgICAqIEBub3RhLWJlbmUgQmVjb21lcyBtdWx0aXBsaWVkIGJ5IHRoZSBpbmRpdmlkdWFsIGNoaWxkJ3Mgb3BhY2l0eSBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBfb3BhY2l0eTogMS4wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI3Zpc2libGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGlzcGxheSB0aGUgcGF0aCBvciBub3QuXG4gICAgICogQG5vdGEtYmVuZSBGb3Ige0BsaW5rIFR3by5DYW52YXNSZW5kZXJlcn0gYW5kIHtAbGluayBUd28uV2ViR0xSZW5kZXJlcn0gd2hlbiBzZXQgdG8gZmFsc2UgYWxsIHVwZGF0aW5nIGlzIGRpc2FibGVkIGltcHJvdmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgd2l0aCBtYW55IG9iamVjdHMgaW4gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIF92aXNpYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2NhcFxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1N0cm9rZUxpbmVjYXBQcm9wZXJ0eX1cbiAgICAgKi9cbiAgICBfY2FwOiAncm91bmQnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2pvaW5cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ31cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvcGFpbnRpbmcuaHRtbCNTdHJva2VMaW5lam9pblByb3BlcnR5fVxuICAgICAqL1xuICAgIF9qb2luOiAncm91bmQnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI21pdGVyXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhaW50aW5nLmh0bWwjU3Ryb2tlTWl0ZXJsaW1pdFByb3BlcnR5fVxuICAgICAqL1xuICAgIF9taXRlcjogNCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNjbG9zZWRcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZmluYWwgbGluZSBpcyBkcmF3biBiZXR3ZWVuIHRoZSBmaW5hbCBwb2ludCBpbiB0aGUgYHZlcnRpY2VzYCBhcnJheSBhbmQgdGhlIGZpcnN0IHBvaW50IG9mIGFsbCBjaGlsZCBzaGFwZXMuXG4gICAgICovXG4gICAgX2Nsb3NlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNjdXJ2ZWRcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gV2hlbiB0aGUgY2hpbGQncyBwYXRoIGlzIGBhdXRvbWF0aWMgPSB0cnVlYCB0aGlzIGJvb2xlYW4gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBsaW5lcyBiZXR3ZWVuIHRoZSBwb2ludHMgYXJlIGN1cnZlZCBvciBub3QuXG4gICAgICovXG4gICAgX2N1cnZlZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYXV0b21hdGljXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciBvciBub3QgVHdvLmpzIHNob3VsZCBjYWxjdWxhdGUgY3VydmVzLCBsaW5lcywgYW5kIGNvbW1hbmRzIGF1dG9tYXRpY2FsbHkgZm9yIHlvdSBvciB0byBsZXQgdGhlIGRldmVsb3BlciBtYW5pcHVsYXRlIHRoZW0gZm9yIHRoZW1zZWx2ZXMuXG4gICAgICovXG4gICAgX2F1dG9tYXRpYzogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNiZWdpbm5pbmdcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgYmV0d2VlbiB6ZXJvIGFuZCBvbmUgdG8gc3RhdGUgdGhlIGJlZ2lubmluZyBvZiB3aGVyZSB0aGUgcGF0aCBpcyByZW5kZXJlZC5cbiAgICAgKiBAZGVzY3JpcHRpb24ge0BsaW5rIFR3by5Hcm91cCNiZWdpbm5pbmd9IGlzIGEgcGVyY2VudGFnZSB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgYXQgd2hhdCBwZXJjZW50YWdlIGludG8gYWxsIGNoaWxkIHNoYXBlcyBzaG91bGQgdGhlIHJlbmRlcmVyIHN0YXJ0IGRyYXdpbmcuXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIGlzIGdyZWF0IGZvciBhbmltYXRpbmcgaW4gYW5kIG91dCBzdHJva2VkIHBhdGhzIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIFR3by5Hcm91cCNlbmRpbmd9LlxuICAgICAqL1xuICAgIF9iZWdpbm5pbmc6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjZW5kaW5nXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIGJldHdlZW4gemVybyBhbmQgb25lIHRvIHN0YXRlIHRoZSBlbmRpbmcgb2Ygd2hlcmUgdGhlIHBhdGggaXMgcmVuZGVyZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIHtAbGluayBUd28uR3JvdXAjZW5kaW5nfSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgdGhhdCByZXByZXNlbnRzIGF0IHdoYXQgcGVyY2VudGFnZSBpbnRvIGFsbCBjaGlsZCBzaGFwZXMgc2hvdWxkIHRoZSByZW5kZXJlciBzdGFydCBkcmF3aW5nLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBpcyBncmVhdCBmb3IgYW5pbWF0aW5nIGluIGFuZCBvdXQgc3Ryb2tlZCBwYXRocyBpbiBjb25qdW5jdGlvbiB3aXRoIHtAbGluayBUd28uR3JvdXAjYmVnaW5uaW5nfS5cbiAgICAgKi9cbiAgICBfZW5kaW5nOiAxLjAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjbGVuZ3RoXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHN1bSBvZiBkaXN0YW5jZXMgYmV0d2VlbiBhbGwgY2hpbGQgbGVuZ3Rocy5cbiAgICAgKi9cbiAgICBfbGVuZ3RoOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI21hc2tcbiAgICAgKiBAcHJvcGVydHkge1R3by5TaGFwZX0gLSBUaGUgVHdvLmpzIG9iamVjdCB0byBjbGlwIGZyb20gYSBncm91cCdzIHJlbmRlcmluZy5cbiAgICAgKi9cbiAgICBfbWFzazogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLkdyb3VwfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5Hcm91cH0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGdyb3VwLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgLy8gLyoqXG4gICAgICAvLyAgKiBUT0RPOiBHcm91cCBoYXMgYSBnb3RjaGEgaW4gdGhhdCBpdCdzIGF0IHRoZSBtb21lbnQgcmVxdWlyZWQgdG8gYmUgYm91bmQgdG9cbiAgICAgIC8vICAqIGFuIGluc3RhbmNlIG9mIHR3byBpbiBvcmRlciB0byBhZGQgZWxlbWVudHMgY29ycmVjdGx5LiBUaGlzIG5lZWRzIHRvXG4gICAgICAvLyAgKiBiZSByZXRob3VnaHQgYW5kIGZpeGVkLlxuICAgICAgLy8gICovXG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBHcm91cCgpO1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmNsb25lKCk7XG4gICAgICB9KTtcblxuICAgICAgY2xvbmUuYWRkKGNoaWxkcmVuKTtcblxuICAgICAgY2xvbmUub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgICAgaWYgKHRoaXMubWFzaykge1xuICAgICAgICBjbG9uZS5tYXNrID0gdGhpcy5tYXNrO1xuICAgICAgfVxuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmUuX3VwZGF0ZSgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIGNoaWxkcmVuOiBbXSxcbiAgICAgICAgdHJhbnNsYXRpb246IHRoaXMudHJhbnNsYXRpb24udG9PYmplY3QoKSxcbiAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXG4gICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlIGluc3RhbmNlb2YgVmVjdG9yID8gdGhpcy5zY2FsZS50b09iamVjdCgpIDogdGhpcy5zY2FsZSxcbiAgICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5LFxuICAgICAgICBjbGFzc05hbWU6IHRoaXMuY2xhc3NOYW1lLFxuICAgICAgICBtYXNrOiAodGhpcy5tYXNrID8gdGhpcy5tYXNrLnRvT2JqZWN0KCkgOiBudWxsKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICByZXN1bHQubWF0cml4ID0gdGhpcy5tYXRyaXgudG9PYmplY3QoKTtcbiAgICAgIH1cblxuICAgICAgXy5lYWNoKHRoaXMuY2hpbGRyZW4sIGZ1bmN0aW9uKGNoaWxkLCBpKSB7XG4gICAgICAgIHJlc3VsdC5jaGlsZHJlbltpXSA9IGNoaWxkLnRvT2JqZWN0KCk7XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY29ybmVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWVudCB0aGUgY2hpbGRyZW4gb2YgdGhlIGdyb3VwIHRvIHRoZSB1cHBlciBsZWZ0LWhhbmQgY29ybmVyIG9mIHRoYXQgZ3JvdXAuXG4gICAgICovXG4gICAgY29ybmVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh0cnVlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGNoaWxkLnRyYW5zbGF0aW9uLnggLT0gcmVjdC5sZWZ0O1xuICAgICAgICBjaGlsZC50cmFuc2xhdGlvbi55IC09IHJlY3QudG9wO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjY2VudGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWVudCB0aGUgY2hpbGRyZW4gb2YgdGhlIGdyb3VwIHRvIHRoZSBjZW50ZXIgb2YgdGhhdCBncm91cC5cbiAgICAgKi9cbiAgICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHRydWUpO1xuICAgICAgdmFyIGN4ID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIgLSB0aGlzLnRyYW5zbGF0aW9uLng7XG4gICAgICB2YXIgY3kgPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMiAtIHRoaXMudHJhbnNsYXRpb24ueTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5pc1NoYXBlKSB7XG4gICAgICAgICAgY2hpbGQudHJhbnNsYXRpb24ueCAtPSBjeDtcbiAgICAgICAgICBjaGlsZC50cmFuc2xhdGlvbi55IC09IGN5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNnZXRCeUlkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgaWQuIFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgZm91bmQuXG4gICAgICogQHJldHVybnMge1R3by5TaGFwZX0gLSBPciBgbnVsbGAgaWYgbm90aGluZyBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXRCeUlkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIHZhciBmb3VuZCA9IG51bGw7XG4gICAgICBmdW5jdGlvbiBzZWFyY2gobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHNlYXJjaChub2RlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2dldEJ5Q2xhc3NOYW1lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFJlY3Vyc2l2ZWx5IHNlYXJjaCBmb3IgY2xhc3Nlcy4gUmV0dXJucyBhbiBhcnJheSBvZiBtYXRjaGluZyBlbGVtZW50cy5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlNoYXBlW119IC0gT3IgZW1wdHkgYXJyYXkgaWYgbm90aGluZyBpcyBmb3VuZC5cbiAgICAgKi9cbiAgICBnZXRCeUNsYXNzTmFtZTogZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChub2RlKSB7XG4gICAgICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG5vZGUuY2xhc3NMaXN0LCBjbGFzc05hbWUpID49IDApIHtcbiAgICAgICAgICBmb3VuZC5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgc2VhcmNoKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyb3VwI2dldEJ5VHlwZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZWN1cnNpdmVseSBzZWFyY2ggZm9yIGNoaWxkcmVuIG9mIGEgc3BlY2lmaWMgdHlwZSwgZS5nLiB7QGxpbmsgVHdvLlBhdGh9LiBQYXNzIGEgcmVmZXJlbmNlIHRvIHRoaXMgdHlwZSBhcyB0aGUgcGFyYW0uIFJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICogQHJldHVybnMge1R3by5TaGFwZVtdfSAtIEVtcHR5IGFycmF5IGlmIG5vdGhpbmcgaXMgZm91bmQuXG4gICAgICovXG4gICAgZ2V0QnlUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgZm91bmQgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIHNlYXJjaChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgdHlwZSkge1xuICAgICAgICAgIGZvdW5kLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBzZWFyY2goY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VhcmNoKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjYWRkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uU2hhcGVbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIG9iamVjdHMgdG8gYmUgYWRkZWQuIENhbiBiZSBhbHNvIGJlIHN1cHBsaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgb2JqZWN0cyB0byB0aGUgZ3JvdXAuXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihvYmplY3RzKSB7XG5cbiAgICAgIC8vIEFsbG93IHRvIHBhc3MgbXVsdGlwbGUgb2JqZWN0cyBlaXRoZXIgYXMgYXJyYXkgb3IgYXMgbXVsdGlwbGUgYXJndW1lbnRzXG4gICAgICAvLyBJZiBpdCdzIGFuIGFycmF5IGFsc28gY3JlYXRlIGNvcHkgb2YgaXQgaW4gY2FzZSB3ZSdyZSBnZXR0aW5nIHBhc3NlZFxuICAgICAgLy8gYSBjaGlsZHJlbnMgYXJyYXkgZGlyZWN0bHkuXG4gICAgICBpZiAoIShvYmplY3RzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIG9iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0cyA9IG9iamVjdHMuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSBvYmplY3RzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gb2JqZWN0c1tpXTtcbiAgICAgICAgaWYgKCEoY2hpbGQgJiYgY2hpbGQuaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNhZGRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5TaGFwZVtdfSBvYmplY3RzIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyB0byBiZSByZW1vdmVkLiBDYW4gYmUgYWxzbyByZW1vdmVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmUgb2JqZWN0cyBmcm9tIHRoZSBncm91cC5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG9iamVjdHMpIHtcblxuICAgICAgdmFyIGwgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBncmFuZHBhcmVudCA9IHRoaXMucGFyZW50O1xuXG4gICAgICAvLyBBbGxvdyB0byBjYWxsIHJlbW92ZSB3aXRob3V0IGFyZ3VtZW50c1xuICAgICAgLy8gVGhpcyB3aWxsIGRldGFjaCB0aGUgb2JqZWN0IGZyb20gaXRzIG93biBwYXJlbnQuXG4gICAgICBpZiAobCA8PSAwICYmIGdyYW5kcGFyZW50KSB7XG4gICAgICAgIGdyYW5kcGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsbG93IHRvIHBhc3MgbXVsdGlwbGUgb2JqZWN0cyBlaXRoZXIgYXMgYXJyYXkgb3IgYXMgbXVsdGlwbGUgYXJndW1lbnRzXG4gICAgICAvLyBJZiBpdCdzIGFuIGFycmF5IGFsc28gY3JlYXRlIGNvcHkgb2YgaXQgaW4gY2FzZSB3ZSdyZSBnZXR0aW5nIHBhc3NlZFxuICAgICAgLy8gYSBjaGlsZHJlbnMgYXJyYXkgZGlyZWN0bHkuXG4gICAgICBpZiAoIShvYmplY3RzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIG9iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0cyA9IG9iamVjdHMuc2xpY2UoKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3RzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG9iamVjdHNbaV07XG4gICAgICAgIGlmICghb2JqZWN0IHx8ICF0aGlzLmNoaWxkcmVuLmlkc1tvYmplY3QuaWRdKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5jaGlsZHJlbi5pbmRleE9mKG9iamVjdCk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzaGFsbG93PWZhbHNlXSAtIERlc2NyaWJlcyB3aGV0aGVyIHRvIGNhbGN1bGF0ZSBvZmYgbG9jYWwgbWF0cml4IG9yIHdvcmxkIG1hdHJpeC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFJldHVybnMgb2JqZWN0IHdpdGggdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aCwgaGVpZ2h0IGF0dHJpYnV0ZXMuXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHdpZHRoLCBhbmQgaGVpZ2h0IHBhcmFtZXRlcnMgb2YgdGhlIGdyb3VwLlxuICAgICAqL1xuICAgIGdldEJvdW5kaW5nQ2xpZW50UmVjdDogZnVuY3Rpb24oc2hhbGxvdykge1xuICAgICAgdmFyIHJlY3QsIG1hdHJpeCwgYSwgYiwgYywgZCwgdGMsIGxjLCByYywgYmM7XG5cbiAgICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIHRvIG5vdCBfX2Fsd2F5c19fIHVwZGF0ZS4gSnVzdCB3aGVuIGl0IG5lZWRzIHRvLlxuICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuXG4gICAgICAvLyBWYXJpYWJsZXMgbmVlZCB0byBiZSBkZWZpbmVkIGhlcmUsIGJlY2F1c2Ugb2YgbmVzdGVkIG5hdHVyZSBvZiBncm91cHMuXG4gICAgICB2YXIgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eSxcbiAgICAgICAgICB0b3AgPSBJbmZpbml0eSwgYm90dG9tID0gLUluZmluaXR5O1xuXG4gICAgICB2YXIgcmVnZXggPSAvdGV4dHVyZXxncmFkaWVudC9pO1xuXG4gICAgICBtYXRyaXggPSBzaGFsbG93ID8gdGhpcy5fbWF0cml4IDogZ2V0Q29tcHV0ZWRNYXRyaXgodGhpcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKCFjaGlsZC52aXNpYmxlIHx8IHJlZ2V4LnRlc3QoY2hpbGQuX3JlbmRlcmVyLnR5cGUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICByZWN0ID0gY2hpbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHNoYWxsb3cpO1xuXG4gICAgICAgIHRjID0gdHlwZW9mIHJlY3QudG9wICE9PSAnbnVtYmVyJyB8fCBfLmlzTmFOKHJlY3QudG9wKSB8fCAhaXNGaW5pdGUocmVjdC50b3ApO1xuICAgICAgICBsYyA9IHR5cGVvZiByZWN0LmxlZnQgIT09ICdudW1iZXInIHx8IF8uaXNOYU4ocmVjdC5sZWZ0KSB8fCAhaXNGaW5pdGUocmVjdC5sZWZ0KTtcbiAgICAgICAgcmMgPSB0eXBlb2YgcmVjdC5yaWdodCAhPT0gJ251bWJlcicgfHwgXy5pc05hTihyZWN0LnJpZ2h0KSB8fCAhaXNGaW5pdGUocmVjdC5yaWdodCk7XG4gICAgICAgIGJjID0gdHlwZW9mIHJlY3QuYm90dG9tICE9PSAnbnVtYmVyJyB8fCBfLmlzTmFOKHJlY3QuYm90dG9tKSB8fCAhaXNGaW5pdGUocmVjdC5ib3R0b20pO1xuXG4gICAgICAgIGlmICh0YyB8fCBsYyB8fCByYyB8fCBiYykge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdG9wID0gbWluJDMocmVjdC50b3AsIHRvcCk7XG4gICAgICAgIGxlZnQgPSBtaW4kMyhyZWN0LmxlZnQsIGxlZnQpO1xuICAgICAgICByaWdodCA9IG1heCQzKHJlY3QucmlnaHQsIHJpZ2h0KTtcbiAgICAgICAgYm90dG9tID0gbWF4JDMocmVjdC5ib3R0b20sIGJvdHRvbSk7XG5cbiAgICAgIH1cblxuICAgICAgaWYgKHNoYWxsb3cpIHtcblxuICAgICAgICBhID0gbWF0cml4Lm11bHRpcGx5KGxlZnQsIHRvcCwgMSk7XG4gICAgICAgIGIgPSBtYXRyaXgubXVsdGlwbHkobGVmdCwgYm90dG9tLCAxKTtcbiAgICAgICAgYyA9IG1hdHJpeC5tdWx0aXBseShyaWdodCwgdG9wLCAxKTtcbiAgICAgICAgZCA9IG1hdHJpeC5tdWx0aXBseShyaWdodCwgYm90dG9tLCAxKTtcblxuICAgICAgICB0b3AgPSBtaW4kMyhhLnksIGIueSwgYy55LCBkLnkpO1xuICAgICAgICBsZWZ0ID0gbWluJDMoYS54LCBiLngsIGMueCwgZC54KTtcbiAgICAgICAgcmlnaHQgPSBtYXgkMyhhLngsIGIueCwgYy54LCBkLngpO1xuICAgICAgICBib3R0b20gPSBtYXgkMyhhLnksIGIueSwgYy55LCBkLnkpO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICB3aWR0aDogcmlnaHQgLSBsZWZ0LFxuICAgICAgICBoZWlnaHQ6IGJvdHRvbSAtIHRvcFxuICAgICAgfTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjbm9GaWxsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEFwcGx5IGBub0ZpbGxgIG1ldGhvZCB0byBhbGwgY2hpbGQgc2hhcGVzLlxuICAgICAqL1xuICAgIG5vRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY2hpbGQubm9GaWxsKCk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjbm9TdHJva2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQXBwbHkgYG5vU3Ryb2tlYCBtZXRob2QgdG8gYWxsIGNoaWxkIHNoYXBlcy5cbiAgICAgKi9cbiAgICBub1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY2hpbGQubm9TdHJva2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNzdWJkaXZpZGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQXBwbHkgYHN1YmRpdmlkZWAgbWV0aG9kIHRvIGFsbCBjaGlsZCBzaGFwZXMuXG4gICAgICovXG4gICAgc3ViZGl2aWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnN1YmRpdmlkZS5hcHBseShjaGlsZCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JvdXAjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgaSwgbCwgY2hpbGQ7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnQmVnaW5uaW5nIHx8IHRoaXMuX2ZsYWdFbmRpbmcpIHtcblxuICAgICAgICB2YXIgYmVnaW5uaW5nID0gTWF0aC5taW4odGhpcy5fYmVnaW5uaW5nLCB0aGlzLl9lbmRpbmcpO1xuICAgICAgICB2YXIgZW5kaW5nID0gTWF0aC5tYXgodGhpcy5fYmVnaW5uaW5nLCB0aGlzLl9lbmRpbmcpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIHZhciBzdW0gPSAwO1xuXG4gICAgICAgIHZhciBiZCA9IGJlZ2lubmluZyAqIGxlbmd0aDtcbiAgICAgICAgdmFyIGVkID0gZW5kaW5nICogbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgbCA9IGNoaWxkLmxlbmd0aDtcblxuICAgICAgICAgIGlmIChiZCA+IHN1bSArIGwpIHtcbiAgICAgICAgICAgIGNoaWxkLmJlZ2lubmluZyA9IDE7XG4gICAgICAgICAgICBjaGlsZC5lbmRpbmcgPSAxO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWQgPCBzdW0pIHtcbiAgICAgICAgICAgIGNoaWxkLmJlZ2lubmluZyA9IDA7XG4gICAgICAgICAgICBjaGlsZC5lbmRpbmcgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYmQgPiBzdW0gJiYgYmQgPCBzdW0gKyBsKSB7XG4gICAgICAgICAgICBjaGlsZC5iZWdpbm5pbmcgPSAoYmQgLSBzdW0pIC8gbDtcbiAgICAgICAgICAgIGNoaWxkLmVuZGluZyA9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChlZCA+IHN1bSAmJiBlZCA8IHN1bSArIGwpIHtcbiAgICAgICAgICAgIGNoaWxkLmJlZ2lubmluZyA9IDA7XG4gICAgICAgICAgICBjaGlsZC5lbmRpbmcgPSAoZWQgLSBzdW0pIC8gbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGQuYmVnaW5uaW5nID0gMDtcbiAgICAgICAgICAgIGNoaWxkLmVuZGluZyA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3VtICs9IGw7XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBTaGFwZS5wcm90b3R5cGUuX3VwZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Hcm91cCNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnQWRkaXRpb25zKSB7XG4gICAgICAgIHRoaXMuYWRkaXRpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuX2ZsYWdBZGRpdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ZsYWdTdWJ0cmFjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5zdWJ0cmFjdGlvbnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fZmxhZ1N1YnRyYWN0aW9ucyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9mbGFnT3JkZXIgPSB0aGlzLl9mbGFnTWFzayA9IHRoaXMuX2ZsYWdPcGFjaXR5ID1cbiAgICAgICAgdGhpcy5fZmxhZ0JlZ2lubmluZyA9IHRoaXMuX2ZsYWdFbmRpbmcgPSBmYWxzZTtcblxuICAgICAgU2hhcGUucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBHcm91cC5NYWtlT2JzZXJ2YWJsZShHcm91cC5wcm90b3R5cGUpO1xuXG4gIC8vIC8qKlxuICAvLyAgKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBzeW5jIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXAgd2l0aGluIHRoZVxuICAvLyAgKiBgVHdvLkdyb3VwLmNoaWxkcmVuYCBvYmplY3QuXG4gIC8vICAqXG4gIC8vICAqIFNldCB0aGUgcGFyZW50IG9mIHRoZSBwYXNzZWQgb2JqZWN0IHRvIGFub3RoZXIgb2JqZWN0XG4gIC8vICAqIGFuZCB1cGRhdGVzIHBhcmVudC1jaGlsZCByZWxhdGlvbnNoaXBzXG4gIC8vICAqIENhbGxpbmcgd2l0aCBvbmUgYXJndW1lbnRzIHdpbGwgc2ltcGx5IHJlbW92ZSB0aGUgcGFyZW50aW5nXG4gIC8vICAqL1xuICBmdW5jdGlvbiByZXBsYWNlUGFyZW50KGNoaWxkLCBuZXdQYXJlbnQpIHtcblxuICAgIHZhciBwYXJlbnQgPSBjaGlsZC5wYXJlbnQ7XG4gICAgdmFyIGluZGV4O1xuXG4gICAgaWYgKHBhcmVudCA9PT0gbmV3UGFyZW50KSB7XG4gICAgICBhZGQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5jaGlsZHJlbi5pZHNbY2hpbGQuaWRdKSB7XG5cbiAgICAgIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICBzcGxpY2UoKTtcblxuICAgIH1cblxuICAgIGlmIChuZXdQYXJlbnQpIHtcbiAgICAgIGFkZCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNwbGljZSgpO1xuXG4gICAgaWYgKHBhcmVudC5fZmxhZ0FkZGl0aW9ucyAmJiBwYXJlbnQuYWRkaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcGFyZW50Ll9mbGFnQWRkaXRpb25zID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwYXJlbnQuX2ZsYWdTdWJ0cmFjdGlvbnMgJiYgcGFyZW50LnN1YnRyYWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgIHBhcmVudC5fZmxhZ1N1YnRyYWN0aW9ucyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG5cbiAgICBmdW5jdGlvbiBhZGQoKSB7XG5cbiAgICAgIGlmIChuZXdQYXJlbnQuc3VidHJhY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG5ld1BhcmVudC5zdWJ0cmFjdGlvbnMsIGNoaWxkKTtcblxuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIG5ld1BhcmVudC5zdWJ0cmFjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmV3UGFyZW50LmFkZGl0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChuZXdQYXJlbnQuYWRkaXRpb25zLCBjaGlsZCk7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBuZXdQYXJlbnQuYWRkaXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQucGFyZW50ID0gbmV3UGFyZW50O1xuICAgICAgbmV3UGFyZW50LmFkZGl0aW9ucy5wdXNoKGNoaWxkKTtcbiAgICAgIG5ld1BhcmVudC5fZmxhZ0FkZGl0aW9ucyA9IHRydWU7XG5cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxpY2UoKSB7XG5cbiAgICAgIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChwYXJlbnQuYWRkaXRpb25zLCBjaGlsZCk7XG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHBhcmVudC5hZGRpdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHBhcmVudC5zdWJ0cmFjdGlvbnMsIGNoaWxkKTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBwYXJlbnQuc3VidHJhY3Rpb25zLnB1c2goY2hpbGQpO1xuICAgICAgICBwYXJlbnQuX2ZsYWdTdWJ0cmFjdGlvbnMgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxuICAvLyBDb25zdGFudHNcbiAgdmFyIGVtcHR5QXJyYXkgPSBbXTtcbiAgdmFyIFRXT19QSSQ1ID0gTWF0aC5QSSAqIDIsXG4gICAgbWF4JDIgPSBNYXRoLm1heCxcbiAgICBtaW4kMiA9IE1hdGgubWluLFxuICAgIGFicyA9IE1hdGguYWJzLFxuICAgIHNpbiQ0ID0gTWF0aC5zaW4sXG4gICAgY29zJDQgPSBNYXRoLmNvcyxcbiAgICBhY29zID0gTWF0aC5hY29zLFxuICAgIHNxcnQgPSBNYXRoLnNxcnQ7XG5cbiAgLy8gUmV0dXJucyB0cnVlIGlmIHRoaXMgaXMgYSBub24tdHJhbnNmb3JtaW5nIG1hdHJpeFxuICB2YXIgaXNEZWZhdWx0TWF0cml4ID0gZnVuY3Rpb24gKG0pIHtcbiAgICByZXR1cm4gKG1bMF0gPT0gMSAmJiBtWzNdID09IDAgJiYgbVsxXSA9PSAwICYmIG1bNF0gPT0gMSAmJiBtWzJdID09IDAgJiYgbVs1XSA9PSAwKTtcbiAgfTtcblxuICB2YXIgY2FudmFzID0ge1xuXG4gICAgaXNIaWRkZW46IC8odW5kZWZpbmVkfG5vbmV8dHJhbnNwYXJlbnQpL2ksXG5cbiAgICBhbGlnbm1lbnRzOiB7XG4gICAgICBsZWZ0OiAnc3RhcnQnLFxuICAgICAgbWlkZGxlOiAnY2VudGVyJyxcbiAgICAgIHJpZ2h0OiAnZW5kJ1xuICAgIH0sXG5cbiAgICBzaGltOiBmdW5jdGlvbihlbGVtLCBuYW1lKSB7XG4gICAgICBlbGVtLnRhZ05hbWUgPSBlbGVtLm5vZGVOYW1lID0gbmFtZSB8fCAnY2FudmFzJztcbiAgICAgIGVsZW0ubm9kZVR5cGUgPSAxO1xuICAgICAgZWxlbS5nZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3Byb3BdO1xuICAgICAgfTtcbiAgICAgIGVsZW0uc2V0QXR0cmlidXRlID0gZnVuY3Rpb24ocHJvcCwgdmFsKSB7XG4gICAgICAgIHRoaXNbcHJvcF0gPSB2YWw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBlbGVtO1xuICAgIH0sXG5cbiAgICBncm91cDoge1xuXG4gICAgICByZW5kZXJDaGlsZDogZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgY2FudmFzW2NoaWxkLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChjaGlsZCwgdGhpcy5jdHgsIHRydWUsIHRoaXMuY2xpcCk7XG4gICAgICB9LFxuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeC5lbGVtZW50cztcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5vcGFjaXR5ID0gdGhpcy5fb3BhY2l0eVxuICAgICAgICAgICogKHBhcmVudCAmJiBwYXJlbnQuX3JlbmRlcmVyID8gcGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5IDogMSk7XG5cbiAgICAgICAgdmFyIG1hc2sgPSB0aGlzLl9tYXNrO1xuICAgICAgICAvLyB2YXIgY2xpcCA9IHRoaXMuX2NsaXA7XG5cbiAgICAgICAgdmFyIGRlZmF1bHRNYXRyaXggPSBpc0RlZmF1bHRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgdmFyIHNob3VsZElzb2xhdGUgPSAhZGVmYXVsdE1hdHJpeCB8fCAhIW1hc2s7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5jb250ZXh0KSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuY29udGV4dCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIuY29udGV4dC5jdHggPSBjdHg7XG4gICAgICAgIC8vIHRoaXMuX3JlbmRlcmVyLmNvbnRleHQuY2xpcCA9IGNsaXA7XG5cbiAgICAgICAgaWYgKHNob3VsZElzb2xhdGUpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGlmICghZGVmYXVsdE1hdHJpeCkge1xuICAgICAgICAgICAgY3R4LnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFszXSwgbWF0cml4WzFdLFxuICAgICAgICAgICAgICBtYXRyaXhbNF0sIG1hdHJpeFsyXSwgbWF0cml4WzVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgIGNhbnZhc1ttYXNrLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChtYXNrLCBjdHgsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX29wYWNpdHkgPiAwICYmIHRoaXMuX3NjYWxlICE9PSAwKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgY2FudmFzW2NoaWxkLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChjaGlsZCwgY3R4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkSXNvbGF0ZSkge1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21tZW50ZWQgdHdvLXdheSBmdW5jdGlvbmFsaXR5IG9mIGNsaXBzIC8gbWFza3Mgd2l0aCBncm91cHMgYW5kXG4gICAgICAgIC8vIHBvbHlnb25zLiBVbmNvbW1lbnQgd2hlbiB0aGlzIGJ1ZyBpcyBmaXhlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MVxuXG4gICAgICAgIC8vIGlmIChjbGlwKSB7XG4gICAgICAgIC8vICAgY3R4LmNsaXAoKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgcGF0aDoge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCwgZm9yY2VkLCBwYXJlbnRDbGlwcGVkKSB7XG5cbiAgICAgICAgdmFyIG1hdHJpeCwgc3Ryb2tlLCBsaW5ld2lkdGgsIGZpbGwsIG9wYWNpdHksIHZpc2libGUsIGNhcCwgam9pbiwgbWl0ZXIsXG4gICAgICAgICAgICBjbG9zZWQsIGNvbW1hbmRzLCBsZW5ndGgsIGxhc3QsIG5leHQsIHByZXYsIGEsIGIsIGMsIGQsIHV4LCB1eSwgdngsIHZ5LFxuICAgICAgICAgICAgYXIsIGJsLCBiciwgY2wsIHgsIHksIG1hc2ssIGNsaXAsIGRlZmF1bHRNYXRyaXgsIGlzT2Zmc2V0LCBkYXNoZXMsIHBvO1xuXG4gICAgICAgIHBvID0gKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50Ll9yZW5kZXJlcilcbiAgICAgICAgICA/IHRoaXMucGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5IDogMTtcbiAgICAgICAgbWFzayA9IHRoaXMuX21hc2s7XG4gICAgICAgIGNsaXAgPSB0aGlzLl9jbGlwO1xuICAgICAgICBvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSAqIChwbyB8fCAxKTtcbiAgICAgICAgdmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG5cbiAgICAgICAgaWYgKCFmb3JjZWQgJiYgKCF2aXNpYmxlIHx8IGNsaXAgfHwgb3BhY2l0eSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIG1hdHJpeCA9IHRoaXMuX21hdHJpeC5lbGVtZW50cztcbiAgICAgICAgc3Ryb2tlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICBsaW5ld2lkdGggPSB0aGlzLl9saW5ld2lkdGg7XG4gICAgICAgIGZpbGwgPSB0aGlzLl9maWxsO1xuICAgICAgICBjYXAgPSB0aGlzLl9jYXA7XG4gICAgICAgIGpvaW4gPSB0aGlzLl9qb2luO1xuICAgICAgICBtaXRlciA9IHRoaXMuX21pdGVyO1xuICAgICAgICBjbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG4gICAgICAgIGNvbW1hbmRzID0gdGhpcy5fcmVuZGVyZXIudmVydGljZXM7IC8vIENvbW1hbmRzXG4gICAgICAgIGxlbmd0aCA9IGNvbW1hbmRzLmxlbmd0aDtcbiAgICAgICAgbGFzdCA9IGxlbmd0aCAtIDE7XG4gICAgICAgIGRlZmF1bHRNYXRyaXggPSBpc0RlZmF1bHRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgZGFzaGVzID0gdGhpcy5kYXNoZXM7XG5cbiAgICAgICAgLy8gVHJhbnNmb3JtXG4gICAgICAgIGlmICghZGVmYXVsdE1hdHJpeCkge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFszXSwgbWF0cml4WzFdLCBtYXRyaXhbNF0sIG1hdHJpeFsyXSwgbWF0cml4WzVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbW1lbnRlZCB0d28td2F5IGZ1bmN0aW9uYWxpdHkgb2YgY2xpcHMgLyBtYXNrcyB3aXRoIGdyb3VwcyBhbmRcbiAgICAgICAgLy8gcG9seWdvbnMuIFVuY29tbWVudCB3aGVuIHRoaXMgYnVnIGlzIGZpeGVkOlxuICAgICAgICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzcwOTUxXG4gICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgY2FudmFzW21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKG1hc2ssIGN0eCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdHlsZXNcbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FudmFzW2ZpbGwuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKGZpbGwsIGN0eCk7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC5fcmVuZGVyZXIuZWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdHJva2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhc1tzdHJva2UuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHN0cm9rZSwgY3R4KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS5fcmVuZGVyZXIuZWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGluZXdpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZXdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWl0ZXIpIHtcbiAgICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gbWl0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqb2luKSB7XG4gICAgICAgICAgICBjdHgubGluZUpvaW4gPSBqb2luO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNsb3NlZCAmJiBjYXApIHtcbiAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gY2FwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXNoZXMgJiYgZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoZXMub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21tYW5kcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgYiA9IGNvbW1hbmRzW2ldO1xuXG4gICAgICAgICAgeCA9IGIueDtcbiAgICAgICAgICB5ID0gYi55O1xuXG4gICAgICAgICAgc3dpdGNoIChiLmNvbW1hbmQpIHtcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5jbG9zZTpcbiAgICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5hcmM6XG5cbiAgICAgICAgICAgICAgdmFyIHJ4ID0gYi5yeDtcbiAgICAgICAgICAgICAgdmFyIHJ5ID0gYi5yeTtcbiAgICAgICAgICAgICAgdmFyIHhBeGlzUm90YXRpb24gPSBiLnhBeGlzUm90YXRpb247XG4gICAgICAgICAgICAgIHZhciBsYXJnZUFyY0ZsYWcgPSBiLmxhcmdlQXJjRmxhZztcbiAgICAgICAgICAgICAgdmFyIHN3ZWVwRmxhZyA9IGIuc3dlZXBGbGFnO1xuXG4gICAgICAgICAgICAgIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGxlbmd0aCkgOiBtYXgkMihpIC0gMSwgMCk7XG4gICAgICAgICAgICAgIGEgPSBjb21tYW5kc1twcmV2XTtcblxuICAgICAgICAgICAgICB2YXIgYXggPSBhLng7XG4gICAgICAgICAgICAgIHZhciBheSA9IGEueTtcblxuICAgICAgICAgICAgICBjYW52YXMucmVuZGVyU3ZnQXJjQ29tbWFuZChjdHgsIGF4LCBheSwgcngsIHJ5LCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeEF4aXNSb3RhdGlvbiwgeCwgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLmN1cnZlOlxuXG4gICAgICAgICAgICAgIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGxlbmd0aCkgOiBNYXRoLm1heChpIC0gMSwgMCk7XG4gICAgICAgICAgICAgIG5leHQgPSBjbG9zZWQgPyBtb2QoaSArIDEsIGxlbmd0aCkgOiBNYXRoLm1pbihpICsgMSwgbGFzdCk7XG5cbiAgICAgICAgICAgICAgYSA9IGNvbW1hbmRzW3ByZXZdO1xuICAgICAgICAgICAgICBjID0gY29tbWFuZHNbbmV4dF07XG4gICAgICAgICAgICAgIGFyID0gKGEuY29udHJvbHMgJiYgYS5jb250cm9scy5yaWdodCkgfHwgVmVjdG9yLnplcm87XG4gICAgICAgICAgICAgIGJsID0gKGIuY29udHJvbHMgJiYgYi5jb250cm9scy5sZWZ0KSB8fCBWZWN0b3IuemVybztcblxuICAgICAgICAgICAgICBpZiAoYS5fcmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB2eCA9IChhci54ICsgYS54KTtcbiAgICAgICAgICAgICAgICB2eSA9IChhci55ICsgYS55KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2eCA9IGFyLng7XG4gICAgICAgICAgICAgICAgdnkgPSBhci55O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGIuX3JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgdXggPSAoYmwueCArIGIueCk7XG4gICAgICAgICAgICAgICAgdXkgPSAoYmwueSArIGIueSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXggPSBibC54O1xuICAgICAgICAgICAgICAgIHV5ID0gYmwueTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZ4LCB2eSwgdXgsIHV5LCB4LCB5KTtcblxuICAgICAgICAgICAgICBpZiAoaSA+PSBsYXN0ICYmIGNsb3NlZCkge1xuXG4gICAgICAgICAgICAgICAgYyA9IGQ7XG5cbiAgICAgICAgICAgICAgICBiciA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMucmlnaHQpIHx8IFZlY3Rvci56ZXJvO1xuICAgICAgICAgICAgICAgIGNsID0gKGMuY29udHJvbHMgJiYgYy5jb250cm9scy5sZWZ0KSB8fCBWZWN0b3IuemVybztcblxuICAgICAgICAgICAgICAgIGlmIChiLl9yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgdnggPSAoYnIueCArIGIueCk7XG4gICAgICAgICAgICAgICAgICB2eSA9IChici55ICsgYi55KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdnggPSBici54O1xuICAgICAgICAgICAgICAgICAgdnkgPSBici55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjLl9yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgdXggPSAoY2wueCArIGMueCk7XG4gICAgICAgICAgICAgICAgICB1eSA9IChjbC55ICsgYy55KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdXggPSBjbC54O1xuICAgICAgICAgICAgICAgICAgdXkgPSBjbC55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHggPSBjLng7XG4gICAgICAgICAgICAgICAgeSA9IGMueTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZ4LCB2eSwgdXgsIHV5LCB4LCB5KTtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMubGluZTpcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMubW92ZTpcbiAgICAgICAgICAgICAgZCA9IGI7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9vc2UgZW5kc1xuXG4gICAgICAgIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsaXAgJiYgIXBhcmVudENsaXBwZWQpIHtcbiAgICAgICAgICBpZiAoIWNhbnZhcy5pc0hpZGRlbi50ZXN0KGZpbGwpKSB7XG4gICAgICAgICAgICBpc09mZnNldCA9IGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldDtcbiAgICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIC0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LngsIC0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LnkpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoZmlsbC5fcmVuZGVyZXIuc2NhbGUueCwgZmlsbC5fcmVuZGVyZXIuc2NhbGUueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY2FudmFzLmlzSGlkZGVuLnRlc3Qoc3Ryb2tlKSkge1xuICAgICAgICAgICAgaXNPZmZzZXQgPSBzdHJva2UuX3JlbmRlcmVyICYmIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0O1xuICAgICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoXG4gICAgICAgICAgICAgICAgLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC54LCAtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LnkpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54LCBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnkpO1xuICAgICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZXdpZHRoIC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgaWYgKGlzT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkZWZhdWx0TWF0cml4KSB7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjbGlwICYmICFwYXJlbnRDbGlwcGVkKSB7XG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXNoZXMgJiYgZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZW1wdHlBcnJheSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHRleHQ6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGZvcmNlZCwgcGFyZW50Q2xpcHBlZCkge1xuXG4gICAgICAgIHZhciBwbyA9ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5fcmVuZGVyZXIpXG4gICAgICAgICAgPyB0aGlzLnBhcmVudC5fcmVuZGVyZXIub3BhY2l0eSA6IDE7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSAqIHBvO1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuX3Zpc2libGU7XG4gICAgICAgIHZhciBtYXNrID0gdGhpcy5fbWFzaztcbiAgICAgICAgdmFyIGNsaXAgPSB0aGlzLl9jbGlwO1xuXG4gICAgICAgIGlmICghZm9yY2VkICYmICghdmlzaWJsZSB8fCBjbGlwIHx8IG9wYWNpdHkgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICB2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LmVsZW1lbnRzO1xuICAgICAgICB2YXIgc3Ryb2tlID0gdGhpcy5fc3Ryb2tlO1xuICAgICAgICB2YXIgbGluZXdpZHRoID0gdGhpcy5fbGluZXdpZHRoO1xuICAgICAgICB2YXIgZmlsbCA9IHRoaXMuX2ZpbGw7XG4gICAgICAgIHZhciBkZWNvcmF0aW9uID0gdGhpcy5fZGVjb3JhdGlvbjtcbiAgICAgICAgdmFyIGRlZmF1bHRNYXRyaXggPSBpc0RlZmF1bHRNYXRyaXgobWF0cml4KTtcbiAgICAgICAgdmFyIGlzT2Zmc2V0ID0gZmlsbC5fcmVuZGVyZXIgJiYgZmlsbC5fcmVuZGVyZXIub2Zmc2V0XG4gICAgICAgICAgJiYgc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldDtcbiAgICAgICAgdmFyIGRhc2hlcyA9IHRoaXMuZGFzaGVzO1xuICAgICAgICB2YXIgYWxpZ25tZW50ID0gY2FudmFzLmFsaWdubWVudHNbdGhpcy5fYWxpZ25tZW50XSB8fCB0aGlzLl9hbGlnbm1lbnQ7XG4gICAgICAgIHZhciBiYXNlbGluZSA9IHRoaXMuX2Jhc2VsaW5lO1xuXG4gICAgICAgIHZhciBhLCBiLCBjLCBkLCBlLCBzeCwgc3ksIHgxLCB5MSwgeDIsIHkyO1xuXG4gICAgICAgIC8vIFRyYW5zZm9ybVxuICAgICAgICBpZiAoIWRlZmF1bHRNYXRyaXgpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbM10sIG1hdHJpeFsxXSwgbWF0cml4WzRdLCBtYXRyaXhbMl0sIG1hdHJpeFs1XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21tZW50ZWQgdHdvLXdheSBmdW5jdGlvbmFsaXR5IG9mIGNsaXBzIC8gbWFza3Mgd2l0aCBncm91cHMgYW5kXG4gICAgICAgIC8vIHBvbHlnb25zLiBVbmNvbW1lbnQgd2hlbiB0aGlzIGJ1ZyBpcyBmaXhlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MVxuICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgIGNhbnZhc1ttYXNrLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChtYXNrLCBjdHgsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc09mZnNldCkge1xuICAgICAgICAgIGN0eC5mb250ID0gW3RoaXMuX3N0eWxlLCB0aGlzLl93ZWlnaHQsIHRoaXMuX3NpemUgKyAncHgvJyArXG4gICAgICAgICAgICB0aGlzLl9sZWFkaW5nICsgJ3B4JywgdGhpcy5fZmFtaWx5XS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgudGV4dEFsaWduID0gYWxpZ25tZW50O1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gYmFzZWxpbmU7XG5cbiAgICAgICAgLy8gU3R5bGVzXG4gICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWxsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbnZhc1tmaWxsLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChmaWxsLCBjdHgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwuX3JlbmRlcmVyLmVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXNbc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChzdHJva2UsIGN0eCk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UuX3JlbmRlcmVyLmVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbmV3aWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhc2hlcyAmJiBkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hlcy5vZmZzZXQgfHwgMDtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2xpcCAmJiAhcGFyZW50Q2xpcHBlZCkge1xuXG4gICAgICAgICAgaWYgKCFjYW52YXMuaXNIaWRkZW4udGVzdChmaWxsKSkge1xuXG4gICAgICAgICAgICBpZiAoZmlsbC5fcmVuZGVyZXIgJiYgZmlsbC5fcmVuZGVyZXIub2Zmc2V0KSB7XG5cbiAgICAgICAgICAgICAgc3ggPSBmaWxsLl9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgICBzeSA9IGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XG5cbiAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSggLSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueCxcbiAgICAgICAgICAgICAgICAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC55KTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKHN4LCBzeSk7XG5cbiAgICAgICAgICAgICAgYSA9IHRoaXMuX3NpemUgLyBmaWxsLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgICBiID0gdGhpcy5fbGVhZGluZyAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgICAgIGN0eC5mb250ID0gW3RoaXMuX3N0eWxlLCB0aGlzLl93ZWlnaHQsIGEgKyAncHgvJyxcbiAgICAgICAgICAgICAgICBiICsgJ3B4JywgdGhpcy5fZmFtaWx5XS5qb2luKCcgJyk7XG5cbiAgICAgICAgICAgICAgYyA9IGZpbGwuX3JlbmRlcmVyLm9mZnNldC54IC8gZmlsbC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgICAgZCA9IGZpbGwuX3JlbmRlcmVyLm9mZnNldC55IC8gZmlsbC5fcmVuZGVyZXIuc2NhbGUueTtcblxuICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGhpcy52YWx1ZSwgYywgZCk7XG4gICAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnZhbHVlLCAwLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghY2FudmFzLmlzSGlkZGVuLnRlc3Qoc3Ryb2tlKSkge1xuXG4gICAgICAgICAgICBpZiAoc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldCkge1xuXG4gICAgICAgICAgICAgIHN4ID0gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgICBzeSA9IHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcblxuICAgICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueCxcbiAgICAgICAgICAgICAgICAtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LnkpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoc3gsIHN5KTtcblxuICAgICAgICAgICAgICBhID0gdGhpcy5fc2l6ZSAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcbiAgICAgICAgICAgICAgYiA9IHRoaXMuX2xlYWRpbmcgLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgICAgIGN0eC5mb250ID0gW3RoaXMuX3N0eWxlLCB0aGlzLl93ZWlnaHQsIGEgKyAncHgvJyxcbiAgICAgICAgICAgICAgICBiICsgJ3B4JywgdGhpcy5fZmFtaWx5XS5qb2luKCcgJyk7XG5cbiAgICAgICAgICAgICAgYyA9IHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LnggLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLng7XG4gICAgICAgICAgICAgIGQgPSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55IC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgICBlID0gbGluZXdpZHRoIC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xuXG4gICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBlO1xuICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dCh0aGlzLnZhbHVlLCBjLCBkKTtcbiAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3R4LnN0cm9rZVRleHQodGhpcy52YWx1ZSwgMCwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIHRleHQtZGVjb3JhdGlvblxuICAgICAgICBpZiAoLyh1bmRlcmxpbmV8c3RyaWtldGhyb3VnaCkvaS50ZXN0KGRlY29yYXRpb24pKSB7XG5cbiAgICAgICAgICB2YXIgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnZhbHVlKTtcbiAgICAgICAgICB2YXIgc2NhbGFyID0gMTtcblxuICAgICAgICAgIHN3aXRjaCAoZGVjb3JhdGlvbikge1xuICAgICAgICAgICAgY2FzZSAndW5kZXJsaW5lJzpcbiAgICAgICAgICAgICAgeTEgPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgICAgICAgICB5MiA9IG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc3RyaWtldGhyb3VnaCc6XG4gICAgICAgICAgICAgIHkxID0gMDtcbiAgICAgICAgICAgICAgeTIgPSAwO1xuICAgICAgICAgICAgICBzY2FsYXIgPSAwLjU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN3aXRjaCAoYmFzZWxpbmUpIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgIHkxICs9IHRoaXMuX3NpemUgKiBzY2FsYXI7XG4gICAgICAgICAgICAgIHkyICs9IHRoaXMuX3NpemUgKiBzY2FsYXI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYmFzZWxpbmUnOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzpcbiAgICAgICAgICAgICAgeTEgLT0gdGhpcy5fc2l6ZSAqIHNjYWxhcjtcbiAgICAgICAgICAgICAgeTIgLT0gdGhpcy5fc2l6ZSAqIHNjYWxhcjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoIChhbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgY2FzZSAnc3RhcnQnOlxuICAgICAgICAgICAgICB4MSA9IDA7XG4gICAgICAgICAgICAgIHgyID0gbWV0cmljcy53aWR0aDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgICB4MSA9IC0gbWV0cmljcy53aWR0aDtcbiAgICAgICAgICAgICAgeDIgPSAwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHgxID0gLSBtZXRyaWNzLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgeDIgPSBtZXRyaWNzLndpZHRoIC8gMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5tYXgoTWF0aC5mbG9vcih0aGlzLl9zaXplIC8gMTUpLCAxKTtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRlZmF1bHRNYXRyaXgpIHtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogVGVzdCBmb3IgdGV4dFxuICAgICAgICBpZiAoY2xpcCAmJiAhcGFyZW50Q2xpcHBlZCkge1xuICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGFzaGVzICYmIGRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGVtcHR5QXJyYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAnbGluZWFyLWdyYWRpZW50Jzoge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWZmZWN0IHx8IHRoaXMuX2ZsYWdFbmRQb2ludHMgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XG5cbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgICAgICB0aGlzLmxlZnQuX3gsIHRoaXMubGVmdC5feSxcbiAgICAgICAgICAgIHRoaXMucmlnaHQuX3gsIHRoaXMucmlnaHQuX3lcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuc3RvcHNbaV07XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QuYWRkQ29sb3JTdG9wKHN0b3AuX29mZnNldCwgc3RvcC5fY29sb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAncmFkaWFsLWdyYWRpZW50Jzoge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWZmZWN0IHx8IHRoaXMuX2ZsYWdDZW50ZXIgfHwgdGhpcy5fZmxhZ0ZvY2FsXG4gICAgICAgICAgICB8fCB0aGlzLl9mbGFnUmFkaXVzIHx8IHRoaXMuX2ZsYWdTdG9wcykge1xuXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KFxuICAgICAgICAgICAgdGhpcy5jZW50ZXIuX3gsIHRoaXMuY2VudGVyLl95LCAwLFxuICAgICAgICAgICAgdGhpcy5mb2NhbC5feCwgdGhpcy5mb2NhbC5feSwgdGhpcy5fcmFkaXVzXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0b3AgPSB0aGlzLnN0b3BzW2ldO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0LmFkZENvbG9yU3RvcChzdG9wLl9vZmZzZXQsIHN0b3AuX2NvbG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGV4dHVyZToge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lZmZlY3QgfHwgKCh0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdJbWFnZSB8fCB0aGlzLl9mbGFnVmlkZW8gfHwgdGhpcy5fZmxhZ1JlcGVhdCkgJiYgdGhpcy5sb2FkZWQpKSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWZmZWN0ID0gY3R4LmNyZWF0ZVBhdHRlcm4odGhpcy5pbWFnZSwgdGhpcy5fcmVwZWF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnT2Zmc2V0IHx8IHRoaXMuX2ZsYWdMb2FkZWQgfHwgdGhpcy5fZmxhZ1NjYWxlKSB7XG5cbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5vZmZzZXQgaW5zdGFuY2VvZiBWZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQgPSBuZXcgVmVjdG9yKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnggPSAtIHRoaXMuX29mZnNldC54O1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ID0gLSB0aGlzLl9vZmZzZXQueTtcblxuICAgICAgICAgIGlmIChpbWFnZSkge1xuXG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueCArPSBpbWFnZS53aWR0aCAvIDI7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueSArPSBpbWFnZS5oZWlnaHQgLyAyO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnggKj0gdGhpcy5fc2NhbGUueDtcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKj0gdGhpcy5fc2NhbGUueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueSAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU2NhbGUgfHwgdGhpcy5fZmxhZ0xvYWRlZCkge1xuXG4gICAgICAgICAgaWYgKCEodGhpcy5fcmVuZGVyZXIuc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZSA9IG5ldyBWZWN0b3IoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLmNvcHkodGhpcy5fc2NhbGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS5zZXQodGhpcy5fc2NhbGUsIHRoaXMuX3NjYWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgcmVuZGVyU3ZnQXJjQ29tbWFuZDogZnVuY3Rpb24oY3R4LCBheCwgYXksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHhBeGlzUm90YXRpb24sIHgsIHkpIHtcblxuICAgICAgeEF4aXNSb3RhdGlvbiA9IHhBeGlzUm90YXRpb24gKiBNYXRoLlBJIC8gMTgwO1xuXG4gICAgICAvLyBFbnN1cmUgcmFkaWkgYXJlIHBvc2l0aXZlXG4gICAgICByeCA9IGFicyhyeCk7XG4gICAgICByeSA9IGFicyhyeSk7XG5cbiAgICAgIC8vIENvbXB1dGUgKHgx4oCyLCB5MeKAsilcbiAgICAgIHZhciBkeDIgPSAoYXggLSB4KSAvIDIuMDtcbiAgICAgIHZhciBkeTIgPSAoYXkgLSB5KSAvIDIuMDtcbiAgICAgIHZhciB4MXAgPSBjb3MkNCh4QXhpc1JvdGF0aW9uKSAqIGR4MiArIHNpbiQ0KHhBeGlzUm90YXRpb24pICogZHkyO1xuICAgICAgdmFyIHkxcCA9IC0gc2luJDQoeEF4aXNSb3RhdGlvbikgKiBkeDIgKyBjb3MkNCh4QXhpc1JvdGF0aW9uKSAqIGR5MjtcblxuICAgICAgLy8gQ29tcHV0ZSAoY3jigLIsIGN54oCyKVxuICAgICAgdmFyIHJ4cyA9IHJ4ICogcng7XG4gICAgICB2YXIgcnlzID0gcnkgKiByeTtcbiAgICAgIHZhciB4MXBzID0geDFwICogeDFwO1xuICAgICAgdmFyIHkxcHMgPSB5MXAgKiB5MXA7XG5cbiAgICAgIC8vIEVuc3VyZSByYWRpaSBhcmUgbGFyZ2UgZW5vdWdoXG4gICAgICB2YXIgY3IgPSB4MXBzIC8gcnhzICsgeTFwcyAvIHJ5cztcblxuICAgICAgaWYgKGNyID4gMSkge1xuXG4gICAgICAgIC8vIHNjYWxlIHVwIHJ4LHJ5IGVxdWFsbHkgc28gY3IgPT0gMVxuICAgICAgICB2YXIgcyA9IHNxcnQoY3IpO1xuICAgICAgICByeCA9IHMgKiByeDtcbiAgICAgICAgcnkgPSBzICogcnk7XG4gICAgICAgIHJ4cyA9IHJ4ICogcng7XG4gICAgICAgIHJ5cyA9IHJ5ICogcnk7XG5cbiAgICAgIH1cblxuICAgICAgdmFyIGRxID0gKHJ4cyAqIHkxcHMgKyByeXMgKiB4MXBzKTtcbiAgICAgIHZhciBwcSA9IChyeHMgKiByeXMgLSBkcSkgLyBkcTtcbiAgICAgIHZhciBxID0gc3FydChtYXgkMigwLCBwcSkpO1xuICAgICAgaWYgKGxhcmdlQXJjRmxhZyA9PT0gc3dlZXBGbGFnKSBxID0gLSBxO1xuICAgICAgdmFyIGN4cCA9IHEgKiByeCAqIHkxcCAvIHJ5O1xuICAgICAgdmFyIGN5cCA9IC0gcSAqIHJ5ICogeDFwIC8gcng7XG5cbiAgICAgIC8vIFN0ZXAgMzogQ29tcHV0ZSAoY3gsIGN5KSBmcm9tIChjeOKAsiwgY3nigLIpXG4gICAgICB2YXIgY3ggPSBjb3MkNCh4QXhpc1JvdGF0aW9uKSAqIGN4cFxuICAgICAgICAtIHNpbiQ0KHhBeGlzUm90YXRpb24pICogY3lwICsgKGF4ICsgeCkgLyAyO1xuICAgICAgdmFyIGN5ID0gc2luJDQoeEF4aXNSb3RhdGlvbikgKiBjeHBcbiAgICAgICAgKyBjb3MkNCh4QXhpc1JvdGF0aW9uKSAqIGN5cCArIChheSArIHkpIC8gMjtcblxuICAgICAgLy8gU3RlcCA0OiBDb21wdXRlIM64MSBhbmQgzpTOuFxuICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBzdmdBbmdsZSgxLCAwLCAoeDFwIC0gY3hwKSAvIHJ4LCAoeTFwIC0gY3lwKSAvIHJ5KTtcbiAgICAgIHZhciBkZWx0YSA9IHN2Z0FuZ2xlKCh4MXAgLSBjeHApIC8gcngsICh5MXAgLSBjeXApIC8gcnksXG4gICAgICAgICgtIHgxcCAtIGN4cCkgLyByeCwgKC0geTFwIC0gY3lwKSAvIHJ5KSAlIFRXT19QSSQ1O1xuXG4gICAgICB2YXIgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgZGVsdGE7XG5cbiAgICAgIHZhciBjbG9ja3dpc2UgPSBzd2VlcEZsYWcgPT09IDA7XG5cbiAgICAgIHJlbmRlckFyY0VzdGltYXRlKGN0eCwgY3gsIGN5LCByeCwgcnksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLFxuICAgICAgICBjbG9ja3dpc2UsIHhBeGlzUm90YXRpb24pO1xuXG4gICAgfVxuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlclxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLkV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gVGhpcyBvYmplY3QgaXMgaW5oZXJpdGVkIHdoZW4gY29uc3RydWN0aW5nIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd299LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtwYXJhbWV0ZXJzLmRvbUVsZW1lbnRdIC0gVGhlIGA8Y2FudmFzIC8+YCB0byBkcmF3IHRvLiBJZiBub25lIGdpdmVuIGEgbmV3IG9uZSB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtwYXJhbWV0ZXJzLm92ZXJkcmF3XSAtIERldGVybWluZXMgd2hldGhlciB0aGUgY2FudmFzIHNob3VsZCBjbGVhciB0aGUgYmFja2dyb3VuZCBvciBub3QuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1ldGVycy5zbW9vdGhpbmc9dHJ1ZV0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNhbnZhcyBzaG91bGQgYW50aWFsaWFzIGRyYXdpbmcuIFNldCBpdCB0byBgZmFsc2VgIHdoZW4gd29ya2luZyB3aXRoIHBpeGVsIGFydC4gYGZhbHNlYCBjYW4gbGVhZCB0byBiZXR0ZXIgcGVyZm9ybWFuY2UsIHNpbmNlIGl0IHdvdWxkIHVzZSBhIGNoZWFwZXIgaW50ZXJwb2xhdGlvbiBhbGdvcml0aG0uXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGNsYXNzIGlzIHVzZWQgYnkge0BsaW5rIFR3b30gd2hlbiBjb25zdHJ1Y3Rpbmcgd2l0aCBgdHlwZWAgb2YgYFR3by5UeXBlcy5jYW52YXNgLiBJdCB0YWtlcyBUd28uanMnIHNjZW5lZ3JhcGggYW5kIHJlbmRlcnMgaXQgdG8gYSBgPGNhbnZhcyAvPmAuXG4gICAqL1xuICBmdW5jdGlvbiBSZW5kZXJlciQyKHBhcmFtcykge1xuXG4gICAgLy8gSXQgbWlnaHQgbm90IG1ha2UgYSBiaWcgZGlmZmVyZW5jZSBvbiBHUFUgYmFja2VkIGNhbnZhc2VzLlxuICAgIHZhciBzbW9vdGhpbmcgPSAocGFyYW1zLnNtb290aGluZyAhPT0gZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyI2RvbUVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IC0gVGhlIGA8Y2FudmFzIC8+YCBhc3NvY2lhdGVkIHdpdGggdGhlIFR3by5qcyBzY2VuZS5cbiAgICAgKi9cbiAgICB0aGlzLmRvbUVsZW1lbnQgPSBwYXJhbXMuZG9tRWxlbWVudCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DYW52YXNSZW5kZXJlciNjdHhcbiAgICAgKiBAcHJvcGVydHkge0NhbnZhczJEQ29udGV4dH0gLSBBc3NvY2lhdGVkIHR3byBkaW1lbnNpb25hbCBjb250ZXh0IHRvIHJlbmRlciBvbiB0aGUgYDxjYW52YXMgLz5gLlxuICAgICAqL1xuICAgIHRoaXMuY3R4ID0gdGhpcy5kb21FbGVtZW50LmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2FudmFzUmVuZGVyZXIjb3ZlcmRyYXdcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYW52YXMgY2xlYXJzIHRoZSBiYWNrZ3JvdW5kIGVhY2ggZHJhdyBjYWxsLlxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICB0aGlzLm92ZXJkcmF3ID0gcGFyYW1zLm92ZXJkcmF3IHx8IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBzbW9vdGhpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyI3NjZW5lXG4gICAgICogQHByb3BlcnR5IHtUd28uR3JvdXB9IC0gVGhlIHJvb3QgZ3JvdXAgb2YgdGhlIHNjZW5lZ3JhcGguXG4gICAgICovXG4gICAgdGhpcy5zY2VuZSA9IG5ldyBHcm91cCgpO1xuICAgIHRoaXMuc2NlbmUucGFyZW50ID0gdGhpcztcbiAgfVxuXG5cbiAgXy5leHRlbmQoUmVuZGVyZXIkMiwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyLlV0aWxzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gQSBtYXNzaXZlIG9iamVjdCBmaWxsZWQgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllcyB0byByZW5kZXIgVHdvLmpzIG9iamVjdHMgdG8gYSBgPGNhbnZhcyAvPmAuXG4gICAgICovXG4gICAgVXRpbHM6IGNhbnZhc1xuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFJlbmRlcmVyJDIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBSZW5kZXJlciQyLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyI3NldFNpemVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgcmVzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JhdGlvXSAtIFRoZSBuZXcgcGl4ZWwgcmF0aW8gKHBpeGVsIGRlbnNpdHkpIG9mIHRoZSByZW5kZXJlci4gRGVmYXVsdHMgdG8gY2FsY3VsYXRlIHRoZSBwaXhlbCBkZW5zaXR5IG9mIHRoZSB1c2VyJ3Mgc2NyZWVuLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGFuZ2UgdGhlIHNpemUgb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHJhdGlvKSB7XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLnJhdGlvID0gdHlwZW9mIHJhdGlvID09PSAndW5kZWZpbmVkJyA/IGdldFJhdGlvKHRoaXMuY3R4KSA6IHJhdGlvO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQud2lkdGggPSB3aWR0aCAqIHRoaXMucmF0aW87XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5yYXRpbztcblxuICAgICAgaWYgKHRoaXMuZG9tRWxlbWVudC5zdHlsZSkge1xuICAgICAgICBfLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyAncHgnLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMucmVzaXplLCB3aWR0aCwgaGVpZ2h0LCByYXRpbyk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNhbnZhc1JlbmRlcmVyI3JlbmRlclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgdG8gdGhlIGA8Y2FudmFzIC8+YC5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgaXNPbmUgPSB0aGlzLnJhdGlvID09PSAxO1xuXG4gICAgICBpZiAoIWlzT25lKSB7XG4gICAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jdHguc2NhbGUodGhpcy5yYXRpbywgdGhpcy5yYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5vdmVyZHJhdykge1xuICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjYW52YXMuZ3JvdXAucmVuZGVyLmNhbGwodGhpcy5zY2VuZSwgdGhpcy5jdHgpO1xuXG4gICAgICBpZiAoIWlzT25lKSB7XG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gcmVuZGVyQXJjRXN0aW1hdGUoY3R4LCBveCwgb3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSwgeEF4aXNSb3RhdGlvbikge1xuXG4gICAgdmFyIGVwc2lsb24gPSBDdXJ2ZS5Ub2xlcmFuY2UuZXBzaWxvbjtcbiAgICB2YXIgZGVsdGFBbmdsZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICB2YXIgc2FtZVBvaW50cyA9IE1hdGguYWJzKGRlbHRhQW5nbGUpIDwgZXBzaWxvbjtcblxuICAgIC8vIGVuc3VyZXMgdGhhdCBkZWx0YUFuZ2xlIGlzIDAgLi4gMiBQSVxuICAgIGRlbHRhQW5nbGUgPSBtb2QoZGVsdGFBbmdsZSwgVFdPX1BJJDUpO1xuXG4gICAgaWYgKGRlbHRhQW5nbGUgPCBlcHNpbG9uKSB7XG5cbiAgICAgIGlmIChzYW1lUG9pbnRzKSB7XG5cbiAgICAgICAgZGVsdGFBbmdsZSA9IDA7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgZGVsdGFBbmdsZSA9IFRXT19QSSQ1O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSB0cnVlICYmICEgc2FtZVBvaW50cykge1xuXG4gICAgICBpZiAoZGVsdGFBbmdsZSA9PT0gVFdPX1BJJDUpIHtcblxuICAgICAgICBkZWx0YUFuZ2xlID0gLSBUV09fUEkkNTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBkZWx0YUFuZ2xlID0gZGVsdGFBbmdsZSAtIFRXT19QSSQ1O1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENvbnN0YW50cy5SZXNvbHV0aW9uOyBpKyspIHtcblxuICAgICAgdmFyIHQgPSBpIC8gKENvbnN0YW50cy5SZXNvbHV0aW9uIC0gMSk7XG5cbiAgICAgIHZhciBhbmdsZSA9IHN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcbiAgICAgIHZhciB4ID0gb3ggKyByeCAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIHZhciB5ID0gb3kgKyByeSAqIE1hdGguc2luKGFuZ2xlKTtcblxuICAgICAgaWYgKHhBeGlzUm90YXRpb24gIT09IDApIHtcblxuICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoeEF4aXNSb3RhdGlvbik7XG4gICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKTtcblxuICAgICAgICB2YXIgdHggPSB4IC0gb3g7XG4gICAgICAgIHZhciB0eSA9IHkgLSBveTtcblxuICAgICAgICAvLyBSb3RhdGUgdGhlIHBvaW50IGFib3V0IHRoZSBjZW50ZXIgb2YgdGhlIGVsbGlwc2UuXG4gICAgICAgIHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgb3g7XG4gICAgICAgIHkgPSB0eCAqIHNpbiArIHR5ICogY29zICsgb3k7XG5cbiAgICAgIH1cblxuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcblxuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gc3ZnQW5nbGUodXgsIHV5LCB2eCwgdnkpIHtcblxuICAgIHZhciBkb3QgPSB1eCAqIHZ4ICsgdXkgKiB2eTtcbiAgICB2YXIgbGVuID0gc3FydCh1eCAqIHV4ICsgdXkgKiB1eSkgKiAgc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG4gICAgLy8gZmxvYXRpbmcgcG9pbnQgcHJlY2lzaW9uLCBzbGlnaHRseSBvdmVyIHZhbHVlcyBhcHBlYXJcbiAgICB2YXIgYW5nID0gYWNvcyhtYXgkMigtMSwgbWluJDIoMSwgZG90IC8gbGVuKSkpO1xuICAgIGlmICgodXggKiB2eSAtIHV5ICogdngpIDwgMCkge1xuICAgICAgYW5nID0gLSBhbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZztcblxuICB9XG5cbiAgdmFyIENhbnZhc1NoaW0gPSB7XG5cbiAgICBJbWFnZTogbnVsbCxcblxuICAgIGlzSGVhZGxlc3M6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlV0aWxzLnNoaW1cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge2NhbnZhc30gY2FudmFzIC0gVGhlIGluc3RhbmNlZCBgQ2FudmFzYCBvYmplY3QgcHJvdmlkZWQgYnkgYG5vZGUtY2FudmFzYC5cbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBbSW1hZ2VdIC0gVGhlIHByb3RvdHlwaWNhbCBgSW1hZ2VgIG9iamVjdCBwcm92aWRlZCBieSBgbm9kZS1jYW52YXNgLiBUaGlzIGlzIG9ubHkgbmVjZXNzYXJ5IHRvIHBhc3MgaWYgeW91J3JlIGdvaW5nIHRvIGxvYWQgYml0bWFwIGltYWdlcnkuXG4gICAgICogQHJldHVybnMge2NhbnZhc30gUmV0dXJucyB0aGUgaW5zdGFuY2VkIGNhbnZhcyBvYmplY3QgeW91IHBhc3NlZCBmcm9tIHdpdGggYWRkaXRpb25hbCBhdHRyaWJ1dGVzIG5lZWRlZCBmb3IgVHdvLmpzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGRlZmluaW5nIGFsbCB0aGUgZGVwZW5kZW5jaWVzIGZyb20gdGhlIG5wbSBwYWNrYWdlIGBub2RlLWNhbnZhc2AuIFNlZSBbbm9kZS1jYW52YXNdKGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL25vZGUtY2FudmFzKSBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBvbiBzZXR0aW5nIHVwIEhUTUw1IGA8Y2FudmFzIC8+YCBkcmF3aW5nIGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudC5cbiAgICAgKi9cbiAgICBzaGltOiBmdW5jdGlvbihjYW52YXMsIEltYWdlKSB7XG4gICAgICBSZW5kZXJlciQyLlV0aWxzLnNoaW0oY2FudmFzKTtcbiAgICAgIGlmICh0eXBlb2YgSW1hZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIENhbnZhc1NoaW0uSW1hZ2UgPSBJbWFnZTtcbiAgICAgIH1cbiAgICAgIENhbnZhc1NoaW0uaXNIZWFkbGVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICB9O1xuXG4gIHZhciBkb20gPSB7XG5cbiAgICBoYXNFdmVudExpc3RlbmVyczogdHlwZW9mIHJvb3QkMS5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nLFxuXG4gICAgYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGlmICh0aGlzLmhhc0V2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgZnVuYywgISFib29sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIHVuYmluZDogZnVuY3Rpb24oZWxlbSwgZXZlbnQsIGZ1bmMsIGJvb2wpIHtcbiAgICAgIGlmIChkb20uaGFzRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVycyhldmVudCwgZnVuYywgISFib29sKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW0uZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmdW5jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb207XG4gICAgfSxcblxuICAgIGdldFJlcXVlc3RBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBsYXN0VGltZSA9IDA7XG4gICAgICB2YXIgdmVuZG9ycyA9IFsnbXMnLCAnbW96JywgJ3dlYmtpdCcsICdvJ107XG4gICAgICB2YXIgcmVxdWVzdCA9IHJvb3QkMS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGNhbmNlbDtcblxuICAgICAgaWYoIXJlcXVlc3QpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVxdWVzdCA9IHJvb3QkMVt2ZW5kb3JzW2ldICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddIHx8IHJlcXVlc3Q7XG4gICAgICAgICAgY2FuY2VsID0gcm9vdCQxW3ZlbmRvcnNbaV0gKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXVxuICAgICAgICAgICAgfHwgcm9vdCQxW3ZlbmRvcnNbaV0gKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10gfHwgY2FuY2VsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3QgfHwgZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgY3VyclRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgICB2YXIgaWQgPSByb290JDEuc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soY3VyclRpbWUgKyB0aW1lVG9DYWxsKTsgfSwgdGltZVRvQ2FsbCk7XG4gICAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVxdWVzdDtcblxuICAgIH1cblxuICB9O1xuXG4gIHZhciB0ZW1wID0gKHJvb3QkMS5kb2N1bWVudCA/IHJvb3QkMS5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IHt9KTtcbiAgdGVtcC5pZCA9ICdoZWxwLXR3by1sb2FkJztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9tLCAndGVtcCcsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoXy5pc0VsZW1lbnQodGVtcCkgJiYgIXJvb3QkMS5kb2N1bWVudC5oZWFkLmNvbnRhaW5zKHRlbXApKSB7XG4gICAgICAgIF8uZXh0ZW5kKHRlbXAuc3R5bGUsIHtcbiAgICAgICAgICBkaXNwbGF5OiAnbm9uZSdcbiAgICAgICAgfSk7XG4gICAgICAgIHJvb3QkMS5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRlbXApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXA7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLkVycm9yXG4gICAqIEBjbGFzc1xuICAgKiBAZGVzY3JpcHRpb24gQ3VzdG9tIGVycm9yIHRocm93aW5nIGZvciBUd28uanMgc3BlY2lmaWMgaWRlbnRpZmljYXRpb24uXG4gICAqL1xuICBmdW5jdGlvbiBUd29FcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5uYW1lID0gJ1R3by5qcyc7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxuXG4gIFR3b0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4gIF8uZXh0ZW5kKFR3b0Vycm9yLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiBUd29FcnJvclxuICB9KTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmRlZmluZUdldHRlclNldHRlclxuICAgKiBAZnVuY3Rpb25cbiAgICogQHRoaXMgVHdvI1xuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBUaGUgcHJvcGVydHkgdG8gYWRkIGFuIGVudW1lcmFibGUgZ2V0dGVyIC8gc2V0dGVyIHRvLlxuICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gc2V0dXAgdGhlIGZsYWcgYmFzZWQgZ2V0dGVyIC8gc2V0dGVyIHRoYXQgbW9zdCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIGFzIGluIFR3by5qcy5cbiAgICovXG4gIHZhciBkZWZpbmVHZXR0ZXJTZXR0ZXIgPSBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXG4gICAgdmFyIG9iamVjdCA9IHRoaXM7XG4gICAgdmFyIHNlY3JldCA9ICdfJyArIHByb3BlcnR5O1xuICAgIHZhciBmbGFnID0gJ19mbGFnJyArIHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3NlY3JldF07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHRoaXNbc2VjcmV0XSA9IHY7XG4gICAgICAgIHRoaXNbZmxhZ10gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5SZWdpc3RyeVxuICAgKiBAY2xhc3NcbiAgICogQGRlc2NyaXB0aW9uIEFuIGFyYml0cmFyeSBjbGFzcyB0byBtYW5hZ2UgYSBkaXJlY3Rvcnkgb2YgdGhpbmdzLiBNYWlubHkgdXNlZCBmb3Iga2VlcGluZyB0YWJzIG9mIHRleHR1cmVzIGluIFR3by5qcy5cbiAgICovXG4gIGZ1bmN0aW9uIFJlZ2lzdHJ5KCkge1xuXG4gICAgdGhpcy5tYXAgPSB7fTtcblxuICB9XG5cbiAgXy5leHRlbmQoUmVnaXN0cnkucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogUmVnaXN0cnksXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVnaXN0cnkjYWRkXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkIC0gQSB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBBbnkgdHlwZSBvZiB2YXJpYWJsZSB0byBiZSByZWdpc3RlcmVkIHRvIHRoZSBkaXJlY3RvcnkuXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZHMgYW55IHZhbHVlIHRvIHRoZSBkaXJlY3RvcnkuIEFzc2lnbmVkIGJ5IHRoZSBgaWRgLlxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24oaWQsIG9iaikge1xuICAgICAgdGhpcy5tYXBbaWRdID0gb2JqO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWdpc3RyeSNyZW1vdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBBIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmUgYW55IHZhbHVlIGZyb20gdGhlIGRpcmVjdG9yeSBieSBpdHMgYGlkYC5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICBkZWxldGUgdGhpcy5tYXBbaWRdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWdpc3RyeSNnZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBBIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqIEByZXR1cm5zIHs/T2JqZWN0fSBUaGUgYXNzb2NpYXRlZCB2YWx1ZS4gSWYgdW5hdmFpbGFibGUgdGhlbiBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IGEgcmVnaXN0ZXJlZCB2YWx1ZSBieSBpdHMgYGlkYC5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYXBbaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVnaXN0cnkjY29udGFpbnNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBBIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBtZXRob2QgdG8gc2VlIGlmIGEgdmFsdWUgaXMgcmVnaXN0ZXJlZCB0byBhbiBgaWRgIGFscmVhZHkuXG4gICAgICovXG4gICAgY29udGFpbnM6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICByZXR1cm4gaWQgaW4gdGhpcy5tYXA7XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uU3RvcFxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gVGhlIG9mZnNldCBwZXJjZW50YWdlIG9mIHRoZSBzdG9wIHJlcHJlc2VudGVkIGFzIGEgemVyby10by1vbmUgdmFsdWUuIERlZmF1bHQgdmFsdWUgZmxpcCBmbG9wcyBmcm9tIHplcm8tdG8tb25lIGFzIG5ldyBzdG9wcyBhcmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtjb2xvcl0gLSBUaGUgY29sb3Igb2YgdGhlIHN0b3AuIERlZmF1bHQgdmFsdWUgZmxpcCBmbG9wcyBmcm9tIHdoaXRlIHRvIGJsYWNrIGFzIG5ldyBzdG9wcyBhcmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcGFjaXR5XSAtIFRoZSBvcGFjaXR5IHZhbHVlLiBEZWZhdWx0IHZhbHVlIGlzIDEsIGNhbm5vdCBiZSBsb3dlciB0aGFuIDAuXG4gICAqIEBub3RhLWJlbmUgVXNlZCBzcGVjaWZpY2FsbHkgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgVHdvLkdyYWRpZW50fXMgdG8gY29udHJvbCBjb2xvciBncmFkdWF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gU3RvcChvZmZzZXQsIGNvbG9yLCBvcGFjaXR5KSB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RvcCNyZW5kZXJlclxuICAgICAqIEBwcm9wZXJ0eSB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBPYmplY3QgYWNjZXNzIHRvIHN0b3JlIHJlbGV2YW50IHJlbmRlcmVyIHNwZWNpZmljIHZhcmlhYmxlcy4gV2FybmluZzogbWFuaXB1bGF0aW5nIHRoaXMgb2JqZWN0IGNhbiBjcmVhdGUgdW5pbnRlbmRlZCBjb25zZXF1ZW5jZXMuXG4gICAgICogQG5vdGEtYmVuZSBXaXRoIHRoZSB7QGxpbmsgVHdvLlN2Z1JlbmRlcmVyfSB5b3UgY2FuIGFjY2VzcyB0aGUgdW5kZXJseWluZyBTVkcgZWxlbWVudCBjcmVhdGVkIHZpYSBgc2hhcGUucmVuZGVyZXIuZWxlbWAuXG4gICAgICovXG4gICAgdGhpcy5yZW5kZXJlciA9IHt9O1xuICAgIHRoaXMuX3JlbmRlcmVyLnR5cGUgPSAnc3RvcCc7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RvcCNvZmZzZXRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgb2Zmc2V0IHBlcmNlbnRhZ2Ugb2YgdGhlIHN0b3AgcmVwcmVzZW50ZWQgYXMgYSB6ZXJvLXRvLW9uZSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldCA9IHR5cGVvZiBvZmZzZXQgPT09ICdudW1iZXInID8gb2Zmc2V0XG4gICAgICA6IFN0b3AuSW5kZXggPD0gMCA/IDAgOiAxO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3Ajb3BhY2l0eVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBhbHBoYSBwZXJjZW50YWdlIG9mIHRoZSBzdG9wIHJlcHJlc2VudGVkIGFzIGEgemVyby10by1vbmUgdmFsdWUuXG4gICAgICovXG4gICAgdGhpcy5vcGFjaXR5ID0gdHlwZW9mIG9wYWNpdHkgPT09ICdudW1iZXInID8gb3BhY2l0eSA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RvcCNjb2xvclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSBjb2xvciBvZiB0aGUgc3RvcC5cbiAgICAgKi9cbiAgICB0aGlzLmNvbG9yID0gKHR5cGVvZiBjb2xvciA9PT0gJ3N0cmluZycpID8gY29sb3JcbiAgICAgIDogU3RvcC5JbmRleCA8PSAwID8gJyNmZmYnIDogJyMwMDAnO1xuXG4gICAgU3RvcC5JbmRleCA9IChTdG9wLkluZGV4ICsgMSkgJSAyO1xuXG4gIH1cblxuICBfLmV4dGVuZChTdG9wLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RvcC5JbmRleFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBjdXJyZW50IGluZGV4IGJlaW5nIHJlZmVyZW5jZWQgZm9yIGNhbGN1bGF0aW5nIGEgc3RvcCdzIGRlZmF1bHQgb2Zmc2V0IHZhbHVlLlxuICAgICAqL1xuICAgIEluZGV4OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3AuUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5TdG9wfS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbXG4gICAgICAnb2Zmc2V0JyxcbiAgICAgICdvcGFjaXR5JyxcbiAgICAgICdjb2xvcidcbiAgICBdLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3AuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5TdG9wfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5TdG9wfSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgIF8uZWFjaChTdG9wLlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG5cbiAgICAgICAgdmFyIG9iamVjdCA9IHRoaXM7XG4gICAgICAgIHZhciBzZWNyZXQgPSAnXycgKyBwcm9wZXJ0eTtcbiAgICAgICAgdmFyIGZsYWcgPSAnX2ZsYWcnICsgcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3NlY3JldF07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgIHRoaXNbc2VjcmV0XSA9IHY7XG4gICAgICAgICAgICB0aGlzW2ZsYWddID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgICB0aGlzLnBhcmVudC5fZmxhZ1N0b3BzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICB9LCBvYmplY3QpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncmVuZGVyZXInLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG9iajtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChTdG9wLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU3RvcCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdG9wI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uU3RvcH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uU3RvcH0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgU3RvcCgpO1xuXG4gICAgICBfLmVhY2goU3RvcC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICBjbG9uZVtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3AjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgXy5lYWNoKFN0b3AuUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0b3AjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnT2Zmc2V0ID0gdGhpcy5fZmxhZ0NvbG9yID0gdGhpcy5fZmxhZ09wYWNpdHkgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgU3RvcC5NYWtlT2JzZXJ2YWJsZShTdG9wLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5HcmFkaWVudFxuICAgKiBAY2xhc3NcbiAgICogQHBhcmFtIHtUd28uU3RvcFtdfSBbc3RvcHNdIC0gQSBsaXN0IG9mIHtAbGluayBUd28uU3RvcH1zIHRoYXQgY29udGFpbiB0aGUgZ3JhZGllbnQgZmlsbCBwYXR0ZXJuIGZvciB0aGUgZ3JhZGllbnQuXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBjb25zdHJ1Y3RpbmcgZGlmZmVyZW50IHR5cGVzIG9mIGdyYWRpZW50cyB3aXRoIFR3by5qcy4gVGhlIHR3byBjb21tb24gZ3JhZGllbnRzIGFyZSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fSBhbmQge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudH0uXG4gICAqL1xuICBmdW5jdGlvbiBHcmFkaWVudChzdG9wcykge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I3JlbmRlcmVyXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIE9iamVjdCBhY2Nlc3MgdG8gc3RvcmUgcmVsZXZhbnQgcmVuZGVyZXIgc3BlY2lmaWMgdmFyaWFibGVzLiBXYXJuaW5nOiBtYW5pcHVsYXRpbmcgdGhpcyBvYmplY3QgY2FuIGNyZWF0ZSB1bmludGVuZGVkIGNvbnNlcXVlbmNlcy5cbiAgICAgKiBAbm90YS1iZW5lIFdpdGggdGhlIHtAbGluayBUd28uU3ZnUmVuZGVyZXJ9IHlvdSBjYW4gYWNjZXNzIHRoZSB1bmRlcmx5aW5nIFNWRyBlbGVtZW50IGNyZWF0ZWQgdmlhIGBzaGFwZS5yZW5kZXJlci5lbGVtYC5cbiAgICAgKi9cbiAgICB0aGlzLnJlbmRlcmVyID0ge307XG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICdncmFkaWVudCc7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQjaWRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBTZXNzaW9uIHNwZWNpZmljIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqIEBub3RhLWJlbmUgSW4gdGhlIHtAbGluayBUd28uU3ZnUmVuZGVyZXJ9IGNoYW5nZSB0aGlzIHRvIGNoYW5nZSB0aGUgdW5kZXJseWluZyBTVkcgZWxlbWVudCdzIGlkIHRvby5cbiAgICAgKi9cbiAgICB0aGlzLmlkID0gQ29uc3RhbnRzLklkZW50aWZpZXIgKyBDb25zdGFudHMudW5pcXVlSWQoKTtcbiAgICB0aGlzLmNsYXNzTGlzdCA9IFtdO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0b3BzID0gR3JhZGllbnQuRmxhZ1N0b3BzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuYmluZFN0b3BzID0gR3JhZGllbnQuQmluZFN0b3BzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIudW5iaW5kU3RvcHMgPSBHcmFkaWVudC5VbmJpbmRTdG9wcy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I3NwcmVhZFxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIEluZGljYXRlcyB3aGF0IGhhcHBlbnMgaWYgdGhlIGdyYWRpZW50IHN0YXJ0cyBvciBlbmRzIGluc2lkZSB0aGUgYm91bmRzIG9mIHRoZSB0YXJnZXQgcmVjdGFuZ2xlLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIGAncGFkJ2AsIGAncmVmbGVjdCdgLCBhbmQgYCdyZXBlYXQnYC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMTEvcHNlcnZlcnMuaHRtbCNMaW5lYXJHcmFkaWVudEVsZW1lbnRTcHJlYWRNZXRob2RBdHRyaWJ1dGV9IGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICAgICovXG4gICAgdGhpcy5zcHJlYWQgPSAncGFkJztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNzdG9wc1xuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlN0b3BbXX0gLSBBbiBvcmRlcmVkIGxpc3Qgb2Yge0BsaW5rIFR3by5TdG9wfXMgZm9yIHJlbmRlcmluZyB0aGUgZ3JhZGllbnQuXG4gICAgICovXG4gICAgaWYgKHN0b3BzKSB7XG4gICAgICB0aGlzLnN0b3BzID0gc3RvcHM7XG4gICAgfVxuXG4gIH1cblxuICBfLmV4dGVuZChHcmFkaWVudCwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50LlN0b3BcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3RvcH1cbiAgICAgKi9cbiAgICBTdG9wOiBTdG9wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50LlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uR3JhZGllbnR9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFtcbiAgICAgICdzcHJlYWQnXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkdyYWRpZW50fSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5HcmFkaWVudH0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICBfLmVhY2goR3JhZGllbnQuUHJvcGVydGllcywgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmplY3QpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc3RvcHMnLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wcztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0b3BzKSB7XG5cbiAgICAgICAgICB2YXIgYmluZFN0b3BzID0gdGhpcy5fcmVuZGVyZXIuYmluZFN0b3BzO1xuICAgICAgICAgIHZhciB1bmJpbmRTdG9wcyA9IHRoaXMuX3JlbmRlcmVyLnVuYmluZFN0b3BzO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGxpc3RlbmVyc1xuICAgICAgICAgIGlmICh0aGlzLl9zdG9wcykge1xuICAgICAgICAgICAgdGhpcy5fc3RvcHNcbiAgICAgICAgICAgICAgLnVuYmluZChFdmVudHMuVHlwZXMuaW5zZXJ0LCBiaW5kU3RvcHMpXG4gICAgICAgICAgICAgIC51bmJpbmQoRXZlbnRzLlR5cGVzLnJlbW92ZSwgdW5iaW5kU3RvcHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIENyZWF0ZSBuZXcgQ29sbGVjdGlvbiB3aXRoIGNvcHkgb2YgU3RvcHNcbiAgICAgICAgICB0aGlzLl9zdG9wcyA9IG5ldyBDb2xsZWN0aW9uKChzdG9wcyB8fCBbXSkuc2xpY2UoMCkpO1xuXG4gICAgICAgICAgLy8gTGlzdGVuIGZvciBDb2xsZWN0aW9uIGNoYW5nZXMgYW5kIGJpbmQgLyB1bmJpbmRcbiAgICAgICAgICB0aGlzLl9zdG9wc1xuICAgICAgICAgICAgLmJpbmQoRXZlbnRzLlR5cGVzLmluc2VydCwgYmluZFN0b3BzKVxuICAgICAgICAgICAgLmJpbmQoRXZlbnRzLlR5cGVzLnJlbW92ZSwgdW5iaW5kU3RvcHMpO1xuXG4gICAgICAgICAgLy8gQmluZCBJbml0aWFsIFN0b3BzXG4gICAgICAgICAgYmluZFN0b3BzKHRoaXMuX3N0b3BzKTtcblxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAncmVuZGVyZXInLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG9iajtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2lkJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5faWQgPSB2O1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudC5GbGFnU3RvcHNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgc3RvcHMgaGF2ZSBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLkdyYWRpZW50fS5cbiAgICAgKi9cbiAgICBGbGFnU3RvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ1N0b3BzID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50LkJpbmRWZXJ0aWNlc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLkdyYWRpZW50fSBrbm93IHZlcnRpY2VzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgQmluZFN0b3BzOiBmdW5jdGlvbihpdGVtcykge1xuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhIGxvdFxuICAgICAgLy8gd2hlbiBpbXBvcnRpbmcgYSBsYXJnZSBTVkdcbiAgICAgIHZhciBpID0gaXRlbXMubGVuZ3RoO1xuICAgICAgd2hpbGUoaS0tKSB7XG4gICAgICAgIGl0ZW1zW2ldLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0b3BzKTtcbiAgICAgICAgaXRlbXNbaV0ucGFyZW50ID0gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0b3BzKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50LlVuYmluZFN0b3BzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHtAbGluayBUd28uR3JhZGllbnR9IGtub3cgdmVydGljZXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgVW5iaW5kU3RvcHM6IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cbiAgICAgIHZhciBpID0gaXRlbXMubGVuZ3RoO1xuICAgICAgd2hpbGUoaS0tKSB7XG4gICAgICAgIGl0ZW1zW2ldLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnU3RvcHMpO1xuICAgICAgICBkZWxldGUgaXRlbXNbaV0ucGFyZW50O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlci5mbGFnU3RvcHMoKTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChHcmFkaWVudC5wcm90b3R5cGUsIEV2ZW50cywge1xuXG4gICAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I19mbGFnSWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JhZGllbnQjaWR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I19mbGFnU3RvcHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uR3JhZGllbnQjc3RvcHN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU3RvcHM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5HcmFkaWVudCNfZmxhZ1NwcmVhZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5HcmFkaWVudCNzcHJlYWR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU3ByZWFkOiBmYWxzZSxcblxuICAgIF9pZDogJycsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uR3JhZGllbnQjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5HcmFkaWVudH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uR3JhZGllbnR9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcy5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICByZXR1cm4gcy5jbG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBHcmFkaWVudChzdG9wcyk7XG5cbiAgICAgIF8uZWFjaChHcmFkaWVudC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICBzdG9wczogdGhpcy5zdG9wcy5tYXAoZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzLnRvT2JqZWN0KCk7XG4gICAgICAgIH0pXG4gICAgICB9O1xuXG4gICAgICBfLmVhY2goR3JhZGllbnQuUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkdyYWRpZW50I2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1NwcmVhZCA9IHRoaXMuX2ZsYWdTdG9wcyA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZShHcmFkaWVudC5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnRcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5HcmFkaWVudFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3gxPTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGZpcnN0IGVuZCBwb2ludCBvZiB0aGUgbGluZWFyIGdyYWRpZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3kxPTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGZpcnN0IGVuZCBwb2ludCBvZiB0aGUgbGluZWFyIGdyYWRpZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3gyPTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNlY29uZCBlbmQgcG9pbnQgb2YgdGhlIGxpbmVhciBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5Mj0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgZW5kIHBvaW50IG9mIHRoZSBsaW5lYXIgZ3JhZGllbnQuXG4gICAqIEBwYXJhbSB7VHdvLlN0b3BbXX0gW3N0b3BzXSAtIEEgbGlzdCBvZiB7QGxpbmsgVHdvLlN0b3B9cyB0aGF0IGNvbnRhaW4gdGhlIGdyYWRpZW50IGZpbGwgcGF0dGVybiBmb3IgdGhlIGdyYWRpZW50LlxuICAgKiBAbm90YS1iZW5lIFRoZSBsaW5lYXIgZ3JhZGllbnQgbGl2ZXMgd2l0aGluIHRoZSBzcGFjZSBvZiB0aGUgcGFyZW50IG9iamVjdCdzIG1hdHJpeCBzcGFjZS5cbiAgICovXG4gIGZ1bmN0aW9uIExpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyLCBzdG9wcykge1xuXG4gICAgR3JhZGllbnQuY2FsbCh0aGlzLCBzdG9wcyk7XG5cbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ2xpbmVhci1ncmFkaWVudCc7XG5cbiAgICB2YXIgZmxhZ0VuZFBvaW50cyA9IExpbmVhckdyYWRpZW50LkZsYWdFbmRQb2ludHMuYmluZCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudCNsZWZ0XG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIFRoZSB4IGFuZCB5IHZhbHVlIGZvciB3aGVyZSB0aGUgZmlyc3QgZW5kIHBvaW50IGlzIHBsYWNlZCBvbiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIHRoaXMubGVmdCA9IG5ldyBWZWN0b3IoKS5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIGZsYWdFbmRQb2ludHMpO1xuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudCNyaWdodFxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlZlY3Rvcn0gLSBUaGUgeCBhbmQgeSB2YWx1ZSBmb3Igd2hlcmUgdGhlIHNlY29uZCBlbmQgcG9pbnQgaXMgcGxhY2VkIG9uIHRoZSBjYW52YXMuXG4gICAgICovXG4gICAgdGhpcy5yaWdodCA9IG5ldyBWZWN0b3IoKS5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIGZsYWdFbmRQb2ludHMpO1xuXG4gICAgaWYgKHR5cGVvZiB4MSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGVmdC54ID0geDE7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeTEgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmxlZnQueSA9IHkxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHgyID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5yaWdodC54ID0geDI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeTIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnJpZ2h0LnkgPSB5MjtcbiAgICB9XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKExpbmVhckdyYWRpZW50LCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQuU3RvcFxuICAgICAqIEBzZWUge0BsaW5rIFR3by5TdG9wfVxuICAgICAqL1xuICAgIFN0b3A6IFN0b3AsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5MaW5lYXJHcmFkaWVudH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uTGluZWFyR3JhZGllbnR9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIEdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudC5GbGFnRW5kUG9pbnRzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IGVuZCBwb2ludHMgaGF2ZSBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50fS5cbiAgICAgKi9cbiAgICBGbGFnRW5kUG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdFbmRQb2ludHMgPSB0cnVlO1xuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChMaW5lYXJHcmFkaWVudC5wcm90b3R5cGUsIEdyYWRpZW50LnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50I19mbGFnRW5kUG9pbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkxpbmVhckdyYWRpZW50I2xlZnR9IG9yIHtAbGluayBUd28uTGluZWFyR3JhZGllbnQjcmlnaHR9IGNoYW5nZWQgYW5kIG5lZWRzIHRvIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBfZmxhZ0VuZFBvaW50czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uTGluZWFyR3JhZGllbnQjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5HcmFkaWVudH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uTGluZWFyR3JhZGllbnR9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcy5tYXAoZnVuY3Rpb24oc3RvcCkge1xuICAgICAgICByZXR1cm4gc3RvcC5jbG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBMaW5lYXJHcmFkaWVudCh0aGlzLmxlZnQuX3gsIHRoaXMubGVmdC5feSxcbiAgICAgICAgdGhpcy5yaWdodC5feCwgdGhpcy5yaWdodC5feSwgc3RvcHMpO1xuXG4gICAgICBfLmVhY2goR3JhZGllbnQuUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudCN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IEdyYWRpZW50LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXN1bHQubGVmdCA9IHRoaXMubGVmdC50b09iamVjdCgpO1xuICAgICAgcmVzdWx0LnJpZ2h0ID0gdGhpcy5yaWdodC50b09iamVjdCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5MaW5lYXJHcmFkaWVudCNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnRW5kUG9pbnRzIHx8IHRoaXMuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkxpbmVhckdyYWRpZW50I2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ0VuZFBvaW50cyA9IGZhbHNlO1xuXG4gICAgICBHcmFkaWVudC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIExpbmVhckdyYWRpZW50Lk1ha2VPYnNlcnZhYmxlKExpbmVhckdyYWRpZW50LnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudFxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLkdyYWRpZW50XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeD0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBvcmlnaW4gb2YgdGhlIHJhZGlhbCBncmFkaWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIG9yaWdpbiBvZiB0aGUgcmFkaWFsIGdyYWRpZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3JhZGl1cz0wXSAtIFRoZSByYWRpdXMgb2YgdGhlIHJhZGlhbCBncmFkaWVudC5cbiAgICogQHBhcmFtIHtUd28uU3RvcFtdfSBbc3RvcHNdIC0gQSBsaXN0IG9mIHtAbGluayBUd28uU3RvcH1zIHRoYXQgY29udGFpbiB0aGUgZ3JhZGllbnQgZmlsbCBwYXR0ZXJuIGZvciB0aGUgZ3JhZGllbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZm9jYWxYPTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGZvY2FsIHBvaW50IG9uIHRoZSByYWRpYWwgZ3JhZGllbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZm9jYWxZPTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGZvY2FsIHBvaW50IG9uIHRoZSByYWRpYWwgZ3JhZGllbnQuXG4gICAqIEBub3RhLWJlbmUgVGhlIHJhZGlhbCBncmFkaWVudCBsaXZlcyB3aXRoaW4gdGhlIHNwYWNlIG9mIHRoZSBwYXJlbnQgb2JqZWN0J3MgbWF0cml4IHNwYWNlLlxuICAgKi9cbiAgZnVuY3Rpb24gUmFkaWFsR3JhZGllbnQoY3gsIGN5LCByLCBzdG9wcywgZngsIGZ5KSB7XG5cbiAgICBHcmFkaWVudC5jYWxsKHRoaXMsIHN0b3BzKTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLnR5cGUgPSAncmFkaWFsLWdyYWRpZW50JztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCNjZW50ZXJcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gVGhlIHggYW5kIHkgdmFsdWUgZm9yIHdoZXJlIHRoZSBvcmlnaW4gb2YgdGhlIHJhZGlhbCBncmFkaWVudCBpcy5cbiAgICAgKi9cbiAgICB0aGlzLmNlbnRlciA9IG5ldyBWZWN0b3IoKVxuICAgICAgLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9mbGFnQ2VudGVyID0gdHJ1ZTtcbiAgICAgIH0pLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5yYWRpdXMgPSB0eXBlb2YgciA9PT0gJ251bWJlcicgPyByIDogMjA7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjZm9jYWxcbiAgICAgKiBAcHJvcGVydHkge1R3by5WZWN0b3J9IC0gVGhlIHggYW5kIHkgdmFsdWUgZm9yIHdoZXJlIHRoZSBmb2NhbCBwb2ludCBvZiB0aGUgcmFkaWFsIGdyYWRpZW50IGlzLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBlZmZlY3RzIHRoZSBzcHJheSBvciBzcHJlYWQgb2YgdGhlIHJhZGlhbCBncmFkaWVudC5cbiAgICAgKi9cbiAgICB0aGlzLmZvY2FsID0gbmV3IFZlY3RvcigpXG4gICAgICAuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2ZsYWdGb2NhbCA9IHRydWU7XG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgIGlmICh0eXBlb2YgY3ggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNlbnRlci54ID0gY3g7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY3kgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmNlbnRlci55ID0gY3k7XG4gICAgfVxuXG4gICAgdGhpcy5mb2NhbC5jb3B5KHRoaXMuY2VudGVyKTtcblxuICAgIGlmICh0eXBlb2YgZnggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmZvY2FsLnggPSBmeDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmeSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuZm9jYWwueSA9IGZ5O1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoUmFkaWFsR3JhZGllbnQsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudC5TdG9wXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlN0b3B9XG4gICAgICovXG4gICAgU3RvcDogU3RvcCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudC5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50fS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbXG4gICAgICAncmFkaXVzJ1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5SYWRpYWxHcmFkaWVudH0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uUmFkaWFsR3JhZGllbnR9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgR3JhZGllbnQuTWFrZU9ic2VydmFibGUob2JqZWN0KTtcblxuICAgICAgXy5lYWNoKFJhZGlhbEdyYWRpZW50LlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqZWN0KTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChSYWRpYWxHcmFkaWVudC5wcm90b3R5cGUsIEdyYWRpZW50LnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IFJhZGlhbEdyYWRpZW50LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50I19mbGFnUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50I3JhZGl1c30gY2hhbmdlZCBhbmQgbmVlZHMgdG8gdXBkYXRlLlxuICAgICAqL1xuICAgIF9mbGFnUmFkaXVzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjX2ZsYWdDZW50ZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUmFkaWFsR3JhZGllbnQjY2VudGVyfSBjaGFuZ2VkIGFuZCBuZWVkcyB0byB1cGRhdGUuXG4gICAgICovXG4gICAgX2ZsYWdDZW50ZXI6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCNfZmxhZ0ZvY2FsXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJhZGlhbEdyYWRpZW50I2ZvY2FsfSBjaGFuZ2VkIGFuZCBuZWVkcyB0byB1cGRhdGUuXG4gICAgICovXG4gICAgX2ZsYWdGb2NhbDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmFkaWFsR3JhZGllbnQjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5HcmFkaWVudH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUmFkaWFsR3JhZGllbnR9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcy5tYXAoZnVuY3Rpb24oc3RvcCkge1xuICAgICAgICByZXR1cm4gc3RvcC5jbG9uZSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBSYWRpYWxHcmFkaWVudCh0aGlzLmNlbnRlci5feCwgdGhpcy5jZW50ZXIuX3ksXG4gICAgICAgICAgdGhpcy5fcmFkaXVzLCBzdG9wcywgdGhpcy5mb2NhbC5feCwgdGhpcy5mb2NhbC5feSk7XG5cbiAgICAgIF8uZWFjaChHcmFkaWVudC5Qcm9wZXJ0aWVzLmNvbmNhdChSYWRpYWxHcmFkaWVudC5Qcm9wZXJ0aWVzKSwgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlc3VsdCA9IEdyYWRpZW50LnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICBfLmVhY2goUmFkaWFsR3JhZGllbnQuUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJlc3VsdC5jZW50ZXIgPSB0aGlzLmNlbnRlci50b09iamVjdCgpO1xuICAgICAgcmVzdWx0LmZvY2FsID0gdGhpcy5mb2NhbC50b09iamVjdCgpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SYWRpYWxHcmFkaWVudCNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnUmFkaXVzIHx8IHRoaXMuX2ZsYXRDZW50ZXIgfHwgdGhpcy5fZmxhZ0ZvY2FsXG4gICAgICAgIHx8IHRoaXMuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJhZGlhbEdyYWRpZW50I2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1JhZGl1cyA9IHRoaXMuX2ZsYWdDZW50ZXIgPSB0aGlzLl9mbGFnRm9jYWwgPSBmYWxzZTtcblxuICAgICAgR3JhZGllbnQucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBSYWRpYWxHcmFkaWVudC5NYWtlT2JzZXJ2YWJsZShSYWRpYWxHcmFkaWVudC5wcm90b3R5cGUpO1xuXG4gIHZhciBhbmNob3I7XG4gIHZhciByZWdleCQxID0ge1xuICAgIHZpZGVvOiAvXFwuKG1wNHx3ZWJtfG9nZykkL2ksXG4gICAgaW1hZ2U6IC9cXC4oanBlP2d8cG5nfGdpZnx0aWZmfHdlYnApJC9pLFxuICAgIGVmZmVjdDogL3RleHR1cmV8Z3JhZGllbnQvaVxuICB9O1xuXG4gIGlmIChyb290JDEuZG9jdW1lbnQpIHtcbiAgICBhbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIH1cblxuICAvKipcbiAgICogQG5hbWUgVHdvLlRleHR1cmVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5TaGFwZVxuICAgKiBAcGFyYW0ge1N0cmluZ3xIVE1MSW1hZ2VFbGVtZW50fSBbc3JjXSAtIFRoZSBVUkwgcGF0aCB0byBhbiBpbWFnZSBmaWxlIG9yIGFuIGA8aW1nIC8+YCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gb25jZSB0aGUgaW1hZ2UgaGFzIGJlZW4gbG9hZGVkLlxuICAgKiBAZGVzY3JpcHRpb24gRnVuZGFtZW50YWwgdG8gd29yayB3aXRoIGJpdG1hcCBkYXRhLCBhLmsuYS4gcHJlZ2VuZXJhdGVkIGltYWdlcnksIGluIFR3by5qcy4gU3VwcG9ydGVkIGZvcm1hdHMgaW5jbHVkZSBqcGcsIHBuZywgZ2lmLCBhbmQgdGlmZi4gU2VlIHtAbGluayBUd28uVGV4dHVyZS5SZWd1bGFyRXhwcmVzc2lvbnN9IGZvciBhIGZ1bGwgbGlzdCBvZiBzdXBwb3J0ZWQgZm9ybWF0cy5cbiAgICovXG4gIGZ1bmN0aW9uIFRleHR1cmUoc3JjLCBjYWxsYmFjaykge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjcmVuZGVyZXJcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gT2JqZWN0IGFjY2VzcyB0byBzdG9yZSByZWxldmFudCByZW5kZXJlciBzcGVjaWZpYyB2YXJpYWJsZXMuIFdhcm5pbmc6IG1hbmlwdWxhdGluZyB0aGlzIG9iamVjdCBjYW4gY3JlYXRlIHVuaW50ZW5kZWQgY29uc2VxdWVuY2VzLlxuICAgICAqIEBub3RhLWJlbmUgV2l0aCB0aGUge0BsaW5rIFR3by5TdmdSZW5kZXJlcn0geW91IGNhbiBhY2Nlc3MgdGhlIHVuZGVybHlpbmcgU1ZHIGVsZW1lbnQgY3JlYXRlZCB2aWEgYHNoYXBlLnJlbmRlcmVyLmVsZW1gLlxuICAgICAqL1xuICAgIHRoaXMucmVuZGVyZXIgPSB7fTtcbiAgICB0aGlzLl9yZW5kZXJlci50eXBlID0gJ3RleHR1cmUnO1xuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdPZmZzZXQgPSBUZXh0dXJlLkZsYWdPZmZzZXQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnU2NhbGUgPSBUZXh0dXJlLkZsYWdTY2FsZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5pZCA9IENvbnN0YW50cy5JZGVudGlmaWVyICsgQ29uc3RhbnRzLnVuaXF1ZUlkKCk7XG4gICAgdGhpcy5jbGFzc0xpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI2xvYWRlZFxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBTaG9ydGhhbmQgdmFsdWUgdG8gZGV0ZXJtaW5lIGlmIGltYWdlIGhhcyBiZWVuIGxvYWRlZCBpbnRvIHRoZSB0ZXh0dXJlLlxuICAgICAqL1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNyZXBlYXRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBDU1Mgc3R5bGUgZGVjbGFyYXRpb24gdG8gdGlsZSB7QGxpbmsgVHdvLlBhdGh9LiBWYWxpZCB2YWx1ZXMgaW5jbHVkZTogYCduby1yZXBlYXQnYCwgYCdyZXBlYXQnYCwgYCdyZXBlYXQteCdgLCBgJ3JlcGVhdC15J2AuXG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSLzJkY29udGV4dC8jZG9tLWNvbnRleHQtMmQtY3JlYXRlcGF0dGVybn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGVhdCA9ICduby1yZXBlYXQnO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjb2Zmc2V0XG4gICAgICogQHByb3BlcnR5IHtUd28uVmVjdG9yfSAtIEEgdHdvLWNvbXBvbmVudCB2ZWN0b3IgZGVzY3JpYmluZyBhbnkgcGl4ZWwgb2Zmc2V0IG9mIHRoZSB0ZXh0dXJlIHdoZW4gYXBwbGllZCB0byBhIHtAbGluayBUd28uUGF0aH0uXG4gICAgICovXG4gICAgdGhpcy5vZmZzZXQgPSBuZXcgVmVjdG9yKCk7XG5cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgbG9hZGVkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVuYmluZChFdmVudHMuVHlwZXMubG9hZCwgbG9hZGVkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmJpbmQoRXZlbnRzLlR5cGVzLmxvYWQsIGxvYWRlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjc3JjXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gVGhlIFVSTCBwYXRoIHRvIHRoZSBpbWFnZSBkYXRhLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBwcm9wZXJ0eSBpcyB1bHRpbWF0ZWx5IHNlcmlhbGl6ZWQgaW4gYSB7QGxpbmsgVHdvLlJlZ2lzdHJ5fSB0byBjYWNoZSByZXRyaWV2YWwuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLnNyYyA9IHNyYztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgZWxlbVN0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzcmMpO1xuICAgICAgaWYgKFxuICAgICAgICBlbGVtU3RyaW5nID09PSAnW29iamVjdCBIVE1MSW1hZ2VFbGVtZW50XScgfHxcbiAgICAgICAgZWxlbVN0cmluZyA9PT0gJ1tvYmplY3QgSFRNTENhbnZhc0VsZW1lbnRdJyB8fFxuICAgICAgICBlbGVtU3RyaW5nID09PSAnW29iamVjdCBIVE1MVmlkZW9FbGVtZW50XScgfHxcbiAgICAgICAgZWxlbVN0cmluZyA9PT0gJ1tvYmplY3QgSW1hZ2VdJ1xuICAgICAgKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNpbWFnZVxuICAgICAgICAgKiBAcHJvcGVydHkge0VsZW1lbnR9IC0gVGhlIGNvcnJlc3BvbmRpbmcgRE9NIEVsZW1lbnQgb2YgdGhlIHRleHR1cmUuIENhbiBiZSBhIGA8aW1nIC8+YCwgYDxjYW52YXMgLz5gLCBvciBgPHZpZGVvIC8+YCBlbGVtZW50LiBTZWUge0BsaW5rIFR3by5UZXh0dXJlLlJlZ3VsYXJFeHByZXNzaW9uc30gZm9yIGEgZnVsbCBsaXN0IG9mIHN1cHBvcnRlZCBlbGVtZW50cy5cbiAgICAgICAgICogQG5vdGEtYmVuZSBJbiBoZWFkbGVzcyBlbnZpcm9ubWVudHMgdGhpcyBpcyBhIGBDYW52YXMuSW1hZ2VgIG9iamVjdC4gU2VlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9ub2RlLWNhbnZhc30gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaGVhZGxlc3MgaW1hZ2Ugb2JqZWN0cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBzcmM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFRleHR1cmUsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uVGV4dHVyZX0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogW1xuICAgICAgJ2lkJyxcbiAgICAgICdzcmMnLFxuICAgICAgJ2xvYWRlZCcsXG4gICAgICAncmVwZWF0J1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5SZWd1bGFyRXhwcmVzc2lvbnNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBBIG1hcCBvZiBjb21wYXRpYmxlIERPTSBFbGVtZW50cyBjYXRlZ29yaXplZCBieSBtZWRpYSBmb3JtYXQuXG4gICAgICovXG4gICAgUmVndWxhckV4cHJlc3Npb25zOiByZWdleCQxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuSW1hZ2VSZWdpc3RyeVxuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlJlZ2lzdHJ5fSAtIEEgY2Fub25pY2FsIGxpc3Rpbmcgb2YgaW1hZ2UgZGF0YSB1c2VkIGluIGEgc2luZ2xlIHNlc3Npb24gb2YgVHdvLmpzLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBvYmplY3QgaXMgdXNlZCB0byBjYWNoZSBpbWFnZSBkYXRhIGJldHdlZW4gZGlmZmVyZW50IHRleHR1cmVzLlxuICAgICAqL1xuICAgIEltYWdlUmVnaXN0cnk6IG5ldyBSZWdpc3RyeSgpLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuZ2V0QWJzb2x1dGVVUkxcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIFNlcmlhbGl6ZXMgYSBVUkwgYXMgYW4gYWJzb2x1dGUgcGF0aCBmb3IgY2Fub25pY2FsIGF0dHJpYnV0aW9uIGluIHtAbGluayBUd28uSW1hZ2VSZWdpc3RyeX0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIFRoZSBzZXJpYWxpemVkIGFic29sdXRlIHBhdGguXG4gICAgICovXG4gICAgZ2V0QWJzb2x1dGVVUkw6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIGlmICghYW5jaG9yKSB7XG4gICAgICAgIC8vIFRPRE86IEZpeCBmb3IgaGVhZGxlc3MgZW52aXJvbm1lbnRzXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfVxuICAgICAgYW5jaG9yLmhyZWYgPSBwYXRoO1xuICAgICAgcmV0dXJuIGFuY2hvci5ocmVmO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5sb2FkSGVhZGxlc3NCdWZmZXJcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIExvYWRzIGFuIGltYWdlIGFzIGEgYnVmZmVyIGluIGhlYWRsZXNzIGVudmlyb25tZW50cy5cbiAgICAgKiBAcGFyYW0ge1R3by5UZXh0dXJlfSB0ZXh0dXJlIC0gVGhlIHtAbGluayBUd28uVGV4dHVyZX0gdG8gYmUgbG9hZGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGxvYWRlZCAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSB0cmlnZ2VyZWQgb25jZSB0aGUgaW1hZ2UgaXMgbG9hZGVkLlxuICAgICAqIEBub3RhLWJlbmUgLSBUaGlzIGZ1bmN0aW9uIHVzZXMgbm9kZSdzIGBmcy5yZWFkRmlsZVN5bmNgIHRvIHNwb29mIHRoZSBgPGltZyAvPmAgbG9hZGluZyBwcm9jZXNzIGluIHRoZSBicm93c2VyLlxuICAgICAqL1xuICAgIGxvYWRIZWFkbGVzc0J1ZmZlcjogZnVuY3Rpb24odGV4dHVyZSwgbG9hZGVkKSB7XG5cbiAgICAgIHRleHR1cmUuaW1hZ2Uub25sb2FkID0gbG9hZGVkO1xuICAgICAgdGV4dHVyZS5pbWFnZS5zcmMgPSB0ZXh0dXJlLnNyYztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5nZXRUYWdcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIFJldHJpZXZlcyB0aGUgdGFnIG5hbWUgb2YgYW4gaW1hZ2UsIHZpZGVvLCBvciBjYW52YXMgbm9kZS5cbiAgICAgKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IC0gVGhlIGltYWdlIHRvIGluZmVyIHRoZSB0YWcgbmFtZSBmcm9tLlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gUmV0dXJucyB0aGUgdGFnIG5hbWUgb2YgYW4gaW1hZ2UsIHZpZGVvLCBvciBjYW52YXMgbm9kZS5cbiAgICAgKi9cbiAgICBnZXRUYWc6IGZ1bmN0aW9uKGltYWdlKSB7XG4gICAgICByZXR1cm4gKGltYWdlICYmIGltYWdlLm5vZGVOYW1lICYmIGltYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIC8vIEhlYWRsZXNzIGVudmlyb25tZW50c1xuICAgICAgICB8fCAnaW1nJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUuZ2V0SW1hZ2VcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIHNldCB7QGxpbmsgVHdvLlRleHR1cmUjaW1hZ2V9IHByb3BlcnRpZXMgd2l0aCBjYW5vbmluY2FsIHZlcnNpb25zIHNldCBpbiB7QGxpbmsgVHdvLlRleHR1cmUuSW1hZ2VSZWdpc3RyeX0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNyYyAtIFRoZSBVUkwgcGF0aCBvZiB0aGUgaW1hZ2UuXG4gICAgICogQHJldHVybnMge0hUTUxJbWFnZUVsZW1lbnR9IC0gUmV0dXJucyBlaXRoZXIgYSBjYWNoZWQgdmVyc2lvbiBvZiB0aGUgaW1hZ2Ugb3IgYSBuZXcgb25lIHRoYXQgaXMgcmVnaXN0ZXJlZCBpbiB7QGxpbmsgVHdvLlRleHR1cmUuSW1hZ2VSZWdpc3RyeX0uXG4gICAgICovXG4gICAgZ2V0SW1hZ2U6IGZ1bmN0aW9uKHNyYykge1xuXG4gICAgICB2YXIgYWJzb2x1dGVTcmMgPSBUZXh0dXJlLmdldEFic29sdXRlVVJMKHNyYyk7XG5cbiAgICAgIGlmIChUZXh0dXJlLkltYWdlUmVnaXN0cnkuY29udGFpbnMoYWJzb2x1dGVTcmMpKSB7XG4gICAgICAgIHJldHVybiBUZXh0dXJlLkltYWdlUmVnaXN0cnkuZ2V0KGFic29sdXRlU3JjKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGltYWdlO1xuXG4gICAgICBpZiAoQ2FudmFzU2hpbS5JbWFnZSkge1xuXG4gICAgICAgIC8vIFRPRE86IEZpeCBmb3IgaGVhZGxlc3MgZW52aXJvbm1lbnRzXG4gICAgICAgIGltYWdlID0gbmV3IENhbnZhc1NoaW0uSW1hZ2UoKTtcbiAgICAgICAgUmVuZGVyZXIkMi5VdGlscy5zaGltKGltYWdlLCAnaW1nJyk7XG5cbiAgICAgIH0gZWxzZSBpZiAocm9vdCQxLmRvY3VtZW50KSB7XG5cbiAgICAgICAgaWYgKHJlZ2V4JDEudmlkZW8udGVzdChhYnNvbHV0ZVNyYykpIHtcbiAgICAgICAgICBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGNvbnNvbGUud2FybignVHdvLmpzOiBubyBwcm90b3R5cGljYWwgaW1hZ2UgZGVmaW5lZCBmb3IgVHdvLlRleHR1cmUnKTtcblxuICAgICAgfVxuXG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdhbm9ueW1vdXMnO1xuXG4gICAgICByZXR1cm4gaW1hZ2U7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlZ2lzdGVyXG4gICAgICogQGludGVyZmFjZVxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRvIHJlZ2lzdGVyIGRpZmZlcmVudCB0eXBlcyBvZiB0ZXh0dXJlcy4gVXNlZCBpbnRlcm5hbGx5IGJ5IGEge0BsaW5rIFR3by5UZXh0dXJlfS5cbiAgICAgKi9cbiAgICBSZWdpc3Rlcjoge1xuICAgICAgY2FudmFzOiBmdW5jdGlvbih0ZXh0dXJlLCBjYWxsYmFjaykge1xuICAgICAgICB0ZXh0dXJlLl9zcmMgPSAnIycgKyB0ZXh0dXJlLmlkO1xuICAgICAgICBUZXh0dXJlLkltYWdlUmVnaXN0cnkuYWRkKHRleHR1cmUuc3JjLCB0ZXh0dXJlLmltYWdlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbWc6IGZ1bmN0aW9uKHRleHR1cmUsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgdmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcblxuICAgICAgICB2YXIgbG9hZGVkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmICghQ2FudmFzU2hpbS5pc0hlYWRsZXNzICYmIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgdHlwZW9mIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkZWQsIGZhbHNlKTtcbiAgICAgICAgICAgIGltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoIUNhbnZhc1NoaW0uaXNIZWFkbGVzcyAmJiB0eXBlb2YgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRlZCwgZmFsc2UpO1xuICAgICAgICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvciwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgVHdvRXJyb3IoJ3VuYWJsZSB0byBsb2FkICcgKyB0ZXh0dXJlLnNyYyk7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZS53aWR0aCA9PT0gJ251bWJlcicgJiYgaW1hZ2Uud2lkdGggPiAwXG4gICAgICAgICAgJiYgdHlwZW9mIGltYWdlLmhlaWdodCA9PT0gJ251bWJlcicgJiYgaW1hZ2UuaGVpZ2h0ID4gMCkge1xuICAgICAgICAgICAgbG9hZGVkKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIUNhbnZhc1NoaW0uaXNIZWFkbGVzcyAmJiB0eXBlb2YgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsb2FkZWQsIGZhbHNlKTtcbiAgICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0dXJlLl9zcmMgPSBUZXh0dXJlLmdldEFic29sdXRlVVJMKHRleHR1cmUuX3NyYyk7XG5cbiAgICAgICAgaWYgKCFDYW52YXNTaGltLmlzSGVhZGxlc3MgJiYgaW1hZ2UgJiYgaW1hZ2UuZ2V0QXR0cmlidXRlKCd0d28tc3JjJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIUNhbnZhc1NoaW0uaXNIZWFkbGVzcykge1xuICAgICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZSgndHdvLXNyYycsIHRleHR1cmUuc3JjKTtcbiAgICAgICAgfVxuXG4gICAgICAgIFRleHR1cmUuSW1hZ2VSZWdpc3RyeS5hZGQodGV4dHVyZS5zcmMsIGltYWdlKTtcblxuICAgICAgICBpZiAoQ2FudmFzU2hpbS5pc0hlYWRsZXNzKSB7XG5cbiAgICAgICAgICBUZXh0dXJlLmxvYWRIZWFkbGVzc0J1ZmZlcih0ZXh0dXJlLCBsb2FkZWQpO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLnNyYyA9IHRleHR1cmUuc3JjO1xuXG4gICAgICAgIH1cblxuICAgICAgfSxcbiAgICAgIHZpZGVvOiBmdW5jdGlvbih0ZXh0dXJlLCBjYWxsYmFjaykge1xuXG4gICAgICAgIGlmIChDYW52YXNTaGltLmlzSGVhZGxlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHdvRXJyb3IoJ3ZpZGVvIHRleHR1cmVzIGFyZSBub3QgaW1wbGVtZW50ZWQgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvYWRlZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgbG9hZGVkLCBmYWxzZSk7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yLCBmYWxzZSk7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS53aWR0aCA9IHRleHR1cmUuaW1hZ2UudmlkZW9XaWR0aDtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleHR1cmUuaW1hZ2UudmlkZW9IZWlnaHQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBlcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJywgbG9hZGVkLCBmYWxzZSk7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yLCBmYWxzZSk7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3b0Vycm9yKCd1bmFibGUgdG8gbG9hZCAnICsgdGV4dHVyZS5zcmMpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRleHR1cmUuX3NyYyA9IFRleHR1cmUuZ2V0QWJzb2x1dGVVUkwodGV4dHVyZS5fc3JjKTtcblxuICAgICAgICBpZiAoIXRleHR1cmUuaW1hZ2UuZ2V0QXR0cmlidXRlKCd0d28tc3JjJykpIHtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLnNldEF0dHJpYnV0ZSgndHdvLXNyYycsIHRleHR1cmUuc3JjKTtcbiAgICAgICAgICBUZXh0dXJlLkltYWdlUmVnaXN0cnkuYWRkKHRleHR1cmUuc3JjLCB0ZXh0dXJlLmltYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0ZXh0dXJlLmltYWdlLnJlYWR5U3RhdGUgPj0gNCkge1xuICAgICAgICAgIGxvYWRlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLCBsb2FkZWQsIGZhbHNlKTtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3IsIGZhbHNlKTtcbiAgICAgICAgICB0ZXh0dXJlLmltYWdlLnNyYyA9IHRleHR1cmUuc3JjO1xuICAgICAgICAgIHRleHR1cmUuaW1hZ2UubG9hZCgpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUubG9hZFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLlRleHR1cmV9IHRleHR1cmUgLSBUaGUgdGV4dHVyZSB0byBsb2FkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIHRoZSB0ZXh0dXJlIGlzIGxvYWRlZC5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbih0ZXh0dXJlLCBjYWxsYmFjaykge1xuXG4gICAgICB2YXIgaW1hZ2UgPSB0ZXh0dXJlLmltYWdlO1xuICAgICAgdmFyIHRhZyA9IFRleHR1cmUuZ2V0VGFnKGltYWdlKTtcblxuICAgICAgaWYgKHRleHR1cmUuX2ZsYWdJbWFnZSkge1xuICAgICAgICBpZiAoL2NhbnZhcy9pLnRlc3QodGFnKSkge1xuICAgICAgICAgIFRleHR1cmUuUmVnaXN0ZXIuY2FudmFzKHRleHR1cmUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0dXJlLl9zcmMgPSAoIUNhbnZhc1NoaW0uaXNIZWFkbGVzcyAmJiBpbWFnZS5nZXRBdHRyaWJ1dGUoJ3R3by1zcmMnKSkgfHwgaW1hZ2Uuc3JjO1xuICAgICAgICAgIFRleHR1cmUuUmVnaXN0ZXJbdGFnXSh0ZXh0dXJlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRleHR1cmUuX2ZsYWdTcmMpIHtcbiAgICAgICAgaWYgKCFpbWFnZSkge1xuICAgICAgICAgIGltYWdlID0gVGV4dHVyZS5nZXRJbWFnZSh0ZXh0dXJlLnNyYyk7XG4gICAgICAgICAgdGV4dHVyZS5pbWFnZSA9IGltYWdlO1xuICAgICAgICB9XG4gICAgICAgIHRhZyA9IFRleHR1cmUuZ2V0VGFnKGltYWdlKTtcbiAgICAgICAgVGV4dHVyZS5SZWdpc3Rlclt0YWddKHRleHR1cmUsIGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5GbGFnT2Zmc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IGBvZmZzZXRgIGhhcyBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLlRleHR1cmV9LlxuICAgICAqL1xuICAgIEZsYWdPZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ09mZnNldCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlLkZsYWdTY2FsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyBgc2NhbGVgIGhhcyBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLlRleHR1cmV9LlxuICAgICAqL1xuICAgIEZsYWdTY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9mbGFnU2NhbGUgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZS5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlRleHR1cmV9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIG9yIGluaGVyaXQgdGhlIHtAbGluayBUd28uVGV4dHVyZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICBfLmVhY2goVGV4dHVyZS5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iamVjdCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdpbWFnZScsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oaW1hZ2UpIHtcblxuICAgICAgICAgIHZhciB0YWcgPSBUZXh0dXJlLmdldFRhZyhpbWFnZSk7XG4gICAgICAgICAgdmFyIGluZGV4O1xuXG4gICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NhbnZhcyc6XG4gICAgICAgICAgICAgIGluZGV4ID0gJyMnICsgaW1hZ2UuaWQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaW5kZXggPSBpbWFnZS5zcmM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFRleHR1cmUuSW1hZ2VSZWdpc3RyeS5jb250YWlucyhpbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlID0gVGV4dHVyZS5JbWFnZVJlZ2lzdHJ5LmdldChpbWFnZS5zcmMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2ZsYWdJbWFnZSA9IHRydWU7XG5cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ29mZnNldCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0O1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBpZiAodGhpcy5fb2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLl9vZmZzZXQudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdPZmZzZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9vZmZzZXQgPSB2O1xuICAgICAgICAgIHRoaXMuX29mZnNldC5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdPZmZzZXQpO1xuICAgICAgICAgIHRoaXMuX2ZsYWdPZmZzZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3NjYWxlJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3NjYWxlLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnU2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NjYWxlID0gdjtcblxuICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGUuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnU2NhbGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2ZsYWdTY2FsZSA9IHRydWU7XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdyZW5kZXJlcicsIHtcblxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyID0gb2JqO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFRleHR1cmUucHJvdG90eXBlLCBFdmVudHMsIFNoYXBlLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IFRleHR1cmUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfZmxhZ0lkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjaWR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnSWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2ZsYWdTcmNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dHVyZSNzcmN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU3JjOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnSW1hZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dHVyZSNpbWFnZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdJbWFnZTogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfZmxhZ1ZpZGVvXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjdmlkZW99IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnVmlkZW86IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2ZsYWdMb2FkZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dHVyZSNsb2FkZWR9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTG9hZGVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19mbGFnUmVwZWF0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHR1cmUjcmVwZWF0fSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1JlcGVhdDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfZmxhZ09mZnNldFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI29mZnNldH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdPZmZzZXQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2ZsYWdTY2FsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0dXJlI3NjYWxlfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1NjYWxlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19pZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHR1cmUjaWR9XG4gICAgICovXG4gICAgX2lkOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19zcmNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5UZXh0dXJlI3NyY31cbiAgICAgKi9cbiAgICBfc3JjOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI19pbWFnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHR1cmUjaW1hZ2V9XG4gICAgICovXG4gICAgX2ltYWdlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX2xvYWRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHR1cmUjbG9hZGVkfVxuICAgICAqL1xuICAgIF9sb2FkZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX3JlcGVhdFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlRleHR1cmUjcmVwZWF0fVxuICAgICAqL1xuICAgIF9yZXBlYXQ6ICduby1yZXBlYXQnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX3NjYWxlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uVGV4dHVyZSNzY2FsZX1cbiAgICAgKi9cbiAgICBfc2NhbGU6IDEsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dHVyZSNfb2Zmc2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uVGV4dHVyZSNvZmZzZXR9XG4gICAgICovXG4gICAgX29mZnNldDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge1R3by5UZXh0dXJlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5UZXh0dXJlfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgdGV4dHVyZS5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2xvbmUgPSBuZXcgVGV4dHVyZSh0aGlzLnNyYyk7XG4gICAgICBjbG9uZS5yZXBlYXQgPSB0aGlzLnJlcGVhdDtcbiAgICAgIGNsb25lLm9mZnNldC5jb3B5KHRoaXMub3JpZ2luKTtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgdGV4dHVyZS5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzcmM6IHRoaXMuc3JjLFxuICAgICAgICAvLyBpbWFnZTogdGhpcy5pbWFnZSxcbiAgICAgICAgcmVwZWF0OiB0aGlzLnJlcGVhdCxcbiAgICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpbi50b09iamVjdCgpLFxuICAgICAgICBzY2FsZTogdHlwZW9mIHRoaXMuc2NhbGUgPT09ICdudW1iZXInID8gdGhpcy5zY2FsZSA6IHRoaXMuc2NhbGUudG9PYmplY3QoKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHR1cmUjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ1NyYyB8fCB0aGlzLl9mbGFnSW1hZ2UpIHtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLmNoYW5nZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTcmMgfHwgdGhpcy5fZmxhZ0ltYWdlKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgICBUZXh0dXJlLmxvYWQodGhpcywgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAudHJpZ2dlcihFdmVudHMuVHlwZXMuY2hhbmdlKVxuICAgICAgICAgICAgICAudHJpZ2dlcihFdmVudHMuVHlwZXMubG9hZCk7XG4gICAgICAgICAgfSkuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2UucmVhZHlTdGF0ZSA+PSA0KSB7XG4gICAgICAgIHRoaXMuX2ZsYWdWaWRlbyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0dXJlI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1NyYyA9IHRoaXMuX2ZsYWdJbWFnZSA9IHRoaXMuX2ZsYWdMb2FkZWRcbiAgICAgICAgPSB0aGlzLl9mbGFnVmlkZW8gPSB0aGlzLl9mbGFnU2NhbGUgPSB0aGlzLl9mbGFnT2Zmc2V0ID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIFRleHR1cmUuTWFrZU9ic2VydmFibGUoVGV4dHVyZS5wcm90b3R5cGUpO1xuXG4gIC8vIENvbnN0YW50c1xuXG4gIHZhciBtaW4kMSA9IE1hdGgubWluLCBtYXgkMSA9IE1hdGgubWF4LFxuICAgIGNlaWwgPSBNYXRoLmNlaWwsIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlBhdGhcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5TaGFwZVxuICAgKiBAcGFyYW0ge1R3by5BbmNob3JbXX0gW3ZlcnRpY2VzXSAtIEEgbGlzdCBvZiB7QGxpbmsgVHdvLkFuY2hvcn1zIHRoYXQgcmVwcmVzZW50IHRoZSBvcmRlciBhbmQgY29vcmRpbmF0ZXMgdG8gY29uc3RydWN0IHRoZSByZW5kZXJlZCBzaGFwZS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbY2xvc2VkPWZhbHNlXSAtIERlc2NyaWJlcyB3aGV0aGVyIHRoZSBzaGFwZSBpcyBjbG9zZWQgb3Igb3Blbi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbY3VydmVkPWZhbHNlXSAtIERlc2NyaWJlcyB3aGV0aGVyIHRoZSBzaGFwZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZXMgYmV6aWVyIGhhbmRsZXMgZm9yIGVhY2ggdmVydGV4LlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYW51YWw9ZmFsc2VdIC0gRGVzY3JpYmVzIHdoZXRoZXIgdGhlIGRldmVsb3BlciBjb250cm9scyBob3cgdmVydGljZXMgYXJlIHBsb3R0ZWQgb3IgaWYgVHdvLmpzIGF1dG9tYXRpY2FsbHkgcGxvdHMgY29vcmRpbmF0ZXMgYmFzZWQgb24gY2xvc2VkIGFuZCBjdXJ2ZWQgYm9vbGVhbnMuXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIHRoZSBwcmltYXJ5IHByaW1pdGl2ZSBjbGFzcyBmb3IgY3JlYXRpbmcgYWxsIGRyYXdhYmxlIHNoYXBlcyBpbiBUd28uanMuIFVubGVzcyBzcGVjaWZpZWQgbWV0aG9kcyByZXR1cm4gdGhlaXIgaW5zdGFuY2Ugb2YgYFR3by5QYXRoYCBmb3IgdGhlIHB1cnBvc2Ugb2YgY2hhaW5pbmcuXG4gICAqL1xuICBmdW5jdGlvbiBQYXRoKHZlcnRpY2VzLCBjbG9zZWQsIGN1cnZlZCwgbWFudWFsKSB7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICdwYXRoJztcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMgPSBQYXRoLkZsYWdWZXJ0aWNlcy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JlbmRlcmVyLmJpbmRWZXJ0aWNlcyA9IFBhdGguQmluZFZlcnRpY2VzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIudW5iaW5kVmVydGljZXMgPSBQYXRoLlVuYmluZFZlcnRpY2VzLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCA9IFBhdGguRmxhZ0ZpbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnU3Ryb2tlID0gUGF0aC5GbGFnU3Ryb2tlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIudmVydGljZXMgPSBbXTtcbiAgICB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjbG9zZWRcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIGEgZmluYWwgbGluZSBpcyBkcmF3biBiZXR3ZWVuIHRoZSBmaW5hbCBwb2ludCBpbiB0aGUgYHZlcnRpY2VzYCBhcnJheSBhbmQgdGhlIGZpcnN0IHBvaW50LlxuICAgICAqL1xuICAgIHRoaXMuX2Nsb3NlZCA9ICEhY2xvc2VkO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjY3VydmVkXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIFdoZW4gdGhlIHBhdGggaXMgYGF1dG9tYXRpYyA9IHRydWVgIHRoaXMgYm9vbGVhbiBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGxpbmVzIGJldHdlZW4gdGhlIHBvaW50cyBhcmUgY3VydmVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICB0aGlzLl9jdXJ2ZWQgPSAhIWN1cnZlZDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2JlZ2lubmluZ1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIE51bWJlciBiZXR3ZWVuIHplcm8gYW5kIG9uZSB0byBzdGF0ZSB0aGUgYmVnaW5uaW5nIG9mIHdoZXJlIHRoZSBwYXRoIGlzIHJlbmRlcmVkLlxuICAgICAqIEBkZXNjcmlwdGlvbiB7QGxpbmsgVHdvLlBhdGgjYmVnaW5uaW5nfSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgdGhhdCByZXByZXNlbnRzIGF0IHdoYXQgcGVyY2VudGFnZSBpbnRvIHRoZSBwYXRoIHNob3VsZCB0aGUgcmVuZGVyZXIgc3RhcnQgZHJhd2luZy5cbiAgICAgKiBAbm90YS1iZW5lIFRoaXMgaXMgZ3JlYXQgZm9yIGFuaW1hdGluZyBpbiBhbmQgb3V0IHN0cm9rZWQgcGF0aHMgaW4gY29uanVuY3Rpb24gd2l0aCB7QGxpbmsgVHdvLlBhdGgjZW5kaW5nfS5cbiAgICAgKi9cbiAgICB0aGlzLmJlZ2lubmluZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNlbmRpbmdcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgYmV0d2VlbiB6ZXJvIGFuZCBvbmUgdG8gc3RhdGUgdGhlIGVuZGluZyBvZiB3aGVyZSB0aGUgcGF0aCBpcyByZW5kZXJlZC5cbiAgICAgKiBAZGVzY3JpcHRpb24ge0BsaW5rIFR3by5QYXRoI2VuZGluZ30gaXMgYSBwZXJjZW50YWdlIHZhbHVlIHRoYXQgcmVwcmVzZW50cyBhdCB3aGF0IHBlcmNlbnRhZ2UgaW50byB0aGUgcGF0aCBzaG91bGQgdGhlIHJlbmRlcmVyIHN0YXJ0IGRyYXdpbmcuXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIGlzIGdyZWF0IGZvciBhbmltYXRpbmcgaW4gYW5kIG91dCBzdHJva2VkIHBhdGhzIGluIGNvbmp1bmN0aW9uIHdpdGgge0BsaW5rIFR3by5QYXRoI2JlZ2lubmluZ30uXG4gICAgICovXG4gICAgdGhpcy5lbmRpbmcgPSAxO1xuXG4gICAgLy8gU3R5bGUgcHJvcGVydGllc1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZmlsbFxuICAgICAqIEBwcm9wZXJ0eSB7KFN0cmluZ3xUd28uR3JhZGllbnR8VHdvLlRleHR1cmUpfSAtIFRoZSB2YWx1ZSBvZiB3aGF0IHRoZSBwYXRoIHNob3VsZCBiZSBmaWxsZWQgaW4gd2l0aC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENTUydzIGNvbG9ycyBhcyBgU3RyaW5nYC5cbiAgICAgKi9cbiAgICB0aGlzLmZpbGwgPSAnI2ZmZic7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNzdHJva2VcbiAgICAgKiBAcHJvcGVydHkgeyhTdHJpbmd8VHdvLkdyYWRpZW50fFR3by5UZXh0dXJlKX0gLSBUaGUgdmFsdWUgb2Ygd2hhdCB0aGUgcGF0aCBzaG91bGQgYmUgb3V0bGluZWQgaW4gd2l0aC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENTUydzIGNvbG9ycyBhcyBgU3RyaW5nYC5cbiAgICAgKi9cbiAgICB0aGlzLnN0cm9rZSA9ICcjMDAwJztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2xpbmV3aWR0aFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSB0aGlja25lc3MgaW4gcGl4ZWxzIG9mIHRoZSBzdHJva2UuXG4gICAgICovXG4gICAgdGhpcy5saW5ld2lkdGggPSAxLjA7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNvcGFjaXR5XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIG9wYXF1ZW5lc3Mgb2YgdGhlIHBhdGguXG4gICAgICogQG5vdGEtYmVuZSBDYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIENTUyBDb2xvcnMgdGhhdCBoYXZlIGFuIGFscGhhIHZhbHVlLlxuICAgICAqL1xuICAgIHRoaXMub3BhY2l0eSA9IDEuMDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2NsYXNzTmFtZVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIEEgY2xhc3MgdG8gYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudCB0byBiZSBjb21wYXRpYmxlIHdpdGggQ1NTIHN0eWxpbmcuXG4gICAgICogQG5vdGEtYmVuZSBPbmx5IGF2YWlsYWJsZSBmb3IgdGhlIFNWRyByZW5kZXJlci5cbiAgICAgKi9cbiAgICB0aGlzLmNsYXNzTmFtZSA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjdmlzaWJsZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEaXNwbGF5IHRoZSBwYXRoIG9yIG5vdC5cbiAgICAgKiBAbm90YS1iZW5lIEZvciB7QGxpbmsgVHdvLkNhbnZhc1JlbmRlcmVyfSBhbmQge0BsaW5rIFR3by5XZWJHTFJlbmRlcmVyfSB3aGVuIHNldCB0byBmYWxzZSBhbGwgdXBkYXRpbmcgaXMgZGlzYWJsZWQgaW1wcm92aW5nIHBlcmZvcm1hbmNlIGRyYW1hdGljYWxseSB3aXRoIG1hbnkgb2JqZWN0cyBpbiB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2NhcFxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1N0cm9rZUxpbmVjYXBQcm9wZXJ0eX1cbiAgICAgKi9cbiAgICB0aGlzLmNhcCA9ICdidXR0JzsgICAgICAvLyBEZWZhdWx0IG9mIEFkb2JlIElsbHVzdHJhdG9yXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNqb2luXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9XG4gICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzExL3BhaW50aW5nLmh0bWwjU3Ryb2tlTGluZWpvaW5Qcm9wZXJ0eX1cbiAgICAgKi9cbiAgICB0aGlzLmpvaW4gPSAnbWl0ZXInOyAgICAvLyBEZWZhdWx0IG9mIEFkb2JlIElsbHVzdHJhdG9yXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNtaXRlclxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfVxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcxMS9wYWludGluZy5odG1sI1N0cm9rZU1pdGVybGltaXRQcm9wZXJ0eX1cbiAgICAgKi9cbiAgICB0aGlzLm1pdGVyID0gNDsgICAgICAgICAvLyBEZWZhdWx0IG9mIEFkb2JlIElsbHVzdHJhdG9yXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCN2ZXJ0aWNlc1xuICAgICAqIEBwcm9wZXJ0eSB7VHdvLkFuY2hvcltdfSAtIEFuIG9yZGVyZWQgbGlzdCBvZiBhbmNob3IgcG9pbnRzIGZvciByZW5kZXJpbmcgdGhlIHBhdGguXG4gICAgICogQGRlc2NyaXB0aW9uIEEgbGlzdCBvZiB7QGxpbmsgVHdvLkFuY2hvcn0gb2JqZWN0cyB0aGF0IGNvbnNpc3Qgb2Ygd2hhdCBmb3JtIHRoZSBwYXRoIHRha2VzLlxuICAgICAqIEBub3RhLWJlbmUgVGhlIGFycmF5IHdoZW4gbWFuaXB1bGF0aW5nIGlzIGFjdHVhbGx5IGEge0BsaW5rIFR3by5Db2xsZWN0aW9ufS5cbiAgICAgKi9cbiAgICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXM7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNhdXRvbWF0aWNcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCBUd28uanMgc2hvdWxkIGNhbGN1bGF0ZSBjdXJ2ZXMsIGxpbmVzLCBhbmQgY29tbWFuZHMgYXV0b21hdGljYWxseSBmb3IgeW91IG9yIHRvIGxldCB0aGUgZGV2ZWxvcGVyIG1hbmlwdWxhdGUgdGhlbSBmb3IgdGhlbXNlbHZlcy5cbiAgICAgKi9cbiAgICB0aGlzLmF1dG9tYXRpYyA9ICFtYW51YWw7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNkYXNoZXNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcltdfSAtIEFycmF5IG9mIG51bWJlcnMuIE9kZCBpbmRpY2VzIHJlcHJlc2VudCBkYXNoIGxlbmd0aC4gRXZlbiBpbmRpY2VzIHJlcHJlc2VudCBkYXNoIHNwYWNlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGxpc3Qgb2YgbnVtYmVycyB0aGF0IHJlcHJlc2VudCB0aGUgcmVwZWF0ZWQgZGFzaCBsZW5ndGggYW5kIGRhc2ggc3BhY2UgYXBwbGllZCB0byB0aGUgc3Ryb2tlIG9mIHRoZSB0ZXh0LlxuICAgICAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvc3Ryb2tlLWRhc2hhcnJheX0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gdGhlIFNWRyBzdHJva2UtZGFzaGFycmF5IGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICB0aGlzLmRhc2hlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZGFzaGVzI29mZnNldFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIEEgbnVtYmVyIGluIHBpeGVscyB0byBvZmZzZXQge0BsaW5rIFR3by5QYXRoI2Rhc2hlc30gZGlzcGxheS5cbiAgICAgKi9cbiAgICB0aGlzLmRhc2hlcy5vZmZzZXQgPSAwO1xuXG4gIH1cblxuICBfLmV4dGVuZChQYXRoLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlBhdGh9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFtcbiAgICAgICdmaWxsJyxcbiAgICAgICdzdHJva2UnLFxuICAgICAgJ2xpbmV3aWR0aCcsXG4gICAgICAnb3BhY2l0eScsXG4gICAgICAndmlzaWJsZScsXG4gICAgICAnY2FwJyxcbiAgICAgICdqb2luJyxcbiAgICAgICdtaXRlcicsXG5cbiAgICAgICdjbG9zZWQnLFxuICAgICAgJ2N1cnZlZCcsXG4gICAgICAnYXV0b21hdGljJyxcbiAgICAgICdiZWdpbm5pbmcnLFxuICAgICAgJ2VuZGluZydcbiAgICBdLFxuXG4gICAgVXRpbHM6IHtcbiAgICAgIGdldEN1cnZlTGVuZ3RoOiBnZXRDdXJ2ZUxlbmd0aFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5GbGFnVmVydGljZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgdmVydGljZXMgaGF2ZSBiZWVuIHVwZGF0ZWQgb24gYSB7QGxpbmsgVHdvLlBhdGh9LlxuICAgICAqL1xuICAgIEZsYWdWZXJ0aWNlczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xuICAgICAgdGhpcy5fZmxhZ0xlbmd0aCA9IHRydWU7XG4gICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQuX2ZsYWdMZW5ndGggPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5CaW5kVmVydGljZXNcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQge0BsaW5rIFR3by5QYXRofSBrbm93IHZlcnRpY2VzIGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgQmluZFZlcnRpY2VzOiBmdW5jdGlvbihpdGVtcykge1xuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBhIGxvdFxuICAgICAgLy8gd2hlbiBpbXBvcnRpbmcgYSBsYXJnZSBTVkdcbiAgICAgIHZhciBpID0gaXRlbXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpdGVtc1tpXS5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdWZXJ0aWNlcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdWZXJ0aWNlcygpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoLlVuYmluZFZlcnRpY2VzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHtAbGluayBUd28uUGF0aH0ga25vdyB2ZXJ0aWNlcyBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBVbmJpbmRWZXJ0aWNlczogZnVuY3Rpb24oaXRlbXMpIHtcblxuICAgICAgdmFyIGkgPSBpdGVtcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGl0ZW1zW2ldLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5GbGFnRmlsbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLlBhdGh9IGtub3cgdGhlIGZpbGwgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgRmxhZ0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ0ZpbGwgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5GbGFnRmlsbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLlBhdGh9IGtub3cgdGhlIHN0cm9rZSBoYXMgY2hhbmdlZC5cbiAgICAgKi9cbiAgICBGbGFnU3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdTdHJva2UgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aC5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLlBhdGh9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlBhdGh9IGNsYXNzIG9uIGEgY3VzdG9tIGNsYXNzLlxuICAgICAqL1xuICAgIE1ha2VPYnNlcnZhYmxlOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgU2hhcGUuTWFrZU9ic2VydmFibGUob2JqZWN0KTtcblxuICAgICAgLy8gT25seSB0aGUgNyBkZWZpbmVkIHByb3BlcnRpZXMgYXJlIGZsYWdnZWQgbGlrZSB0aGlzLiBUaGUgc3Vic2VxdWVudFxuICAgICAgLy8gcHJvcGVydGllcyBiZWhhdmUgZGlmZmVyZW50bHkgYW5kIG5lZWQgdG8gYmUgaGFuZCB3cml0dGVuLlxuICAgICAgXy5lYWNoKFBhdGguUHJvcGVydGllcy5zbGljZSgyLCA4KSwgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmplY3QpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnZmlsbCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdGaWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9maWxsID0gZjtcbiAgICAgICAgICB0aGlzLl9mbGFnRmlsbCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc3Ryb2tlJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBMaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZS51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc3Ryb2tlID0gZjtcbiAgICAgICAgICB0aGlzLl9mbGFnU3Ryb2tlID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFJhZGlhbEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnU3Ryb2tlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgVHdvLlBhdGgjbGVuZ3RoXG4gICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc3VtIG9mIGRpc3RhbmNlcyBiZXR3ZWVuIGFsbCB7QGxpbmsgVHdvLlBhdGgjdmVydGljZXN9LlxuICAgICAgICovXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnbGVuZ3RoJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9mbGFnTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVMZW5ndGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjbG9zZWQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fY2xvc2VkID0gISF2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdWZXJ0aWNlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY3VydmVkJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJ2ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2N1cnZlZCA9ICEhdjtcbiAgICAgICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2F1dG9tYXRpYycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYXV0b21hdGljO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBpZiAodiA9PT0gdGhpcy5fYXV0b21hdGljKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2F1dG9tYXRpYyA9ICEhdjtcbiAgICAgICAgICB2YXIgbWV0aG9kID0gdGhpcy5fYXV0b21hdGljID8gJ2lnbm9yZScgOiAnbGlzdGVuJztcbiAgICAgICAgICBfLmVhY2godGhpcy52ZXJ0aWNlcywgZnVuY3Rpb24odikge1xuICAgICAgICAgICAgdlttZXRob2RdKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnYmVnaW5uaW5nJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9iZWdpbm5pbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX2JlZ2lubmluZyA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ1ZlcnRpY2VzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdlbmRpbmcnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VuZGluZztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fZW5kaW5nID0gdjtcbiAgICAgICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ3ZlcnRpY2VzJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY29sbGVjdGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZlcnRpY2VzKSB7XG5cbiAgICAgICAgICB2YXIgYmluZFZlcnRpY2VzID0gdGhpcy5fcmVuZGVyZXIuYmluZFZlcnRpY2VzO1xuICAgICAgICAgIHZhciB1bmJpbmRWZXJ0aWNlcyA9IHRoaXMuX3JlbmRlcmVyLnVuYmluZFZlcnRpY2VzO1xuXG4gICAgICAgICAgLy8gUmVtb3ZlIHByZXZpb3VzIGxpc3RlbmVyc1xuICAgICAgICAgIGlmICh0aGlzLl9jb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uXG4gICAgICAgICAgICAgIC51bmJpbmQoRXZlbnRzLlR5cGVzLmluc2VydCwgYmluZFZlcnRpY2VzKVxuICAgICAgICAgICAgICAudW5iaW5kKEV2ZW50cy5UeXBlcy5yZW1vdmUsIHVuYmluZFZlcnRpY2VzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IENvbGxlY3Rpb24gd2l0aCBjb3B5IG9mIHZlcnRpY2VzXG4gICAgICAgICAgaWYgKHZlcnRpY2VzIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fY29sbGVjdGlvbiA9IHZlcnRpY2VzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uID0gbmV3IENvbGxlY3Rpb24odmVydGljZXMgfHwgW10pO1xuICAgICAgICAgIH1cblxuXG4gICAgICAgICAgLy8gTGlzdGVuIGZvciBDb2xsZWN0aW9uIGNoYW5nZXMgYW5kIGJpbmQgLyB1bmJpbmRcbiAgICAgICAgICB0aGlzLl9jb2xsZWN0aW9uXG4gICAgICAgICAgICAuYmluZChFdmVudHMuVHlwZXMuaW5zZXJ0LCBiaW5kVmVydGljZXMpXG4gICAgICAgICAgICAuYmluZChFdmVudHMuVHlwZXMucmVtb3ZlLCB1bmJpbmRWZXJ0aWNlcyk7XG5cbiAgICAgICAgICAvLyBCaW5kIEluaXRpYWwgVmVydGljZXNcbiAgICAgICAgICBiaW5kVmVydGljZXModGhpcy5fY29sbGVjdGlvbik7XG5cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgICAgLyoqXG4gICAgICAgKiBAbmFtZSBUd28uUGF0aCNtYXNrXG4gICAgICAgKiBAcHJvcGVydHkge1R3by5TaGFwZX0gLSBUaGUgc2hhcGUgd2hvc2UgYWxwaGEgcHJvcGVydHkgYmVjb21lcyBhIGNsaXBwaW5nIGFyZWEgZm9yIHRoZSBwYXRoLlxuICAgICAgICogQG5vdGEtYmVuZSBUaGlzIHByb3BlcnR5IGlzIGN1cnJlbnRseSBub3Qgd29ya2luZyBiZWN1YXNlIG9mIFNWRyBzcGVjIGlzc3VlcyBmb3VuZCBoZXJlIHtAbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzcwOTUxfS5cbiAgICAgICAqL1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ21hc2snLCB7XG5cbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIHRoaXMuX21hc2sgPSB2O1xuICAgICAgICAgIHRoaXMuX2ZsYWdNYXNrID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoIXYuY2xpcCkge1xuICAgICAgICAgICAgdi5jbGlwID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSk7XG5cbiAgICAgIC8qKlxuICAgICAgICogQG5hbWUgVHdvLlBhdGgjY2xpcFxuICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIFRlbGxzIFR3by5qcyByZW5kZXJlciBpZiB0aGlzIG9iamVjdCByZXByZXNlbnRzIGEgbWFzayBmb3IgYW5vdGhlciBvYmplY3QgKG9yIG5vdCkuXG4gICAgICAgKi9cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdjbGlwJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9jbGlwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9jbGlwID0gdjtcbiAgICAgICAgICB0aGlzLl9mbGFnQ2xpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnZGFzaGVzJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9kYXNoZXM7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICAgIGlmICh0eXBlb2Ygdi5vZmZzZXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2Lm9mZnNldCA9IHRoaXMuX2Rhc2hlcy5vZmZzZXQgfHwgMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fZGFzaGVzID0gdjtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoUGF0aC5wcm90b3R5cGUsIFNoYXBlLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IFBhdGgsXG5cbiAgICAvLyBGbGFnc1xuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmxhZ1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdWZXJ0aWNlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI3ZlcnRpY2VzfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnVmVydGljZXM6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ0xlbmd0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2xlbmd0aH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdMZW5ndGg6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ0ZpbGxcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNmaWxsfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0ZpbGw6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ1N0cm9rZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI3N0cm9rZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdTdHJva2U6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ0xpbmV3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2xpbmV3aWR0aH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdMaW5ld2lkdGg6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ09wYWNpdHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNvcGFjaXR5fSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ09wYWNpdHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ1Zpc2libGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCN2aXNpYmxlfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1Zpc2libGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ0NhcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI2NhcH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdDYXA6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ0pvaW5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNqb2lufSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0pvaW46IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ01pdGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjbWl0ZXJ9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTWl0ZXI6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmxhZ01hc2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUGF0aCNtYXNrfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ01hc2s6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2ZsYWdDbGlwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlBhdGgjY2xpcH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdDbGlwOiBmYWxzZSxcblxuICAgIC8vIFVuZGVybHlpbmcgUHJvcGVydGllc1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2xlbmd0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjbGVuZ3RofVxuICAgICAqL1xuICAgIF9sZW5ndGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZmlsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjZmlsbH1cbiAgICAgKi9cbiAgICBfZmlsbDogJyNmZmYnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX3N0cm9rZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjc3Ryb2tlfVxuICAgICAqL1xuICAgIF9zdHJva2U6ICcjMDAwJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19saW5ld2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2xpbmV3aWR0aH1cbiAgICAgKi9cbiAgICBfbGluZXdpZHRoOiAxLjAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfb3BhY2l0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjb3BhY2l0eX1cbiAgICAgKi9cbiAgICBfb3BhY2l0eTogMS4wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX3Zpc2libGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI3Zpc2libGV9XG4gICAgICovXG4gICAgX3Zpc2libGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfY2FwXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNjYXB9XG4gICAgICovXG4gICAgX2NhcDogJ3JvdW5kJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19qb2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNqb2lufVxuICAgICAqL1xuICAgIF9qb2luOiAncm91bmQnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX21pdGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNtaXRlcn1cbiAgICAgKi9cbiAgICBfbWl0ZXI6IDQsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfY2xvc2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNjbG9zZWR9XG4gICAgICovXG4gICAgX2Nsb3NlZDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19jdXJ2ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2N1cnZlZH1cbiAgICAgKi9cbiAgICBfY3VydmVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19hdXRvbWF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI2F1dG9tYXRpY31cbiAgICAgKi9cbiAgICBfYXV0b21hdGljOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX2JlZ2lubmluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjYmVnaW5uaW5nfVxuICAgICAqL1xuICAgIF9iZWdpbm5pbmc6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZW5kaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNlbmRpbmd9XG4gICAgICovXG4gICAgX2VuZGluZzogMS4wLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX21hc2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5QYXRoI21hc2t9XG4gICAgICovXG4gICAgX21hc2s6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfY2xpcFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlBhdGgjY2xpcH1cbiAgICAgKi9cbiAgICBfY2xpcDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfZGFzaGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUGF0aCNkYXNoZXN9XG4gICAgICovXG4gICAgX2Rhc2hlczogW10sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlBhdGh9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlBhdGh9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIGNsb25lID0gbmV3IFBhdGgoKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGNsb25lLnZlcnRpY2VzLnB1c2godGhpcy52ZXJ0aWNlc1tqXS5jbG9uZSgpKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBQYXRoLlByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGsgPSBQYXRoLlByb3BlcnRpZXNbaV07XG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcbiAgICAgIH1cblxuICAgICAgY2xvbmUuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XG5cbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICBjbG9uZS5za2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICBjbG9uZS5za2V3WSA9IHRoaXMuc2tld1k7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmUuX3VwZGF0ZSgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICB2ZXJ0aWNlczogdGhpcy52ZXJ0aWNlcy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiB2LnRvT2JqZWN0KCk7XG4gICAgICAgIH0pXG4gICAgICB9O1xuXG4gICAgICBfLmVhY2goUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmVzdWx0LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuXG4gICAgICByZXN1bHQudHJhbnNsYXRpb24gPSB0aGlzLnRyYW5zbGF0aW9uLnRvT2JqZWN0KCk7XG4gICAgICByZXN1bHQucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgcmVzdWx0LnNjYWxlID0gdGhpcy5zY2FsZSBpbnN0YW5jZW9mIFZlY3RvciA/IHRoaXMuc2NhbGUudG9PYmplY3QoKSA6IHRoaXMuc2NhbGU7XG4gICAgICByZXN1bHQuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgcmVzdWx0LnNrZXdZID0gdGhpcy5za2V3WTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICByZXN1bHQubWF0cml4ID0gdGhpcy5tYXRyaXgudG9PYmplY3QoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNub0ZpbGxcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvcnQgaGFuZCBtZXRob2QgdG8gc2V0IGZpbGwgdG8gYHRyYW5zcGFyZW50YC5cbiAgICAgKi9cbiAgICBub0ZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5maWxsID0gJ3RyYW5zcGFyZW50JztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNub1N0cm9rZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBTaG9ydCBoYW5kIG1ldGhvZCB0byBzZXQgc3Ryb2tlIHRvIGB0cmFuc3BhcmVudGAuXG4gICAgICovXG4gICAgbm9TdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zdHJva2UgPSB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjY29ybmVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWVudCB0aGUgdmVydGljZXMgb2YgdGhlIHNoYXBlIHRvIHRoZSB1cHBlciBsZWZ0LWhhbmQgY29ybmVyIG9mIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIGNvcm5lcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QodHJ1ZSk7XG4gICAgICB2YXIgaHcgPSByZWN0LndpZHRoIC8gMjtcbiAgICAgIHZhciBoaCA9IHJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgIHZhciBjeCA9IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyO1xuICAgICAgdmFyIGN5ID0gcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDI7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXNbaV07XG4gICAgICAgIHYueCAtPSBjeDtcbiAgICAgICAgdi55IC09IGN5O1xuICAgICAgICB2LnggKz0gaHc7XG4gICAgICAgIHYueSArPSBoaDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjY2VudGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIE9yaWVudCB0aGUgdmVydGljZXMgb2YgdGhlIHNoYXBlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHBhdGguXG4gICAgICovXG4gICAgY2VudGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCh0cnVlKTtcblxuICAgICAgdmFyIGN4ID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIgLSB0aGlzLnRyYW5zbGF0aW9uLng7XG4gICAgICB2YXIgY3kgPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMiAtIHRoaXMudHJhbnNsYXRpb24ueTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcbiAgICAgICAgdi54IC09IGN4O1xuICAgICAgICB2LnkgLT0gY3k7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI3JlbW92ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmUgc2VsZiBmcm9tIHRoZSBzY2VuZSAvIHBhcmVudC5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2dldEJvdW5kaW5nQ2xpZW50UmVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NoYWxsb3c9ZmFsc2VdIC0gRGVzY3JpYmVzIHdoZXRoZXIgdG8gY2FsY3VsYXRlIG9mZiBsb2NhbCBtYXRyaXggb3Igd29ybGQgbWF0cml4LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IC0gUmV0dXJucyBvYmplY3Qgd2l0aCB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHdpZHRoLCBoZWlnaHQgYXR0cmlidXRlcy5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGgsIGFuZCBoZWlnaHQgcGFyYW1ldGVycyBvZiB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uKHNoYWxsb3cpIHtcbiAgICAgIHZhciBtYXRyaXgsIGJvcmRlciwgbCwgaSwgdjAsIHYxLCBjMHgsIGMweSwgYzF4LCBjMXksIGEsIGIsIGMsIGQ7XG5cbiAgICAgIHZhciBsZWZ0ID0gSW5maW5pdHksIHJpZ2h0ID0gLUluZmluaXR5LFxuICAgICAgICAgIHRvcCA9IEluZmluaXR5LCBib3R0b20gPSAtSW5maW5pdHk7XG5cbiAgICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIHRvIG5vdCBfX2Fsd2F5c19fIHVwZGF0ZS4gSnVzdCB3aGVuIGl0IG5lZWRzIHRvLlxuICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuXG4gICAgICBtYXRyaXggPSBzaGFsbG93ID8gdGhpcy5fbWF0cml4IDogZ2V0Q29tcHV0ZWRNYXRyaXgodGhpcyk7XG5cbiAgICAgIGJvcmRlciA9ICh0aGlzLmxpbmV3aWR0aCB8fCAwKSAvIDI7XG4gICAgICBsID0gdGhpcy5fcmVuZGVyZXIudmVydGljZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobCA8PSAwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgICAgaGVpZ2h0OiAwXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICB2MSA9IHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzW2ldO1xuICAgICAgICAvLyBJZiBpID0gMCwgdGhlbiB0aGlzIFwid3JhcHMgYXJvdW5kXCIgdG8gdGhlIGxhc3QgdmVydGV4LiBPdGhlcndpc2UsIGl0J3MgdGhlIHByZXZpb3VzIHZlcnRleC5cbiAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIGhhbmRsaW5nIGN5Y2xpYyBwYXRocy5cbiAgICAgICAgdjAgPSB0aGlzLl9yZW5kZXJlci52ZXJ0aWNlc1soaSArIGwgLSAxKSAlIGxdO1xuXG4gICAgICAgIGlmICh2MC5jb250cm9scyAmJiB2MS5jb250cm9scykge1xuXG4gICAgICAgICAgYzB4ID0gdjAuY29udHJvbHMucmlnaHQueDtcbiAgICAgICAgICBjMHkgPSB2MC5jb250cm9scy5yaWdodC55O1xuXG4gICAgICAgICAgaWYgKHYwLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICBjMHggKz0gdjAueDtcbiAgICAgICAgICAgIGMweSArPSB2MC55O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGMxeCA9IHYxLmNvbnRyb2xzLmxlZnQueDtcbiAgICAgICAgICBjMXkgPSB2MS5jb250cm9scy5sZWZ0Lnk7XG5cbiAgICAgICAgICBpZiAodjEucmVsYXRpdmUpIHtcbiAgICAgICAgICAgIGMxeCArPSB2MS54O1xuICAgICAgICAgICAgYzF5ICs9IHYxLnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJiID0gZ2V0Q3VydmVCb3VuZGluZ0JveCh2MC54LCB2MC55LFxuICAgICAgICAgICAgYzB4LCBjMHksIGMxeCwgYzF5LCB2MS54LCB2MS55KTtcblxuICAgICAgICAgIHRvcCA9IG1pbiQxKGJiLm1pbi55IC0gYm9yZGVyLCB0b3ApO1xuICAgICAgICAgIGxlZnQgPSBtaW4kMShiYi5taW4ueCAtIGJvcmRlciwgbGVmdCk7XG4gICAgICAgICAgcmlnaHQgPSBtYXgkMShiYi5tYXgueCArIGJvcmRlciwgcmlnaHQpO1xuICAgICAgICAgIGJvdHRvbSA9IG1heCQxKGJiLm1heC55ICsgYm9yZGVyLCBib3R0b20pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoaSA8PSAxKSB7XG5cbiAgICAgICAgICAgIHRvcCA9IG1pbiQxKHYwLnkgLSBib3JkZXIsIHRvcCk7XG4gICAgICAgICAgICBsZWZ0ID0gbWluJDEodjAueCAtIGJvcmRlciwgbGVmdCk7XG4gICAgICAgICAgICByaWdodCA9IG1heCQxKHYwLnggKyBib3JkZXIsIHJpZ2h0KTtcbiAgICAgICAgICAgIGJvdHRvbSA9IG1heCQxKHYwLnkgKyBib3JkZXIsIGJvdHRvbSk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b3AgPSBtaW4kMSh2MS55IC0gYm9yZGVyLCB0b3ApO1xuICAgICAgICAgIGxlZnQgPSBtaW4kMSh2MS54IC0gYm9yZGVyLCBsZWZ0KTtcbiAgICAgICAgICByaWdodCA9IG1heCQxKHYxLnggKyBib3JkZXIsIHJpZ2h0KTtcbiAgICAgICAgICBib3R0b20gPSBtYXgkMSh2MS55ICsgYm9yZGVyLCBib3R0b20pO1xuXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBhID0gbWF0cml4Lm11bHRpcGx5KGxlZnQsIHRvcCwgMSk7XG4gICAgICBiID0gbWF0cml4Lm11bHRpcGx5KGxlZnQsIGJvdHRvbSwgMSk7XG4gICAgICBjID0gbWF0cml4Lm11bHRpcGx5KHJpZ2h0LCB0b3AsIDEpO1xuICAgICAgZCA9IG1hdHJpeC5tdWx0aXBseShyaWdodCwgYm90dG9tLCAxKTtcblxuICAgICAgdG9wID0gbWluJDEoYS55LCBiLnksIGMueSwgZC55KTtcbiAgICAgIGxlZnQgPSBtaW4kMShhLngsIGIueCwgYy54LCBkLngpO1xuICAgICAgcmlnaHQgPSBtYXgkMShhLngsIGIueCwgYy54LCBkLngpO1xuICAgICAgYm90dG9tID0gbWF4JDEoYS55LCBiLnksIGMueSwgZC55KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3AsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgYm90dG9tOiBib3R0b20sXG4gICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wXG4gICAgICB9O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI2dldFBvaW50QXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHQgLSBQZXJjZW50YWdlIHZhbHVlIGRlc2NyaWJpbmcgd2hlcmUgb24gdGhlIFR3by5QYXRoIHRvIGVzdGltYXRlIGFuZCBhc3NpZ24gY29vcmRpbmF0ZSB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtUd28uVmVjdG9yfSBbb2JqPXVuZGVmaW5lZF0gLSBPYmplY3QgdG8gYXBwbHkgY2FsY3VsYXRlZCB4LCB5IHRvLiBJZiBub25lIGF2YWlsYWJsZSByZXR1cm5zIG5ldyBPYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gR2l2ZW4gYSBmbG9hdCBgdGAgZnJvbSAwIHRvIDEsIHJldHVybiBhIHBvaW50IG9yIGFzc2lnbiBhIHBhc3NlZCBgb2JqYCdzIGNvb3JkaW5hdGVzIHRvIHRoYXQgcGVyY2VudGFnZSBvbiB0aGlzIFR3by5QYXRoJ3MgY3VydmUuXG4gICAgICovXG4gICAgZ2V0UG9pbnRBdDogZnVuY3Rpb24odCwgb2JqKSB7XG5cbiAgICAgIHZhciBpYSwgaWIsIHJlc3VsdDtcbiAgICAgIHZhciB4LCB4MSwgeDIsIHgzLCB4NCwgeSwgeTEsIHkyLCB5MywgeTQsIGxlZnQsIHJpZ2h0O1xuICAgICAgdmFyIHRhcmdldCA9IHRoaXMubGVuZ3RoICogTWF0aC5taW4oTWF0aC5tYXgodCwgMCksIDEpO1xuICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgdmFyIGxhc3QgPSBsZW5ndGggLSAxO1xuXG4gICAgICB2YXIgYSA9IG51bGw7XG4gICAgICB2YXIgYiA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fbGVuZ3Rocy5sZW5ndGgsIHN1bSA9IDA7IGkgPCBsOyBpKyspIHtcblxuICAgICAgICBpZiAoc3VtICsgdGhpcy5fbGVuZ3Roc1tpXSA+PSB0YXJnZXQpIHtcblxuICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIGlhID0gbW9kKGksIGxlbmd0aCk7XG4gICAgICAgICAgICBpYiA9IG1vZChpIC0gMSwgbGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgIGlhID0gaWI7XG4gICAgICAgICAgICAgIGliID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWEgPSBpO1xuICAgICAgICAgICAgaWIgPSBNYXRoLm1pbihNYXRoLm1heChpIC0gMSwgMCksIGxhc3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGEgPSB0aGlzLnZlcnRpY2VzW2lhXTtcbiAgICAgICAgICBiID0gdGhpcy52ZXJ0aWNlc1tpYl07XG4gICAgICAgICAgdGFyZ2V0IC09IHN1bTtcbiAgICAgICAgICBpZiAodGhpcy5fbGVuZ3Roc1tpXSAhPT0gMCkge1xuICAgICAgICAgICAgdCA9IHRhcmdldCAvIHRoaXMuX2xlbmd0aHNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBzdW0gKz0gdGhpcy5fbGVuZ3Roc1tpXTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWEpIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9IGVsc2UgaWYgKCFiKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuXG4gICAgICByaWdodCA9IGIuY29udHJvbHMgJiYgYi5jb250cm9scy5yaWdodDtcbiAgICAgIGxlZnQgPSBhLmNvbnRyb2xzICYmIGEuY29udHJvbHMubGVmdDtcblxuICAgICAgeDEgPSBiLng7XG4gICAgICB5MSA9IGIueTtcbiAgICAgIHgyID0gKHJpZ2h0IHx8IGIpLng7XG4gICAgICB5MiA9IChyaWdodCB8fCBiKS55O1xuICAgICAgeDMgPSAobGVmdCB8fCBhKS54O1xuICAgICAgeTMgPSAobGVmdCB8fCBhKS55O1xuICAgICAgeDQgPSBhLng7XG4gICAgICB5NCA9IGEueTtcblxuICAgICAgaWYgKHJpZ2h0ICYmIGIucmVsYXRpdmUpIHtcbiAgICAgICAgeDIgKz0gYi54O1xuICAgICAgICB5MiArPSBiLnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChsZWZ0ICYmIGEucmVsYXRpdmUpIHtcbiAgICAgICAgeDMgKz0gYS54O1xuICAgICAgICB5MyArPSBhLnk7XG4gICAgICB9XG5cbiAgICAgIHggPSBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyKHQsIHgxLCB4MiwgeDMsIHg0KTtcbiAgICAgIHkgPSBnZXRDb21wb25lbnRPbkN1YmljQmV6aWVyKHQsIHkxLCB5MiwgeTMsIHk0KTtcblxuICAgICAgLy8gSGlnaGVyIG9yZGVyIHBvaW50cyBmb3IgY29udHJvbCBjYWxjdWxhdGlvbi5cbiAgICAgIHZhciB0MXggPSBsZXJwKHgxLCB4MiwgdCk7XG4gICAgICB2YXIgdDF5ID0gbGVycCh5MSwgeTIsIHQpO1xuICAgICAgdmFyIHQyeCA9IGxlcnAoeDIsIHgzLCB0KTtcbiAgICAgIHZhciB0MnkgPSBsZXJwKHkyLCB5MywgdCk7XG4gICAgICB2YXIgdDN4ID0gbGVycCh4MywgeDQsIHQpO1xuICAgICAgdmFyIHQzeSA9IGxlcnAoeTMsIHk0LCB0KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSByZXR1cm5lZCBwb2ludHMgY29udHJvbCBwb2ludHMuXG4gICAgICB2YXIgYnJ4ID0gbGVycCh0MXgsIHQyeCwgdCk7XG4gICAgICB2YXIgYnJ5ID0gbGVycCh0MXksIHQyeSwgdCk7XG4gICAgICB2YXIgYWx4ID0gbGVycCh0MngsIHQzeCwgdCk7XG4gICAgICB2YXIgYWx5ID0gbGVycCh0MnksIHQzeSwgdCk7XG5cbiAgICAgIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcblxuICAgICAgICBvYmoueCA9IHg7XG4gICAgICAgIG9iai55ID0geTtcblxuICAgICAgICBpZiAoIV8uaXNPYmplY3Qob2JqLmNvbnRyb2xzKSkge1xuICAgICAgICAgIEFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXMob2JqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai5jb250cm9scy5sZWZ0LnggPSBicng7XG4gICAgICAgIG9iai5jb250cm9scy5sZWZ0LnkgPSBicnk7XG4gICAgICAgIG9iai5jb250cm9scy5yaWdodC54ID0gYWx4O1xuICAgICAgICBvYmouY29udHJvbHMucmlnaHQueSA9IGFseTtcblxuICAgICAgICBpZiAoIXR5cGVvZiBvYmoucmVsYXRpdmUgPT09ICdib29sZWFuJyB8fCBvYmoucmVsYXRpdmUpIHtcbiAgICAgICAgICBvYmouY29udHJvbHMubGVmdC54IC09IHg7XG4gICAgICAgICAgb2JqLmNvbnRyb2xzLmxlZnQueSAtPSB5O1xuICAgICAgICAgIG9iai5jb250cm9scy5yaWdodC54IC09IHg7XG4gICAgICAgICAgb2JqLmNvbnRyb2xzLnJpZ2h0LnkgLT0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iai50ID0gdDtcblxuICAgICAgICByZXR1cm4gb2JqO1xuXG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBBbmNob3IoXG4gICAgICAgIHgsIHksIGJyeCAtIHgsIGJyeSAtIHksIGFseCAtIHgsIGFseSAtIHksXG4gICAgICAgIHRoaXMuX2N1cnZlZCA/IENvbW1hbmRzLmN1cnZlIDogQ29tbWFuZHMubGluZVxuICAgICAgKTtcblxuICAgICAgcmVzdWx0LnQgPSB0O1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI3Bsb3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQmFzZWQgb24gY2xvc2VkIC8gY3VydmVkIGFuZCBzb3J0aW5nIG9mIHZlcnRpY2VzIHBsb3Qgd2hlcmUgYWxsIHBvaW50cyBzaG91bGQgYmUgYW5kIHdoZXJlIHRoZSByZXNwZWN0aXZlIGhhbmRsZXMgc2hvdWxkIGJlIHRvby5cbiAgICAgKiBAbm90YS1iZW5lIFdoaWxlIHRoaXMgbWV0aG9kIGlzIHB1YmxpYyBpdCBpcyBpbnRlcm5hbGx5IGNhbGxlZCBieSB7QGxpbmsgVHdvLlBhdGgjX3VwZGF0ZX0gd2hlbiBgYXV0b21hdGljID0gdHJ1ZWAuXG4gICAgICovXG4gICAgcGxvdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLmN1cnZlZCkge1xuICAgICAgICBnZXRDdXJ2ZUZyb21Qb2ludHModGhpcy5fY29sbGVjdGlvbiwgdGhpcy5jbG9zZWQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb2xsZWN0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2NvbGxlY3Rpb25baV0uY29tbWFuZCA9IGkgPT09IDAgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMubGluZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjc3ViZGl2aWRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0IC0gSG93IG1hbnkgdGltZXMgdG8gcmVjdXJzZSBzdWJkaXZpc2lvbnMuXG4gICAgICogQGRlc2NyaXB0aW9uIEluc2VydCBhIHtAbGluayBUd28uQW5jaG9yfSBhdCB0aGUgbWlkcG9pbnQgYmV0d2VlbiBldmVyeSBpdGVtIGluIHtAbGluayBUd28uUGF0aCN2ZXJ0aWNlc30uXG4gICAgICovXG4gICAgc3ViZGl2aWRlOiBmdW5jdGlvbihsaW1pdCkge1xuICAgICAgLy9UT0RPOiBEUlluZXNzIChmdW5jdGlvbiBiZWxvdylcbiAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICB2YXIgbGFzdCA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBiID0gdGhpcy52ZXJ0aWNlc1tsYXN0XTtcbiAgICAgIHZhciBjbG9zZWQgPSB0aGlzLl9jbG9zZWQgfHwgdGhpcy52ZXJ0aWNlc1tsYXN0XS5fY29tbWFuZCA9PT0gQ29tbWFuZHMuY2xvc2U7XG4gICAgICB2YXIgcG9pbnRzID0gW107XG4gICAgICBfLmVhY2godGhpcy52ZXJ0aWNlcywgZnVuY3Rpb24oYSwgaSkge1xuXG4gICAgICAgIGlmIChpIDw9IDAgJiYgIWNsb3NlZCkge1xuICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhLmNvbW1hbmQgPT09IENvbW1hbmRzLm1vdmUpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChuZXcgQW5jaG9yKGIueCwgYi55KSk7XG4gICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBiID0gYTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmVydHMgPSBnZXRTdWJkaXZpc2lvbnMoYSwgYiwgbGltaXQpO1xuICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KHZlcnRzKTtcblxuICAgICAgICAvLyBBc3NpZ24gY29tbWFuZHMgdG8gYWxsIHRoZSB2ZXJ0c1xuICAgICAgICBfLmVhY2godmVydHMsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgICAgICBpZiAoaSA8PSAwICYmIGIuY29tbWFuZCA9PT0gQ29tbWFuZHMubW92ZSkge1xuICAgICAgICAgICAgdi5jb21tYW5kID0gQ29tbWFuZHMubW92ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdi5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChpID49IGxhc3QpIHtcblxuICAgICAgICAgIC8vIFRPRE86IEFkZCBjaGVjayBpZiB0aGUgdHdvIHZlY3RvcnMgaW4gcXVlc3Rpb24gYXJlIHRoZSBzYW1lIHZhbHVlcy5cbiAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkICYmIHRoaXMuX2F1dG9tYXRpYykge1xuXG4gICAgICAgICAgICBiID0gYTtcblxuICAgICAgICAgICAgdmVydHMgPSBnZXRTdWJkaXZpc2lvbnMoYSwgYiwgbGltaXQpO1xuICAgICAgICAgICAgcG9pbnRzID0gcG9pbnRzLmNvbmNhdCh2ZXJ0cyk7XG5cbiAgICAgICAgICAgIC8vIEFzc2lnbiBjb21tYW5kcyB0byBhbGwgdGhlIHZlcnRzXG4gICAgICAgICAgICBfLmVhY2godmVydHMsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgICAgICAgICAgaWYgKGkgPD0gMCAmJiBiLmNvbW1hbmQgPT09IENvbW1hbmRzLm1vdmUpIHtcbiAgICAgICAgICAgICAgICB2LmNvbW1hbmQgPSBDb21tYW5kcy5tb3ZlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHYuY29tbWFuZCA9IENvbW1hbmRzLmxpbmU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSBlbHNlIGlmIChjbG9zZWQpIHtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKG5ldyBBbmNob3IoYS54LCBhLnkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmNvbW1hbmQgPSBjbG9zZWRcbiAgICAgICAgICAgID8gQ29tbWFuZHMuY2xvc2UgOiBDb21tYW5kcy5saW5lO1xuXG4gICAgICAgIH1cblxuICAgICAgICBiID0gYTtcblxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2F1dG9tYXRpYyA9IGZhbHNlO1xuICAgICAgdGhpcy5fY3VydmVkID0gZmFsc2U7XG4gICAgICB0aGlzLnZlcnRpY2VzID0gcG9pbnRzO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUGF0aCNfdXBkYXRlTGVuZ3RoXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xpbWl0PV0gLVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NpbGVudD1mYWxzZV0gLSBJZiBzZXQgdG8gYHRydWVgIHRoZW4gdGhlIHBhdGggaXNuJ3QgdXBkYXRlZCBiZWZvcmUgY2FsY3VsYXRpb24uIFVzZWZ1bCBmb3IgaW50ZXJuYWwgdXNlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZWNhbGN1bGF0ZSB0aGUge0BsaW5rIFR3by5QYXRoI2xlbmd0aH0gdmFsdWUuXG4gICAgICovXG4gICAgX3VwZGF0ZUxlbmd0aDogZnVuY3Rpb24obGltaXQsIHNpbGVudCkge1xuICAgICAgLy9UT0RPOiBEUlluZXNzIChmdW5jdGlvbiBhYm92ZSlcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICB2YXIgbGFzdCA9IGxlbmd0aCAtIDE7XG4gICAgICB2YXIgYiA9IHRoaXMudmVydGljZXNbbGFzdF07XG4gICAgICB2YXIgY2xvc2VkID0gZmFsc2U7Ly90aGlzLl9jbG9zZWQgfHwgdGhpcy52ZXJ0aWNlc1tsYXN0XS5fY29tbWFuZCA9PT0gQ29tbWFuZHMuY2xvc2U7XG4gICAgICB2YXIgc3VtID0gMDtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9sZW5ndGhzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9sZW5ndGhzID0gW107XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaCh0aGlzLnZlcnRpY2VzLCBmdW5jdGlvbihhLCBpKSB7XG5cbiAgICAgICAgaWYgKChpIDw9IDAgJiYgIWNsb3NlZCkgfHwgYS5jb21tYW5kID09PSBDb21tYW5kcy5tb3ZlKSB7XG4gICAgICAgICAgYiA9IGE7XG4gICAgICAgICAgdGhpcy5fbGVuZ3Roc1tpXSA9IDA7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGVuZ3Roc1tpXSA9IGdldEN1cnZlTGVuZ3RoKGEsIGIsIGxpbWl0KTtcbiAgICAgICAgc3VtICs9IHRoaXMuX2xlbmd0aHNbaV07XG5cbiAgICAgICAgaWYgKGkgPj0gbGFzdCAmJiBjbG9zZWQpIHtcblxuICAgICAgICAgIGIgPSB0aGlzLnZlcnRpY2VzWyhpICsgMSkgJSBsZW5ndGhdO1xuXG4gICAgICAgICAgdGhpcy5fbGVuZ3Roc1tpICsgMV0gPSBnZXRDdXJ2ZUxlbmd0aChhLCBiLCBsaW1pdCk7XG4gICAgICAgICAgc3VtICs9IHRoaXMuX2xlbmd0aHNbaSArIDFdO1xuXG4gICAgICAgIH1cblxuICAgICAgICBiID0gYTtcblxuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHRoaXMuX2xlbmd0aCA9IHN1bTtcbiAgICAgIHRoaXMuX2ZsYWdMZW5ndGggPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ1ZlcnRpY2VzKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2F1dG9tYXRpYykge1xuICAgICAgICAgIHRoaXMucGxvdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdMZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVMZW5ndGgodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsID0gdGhpcy5fY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgIHZhciBjbG9zZWQgPSB0aGlzLl9jbG9zZWQ7XG5cbiAgICAgICAgdmFyIGJlZ2lubmluZyA9IE1hdGgubWluKHRoaXMuX2JlZ2lubmluZywgdGhpcy5fZW5kaW5nKTtcbiAgICAgICAgdmFyIGVuZGluZyA9IE1hdGgubWF4KHRoaXMuX2JlZ2lubmluZywgdGhpcy5fZW5kaW5nKTtcblxuICAgICAgICB2YXIgYmlkID0gZ2V0SWRCeUxlbmd0aCh0aGlzLCBiZWdpbm5pbmcgKiB0aGlzLl9sZW5ndGgpO1xuICAgICAgICB2YXIgZWlkID0gZ2V0SWRCeUxlbmd0aCh0aGlzLCBlbmRpbmcgKiB0aGlzLl9sZW5ndGgpO1xuXG4gICAgICAgIHZhciBsb3cgPSBjZWlsKGJpZCk7XG4gICAgICAgIHZhciBoaWdoID0gZmxvb3IoZWlkKTtcblxuICAgICAgICB2YXIgbGVmdCwgcmlnaHQsIHByZXYsIG5leHQsIHY7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyZXIudmVydGljZXMubGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb24ubGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICAgIC8vIEV4cGVjdGVkIHRvIGJlIGByZWxhdGl2ZWAgYW5jaG9yIHBvaW50cy5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb24ucHVzaChuZXcgQW5jaG9yKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpID4gaGlnaCAmJiAhcmlnaHQpIHtcblxuICAgICAgICAgICAgdiA9IHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baV07XG4gICAgICAgICAgICB2LmNvcHkodGhpcy5fY29sbGVjdGlvbltpXSk7XG4gICAgICAgICAgICB0aGlzLmdldFBvaW50QXQoZW5kaW5nLCB2KTtcbiAgICAgICAgICAgIHYuY29tbWFuZCA9IHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baV0uY29tbWFuZDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzLnB1c2godik7XG5cbiAgICAgICAgICAgIHJpZ2h0ID0gdjtcbiAgICAgICAgICAgIHByZXYgPSB0aGlzLl9jb2xsZWN0aW9uW2kgLSAxXTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBjb250cm9sIG92ZXIgdGhlIHBlcmNlbnRhZ2UgYHRgXG4gICAgICAgICAgICAvLyBvZiB0aGUgaW4tYmV0d2VlbiBwb2ludFxuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5jb250cm9scykge1xuXG4gICAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcblxuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uW2kgLSAxXS5jb250cm9scy5yaWdodFxuICAgICAgICAgICAgICAgIC5jbGVhcigpXG4gICAgICAgICAgICAgICAgLmxlcnAocHJldi5jb250cm9scy5yaWdodCwgdi50KTtcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChpID49IGxvdyAmJiBpIDw9IGhpZ2gpIHtcblxuICAgICAgICAgICAgdiA9IHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baV1cbiAgICAgICAgICAgICAgLmNvcHkodGhpcy5fY29sbGVjdGlvbltpXSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci52ZXJ0aWNlcy5wdXNoKHYpO1xuXG4gICAgICAgICAgICBpZiAoaSA9PT0gaGlnaCAmJiBjb250YWlucyh0aGlzLCBlbmRpbmcpKSB7XG4gICAgICAgICAgICAgIHJpZ2h0ID0gdjtcbiAgICAgICAgICAgICAgaWYgKCFjbG9zZWQgJiYgcmlnaHQuY29udHJvbHMpIHtcbiAgICAgICAgICAgICAgICByaWdodC5jb250cm9scy5yaWdodC5jbGVhcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IGxvdyAmJiBjb250YWlucyh0aGlzLCBiZWdpbm5pbmcpKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSB2O1xuICAgICAgICAgICAgICBsZWZ0LmNvbW1hbmQgPSBDb21tYW5kcy5tb3ZlO1xuICAgICAgICAgICAgICBpZiAoIWNsb3NlZCAmJiBsZWZ0LmNvbnRyb2xzKSB7XG4gICAgICAgICAgICAgICAgbGVmdC5jb250cm9scy5sZWZ0LmNsZWFyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJlcGVuZCB0aGUgdHJpbW1lZCBwb2ludCBpZiBuZWNlc3NhcnkuXG4gICAgICAgIGlmIChsb3cgPiAwICYmICFsZWZ0KSB7XG5cbiAgICAgICAgICBpID0gbG93IC0gMTtcblxuICAgICAgICAgIHYgPSB0aGlzLl9yZW5kZXJlci5jb2xsZWN0aW9uW2ldO1xuICAgICAgICAgIHYuY29weSh0aGlzLl9jb2xsZWN0aW9uW2ldKTtcbiAgICAgICAgICB0aGlzLmdldFBvaW50QXQoYmVnaW5uaW5nLCB2KTtcbiAgICAgICAgICB2LmNvbW1hbmQgPSBDb21tYW5kcy5tb3ZlO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzLnVuc2hpZnQodik7XG5cbiAgICAgICAgICBsZWZ0ID0gdjtcbiAgICAgICAgICBuZXh0ID0gdGhpcy5fY29sbGVjdGlvbltpICsgMV07XG5cbiAgICAgICAgICAvLyBQcm9qZWN0IGNvbnRyb2wgb3ZlciB0aGUgcGVyY2VudGFnZSBgdGBcbiAgICAgICAgICAvLyBvZiB0aGUgaW4tYmV0d2VlbiBwb2ludFxuICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQuY29udHJvbHMpIHtcblxuICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmNvbGxlY3Rpb25baSArIDFdLmNvbnRyb2xzLmxlZnRcbiAgICAgICAgICAgICAgLmNvcHkobmV4dC5jb250cm9scy5sZWZ0KVxuICAgICAgICAgICAgICAubGVycChWZWN0b3IuemVybywgdi50KTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgU2hhcGUucHJvdG90eXBlLl91cGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBhdGgjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnVmVydGljZXMgPSAgdGhpcy5fZmxhZ0ZpbGwgPSAgdGhpcy5fZmxhZ1N0cm9rZSA9XG4gICAgICAgICAgdGhpcy5fZmxhZ0xpbmV3aWR0aCA9IHRoaXMuX2ZsYWdPcGFjaXR5ID0gdGhpcy5fZmxhZ1Zpc2libGUgPVxuICAgICAgICAgIHRoaXMuX2ZsYWdDYXAgPSB0aGlzLl9mbGFnSm9pbiA9IHRoaXMuX2ZsYWdNaXRlciA9XG4gICAgICAgICAgdGhpcy5fZmxhZ0NsaXAgPSBmYWxzZTtcblxuICAgICAgU2hhcGUucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICBQYXRoLk1ha2VPYnNlcnZhYmxlKFBhdGgucHJvdG90eXBlKTtcblxuICAgIC8vIFV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgZnVuY3Rpb24gY29udGFpbnMocGF0aCwgdCkge1xuXG4gICAgaWYgKHQgPT09IDAgfHwgdCA9PT0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHBhdGguX2xlbmd0aDtcbiAgICB2YXIgdGFyZ2V0ID0gbGVuZ3RoICogdDtcbiAgICB2YXIgZWxhcHNlZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGguX2xlbmd0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaXN0ID0gcGF0aC5fbGVuZ3Roc1tpXTtcbiAgICAgIGlmIChlbGFwc2VkID49IHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0IC0gZWxhcHNlZCA+PSAwO1xuICAgICAgfVxuICAgICAgZWxhcHNlZCArPSBkaXN0O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7VHdvLlBhdGh9IHBhdGggLSBUaGUgcGF0aCB0byBhbmFseXplIGFnYWluc3QuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IGxlbmd0aCBhdCB3aGljaCB0byBmaW5kIGFuIGFuY2hvci5cbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICogQGRlc2NyaXB0aW9uIFJldHVybiB0aGUgaWQgb2YgYW4gYW5jaG9yIGJhc2VkIG9uIGEgdGFyZ2V0IGxlbmd0aC5cbiAgICovXG4gIGZ1bmN0aW9uIGdldElkQnlMZW5ndGgocGF0aCwgdGFyZ2V0KSB7XG5cbiAgICB2YXIgdG90YWwgPSBwYXRoLl9sZW5ndGg7XG5cbiAgICBpZiAodGFyZ2V0IDw9IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0ID49IHRvdGFsKSB7XG4gICAgICByZXR1cm4gcGF0aC5fbGVuZ3Rocy5sZW5ndGggLSAxO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBzdW0gPSAwOyBpIDwgcGF0aC5fbGVuZ3Rocy5sZW5ndGg7IGkrKykge1xuXG4gICAgICBpZiAoc3VtICsgcGF0aC5fbGVuZ3Roc1tpXSA+PSB0YXJnZXQpIHtcbiAgICAgICAgdGFyZ2V0IC09IHN1bTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGkgLSAxLCAwKSArIHRhcmdldCAvIHBhdGguX2xlbmd0aHNbaV07XG4gICAgICB9XG5cbiAgICAgIHN1bSArPSBwYXRoLl9sZW5ndGhzW2ldO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIC0gMTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VydmVMZW5ndGgoYSwgYiwgbGltaXQpIHtcbiAgICAvLyBUT0RPOiBEUlluZXNzXG4gICAgdmFyIHgxLCB4MiwgeDMsIHg0LCB5MSwgeTIsIHkzLCB5NDtcblxuICAgIHZhciByaWdodCA9IGIuY29udHJvbHMgJiYgYi5jb250cm9scy5yaWdodDtcbiAgICB2YXIgbGVmdCA9IGEuY29udHJvbHMgJiYgYS5jb250cm9scy5sZWZ0O1xuXG4gICAgeDEgPSBiLng7XG4gICAgeTEgPSBiLnk7XG4gICAgeDIgPSAocmlnaHQgfHwgYikueDtcbiAgICB5MiA9IChyaWdodCB8fCBiKS55O1xuICAgIHgzID0gKGxlZnQgfHwgYSkueDtcbiAgICB5MyA9IChsZWZ0IHx8IGEpLnk7XG4gICAgeDQgPSBhLng7XG4gICAgeTQgPSBhLnk7XG5cbiAgICBpZiAocmlnaHQgJiYgYi5fcmVsYXRpdmUpIHtcbiAgICAgIHgyICs9IGIueDtcbiAgICAgIHkyICs9IGIueTtcbiAgICB9XG5cbiAgICBpZiAobGVmdCAmJiBhLl9yZWxhdGl2ZSkge1xuICAgICAgeDMgKz0gYS54O1xuICAgICAgeTMgKz0gYS55O1xuICAgIH1cblxuICAgIHJldHVybiBnZXRDdXJ2ZUxlbmd0aCQxKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHg0LCB5NCwgbGltaXQpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdWJkaXZpc2lvbnMoYSwgYiwgbGltaXQpIHtcbiAgICAvLyBUT0RPOiBEUlluZXNzXG4gICAgdmFyIHgxLCB4MiwgeDMsIHg0LCB5MSwgeTIsIHkzLCB5NDtcblxuICAgIHZhciByaWdodCA9IGIuY29udHJvbHMgJiYgYi5jb250cm9scy5yaWdodDtcbiAgICB2YXIgbGVmdCA9IGEuY29udHJvbHMgJiYgYS5jb250cm9scy5sZWZ0O1xuXG4gICAgeDEgPSBiLng7XG4gICAgeTEgPSBiLnk7XG4gICAgeDIgPSAocmlnaHQgfHwgYikueDtcbiAgICB5MiA9IChyaWdodCB8fCBiKS55O1xuICAgIHgzID0gKGxlZnQgfHwgYSkueDtcbiAgICB5MyA9IChsZWZ0IHx8IGEpLnk7XG4gICAgeDQgPSBhLng7XG4gICAgeTQgPSBhLnk7XG5cbiAgICBpZiAocmlnaHQgJiYgYi5fcmVsYXRpdmUpIHtcbiAgICAgIHgyICs9IGIueDtcbiAgICAgIHkyICs9IGIueTtcbiAgICB9XG5cbiAgICBpZiAobGVmdCAmJiBhLl9yZWxhdGl2ZSkge1xuICAgICAgeDMgKz0gYS54O1xuICAgICAgeTMgKz0gYS55O1xuICAgIH1cblxuICAgIHJldHVybiBzdWJkaXZpZGUoeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCBsaW1pdCk7XG5cbiAgfVxuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3dpZHRoXSAtIFRoZSB3aWR0aCB2YWx1ZSBvZiB0aGUgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodF0gLSBUaGUgd2lkdGggdmFsdWUgb2YgdGhlIHJlY3RhbmdsZS5cbiAgICovXG4gIGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICBQYXRoLmNhbGwodGhpcywgW1xuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpLFxuICAgICAgbmV3IEFuY2hvcigpXG4gICAgICAvLyBuZXcgQW5jaG9yKCkgLy8gVE9ETzogRmlndXJlIG91dCBob3cgdG8gaGFuZGxlIHRoaXMgZm9yIGBiZWdpbm5pbmdgIC8gYGVuZGluZ2AgYW5pbWF0aW9uc1xuICAgIF0sIHRydWUsIGZhbHNlLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNoZWlnaHRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgaGVpZ2h0IG9mIHRoZSByZWN0YW5nbGUuXG4gICAgICovXG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI29yaWdpblxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIEEgdHdvLWNvbXBvbmVudCB2ZWN0b3IgZGVzY3JpYmluZyB0aGUgb3JpZ2luIG9mZnNldCB0byBkcmF3IHRoZSByZWN0YW5nbGUuIERlZmF1bHQgaXMgYDAsIDBgLlxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gbmV3IFZlY3RvcigpO1xuICAgIHRoaXMudHJhbnNsYXRpb24uc2V0KHgsIHkpO1xuXG4gICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFJlY3RhbmdsZSwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZS5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlJlY3RhbmdsZX0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogWyd3aWR0aCcsICdoZWlnaHQnXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5SZWN0YW5nbGV9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIHRoZSB7QGxpbmsgVHdvLlJlY3RhbmdsZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XG4gICAgICBfLmVhY2goUmVjdGFuZ2xlLlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqZWN0KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ29yaWdpbicsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fb3JpZ2luO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBpZiAodGhpcy5fb3JpZ2luKSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW4udW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdWZXJ0aWNlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX29yaWdpbiA9IHY7XG4gICAgICAgICAgdGhpcy5fb3JpZ2luLmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1ZlcnRpY2VzKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5mbGFnVmVydGljZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoUmVjdGFuZ2xlLnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBSZWN0YW5nbGUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI19mbGFnV2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUmVjdGFuZ2xlI3dpZHRofSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1dpZHRoOiAwLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjX2ZsYWdIZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUmVjdGFuZ2xlI2hlaWdodH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdIZWlnaHQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUmVjdGFuZ2xlI193aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlJlY3RhbmdsZSN3aWR0aH1cbiAgICAgKi9cbiAgICBfd2lkdGg6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNfaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUmVjdGFuZ2xlI2hlaWdodH1cbiAgICAgKi9cbiAgICBfaGVpZ2h0OiAwLFxuXG4gICAgX29yaWdpbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ1ZlcnRpY2VzIHx8IHRoaXMuX2ZsYWdXaWR0aCB8fCB0aGlzLl9mbGFnSGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIHhyID0gdGhpcy5fd2lkdGggLyAyO1xuICAgICAgICB2YXIgeXIgPSB0aGlzLl9oZWlnaHQgLyAyO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2xvc2VkICYmIHRoaXMudmVydGljZXMubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgdGhpcy52ZXJ0aWNlcy5wdXNoKG5ldyBBbmNob3IoKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZlcnRpY2VzWzBdLnNldCgteHIsIC15cikuYWRkKHRoaXMuX29yaWdpbikuY29tbWFuZCA9IENvbW1hbmRzLm1vdmU7XG4gICAgICAgIHRoaXMudmVydGljZXNbMV0uc2V0KHhyLCAteXIpLmFkZCh0aGlzLl9vcmlnaW4pLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzJdLnNldCh4ciwgeXIpLmFkZCh0aGlzLl9vcmlnaW4pLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuICAgICAgICB0aGlzLnZlcnRpY2VzWzNdLnNldCgteHIsIHlyKS5hZGQodGhpcy5fb3JpZ2luKS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcbiAgICAgICAgLy8gRllJOiBUd28uU3ByaXRlIGFuZCBUd28uSW1hZ2VTZXF1ZW5jZSBoYXZlIDQgdmVydHNcbiAgICAgICAgaWYgKHRoaXMudmVydGljZXNbNF0pIHtcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzWzRdLnNldCgteHIsIC15cikuYWRkKHRoaXMuX29yaWdpbikuY29tbWFuZCA9IENvbW1hbmRzLmxpbmU7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBQYXRoLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnV2lkdGggPSB0aGlzLl9mbGFnSGVpZ2h0ID0gZmFsc2U7XG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJlY3RhbmdsZSNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlJlY3RhbmdsZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uUmVjdGFuZ2xlfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgY2xvbmUuc2tld1kgPSB0aGlzLnNrZXdZO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgXy5lYWNoKFBhdGguUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5SZWN0YW5nbGUjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgb2JqZWN0LndpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIG9iamVjdC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIG9iamVjdC5vcmlnaW4gPSB0aGlzLm9yaWdpbi50b09iamVjdCgpO1xuICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgIH1cblxuICB9KTtcblxuICBSZWN0YW5nbGUuTWFrZU9ic2VydmFibGUoUmVjdGFuZ2xlLnByb3RvdHlwZSk7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5TcHJpdGVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5SZWN0YW5nbGVcbiAgICogQHBhcmFtIHtTdHJpbmd8VHdvLlRleHR1cmV9IFtwYXRoXSAtIFRoZSBVUkwgcGF0aCBvciB7QGxpbmsgVHdvLlRleHR1cmV9IHRvIGJlIHVzZWQgYXMgdGhlIGJpdG1hcCBkYXRhIGRpc3BsYXllZCBvbiB0aGUgc3ByaXRlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW294PTBdIC0gVGhlIGluaXRpYWwgYHhgIHBvc2l0aW9uIG9mIHRoZSBUd28uU3ByaXRlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW295PTBdIC0gVGhlIGluaXRpYWwgYHlgIHBvc2l0aW9uIG9mIHRoZSBUd28uU3ByaXRlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbHM9MV0gLSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdGhlIHNwcml0ZSBjb250YWlucy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyb3dzPTFdIC0gVGhlIG51bWJlciBvZiByb3dzIHRoZSBzcHJpdGUgY29udGFpbnMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJhbWVSYXRlPTBdIC0gVGhlIGZyYW1lIHJhdGUgYXQgd2hpY2ggdGhlIHBhcnRpdGlvbnMgb2YgdGhlIGltYWdlIHNob3VsZCBwbGF5YmFjayBhdC5cbiAgICogQGRlc2NyaXB0aW9uIEEgY29udmVuaWVudCBwYWNrYWdlIHRvIGRpc3BsYXkgc3RpbGwgb3IgYW5pbWF0ZWQgaW1hZ2VzIHRocm91Z2ggYSB0aWxlZCBpbWFnZSBzb3VyY2UuIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBwcmluY2lwYWxzIG9mIGFuaW1hdGVkIGltYWdlcnkgdGhyb3VnaCB0aWxpbmcgc2VlIFtUZXh0dXJlIEF0bGFzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9UZXh0dXJlX2F0bGFzKSBvbiBXaWtpcGVkaWEuXG4gICAqL1xuICBmdW5jdGlvbiBTcHJpdGUocGF0aCwgb3gsIG95LCBjb2xzLCByb3dzLCBmcmFtZVJhdGUpIHtcblxuICAgIC8vIE5vdCB1c2luZyBkZWZhdWx0IGNvbnN0cnVjdG9yIG9mIFJlY3RhbmdsZSBkdWUgdG8gb2RkIGBiZWdpbm5pbmdgIC8gYGVuZGluZ2AgYmVoYXZpb3IuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMS90d28uanMvaXNzdWVzLzM4M1xuICAgIFBhdGguY2FsbCh0aGlzLCBbXG4gICAgICBuZXcgQW5jaG9yKCksXG4gICAgICBuZXcgQW5jaG9yKCksXG4gICAgICBuZXcgQW5jaG9yKCksXG4gICAgICBuZXcgQW5jaG9yKClcbiAgICBdLCB0cnVlKTtcblxuICAgIHRoaXMubm9TdHJva2UoKTtcbiAgICB0aGlzLm5vRmlsbCgpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSN0ZXh0dXJlXG4gICAgICogQHByb3BlcnR5IHtUd28uVGV4dHVyZX0gLSBUaGUgdGV4dHVyZSB0byBiZSB1c2VkIGFzIGJpdG1hcCBkYXRhIHRvIGRpc3BsYXkgaW1hZ2UgaW4gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIGlmIChwYXRoIGluc3RhbmNlb2YgVGV4dHVyZSkge1xuICAgICAgdGhpcy50ZXh0dXJlID0gcGF0aDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy50ZXh0dXJlID0gbmV3IFRleHR1cmUocGF0aCk7XG4gICAgfVxuXG4gICAgdGhpcy5vcmlnaW4gPSBuZXcgVmVjdG9yKCk7XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldChveCB8fCAwLCBveSB8fCAwKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjY29sdW1uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBudW1iZXIgb2YgY29sdW1ucyB0byBzcGxpdCB0aGUgdGV4dHVyZSBpbnRvLiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBjb2xzID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jb2x1bW5zID0gY29scztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI3Jvd3NcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgbnVtYmVyIG9mIHJvd3MgdG8gc3BsaXQgdGhlIHRleHR1cmUgaW50by4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygcm93cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNmcmFtZVJhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgbnVtYmVyIG9mIGZyYW1lcyB0byBhbmltYXRlIGFnYWluc3QgcGVyIHNlY29uZC4gRGVmYXVsdHMgdG8gYDBgIGZvciBub24tYW5pbWF0ZWQgc3ByaXRlcy5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGZyYW1lUmF0ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gZnJhbWVSYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjaW5kZXhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdGlsZSBvZiB0aGUgc3ByaXRlIHRvIGRpc3BsYXkuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLmluZGV4ID0gMDtcblxuICB9XG5cbiAgXy5leHRlbmQoU3ByaXRlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uU3ByaXRlfS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbXG4gICAgICAndGV4dHVyZScsICdjb2x1bW5zJywgJ3Jvd3MnLCAnZnJhbWVSYXRlJywgJ2luZGV4J1xuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uU3ByaXRlfSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCBvciBpbmhlcml0IHRoZSB7QGxpbmsgVHdvLlNwcml0ZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgICBSZWN0YW5nbGUuTWFrZU9ic2VydmFibGUob2JqKTtcbiAgICAgIF8uZWFjaChTcHJpdGUuUHJvcGVydGllcywgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmopO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFNwcml0ZS5wcm90b3R5cGUsIFJlY3RhbmdsZS5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBTcHJpdGUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19mbGFnVGV4dHVyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TcHJpdGUjdGV4dHVyZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdUZXh0dXJlOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TcHJpdGUjX2ZsYWdDb2x1bW5zXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlNwcml0ZSNjb2x1bW5zfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQ29sdW1uczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19mbGFnUm93c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TcHJpdGUjcm93c30gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1Jvd3M6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmxhZ0ZyYW1lUmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TcHJpdGUjZmxhZ0ZyYW1lUmF0ZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdGcmFtZVJhdGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmxhZ0luZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlNwcml0ZSNpbmRleH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgZmxhZ0luZGV4OiBmYWxzZSxcblxuICAgIC8vIFByaXZhdGUgdmFyaWFibGVzXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19hbW91bnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIE51bWJlciBvZiBmcmFtZXMgZm9yIGEgZ2l2ZW4ge0BsaW5rIFR3by5TcHJpdGV9LlxuICAgICAqL1xuICAgIF9hbW91bnQ6IDEsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19kdXJhdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhIHtAbGluayBUd28uU3ByaXRlfS5cbiAgICAgKi9cbiAgICBfZHVyYXRpb246IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19zdGFydFRpbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TWlsbGlzZWNvbmRzfSAtIEVwb2NoIHRpbWUgaW4gbWlsbGlzZWNvbmRzIG9mIHdoZW4gdGhlIHtAbGluayBUd28uU3ByaXRlfSBzdGFydGVkLlxuICAgICAqL1xuICAgIF9zdGFydFRpbWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19wbGF5aW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGljdGF0ZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TcHJpdGV9IGlzIGFuaW1hdGluZyBvciBub3QuXG4gICAgICovXG4gICAgX3BsYXlpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZmlyc3RGcmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGZyYW1lIHRoZSB7QGxpbmsgVHdvLlNwcml0ZX0gc2hvdWxkIHN0YXJ0IHdpdGguXG4gICAgICovXG4gICAgX2ZpcnN0RnJhbWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI19sYXN0RnJhbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBmcmFtZSB0aGUge0BsaW5rIFR3by5TcHJpdGV9IHNob3VsZCBlbmQgd2l0aC5cbiAgICAgKi9cbiAgICBfbGFzdEZyYW1lOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfcGxheWluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpY3RhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3ByaXRlfSBzaG91bGQgbG9vcCBvciBub3QuXG4gICAgICovXG4gICAgX2xvb3A6IHRydWUsXG5cbiAgICAvLyBFeHBvc2VkIHRocm91Z2ggZ2V0dGVyLXNldHRlclxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfdGV4dHVyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlNwcml0ZSN0ZXh0dXJlfVxuICAgICAqL1xuICAgIF90ZXh0dXJlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfY29sdW1uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlNwcml0ZSNjb2x1bW5zfVxuICAgICAqL1xuICAgIF9jb2x1bW5zOiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfcm93c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLlNwcml0ZSNyb3dzfVxuICAgICAqL1xuICAgIF9yb3dzOiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfZnJhbWVSYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3ByaXRlI2ZyYW1lUmF0ZX1cbiAgICAgKi9cbiAgICBfZnJhbWVSYXRlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfaW5kZXhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBjdXJyZW50IGZyYW1lIHRoZSB7QGxpbmsgVHdvLlNwcml0ZX0gaXMgY3VycmVudGx5IGRpc3BsYXlpbmcuXG4gICAgICovXG4gICAgX2luZGV4OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfb3JpZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3ByaXRlI29yaWdpbn1cbiAgICAgKi9cbiAgICBfb3JpZ2luOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNwbGF5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtmaXJzdEZyYW1lPTBdIC0gVGhlIGluZGV4IG9mIHRoZSBmcmFtZSB0byBzdGFydCB0aGUgYW5pbWF0aW9uIHdpdGguXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtsYXN0RnJhbWVdIC0gVGhlIGluZGV4IG9mIHRoZSBmcmFtZSB0byBlbmQgdGhlIGFuaW1hdGlvbiB3aXRoLiBEZWZhdWx0cyB0byB0aGUgbGFzdCBpdGVtIGluIHRoZSB7QGxpbmsgVHdvLlNwcml0ZSN0ZXh0dXJlc30uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTGFzdEZyYW1lXSAtIE9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHRyaWdnZXJlZCBhZnRlciBwbGF5aW5nIHRoZSBsYXN0IGZyYW1lLiBUaGlzIGZpcmVzIG11bHRpcGxlIHRpbWVzIHdoZW4gdGhlIHNwcml0ZSBpcyBsb29wZWQuXG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYXRlIGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uU3ByaXRlfS5cbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbihmaXJzdEZyYW1lLCBsYXN0RnJhbWUsIG9uTGFzdEZyYW1lKSB7XG5cbiAgICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fZmlyc3RGcmFtZSA9IDA7XG4gICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLmFtb3VudCAtIDE7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBfLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBpZiAodHlwZW9mIGZpcnN0RnJhbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0RnJhbWUgPSBmaXJzdEZyYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXN0RnJhbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGxhc3RGcmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb25MYXN0RnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fb25MYXN0RnJhbWUgPSBvbkxhc3RGcmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbkxhc3RGcmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2luZGV4ICE9PSB0aGlzLl9maXJzdEZyYW1lKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSAtPSAxMDAwICogTWF0aC5hYnModGhpcy5faW5kZXggLSB0aGlzLl9maXJzdEZyYW1lKVxuICAgICAgICAgIC8gdGhpcy5fZnJhbWVSYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI3BhdXNlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbHQgYW5pbWF0aW9uIHBsYXliYWNrIG9mIGEge0BsaW5rIFR3by5TcHJpdGV9LlxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNzdG9wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbHQgYW5pbWF0aW9uIHBsYXliYWNrIG9mIGEge0BsaW5rIFR3by5TcHJpdGV9IGFuZCBzZXQgdGhlIGN1cnJlbnQgZnJhbWUgYmFjayB0byB0aGUgZmlyc3QgZnJhbWUuXG4gICAgICovXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2luZGV4ID0gMDtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlNwcml0ZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uU3ByaXRlfSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgc3ByaXRlLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIGNsb25lID0gbmV3IFNwcml0ZShcbiAgICAgICAgdGhpcy50ZXh0dXJlLCB0aGlzLnRyYW5zbGF0aW9uLngsIHRoaXMudHJhbnNsYXRpb24ueSxcbiAgICAgICAgdGhpcy5jb2x1bW5zLCB0aGlzLnJvd3MsIHRoaXMuZnJhbWVSYXRlXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICAgIGNsb25lLnBsYXkodGhpcy5fZmlyc3RGcmFtZSwgdGhpcy5fbGFzdEZyYW1lKTtcbiAgICAgICAgY2xvbmUuX2xvb3AgPSB0aGlzLl9sb29wO1xuICAgICAgfVxuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3QgPSBSZWN0YW5nbGUucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG4gICAgICBvYmplY3QudGV4dHVyZSA9IHRoaXMudGV4dHVyZS50b09iamVjdCgpO1xuICAgICAgb2JqZWN0LmNvbHVtbnMgPSB0aGlzLmNvbHVtbnM7XG4gICAgICBvYmplY3Qucm93cyA9IHRoaXMucm93cztcbiAgICAgIG9iamVjdC5mcmFtZVJhdGUgPSB0aGlzLmZyYW1lUmF0ZTtcbiAgICAgIG9iamVjdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBvYmplY3QuX2ZpcnN0RnJhbWUgPSB0aGlzLl9maXJzdEZyYW1lO1xuICAgICAgb2JqZWN0Ll9sYXN0RnJhbWUgPSB0aGlzLl9sYXN0RnJhbWU7XG4gICAgICBvYmplY3QuX2xvb3AgPSB0aGlzLl9sb29wO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNwcml0ZSNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBlZmZlY3QgPSB0aGlzLl90ZXh0dXJlO1xuICAgICAgdmFyIGNvbHMgPSB0aGlzLl9jb2x1bW5zO1xuICAgICAgdmFyIHJvd3MgPSB0aGlzLl9yb3dzO1xuXG4gICAgICB2YXIgd2lkdGgsIGhlaWdodCwgZWxhcHNlZCwgYW1vdW50LCBkdXJhdGlvbjtcbiAgICAgIHZhciBpbmRleCwgaXcsIGloLCBmcmFtZXM7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnQ29sdW1ucyB8fCB0aGlzLl9mbGFnUm93cykge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSB0aGlzLl9jb2x1bW5zICogdGhpcy5fcm93cztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ZsYWdGcmFtZVJhdGUpIHtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSAxMDAwICogdGhpcy5fYW1vdW50IC8gdGhpcy5fZnJhbWVSYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZmxhZ1RleHR1cmUpIHtcbiAgICAgICAgdGhpcy5maWxsID0gdGhpcy5fdGV4dHVyZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3RleHR1cmUubG9hZGVkKSB7XG5cbiAgICAgICAgaXcgPSBlZmZlY3QuaW1hZ2Uud2lkdGg7XG4gICAgICAgIGloID0gZWZmZWN0LmltYWdlLmhlaWdodDtcblxuICAgICAgICB3aWR0aCA9IGl3IC8gY29scztcbiAgICAgICAgaGVpZ2h0ID0gaWggLyByb3dzO1xuICAgICAgICBhbW91bnQgPSB0aGlzLl9hbW91bnQ7XG5cbiAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcGxheWluZyAmJiB0aGlzLl9mcmFtZVJhdGUgPiAwKSB7XG5cbiAgICAgICAgICBpZiAoXy5pc05hTih0aGlzLl9sYXN0RnJhbWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBhbW91bnQgLSAxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRPRE86IE9mZmxvYWQgcGVyZiBsb2dpYyB0byBpbnN0YW5jZSBvZiBgVHdvYC5cbiAgICAgICAgICBlbGFwc2VkID0gXy5wZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgICBmcmFtZXMgPSB0aGlzLl9sYXN0RnJhbWUgKyAxO1xuICAgICAgICAgIGR1cmF0aW9uID0gMTAwMCAqIChmcmFtZXMgLSB0aGlzLl9maXJzdEZyYW1lKSAvIHRoaXMuX2ZyYW1lUmF0ZTtcblxuICAgICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG4gICAgICAgICAgICBlbGFwc2VkID0gZWxhcHNlZCAlIGR1cmF0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGFwc2VkID0gTWF0aC5taW4oZWxhcHNlZCwgZHVyYXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZGV4ID0gbGVycCh0aGlzLl9maXJzdEZyYW1lLCBmcmFtZXMsIGVsYXBzZWQgLyBkdXJhdGlvbik7XG4gICAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4KTtcblxuICAgICAgICAgIGlmIChpbmRleCAhPT0gdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fbGFzdEZyYW1lIC0gMSAmJiB0aGlzLl9vbkxhc3RGcmFtZSkge1xuICAgICAgICAgICAgICB0aGlzLl9vbkxhc3RGcmFtZSgpOyAgLy8gU2hvcnRjdXQgZm9yIGNoYWluYWJsZSBzcHJpdGUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbCA9IHRoaXMuX2luZGV4ICUgY29scztcbiAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IodGhpcy5faW5kZXggLyBjb2xzKTtcblxuICAgICAgICB2YXIgb3ggPSAtIHdpZHRoICogY29sICsgKGl3IC0gd2lkdGgpIC8gMjtcbiAgICAgICAgdmFyIG95ID0gLSBoZWlnaHQgKiByb3cgKyAoaWggLSBoZWlnaHQpIC8gMjtcblxuICAgICAgICAvLyBUT0RPOiBJbXByb3ZlIHBlcmZvcm1hbmNlXG4gICAgICAgIGlmIChveCAhPT0gZWZmZWN0Lm9mZnNldC54KSB7XG4gICAgICAgICAgZWZmZWN0Lm9mZnNldC54ID0gb3g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG95ICE9PSBlZmZlY3Qub2Zmc2V0LnkpIHtcbiAgICAgICAgICBlZmZlY3Qub2Zmc2V0LnkgPSBveTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3ByaXRlI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1RleHR1cmUgPSB0aGlzLl9mbGFnQ29sdW1ucyA9IHRoaXMuX2ZsYWdSb3dzXG4gICAgICAgID0gdGhpcy5fZmxhZ0ZyYW1lUmF0ZSA9IGZhbHNlO1xuXG4gICAgICBSZWN0YW5nbGUucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblxuICB9KTtcblxuICBTcHJpdGUuTWFrZU9ic2VydmFibGUoU3ByaXRlLnByb3RvdHlwZSk7XG5cbiAgdmFyIFRXT19QSSQ0ID0gTWF0aC5QSSAqIDIsIEhBTEZfUEkkMiA9IE1hdGguUEkgLyAyO1xuICB2YXIgY29zJDMgPSBNYXRoLmNvcywgc2luJDMgPSBNYXRoLnNpbjtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLkNpcmNsZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIGNpcmNsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGNpcmNsZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyYWRpdXM9MF0gLSBUaGUgcmFkaXVzIHZhbHVlIG9mIHRoZSBjaXJjbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj00XSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIGNpcmNsZS5cbiAgICovXG4gIGZ1bmN0aW9uIENpcmNsZShveCwgb3ksIHIsIHJlc29sdXRpb24pIHtcblxuICAgIC8vIEF0IGxlYXN0IDIgdmVydGljZXMgYXJlIHJlcXVpcmVkIGZvciBwcm9wZXIgY2lyY2xhZ2VcbiAgICB2YXIgYW1vdW50ID0gcmVzb2x1dGlvbiA/IE1hdGgubWF4KHJlc29sdXRpb24sIDIpIDogNDtcblxuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICBwb2ludHMucHVzaChuZXcgQW5jaG9yKDAsIDAsIDAsIDAsIDAsIDApKTtcbiAgICB9XG5cbiAgICBQYXRoLmNhbGwodGhpcywgcG9pbnRzLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUjcmFkaXVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gcjtcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIGlmICh0eXBlb2Ygb3ggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnggPSBveDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBveSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueSA9IG95O1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoQ2lyY2xlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uQ2lyY2xlfS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbJ3JhZGl1cyddLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZS5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkNpcmNsZX0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uQ2lyY2xlfSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqKSB7XG5cbiAgICAgIFBhdGguTWFrZU9ic2VydmFibGUob2JqKTtcbiAgICAgIF8uZWFjaChDaXJjbGUuUHJvcGVydGllcywgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmopO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKENpcmNsZS5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogQ2lyY2xlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZSNfZmxhZ1JhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5DaXJjbGUjcmFkaXVzfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1JhZGl1czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlI19yYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5DaXJjbGUjcmFkaXVzfVxuICAgICAqL1xuICAgIF9yYWRpdXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcyB8fCB0aGlzLl9mbGFnUmFkaXVzKSB7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBsZW5ndGggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvZWZmaWNpZW50IGZvciBhcHByb3hpbWF0aW5nIGNpcmN1bGFyIGFyY3Mgd2l0aCBCZXppZXIgY3VydmVzXG4gICAgICAgIHZhciBjID0gKDQgLyAzKSAqIE1hdGgudGFuKE1hdGguUEkgLyAobGVuZ3RoICogMikpO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5fcmFkaXVzO1xuICAgICAgICB2YXIgcmMgPSByYWRpdXMgKiBjO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBwY3QgPSBpIC8gbGVuZ3RoO1xuICAgICAgICAgIHZhciB0aGV0YSA9IHBjdCAqIFRXT19QSSQ0O1xuXG4gICAgICAgICAgdmFyIHggPSByYWRpdXMgKiBjb3MkMyh0aGV0YSk7XG4gICAgICAgICAgdmFyIHkgPSByYWRpdXMgKiBzaW4kMyh0aGV0YSk7XG5cbiAgICAgICAgICB2YXIgbHggPSByYyAqIGNvcyQzKHRoZXRhIC0gSEFMRl9QSSQyKTtcbiAgICAgICAgICB2YXIgbHkgPSByYyAqIHNpbiQzKHRoZXRhIC0gSEFMRl9QSSQyKTtcblxuICAgICAgICAgIHZhciByeCA9IHJjICogY29zJDModGhldGEgKyBIQUxGX1BJJDIpO1xuICAgICAgICAgIHZhciByeSA9IHJjICogc2luJDModGhldGEgKyBIQUxGX1BJJDIpO1xuXG4gICAgICAgICAgdmFyIHYgPSB0aGlzLnZlcnRpY2VzW2ldO1xuXG4gICAgICAgICAgdi5jb21tYW5kID0gaSA9PT0gMCA/IENvbW1hbmRzLm1vdmUgOiBDb21tYW5kcy5jdXJ2ZTtcbiAgICAgICAgICB2LnNldCh4LCB5KTtcbiAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQuc2V0KGx4LCBseSk7XG4gICAgICAgICAgdi5jb250cm9scy5yaWdodC5zZXQocngsIHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBQYXRoLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQ2lyY2xlI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1JhZGl1cyA9IGZhbHNlO1xuXG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5DaXJjbGUjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5DaXJjbGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkNpcmNsZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICB2YXIgY2xvbmUgPSBuZXcgQ2lyY2xlKDAsIDAsIHRoaXMucmFkaXVzLCB0aGlzLnZlcnRpY2VzLmxlbmd0aCk7XG5cbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICBjbG9uZS5za2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICBjbG9uZS5za2V3WSA9IHRoaXMuc2tld1k7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2goUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkNpcmNsZSN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIG9iamVjdCA9IFBhdGgucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgIF8uZWFjaChDaXJjbGUuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgQ2lyY2xlLk1ha2VPYnNlcnZhYmxlKENpcmNsZS5wcm90b3R5cGUpO1xuXG4gIHZhciBUV09fUEkkMyA9IE1hdGguUEkgKiAyLCBIQUxGX1BJJDEgPSBNYXRoLlBJIC8gMjtcbiAgdmFyIGNvcyQyID0gTWF0aC5jb3MsIHNpbiQyID0gTWF0aC5zaW47XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5FbGxpcHNlXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgZWxsaXBzZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGVsbGlwc2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcng9MF0gLSBUaGUgcmFkaXVzIHZhbHVlIG9mIHRoZSBlbGxpcHNlIGluIHRoZSB4IGRpcmVjdGlvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtyeT0wXSAtIFRoZSByYWRpdXMgdmFsdWUgb2YgdGhlIGVsbGlwc2UgaW4gdGhlIHkgZGlyZWN0aW9uLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3Jlc29sdXRpb249NF0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBlbGxpcHNlLlxuICAgKi9cbiAgZnVuY3Rpb24gRWxsaXBzZShveCwgb3ksIHJ4LCByeSwgcmVzb2x1dGlvbikge1xuXG4gICAgaWYgKHR5cGVvZiByeSAhPT0gJ251bWJlcicgJiYgdHlwZW9mIHJ4ID09PSAnbnVtYmVyJykge1xuICAgICAgcnkgPSByeDtcbiAgICB9XG5cbiAgICAvLyBBdCBsZWFzdCAyIHZlcnRpY2VzIGFyZSByZXF1aXJlZCBmb3IgcHJvcGVyIGNpcmNsYWdlXG4gICAgdmFyIGFtb3VudCA9IHJlc29sdXRpb24gPyBNYXRoLm1heChyZXNvbHV0aW9uLCAyKSA6IDQ7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcigpKTtcbiAgICB9XG5cbiAgICBQYXRoLmNhbGwodGhpcywgcG9pbnRzLCB0cnVlLCB0cnVlLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI3dpZHRoXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHdpZHRoIG9mIHRoZSBlbGxpcHNlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgcnggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLndpZHRoID0gcnggKiAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI2hlaWdodFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBoZWlnaHQgb2YgdGhlIGVsbGlwc2UuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiByeSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcnkgKiAyO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIHRoaXMudHJhbnNsYXRpb24uc2V0KG94LCBveSk7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKEVsbGlwc2UsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uRWxsaXBzZX0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogWyd3aWR0aCcsICdoZWlnaHQnXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uRWxsaXBzZX0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uRWxsaXBzZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iaik7XG4gICAgICBfLmVhY2goRWxsaXBzZS5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iaik7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoRWxsaXBzZS5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uRWxsaXBzZSNfZmxhZ1dpZHRoXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkVsbGlwc2Ujd2lkdGh9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnV2lkdGg6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5FbGxpcHNlI19mbGFnSGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkVsbGlwc2UjaGVpZ2h0fSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0hlaWdodDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5FbGxpcHNlI3dpZHRofVxuICAgICAqL1xuICAgIF93aWR0aDogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uRWxsaXBzZSNoZWlnaHR9XG4gICAgICovXG4gICAgX2hlaWdodDogMCxcblxuICAgIGNvbnN0cnVjdG9yOiBFbGxpcHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkVsbGlwc2UjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAodGhpcy5fZmxhZ1ZlcnRpY2VzIHx8IHRoaXMuX2ZsYWdXaWR0aCB8fCB0aGlzLl9mbGFnSGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmICghdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDIpIHtcbiAgICAgICAgICBsZW5ndGggLT0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvZWZmaWNpZW50IGZvciBhcHByb3hpbWF0aW5nIGNpcmN1bGFyIGFyY3Mgd2l0aCBCZXppZXIgY3VydmVzXG4gICAgICAgIHZhciBjID0gKDQgLyAzKSAqIE1hdGgudGFuKE1hdGguUEkgLyAodGhpcy52ZXJ0aWNlcy5sZW5ndGggKiAyKSk7XG4gICAgICAgIHZhciByYWRpdXNYID0gdGhpcy5fd2lkdGggLyAyO1xuICAgICAgICB2YXIgcmFkaXVzWSA9IHRoaXMuX2hlaWdodCAvIDI7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBjdCA9IGkgLyBsZW5ndGg7XG4gICAgICAgICAgdmFyIHRoZXRhID0gcGN0ICogVFdPX1BJJDM7XG5cbiAgICAgICAgICB2YXIgeCA9IHJhZGl1c1ggKiBjb3MkMih0aGV0YSk7XG4gICAgICAgICAgdmFyIHkgPSByYWRpdXNZICogc2luJDIodGhldGEpO1xuXG4gICAgICAgICAgdmFyIGx4ID0gcmFkaXVzWCAqIGMgKiBjb3MkMih0aGV0YSAtIEhBTEZfUEkkMSk7XG4gICAgICAgICAgdmFyIGx5ID0gcmFkaXVzWSAqIGMgKiBzaW4kMih0aGV0YSAtIEhBTEZfUEkkMSk7XG5cbiAgICAgICAgICB2YXIgcnggPSByYWRpdXNYICogYyAqIGNvcyQyKHRoZXRhICsgSEFMRl9QSSQxKTtcbiAgICAgICAgICB2YXIgcnkgPSByYWRpdXNZICogYyAqIHNpbiQyKHRoZXRhICsgSEFMRl9QSSQxKTtcblxuICAgICAgICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tpXTtcblxuICAgICAgICAgIHYuY29tbWFuZCA9IGkgPT09IDAgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMuY3VydmU7XG4gICAgICAgICAgdi5zZXQoeCwgeSk7XG4gICAgICAgICAgdi5jb250cm9scy5sZWZ0LnNldChseCwgbHkpO1xuICAgICAgICAgIHYuY29udHJvbHMucmlnaHQuc2V0KHJ4LCByeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkVsbGlwc2UjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnV2lkdGggPSB0aGlzLl9mbGFnSGVpZ2h0ID0gZmFsc2U7XG5cbiAgICAgIFBhdGgucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkVsbGlwc2UjY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5Qb2x5Z29ufVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5Qb2x5Z29ufSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciByeCA9IHRoaXMud2lkdGggLyAyO1xuICAgICAgdmFyIHJ5ID0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyBFbGxpcHNlKDAsIDAsIHJ4LCByeSwgcmVzb2x1dGlvbik7XG5cbiAgICAgIGNsb25lLnRyYW5zbGF0aW9uLmNvcHkodGhpcy50cmFuc2xhdGlvbik7XG4gICAgICBjbG9uZS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XG4gICAgICBjbG9uZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgICBjbG9uZS5za2V3WCA9IHRoaXMuc2tld1g7XG4gICAgICBjbG9uZS5za2V3WSA9IHRoaXMuc2tld1k7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgY2xvbmUubWF0cml4LmNvcHkodGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBfLmVhY2goUGF0aC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihrKSB7XG4gICAgICAgIGNsb25lW2tdID0gdGhpc1trXTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5hZGQoY2xvbmUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkVsbGlwc2UjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBvYmplY3QgPSBQYXRoLnByb3RvdHlwZS50b09iamVjdC5jYWxsKHRoaXMpO1xuXG4gICAgICBfLmVhY2goRWxsaXBzZS5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICBvYmplY3RbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgIH1cblxuICB9KTtcblxuICBFbGxpcHNlLk1ha2VPYnNlcnZhYmxlKEVsbGlwc2UucHJvdG90eXBlKTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLkxpbmVcbiAgICogQGNsYXNzXG4gICAqIEBleHRlbmRzIFR3by5QYXRoXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeDE9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgdmVydGV4IG9uIHRoZSBsaW5lLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3kxPTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIGZpcnN0IHZlcnRleCBvbiB0aGUgbGluZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4Mj0wXSAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzZWNvbmQgdmVydGV4IG9uIHRoZSBsaW5lLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3kyPTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNlY29uZCB2ZXJ0ZXggb24gdGhlIGxpbmUuXG4gICAqL1xuICBmdW5jdGlvbiBMaW5lKHgxLCB5MSwgeDIsIHkyKSB7XG5cbiAgICBQYXRoLmNhbGwodGhpcywgW1xuICAgICAgICBuZXcgQW5jaG9yKHgxLCB5MSksXG4gICAgICAgIG5ldyBBbmNob3IoeDIsIHkyKVxuICAgIF0pO1xuXG4gICAgdGhpcy52ZXJ0aWNlc1swXS5jb21tYW5kID0gQ29tbWFuZHMubW92ZTtcbiAgICB0aGlzLnZlcnRpY2VzWzFdLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuXG4gICAgdGhpcy5hdXRvbWF0aWMgPSBmYWxzZTtcblxuICB9XG5cbiAgXy5leHRlbmQoTGluZS5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogTGluZVxuXG4gIH0pO1xuXG4gIFBhdGguTWFrZU9ic2VydmFibGUoTGluZS5wcm90b3R5cGUpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZVxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3k9MF0gLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGg9MF0gLSBUaGUgd2lkdGggdmFsdWUgb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2hlaWdodD0wXSAtIFRoZSB3aWR0aCB2YWx1ZSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzPTBdIC0gVGhlIHJhZGl1cyB2YWx1ZSBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj0xMl0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHVzZWQgdG8gY29uc3RydWN0IHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICovXG4gIGZ1bmN0aW9uIFJvdW5kZWRSZWN0YW5nbGUob3gsIG95LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpIHtcblxuICAgIGlmICh0eXBlb2YgcmFkaXVzID09PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgaGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgcmFkaXVzID0gTWF0aC5mbG9vcihNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDEyKTtcbiAgICB9XG5cbiAgICB2YXIgYW1vdW50ID0gMTA7XG5cbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuICAgICAgcG9pbnRzLnB1c2goXG4gICAgICAgIG5ldyBBbmNob3IoMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAgICAgICBpID09PSAwID8gQ29tbWFuZHMubW92ZSA6IENvbW1hbmRzLmN1cnZlKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLmNvbW1hbmQgPSBUd28uQ29tbWFuZHMuY2xvc2U7XG5cbiAgICBQYXRoLmNhbGwodGhpcywgcG9pbnRzKTtcblxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9tYXRpYyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIuZmxhZ1JhZGl1cyA9IFJvdW5kZWRSZWN0YW5nbGUuRmxhZ1JhZGl1cy5iaW5kKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgd2lkdGggb2YgdGhlIHJvdW5kZWQgcmVjdGFuZ2xlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjaGVpZ2h0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGhlaWdodCBvZiB0aGUgcm91bmRlZCByZWN0YW5nbGUuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBoZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNyYWRpdXNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgcmFkaXVzIG9mIHRoZSByb3VuZGVkIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIHRoaXMudHJhbnNsYXRpb24uc2V0KG94LCBveSk7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKFJvdW5kZWRSZWN0YW5nbGUsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZX0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogWyd3aWR0aCcsICdoZWlnaHQnXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlLkZsYWdSYWRpdXNcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIEEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gdHJpZ2dlciB0aGUgZmxhZyBmb3IgcmFkaXVzIGNoYW5naW5nLlxuICAgICAqL1xuICAgIEZsYWdSYWRpdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fZmxhZ1JhZGl1cyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZX0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iamVjdCk7XG4gICAgICBfLmVhY2goUm91bmRlZFJlY3RhbmdsZS5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iamVjdCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdyYWRpdXMnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcmFkaXVzIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yYWRpdXMudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdSYWRpdXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3JhZGl1cyA9IHY7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcmFkaXVzIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yYWRpdXMuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnUmFkaXVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9mbGFnUmFkaXVzID0gdHJ1ZTtcblxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChSb3VuZGVkUmVjdGFuZ2xlLnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBSb3VuZGVkUmVjdGFuZ2xlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlJvdW5kZWRSZWN0YW5nbGUjX2ZsYWdXaWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3dpZHRofSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1dpZHRoOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNfZmxhZ0hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI2hlaWdodH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdIZWlnaHQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI19mbGFnUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGUjcmFkaXVzfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1JhZGl1czogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNfd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI3dpZHRofVxuICAgICAqL1xuICAgIF93aWR0aDogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNfaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZSNoZWlnaHR9XG4gICAgICovXG4gICAgX2hlaWdodDogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNfcmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUm91bmRlZFJlY3RhbmdsZSNyYWRpdXN9XG4gICAgICovXG4gICAgX3JhZGl1czogMTIsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnVmVydGljZXMgfHwgdGhpcy5fZmxhZ1dpZHRoIHx8IHRoaXMuX2ZsYWdIZWlnaHQgfHwgdGhpcy5fZmxhZ1JhZGl1cykge1xuXG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuX3dpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5faGVpZ2h0O1xuXG4gICAgICAgIHZhciByeCwgcnk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3JhZGl1cyBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgIHJ4ID0gdGhpcy5fcmFkaXVzLng7XG4gICAgICAgICAgcnkgPSB0aGlzLl9yYWRpdXMueTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByeCA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgICByeSA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2O1xuICAgICAgICB2YXIgdyA9IHdpZHRoIC8gMjtcbiAgICAgICAgdmFyIGggPSBoZWlnaHQgLyAyO1xuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzBdO1xuICAgICAgICB2LnggPSAtICh3IC0gcngpO1xuICAgICAgICB2LnkgPSAtIGg7XG5cbiAgICAgICAgLy8gVXBwZXIgUmlnaHQgQ29ybmVyXG5cbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbMV07XG4gICAgICAgIHYueCA9ICh3IC0gcngpO1xuICAgICAgICB2LnkgPSAtIGg7XG4gICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnggPSByeDtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC55ID0gMDtcblxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1syXTtcbiAgICAgICAgdi54ID0gdztcbiAgICAgICAgdi55ID0gLSAoaCAtIHJ5KTtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC5jbGVhcigpO1xuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcblxuICAgICAgICAvLyBCb3R0b20gUmlnaHQgQ29ybmVyXG5cbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbM107XG4gICAgICAgIHYueCA9IHc7XG4gICAgICAgIHYueSA9IChoIC0gcnkpO1xuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC54ID0gMDtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC55ID0gcnk7XG5cbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbNF07XG4gICAgICAgIHYueCA9ICh3IC0gcngpO1xuICAgICAgICB2LnkgPSBoO1xuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XG4gICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xuXG4gICAgICAgIC8vIEJvdHRvbSBMZWZ0IENvcm5lclxuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzVdO1xuICAgICAgICB2LnggPSAtICh3IC0gcngpO1xuICAgICAgICB2LnkgPSBoO1xuICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC54ID0gLSByeDtcbiAgICAgICAgdi5jb250cm9scy5yaWdodC55ID0gMDtcblxuICAgICAgICB2ID0gdGhpcy52ZXJ0aWNlc1s2XTtcbiAgICAgICAgdi54ID0gLSB3O1xuICAgICAgICB2LnkgPSAoaCAtIHJ5KTtcbiAgICAgICAgdi5jb250cm9scy5sZWZ0LmNsZWFyKCk7XG4gICAgICAgIHYuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcblxuICAgICAgICAvLyBVcHBlciBMZWZ0IENvcm5lclxuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzddO1xuICAgICAgICB2LnggPSAtIHc7XG4gICAgICAgIHYueSA9IC0gKGggLSByeSk7XG4gICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnggPSAwO1xuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnkgPSAtIHJ5O1xuXG4gICAgICAgIHYgPSB0aGlzLnZlcnRpY2VzWzhdO1xuICAgICAgICB2LnggPSAtICh3IC0gcngpO1xuICAgICAgICB2LnkgPSAtIGg7XG4gICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xuICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LmNsZWFyKCk7XG5cbiAgICAgICAgdiA9IHRoaXMudmVydGljZXNbOV07XG4gICAgICAgIHYuY29weSh0aGlzLnZlcnRpY2VzWzhdKTtcblxuICAgICAgfVxuXG4gICAgICBQYXRoLnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Sb3VuZGVkUmVjdGFuZ2xlI2ZsYWdSZXNldFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGRlc2NyaXB0aW9uIENhbGxlZCBpbnRlcm5hbGx5IHRvIHJlc2V0IGFsbCBmbGFncy4gRW5zdXJlcyB0aGF0IG9ubHkgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBhcmUgdXBkYXRlZCBiZWZvcmUgYmVpbmcgc2VudCB0byB0aGUgcmVuZGVyZXIuXG4gICAgICovXG4gICAgZmxhZ1Jlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5fZmxhZ1dpZHRoID0gdGhpcy5fZmxhZ0hlaWdodCA9IHRoaXMuX2ZsYWdSYWRpdXMgPSBmYWxzZTtcbiAgICAgIFBhdGgucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlJvdW5kZWRSZWN0YW5nbGV9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlJvdW5kZWRSZWN0YW5nbGV9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIHZhciByYWRpdXMgPSB0aGlzLnJhZGl1cztcblxuICAgICAgdmFyIGNsb25lID0gbmV3IFJvdW5kZWRSZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKTtcblxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIGNsb25lLnNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIGNsb25lLnNrZXdZID0gdGhpcy5za2V3WTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaChQYXRoLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUm91bmRlZFJlY3RhbmdsZSN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIG9iamVjdCA9IFBhdGgucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgIF8uZWFjaChSb3VuZGVkUmVjdGFuZ2xlLlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBvYmplY3QucmFkaXVzID0gdHlwZW9mIHRoaXMucmFkaXVzID09PSAnbnVtYmVyJ1xuICAgICAgICA/IHRoaXMucmFkaXVzIDogdGhpcy5yYWRpdXMudG9PYmplY3QoKTtcblxuICAgICAgcmV0dXJuIG9iamVjdDtcblxuICAgIH1cblxuICB9KTtcblxuICBSb3VuZGVkUmVjdGFuZ2xlLk1ha2VPYnNlcnZhYmxlKFJvdW5kZWRSZWN0YW5nbGUucHJvdG90eXBlKTtcblxuICB2YXIgbWluID0gTWF0aC5taW4sIG1heCA9IE1hdGgubWF4O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVGV4dFxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlNoYXBlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gLSBUaGUgU3RyaW5nIHRvIGJlIHJlbmRlcmVkIHRvIHRoZSBzY2VuZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHBvc2l0aW9uIGluIHRoZSB4IGRpcmVjdGlvbiBmb3IgdGhlIG9iamVjdC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHBvc2l0aW9uIGluIHRoZSB5IGRpcmVjdGlvbiBmb3IgdGhlIG9iamVjdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIC0gQW4gb2JqZWN0IHdoZXJlIHN0eWxlcyBhcmUgYXBwbGllZC4gQXR0cmlidXRlIG11c3QgZXhpc3QgaW4gVHdvLlRleHQuUHJvcGVydGllcy5cbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgYSBwcmltaXRpdmUgY2xhc3MgZm9yIGNyZWF0aW5nIGRyYXdhYmxlIHRleHQgdGhhdCBjYW4gYmUgYWRkZWQgdG8gdGhlIHNjZW5lZ3JhcGguXG4gICAqIEByZXR1cm5zIHtUd28uVGV4dH1cbiAgICovXG4gIGZ1bmN0aW9uIFRleHQobWVzc2FnZSwgeCwgeSwgc3R5bGVzKSB7XG5cbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIudHlwZSA9ICd0ZXh0JztcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCA9IFRleHQuRmxhZ0ZpbGwuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlci5mbGFnU3Ryb2tlID0gVGV4dC5GbGFnU3Ryb2tlLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLnZhbHVlID0gbWVzc2FnZTtcblxuICAgIGlmICh0eXBlb2YgeCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueCA9IHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueSA9IHk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjZGFzaGVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJbXX0gLSBBcnJheSBvZiBudW1iZXJzLiBPZGQgaW5kaWNlcyByZXByZXNlbnQgZGFzaCBsZW5ndGguIEV2ZW4gaW5kaWNlcyByZXByZXNlbnQgZGFzaCBzcGFjZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQSBsaXN0IG9mIG51bWJlcnMgdGhhdCByZXByZXNlbnQgdGhlIHJlcGVhdGVkIGRhc2ggbGVuZ3RoIGFuZCBkYXNoIHNwYWNlIGFwcGxpZWQgdG8gdGhlIHN0cm9rZSBvZiB0aGUgdGV4dC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3N0cm9rZS1kYXNoYXJyYXl9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZSBTVkcgc3Ryb2tlLWRhc2hhcnJheSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgdGhpcy5kYXNoZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I2Rhc2hlcyNvZmZzZXRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBIG51bWJlciBpbiBwaXhlbHMgdG8gb2Zmc2V0IHtAbGluayBUd28uVGV4dCNkYXNoZXN9IGRpc3BsYXkuXG4gICAgICovXG4gICAgdGhpcy5kYXNoZXMub2Zmc2V0ID0gMDtcblxuICAgIGlmICghXy5pc09iamVjdChzdHlsZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBfLmVhY2goVGV4dC5Qcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wZXJ0eSkge1xuXG4gICAgICBpZiAocHJvcGVydHkgaW4gc3R5bGVzKSB7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gc3R5bGVzW3Byb3BlcnR5XTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuXG4gIH1cblxuICBfLmV4dGVuZChUZXh0LCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dC5SYXRpb1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIEFwcHJveGltYXRlIGFzcGVjdCByYXRpbyBvZiBhIHR5cGVmYWNlJ3MgY2hhcmFjdGVyIHdpZHRoIHRvIGhlaWdodC5cbiAgICAgKi9cbiAgICBSYXRpbzogMC42LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQuUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5UZXh0fS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbXG4gICAgICAndmFsdWUnLCAnZmFtaWx5JywgJ3NpemUnLCAnbGVhZGluZycsICdhbGlnbm1lbnQnLCAnbGluZXdpZHRoJywgJ3N0eWxlJyxcbiAgICAgICd3ZWlnaHQnLCAnZGVjb3JhdGlvbicsICdiYXNlbGluZScsICdvcGFjaXR5JywgJ3Zpc2libGUnLCAnY2xhc3NOYW1lJyxcbiAgICAgICdmaWxsJywgJ3N0cm9rZScsXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0LkZsYWdGaWxsXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHJlbmRlcmVycyBrbm93IHRoZSBmaWxsIHByb3BlcnR5IGhhdmUgYmVlbiB1cGRhdGVkIG9uIGEge0BsaW5rIFR3by5UZXh0fS5cbiAgICAgKi9cbiAgICBGbGFnRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9mbGFnRmlsbCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0LkZsYWdTdHJva2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FjaGVkIG1ldGhvZCB0byBsZXQgcmVuZGVyZXJzIGtub3cgdGhlIHN0cm9rZSBwcm9wZXJ0eSBoYXZlIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uVGV4dH0uXG4gICAgICovXG4gICAgRmxhZ1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9mbGFnU3Ryb2tlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iamVjdCkge1xuXG4gICAgICBTaGFwZS5NYWtlT2JzZXJ2YWJsZShvYmplY3QpO1xuXG4gICAgICBfLmVhY2goVGV4dC5Qcm9wZXJ0aWVzLnNsaWNlKDAsIDEyKSwgZGVmaW5lR2V0dGVyU2V0dGVyLCBvYmplY3QpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnZmlsbCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbihmKSB7XG5cbiAgICAgICAgICBpZiAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwudW5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdGaWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9maWxsID0gZjtcbiAgICAgICAgICB0aGlzLl9mbGFnRmlsbCA9IHRydWU7XG5cbiAgICAgICAgICBpZiAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9maWxsIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fZmlsbCBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbGwuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnRmlsbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnc3Ryb2tlJywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJva2U7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oZikge1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBMaW5lYXJHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZS51bmJpbmQoRXZlbnRzLlR5cGVzLmNoYW5nZSwgdGhpcy5fcmVuZGVyZXIuZmxhZ1N0cm9rZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fc3Ryb2tlID0gZjtcbiAgICAgICAgICB0aGlzLl9mbGFnU3Ryb2tlID0gdHJ1ZTtcblxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBHcmFkaWVudFxuICAgICAgICAgICAgfHwgdGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnRcbiAgICAgICAgICAgIHx8IHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIFJhZGlhbEdyYWRpZW50XG4gICAgICAgICAgICB8fCB0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdHJva2UuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnU3Ryb2tlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsICdtYXNrJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcbiAgICAgICAgfSxcblxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB0aGlzLl9tYXNrID0gdjtcbiAgICAgICAgICB0aGlzLl9mbGFnTWFzayA9IHRydWU7XG4gICAgICAgICAgaWYgKCF2LmNsaXApIHtcbiAgICAgICAgICAgIHYuY2xpcCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCAnY2xpcCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY2xpcDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgdGhpcy5fY2xpcCA9IHY7XG4gICAgICAgICAgdGhpcy5fZmxhZ0NsaXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgJ2Rhc2hlcycsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZGFzaGVzO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHYub2Zmc2V0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdi5vZmZzZXQgPSB0aGlzLl9kYXNoZXMub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2Rhc2hlcyA9IHY7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFRleHQucHJvdG90eXBlLCBTaGFwZS5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBUZXh0LFxuXG4gICAgLy8gRmxhZ3NcbiAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZsYWdcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnVmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCN2YWx1ZX0gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1ZhbHVlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdGYW1pbHlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNmYW1pbHl9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdGYW1pbHk6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ1NpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNzaXplfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU2l6ZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnTGVhZGluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I2xlYWRpbmd9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdMZWFkaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdBbGlnbm1lbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNhbGlnbm1lbnR9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdBbGlnbm1lbnQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0Jhc2VsaW5lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlRleHQjYmFzZWxpbmV9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdCYXNlbGluZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnU3R5bGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNzdHlsZX0gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1N0eWxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdXZWlnaHRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCN3ZWlnaHR9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdXZWlnaHQ6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0RlY29yYXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNkZWNvcmF0aW9ufSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnRGVjb3JhdGlvbjogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnRmlsbFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I2ZpbGx9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdGaWxsOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdTdHJva2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNzdHJva2V9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdTdHJva2U6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0xpbmV3aWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I2xpbmV3aWR0aH0gbmVlZCB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0xpbmV3aWR0aDogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I19mbGFnT3BhY2l0eVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5UZXh0I29wYWNpdHl9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdPcGFjaXR5OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjX2ZsYWdDbGFzc05hbWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNjbGFzc05hbWV9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdDbGFzc05hbWU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ1Zpc2libGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCN2aXNpYmxlfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnVmlzaWJsZTogdHJ1ZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5QYXRoI19mbGFnTWFza1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5QYXRoI21hc2t9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnTWFzazogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZmxhZ0NsaXBcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uVGV4dCNjbGlwfSBuZWVkIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnQ2xpcDogZmFsc2UsXG5cbiAgICAvLyBVbmRlcmx5aW5nIFByb3BlcnRpZXNcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I3ZhbHVlXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmd9IC0gVGhlIGNoYXJhY3RlcnMgdG8gYmUgcmVuZGVyZWQgdG8gdGhlIHRoZSBzY3JlZW4uIFJlZmVycmVkIHRvIGluIHRoZSBkb2N1bWVudGF0aW9uIHNvbWV0aW1lcyBhcyB0aGUgYG1lc3NhZ2VgLlxuICAgICAqL1xuICAgIF92YWx1ZTogJycsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNmYW1pbHlcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBUaGUgZm9udCBmYW1pbHkgVHdvLmpzIHNob3VsZCBhdHRlbXB0IHRvIHJlZ3NpdGVyIGZvciByZW5kZXJpbmcuIFRoZSBkZWZhdWx0IHZhbHVlIGlzIGAnc2Fucy1zZXJpZidgLiBDb21tYSBzZXBhcmF0ZWQgZm9udCBuYW1lcyBjYW4gYmUgc3VwcGxpZWQgYXMgYSBcInN0YWNrXCIsIHNpbWlsYXIgdG8gdGhlIENTUyBpbXBsZW1lbnRhdGlvbiBvZiBgZm9udC1mYW1pbHlgLlxuICAgICAqL1xuICAgIF9mYW1pbHk6ICdzYW5zLXNlcmlmJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I3NpemVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgZm9udCBzaXplIGluIFR3by5qcyBwb2ludCBzcGFjZS4gRGVmYXVsdHMgdG8gYDEzYC5cbiAgICAgKi9cbiAgICBfc2l6ZTogMTMsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNsZWFkaW5nXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGhlaWdodCBiZXR3ZWVuIGxpbmVzIG1lYXN1cmVkIGZyb20gYmFzZSB0byBiYXNlIGluIFR3by5qcyBwb2ludCBzcGFjZS4gRGVmYXVsdHMgdG8gYDE3YC5cbiAgICAgKi9cbiAgICBfbGVhZGluZzogMTcsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNhbGlnbm1lbnRcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBBbGlnbm1lbnQgb2YgdGV4dCBpbiByZWxhdGlvbiB0byB7QGxpbmsgVHdvLlRleHQjdHJhbnNsYXRpb259J3MgY29vcmRpbmF0ZXMuIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlIGAnbGVmdCdgLCBgJ2NlbnRlcidgLCBgJ3JpZ2h0J2AuIERlZmF1bHRzIHRvIGAnY2VudGVyJ2AuXG4gICAgICovXG4gICAgX2FsaWdubWVudDogJ2NlbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNiYXNlbGluZVxuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nfSAtIFRoZSB2ZXJ0aWNhbCBhbGlnbWVudCBvZiB0aGUgdGV4dCBpbiByZWxhdGlvbiB0byB7QGxpbmsgVHdvLlRleHQjdHJhbnNsYXRpb259J3MgY29vcmRpbmF0ZXMuIFBvc3NpYmxlIHZhbHVlcyBpbmNsdWRlIGAndG9wJ2AsIGAnbWlkZGxlJ2AsIGAnYm90dG9tJ2AsIGFuZCBgJ2Jhc2VsaW5lJ2AuIERlZmF1bHRzIHRvIGAnYmFzZWxpbmUnYC5cbiAgICAgKi9cbiAgICBfYmFzZWxpbmU6ICdtaWRkbGUnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjc3R5bGVcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBUaGUgZm9udCdzIHN0eWxlLiBQb3NzaWJsZSB2YWx1ZXMgaW5jbHVkZSAnYG5vcm1hbGAnLCBgJ2l0YWxpYydgLiBEZWZhdWx0cyB0byBgJ25vcm1hbCdgLlxuICAgICAqL1xuICAgIF9zdHlsZTogJ25vcm1hbCcsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCN3ZWlnaHRcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBIG51bWJlciBhdCBpbnRlcnZhbHMgb2YgMTAwIHRvIGRlc2NyaWJlIHRoZSBmb250J3Mgd2VpZ2h0LiBUaGlzIGNvbXBhdGliaWxpdHkgdmFyaWVzIHdpdGggdGhlIHR5cGVmYWNlJ3MgdmFyaWFudCB3ZWlnaHRzLiBMYXJnZXIgdmFsdWVzIGFyZSBib2xkZXIuIFNtYWxsZXIgdmFsdWVzIGFyZSB0aGlubmVyLiBEZWZhdWx0cyB0byBgJzUwMCdgLlxuICAgICAqL1xuICAgIF93ZWlnaHQ6IDUwMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I2RlY29yYXRpb25cbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBTdHJpbmcgdG8gZGVsaW5lYXRlIHdoZXRoZXIgdGV4dCBzaG91bGQgYmUgZGVjb3JhdGVkIHdpdGggZm9yIGluc3RhbmNlIGFuIGAndW5kZXJsaW5lJ2AuIERlZmF1bHRzIHRvIGAnbm9uZSdgLlxuICAgICAqL1xuICAgIF9kZWNvcmF0aW9uOiAnbm9uZScsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNmaWxsXG4gICAgICogQHByb3BlcnR5IHsoU3RyaW5nfFR3by5HcmFkaWVudHxUd28uVGV4dHVyZSl9IC0gVGhlIHZhbHVlIG9mIHdoYXQgdGhlIHRleHQgb2JqZWN0IHNob3VsZCBiZSBmaWxsZWQgaW4gd2l0aC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENTUydzIGNvbG9ycyBhcyBgU3RyaW5nYC5cbiAgICAgKi9cbiAgICBfZmlsbDogJyMwMDAnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjc3Ryb2tlXG4gICAgICogQHByb3BlcnR5IHsoU3RyaW5nfFR3by5HcmFkaWVudHxUd28uVGV4dHVyZSl9IC0gVGhlIHZhbHVlIG9mIHdoYXQgdGhlIHRleHQgb2JqZWN0IHNob3VsZCBiZSBmaWxsZWQgaW4gd2l0aC5cbiAgICAgKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvY29sb3JfdmFsdWV9IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIENTUydzIGNvbG9ycyBhcyBgU3RyaW5nYC5cbiAgICAgKi9cbiAgICBfc3Ryb2tlOiAndHJhbnNwYXJlbnQnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjbGluZXdpZHRoXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHRoaWNrbmVzcyBpbiBwaXhlbHMgb2YgdGhlIHN0cm9rZS5cbiAgICAgKi9cbiAgICBfbGluZXdpZHRoOiAxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjb3BhY2l0eVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBvcGFxdWVuZXNzIG9mIHRoZSB0ZXh0IG9iamVjdC5cbiAgICAgKiBAbm90YS1iZW5lIENhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggQ1NTIENvbG9ycyB0aGF0IGhhdmUgYW4gYWxwaGEgdmFsdWUuXG4gICAgICovXG4gICAgX29wYWNpdHk6IDEsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNjbGFzc05hbWVcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBBIGNsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgdG8gYmUgY29tcGF0aWJsZSB3aXRoIENTUyBzdHlsaW5nLiBPbmx5IGF2YWlsYWJsZSBmb3IgdGhlIHtAbGluayBUd28uU3ZnUmVuZGVyZXJ9LlxuICAgICAqL1xuICAgIF9jbGFzc05hbWU6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjdmlzaWJsZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEaXNwbGF5IHRoZSB0ZXh0IG9iamVjdCBvciBub3QuXG4gICAgICogQG5vdGEtYmVuZSBGb3Ige0BsaW5rIFR3by5DYW52YXNSZW5kZXJlcn0gYW5kIHtAbGluayBUd28uV2ViR0xSZW5kZXJlcn0gd2hlbiBzZXQgdG8gZmFsc2UgYWxsIHVwZGF0aW5nIGlzIGRpc2FibGVkIGltcHJvdmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgd2l0aCBtYW55IG9iamVjdHMgaW4gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIF92aXNpYmxlOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjbWFza1xuICAgICAqIEBwcm9wZXJ0eSB7VHdvLlNoYXBlfSAtIFRoZSBzaGFwZSB3aG9zZSBhbHBoYSBwcm9wZXJ0eSBiZWNvbWVzIGEgY2xpcHBpbmcgYXJlYSBmb3IgdGhlIHRleHQuXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIHByb3BlcnR5IGlzIGN1cnJlbnRseSBub3Qgd29ya2luZyBiZWN1YXNlIG9mIFNWRyBzcGVjIGlzc3VlcyBmb3VuZCBoZXJlIHtAbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzcwOTUxfS5cbiAgICAgKi9cbiAgICBfbWFzazogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I2NsaXBcbiAgICAgKiBAcHJvcGVydHkge1R3by5TaGFwZX0gLSBPYmplY3QgdG8gZGVmaW5lIGNsaXBwaW5nIGFyZWEuXG4gICAgICogQG5vdGEtYmVuZSBUaGlzIHByb3BlcnR5IGlzIGN1cnJlbnRseSBub3Qgd29ya2luZyBiZWN1YXNlIG9mIFNWRyBzcGVjIGlzc3VlcyBmb3VuZCBoZXJlIHtAbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzcwOTUxfS5cbiAgICAgKi9cbiAgICBfY2xpcDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNfZGFzaGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uVGV4dCNkYXNoZXN9XG4gICAgICovXG4gICAgX2Rhc2hlczogW10sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNyZW1vdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIHNlbGYgZnJvbSB0aGUgc2NlbmUgLyBwYXJlbnQuXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVGV4dCNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlRleHR9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLlRleHR9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCB0ZXh0IG9iamVjdC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBUZXh0KHRoaXMudmFsdWUpO1xuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcblxuICAgICAgXy5lYWNoKFRleHQuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgY2xvbmVbcHJvcGVydHldID0gdGhpc1twcm9wZXJ0eV07XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZS5fdXBkYXRlKCk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjdG9PYmplY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSBKU09OIGNvbXBhdGlibGUgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgdGV4dCBvYmplY3QuXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICB0cmFuc2xhdGlvbjogdGhpcy50cmFuc2xhdGlvbi50b09iamVjdCgpLFxuICAgICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGVcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeC5tYW51YWwpIHtcbiAgICAgICAgcmVzdWx0Lm1hdHJpeCA9IHRoaXMubWF0cml4LnRvT2JqZWN0KCk7XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaChUZXh0LlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIHJlc3VsdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I25vRmlsbFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBTaG9ydCBoYW5kIG1ldGhvZCB0byBzZXQgZmlsbCB0byBgdHJhbnNwYXJlbnRgLlxuICAgICAqL1xuICAgIG5vRmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmZpbGwgPSAndHJhbnNwYXJlbnQnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5UZXh0I25vU3Ryb2tlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFNob3J0IGhhbmQgbWV0aG9kIHRvIHNldCBzdHJva2UgdG8gYHRyYW5zcGFyZW50YC5cbiAgICAgKi9cbiAgICBub1N0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnN0cm9rZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMubGluZXdpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEEgc2hpbSB0byBub3QgYnJlYWsgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgY2FsbHMuXG4gICAgLy8gVE9ETzogSW1wbGVtZW50IGEgd2F5IHRvIGNhbGN1bGF0ZSBwcm9wZXIgYm91bmRpbmdcbiAgICAvLyBib3hlcyBvZiBgVHdvLlRleHRgLlxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbc2hhbGxvdz1mYWxzZV0gLSBEZXNjcmliZXMgd2hldGhlciB0byBjYWxjdWxhdGUgb2ZmIGxvY2FsIG1hdHJpeCBvciB3b3JsZCBtYXRyaXguXG4gICAgICogQHJldHVybnMge09iamVjdH0gLSBSZXR1cm5zIG9iamVjdCB3aXRoIHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgd2lkdGgsIGhlaWdodCBhdHRyaWJ1dGVzLlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYW4gb2JqZWN0IHdpdGggdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCB3aWR0aCwgYW5kIGhlaWdodCBwYXJhbWV0ZXJzIG9mIHRoZSB0ZXh0IG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uKHNoYWxsb3cpIHtcblxuICAgICAgdmFyIG1hdHJpeCwgYSwgYiwgYywgZDtcbiAgICAgIHZhciBsZWZ0LCByaWdodCwgdG9wLCBib3R0b207XG5cbiAgICAgIC8vIFRPRE86IFVwZGF0ZSB0aGlzIHRvIG5vdCBfX2Fsd2F5c19fIHVwZGF0ZS4gSnVzdCB3aGVuIGl0IG5lZWRzIHRvLlxuICAgICAgdGhpcy5fdXBkYXRlKHRydWUpO1xuXG4gICAgICBtYXRyaXggPSBzaGFsbG93ID8gdGhpcy5fbWF0cml4IDogZ2V0Q29tcHV0ZWRNYXRyaXgodGhpcyk7XG5cbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmxlYWRpbmc7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLnZhbHVlLmxlbmd0aCAqIHRoaXMuc2l6ZSAqIFRleHQuUmF0aW87XG4gICAgICB2YXIgYm9yZGVyID0gKHRoaXMuX2xpbmV3aWR0aCB8fCAwKSAvIDI7XG5cbiAgICAgIHN3aXRjaCAodGhpcy5hbGlnbm1lbnQpIHtcbiAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgbGVmdCA9IC0gYm9yZGVyO1xuICAgICAgICAgIHJpZ2h0ID0gd2lkdGggKyBib3JkZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBsZWZ0ID0gLSAod2lkdGggKyBib3JkZXIpO1xuICAgICAgICAgIHJpZ2h0ID0gYm9yZGVyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxlZnQgPSAtICh3aWR0aCAvIDIgKyBib3JkZXIpO1xuICAgICAgICAgIHJpZ2h0ID0gd2lkdGggLyAyICsgYm9yZGVyO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuYmFzZWxpbmUpIHtcbiAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICB0b3AgPSAtIGJvcmRlcjtcbiAgICAgICAgICBib3R0b20gPSBoZWlnaHQgKyBib3JkZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgdG9wID0gLSAoaGVpZ2h0ICsgYm9yZGVyKTtcbiAgICAgICAgICBib3R0b20gPSBib3JkZXI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdG9wID0gLSAoaGVpZ2h0IC8gMiArIGJvcmRlcik7XG4gICAgICAgICAgYm90dG9tID0gaGVpZ2h0IC8gMiArIGJvcmRlcjtcbiAgICAgIH1cblxuICAgICAgYSA9IG1hdHJpeC5tdWx0aXBseShsZWZ0LCB0b3AsIDEpO1xuICAgICAgYiA9IG1hdHJpeC5tdWx0aXBseShsZWZ0LCBib3R0b20sIDEpO1xuICAgICAgYyA9IG1hdHJpeC5tdWx0aXBseShyaWdodCwgdG9wLCAxKTtcbiAgICAgIGQgPSBtYXRyaXgubXVsdGlwbHkocmlnaHQsIGJvdHRvbSwgMSk7XG5cbiAgICAgIHRvcCA9IG1pbihhLnksIGIueSwgYy55LCBkLnkpO1xuICAgICAgbGVmdCA9IG1pbihhLngsIGIueCwgYy54LCBkLngpO1xuICAgICAgcmlnaHQgPSBtYXgoYS54LCBiLngsIGMueCwgZC54KTtcbiAgICAgIGJvdHRvbSA9IG1heChhLnksIGIueSwgYy55LCBkLnkpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgd2lkdGg6IHJpZ2h0IC0gbGVmdCxcbiAgICAgICAgaGVpZ2h0OiBib3R0b20gLSB0b3BcbiAgICAgIH07XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlRleHQjZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnVmFsdWUgPSB0aGlzLl9mbGFnRmFtaWx5ID0gdGhpcy5fZmxhZ1NpemUgPVxuICAgICAgICB0aGlzLl9mbGFnTGVhZGluZyA9IHRoaXMuX2ZsYWdBbGlnbm1lbnQgPSB0aGlzLl9mbGFnRmlsbCA9XG4gICAgICAgIHRoaXMuX2ZsYWdTdHJva2UgPSB0aGlzLl9mbGFnTGluZXdpZHRoID0gdGhpcy5fZmxhZ09wYWNpdHkgPVxuICAgICAgICB0aGlzLl9mbGFnVmlzaWJsZSA9IHRoaXMuX2ZsYWdDbGlwID0gdGhpcy5fZmxhZ0RlY29yYXRpb24gPVxuICAgICAgICB0aGlzLl9mbGFnQ2xhc3NOYW1lID0gdGhpcy5fZmxhZ0Jhc2VsaW5lID0gdGhpcy5fZmxhZ1dlaWdodCA9XG4gICAgICAgICAgdGhpcy5fZmxhZ1N0eWxlID0gZmFsc2U7XG5cbiAgICAgIFNoYXBlLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgVGV4dC5NYWtlT2JzZXJ2YWJsZShUZXh0LnByb3RvdHlwZSk7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2pvbm9icjEvdHdvLmpzL2lzc3Vlcy81MDcjaXNzdWVjb21tZW50LTc3NzE1OTIxM1xuICB2YXIgcmVnZXggPSB7XG4gICAgcGF0aDogL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkKykoPzpbZUVdWystXVxcZCspPy9nXG4gIH07XG5cbiAgdmFyIGFsaWdubWVudHMgPSB7XG4gICAgc3RhcnQ6ICdsZWZ0JyxcbiAgICBtaWRkbGU6ICdjZW50ZXInLFxuICAgIGVuZDogJ3JpZ2h0J1xuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0QWxpZ25tZW50XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge0FsaWdubWVudFN0cmluZ31cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvU1ZHL0F0dHJpYnV0ZS90ZXh0LWFuY2hvcn1cbiAgICovXG4gIHZhciBnZXRBbGlnbm1lbnQgPSBmdW5jdGlvbihhbmNob3IpIHtcbiAgICByZXR1cm4gYWxpZ25tZW50c1thbmNob3JdO1xuICB9O1xuXG4gIHZhciBnZXRCYXNlbGluZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkb21pbmFudC1iYXNlbGluZScpO1xuICAgIHZhciBiID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2FsaWdubWVudC1iYXNlbGluZScpO1xuICAgIHJldHVybiBhIHx8IGI7XG4gIH07XG5cbiAgdmFyIGdldFRhZ05hbWUgPSBmdW5jdGlvbih0YWcpIHtcbiAgICByZXR1cm4gdGFnLnJlcGxhY2UoL3N2ZzovaWcsICcnKS50b0xvd2VyQ2FzZSgpO1xuICB9O1xuXG4gIHZhciBhcHBseVRyYW5zZm9ybXNUb1ZlY3RvciA9IGZ1bmN0aW9uKHRyYW5zZm9ybXMsIHZlY3Rvcikge1xuXG4gICAgdmVjdG9yLnggKz0gdHJhbnNmb3Jtcy50cmFuc2xhdGVYO1xuICAgIHZlY3Rvci55ICs9IHRyYW5zZm9ybXMudHJhbnNsYXRlWTtcblxuICAgIHZlY3Rvci54ICo9IHRyYW5zZm9ybXMuc2NhbGVYO1xuICAgIHZlY3Rvci55ICo9IHRyYW5zZm9ybXMuc2NhbGVZO1xuXG4gICAgaWYgKHRyYW5zZm9ybXMucm90YXRpb24gIT09IDApIHtcbiAgICAgIC8vIFRPRE86IFRlc3QgZnVydGhlclxuICAgICAgdmFyIGwgPSB2ZWN0b3IubGVuZ3RoKCk7XG4gICAgICB2ZWN0b3IueCA9IGwgKiBNYXRoLmNvcyh0cmFuc2Zvcm1zLnJvdGF0aW9uKTtcbiAgICAgIHZlY3Rvci55ID0gbCAqIE1hdGguc2luKHRyYW5zZm9ybXMucm90YXRpb24pO1xuICAgIH1cblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZXh0cmFjdENTU1RleHRcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IC0gVGhlIENTUyB0ZXh0IGJvZHkgdG8gYmUgcGFyc2VkIGFuZCBleHRyYWN0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVzXSAtIFRoZSBzdHlsZXMgb2JqZWN0IHRvIGFwcGx5IENTUyBrZXkgdmFsdWVzIHRvLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdHlsZXNcbiAgICogQGRlc2NyaXB0aW9uIFBhcnNlIENTUyB0ZXh0IGJvZHkgYW5kIGFwcGx5IHRoZW0gYXMga2V5IHZhbHVlIHBhaXJzIHRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAqL1xuICB2YXIgZXh0cmFjdENTU1RleHQgPSBmdW5jdGlvbih0ZXh0LCBzdHlsZXMpIHtcblxuICAgIHZhciBjb21tYW5kcywgY29tbWFuZCwgbmFtZSwgdmFsdWU7XG5cbiAgICBpZiAoIXN0eWxlcykge1xuICAgICAgc3R5bGVzID0ge307XG4gICAgfVxuXG4gICAgY29tbWFuZHMgPSB0ZXh0LnNwbGl0KCc7Jyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbW1hbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb21tYW5kID0gY29tbWFuZHNbaV0uc3BsaXQoJzonKTtcbiAgICAgIG5hbWUgPSBjb21tYW5kWzBdO1xuICAgICAgdmFsdWUgPSBjb21tYW5kWzFdO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgc3R5bGVzW25hbWVdID0gdmFsdWUucmVwbGFjZSgvXFxzLywgJycpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlV0aWxzLmdldFN2Z1N0eWxlc1xuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBub2RlIC0gVGhlIFNWRyBub2RlIHRvIHBhcnNlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBzdHlsZXNcbiAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgQ1NTIGNvbWFuZHMgZnJvbSB0aGUgYHN0eWxlYCBhdHRyaWJ1dGUgb2YgYW4gU1ZHIG5vZGUgYW5kIGFwcGx5IHRoZW0gYXMga2V5IHZhbHVlIHBhaXJzIHRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAqL1xuICB2YXIgZ2V0U3ZnU3R5bGVzID0gZnVuY3Rpb24obm9kZSkge1xuXG4gICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZ2V0U3ZnQXR0cmlidXRlcyhub2RlKTtcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoYXR0cmlidXRlcy5sZW5ndGgsIG5vZGUuc3R5bGUubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgdmFyIGNvbW1hbmQgPSBub2RlLnN0eWxlW2ldO1xuICAgICAgdmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbaV07XG5cbiAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgIHN0eWxlc1tjb21tYW5kXSA9IG5vZGUuc3R5bGVbY29tbWFuZF07XG4gICAgICB9XG4gICAgICBpZiAoYXR0cmlidXRlKSB7XG4gICAgICAgIHN0eWxlc1thdHRyaWJ1dGVdID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZXM7XG5cbiAgfTtcblxuICB2YXIgZ2V0U3ZnQXR0cmlidXRlcyA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5nZXRBdHRyaWJ1dGVOYW1lcygpO1xuXG4gICAgLy8gUmVzZXJ2ZWQgYXR0cmlidXRlcyB0byByZW1vdmVcbiAgICB2YXIga2V5d29yZHMgPSBbJ2lkJywgJ2NsYXNzJywgJ3RyYW5zZm9ybScsICd4bWxucycsICd2aWV3Qm94J107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXdvcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5d29yZCA9IGtleXdvcmRzW2ldO1xuICAgICAgdmFyIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChhdHRyaWJ1dGVzLCBrZXl3b3JkKTtcbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXR0cmlidXRlcztcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuYXBwbHlTdmdWaWV3Qm94XG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1R3by5TaGFwZX0gbm9kZSAtIFRoZSBUd28uanMgb2JqZWN0IHRvIGFwcGx5IHZpZXdib3ggbWF0cml4IHRvXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSAtIFRoZSB2aWV3Qm94IHZhbHVlIGZyb20gdGhlIFNWRyBhdHRyaWJ1dGVcbiAgICogQHJldHVybnMge1R3by5TaGFwZX0gbm9kZVxuICAgKiBAZGVzY3JpcHRpb24gQXBwbGllcyB0aGUgdHJhbnNmb3JtIG9mIHRoZSBTVkcgVmlld2JveCBvbiBhIGdpdmVuIG5vZGUuXG4gICAqL1xuICB2YXIgYXBwbHlTdmdWaWV3Qm94ID0gZnVuY3Rpb24obm9kZSwgdmFsdWUpIHtcblxuICAgIHZhciBlbGVtZW50cyA9IHZhbHVlLnNwbGl0KC9cXHMvKTtcblxuICAgIHZhciB4ID0gcGFyc2VGbG9hdChlbGVtZW50c1swXSk7XG4gICAgdmFyIHkgPSBwYXJzZUZsb2F0KGVsZW1lbnRzWzFdKTtcbiAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KGVsZW1lbnRzWzJdKTtcbiAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChlbGVtZW50c1szXSk7XG5cbiAgICB2YXIgcyA9IE1hdGgubWluKHRoaXMud2lkdGggLyB3aWR0aCwgdGhpcy5oZWlnaHQgLyBoZWlnaHQpO1xuXG4gICAgbm9kZS50cmFuc2xhdGlvbi54IC09IHggKiBzO1xuICAgIG5vZGUudHJhbnNsYXRpb24ueSAtPSB5ICogcztcbiAgICBub2RlLnNjYWxlID0gcztcblxuICAgIHJldHVybiBub2RlO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5hcHBseVN2Z0F0dHJpYnV0ZXNcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gbm9kZSAtIEFuIFNWRyBOb2RlIHRvIGV4dHJhcG9sYXRlIGF0dHJpYnV0ZXMgZnJvbS5cbiAgICogQHBhcmFtIHtUd28uU2hhcGV9IGVsZW0gLSBUaGUgVHdvLmpzIG9iamVjdCB0byBhcHBseSBleHRyYXBvbGF0ZWQgYXR0cmlidXRlcyB0by5cbiAgICogQHJldHVybnMge1R3by5TaGFwZX0gVGhlIFR3by5qcyBvYmplY3QgcGFzc2VkIG5vdyB3aXRoIGFwcGxpZWQgYXR0cmlidXRlcy5cbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gaXRlcmF0ZXMgdGhyb3VnaCBhbiBTVkcgTm9kZSdzIHByb3BlcnRpZXMgYW5kIHN0b3JlcyBvbmVzIG9mIGludGVyZXN0LiBJdCB0cmllcyB0byByZXNvbHZlIHN0eWxlcyBhcHBsaWVkIHZpYSBDU1MgYXMgd2VsbC5cbiAgICogQFRPRE8gUmV2ZXJzZSBjYWxjdWxhdGUge0BsaW5rIFR3by5HcmFkaWVudH1zIGZvciBmaWxsIC8gc3Ryb2tlIG9mIGFueSBnaXZlbiBwYXRoLlxuICAgKi9cbiAgdmFyIGFwcGx5U3ZnQXR0cmlidXRlcyA9IGZ1bmN0aW9uKG5vZGUsIGVsZW0sIHBhcmVudFN0eWxlcykge1xuXG4gICAgdmFyIHN0eWxlcyA9IHt9LCBhdHRyaWJ1dGVzID0ge30sIGV4dHJhY3RlZCA9IHt9LCBpLCBtLCBrZXksIHZhbHVlLCBhdHRyO1xuICAgIHZhciB0cmFuc2Zvcm1zLCB4LCB5O1xuICAgIHZhciBpZCwgc2NlbmUsIHJlZiwgdGFnTmFtZTtcblxuICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gbm9uIGJyb3dzZXIgZW52aXJvbm1lbnRzXG4gICAgaWYgKHJvb3QkMS5nZXRDb21wdXRlZFN0eWxlKSB7XG4gICAgICAvLyBDb252ZXJ0IENTU1N0eWxlRGVjbGFyYXRpb24gdG8gYSBub3JtYWwgb2JqZWN0XG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZXMgPSByb290JDEuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgIGkgPSBjb21wdXRlZFN0eWxlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAga2V5ID0gY29tcHV0ZWRTdHlsZXNbaV07XG4gICAgICAgIHZhbHVlID0gY29tcHV0ZWRTdHlsZXNba2V5XTtcbiAgICAgICAgLy8gR2Vja28gcmV0dXJucyB1bmRlZmluZWQgZm9yIHVuc2V0IHByb3BlcnRpZXNcbiAgICAgICAgLy8gV2Via2l0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBzdHlsZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBOb2RlTWFwIHRvIGEgbm9ybWFsIG9iamVjdFxuICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICBpZiAoL3N0eWxlL2kudGVzdChhdHRyLm5vZGVOYW1lKSkge1xuICAgICAgICBleHRyYWN0Q1NTVGV4dChhdHRyLnZhbHVlLCBleHRyYWN0ZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cmlidXRlc1thdHRyLm5vZGVOYW1lXSA9IGF0dHIudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0dGluZyB0aGUgY29ycmVjdCBvcGFjaXR5IGlzIGEgYml0IHRyaWNreSwgc2luY2UgU1ZHIHBhdGggZWxlbWVudHMgZG9uJ3RcbiAgICAvLyBzdXBwb3J0IG9wYWNpdHkgYXMgYW4gYXR0cmlidXRlLCBidXQgeW91IGNhbiBhcHBseSBpdCB2aWEgQ1NTLlxuICAgIC8vIFNvIHdlIHRha2UgdGhlIG9wYWNpdHkgYW5kIHNldCAoc3Ryb2tlL2ZpbGwpLW9wYWNpdHkgdG8gdGhlIHNhbWUgdmFsdWUuXG4gICAgaWYgKHR5cGVvZiBzdHlsZXMub3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHN0eWxlc1snc3Ryb2tlLW9wYWNpdHknXSA9IHN0eWxlcy5vcGFjaXR5O1xuICAgICAgc3R5bGVzWydmaWxsLW9wYWNpdHknXSA9IHN0eWxlcy5vcGFjaXR5O1xuICAgICAgZGVsZXRlIHN0eWxlcy5vcGFjaXR5O1xuICAgIH1cblxuICAgIC8vIE1lcmdlIGF0dHJpYnV0ZXMgYW5kIGFwcGxpZWQgc3R5bGVzIChhdHRyaWJ1dGVzIHRha2UgcHJlY2VkZW5jZSlcbiAgICBpZiAocGFyZW50U3R5bGVzKSB7XG4gICAgICBfLmRlZmF1bHRzKHN0eWxlcywgcGFyZW50U3R5bGVzKTtcbiAgICB9XG4gICAgXy5leHRlbmQoc3R5bGVzLCBleHRyYWN0ZWQsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gU2ltaWxhcmx5IHZpc2liaWxpdHkgaXMgaW5mbHVlbmNlZCBieSB0aGUgdmFsdWUgb2YgYm90aCBkaXNwbGF5IGFuZCB2aXNpYmlsaXR5LlxuICAgIC8vIENhbGN1bGF0ZSBhIHVuaWZpZWQgdmFsdWUgaGVyZSB3aGljaCBkZWZhdWx0cyB0byBgdHJ1ZWAuXG4gICAgc3R5bGVzLnZpc2libGUgPSAhKHR5cGVvZiBzdHlsZXMuZGlzcGxheSA9PT0gJ3VuZGVmaW5lZCcgJiYgL25vbmUvaS50ZXN0KHN0eWxlcy5kaXNwbGF5KSlcbiAgICAgIHx8ICh0eXBlb2Ygc3R5bGVzLnZpc2liaWxpdHkgPT09ICd1bmRlZmluZWQnICYmIC9oaWRkZW4vaS50ZXN0KHN0eWxlcy52aXNpYmlsaXR5KSk7XG5cbiAgICAvLyBOb3cgaXRlcmF0ZSB0aGUgd2hvbGUgdGhpbmdcbiAgICBmb3IgKGtleSBpbiBzdHlsZXMpIHtcbiAgICAgIHZhbHVlID0gc3R5bGVzW2tleV07XG5cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgJ2dyYWRpZW50VHJhbnNmb3JtJzpcbiAgICAgICAgICAvLyBUT0RPOiBDaGVjayB0aGlzIG91dCBodHRwczovL2dpdGh1Yi5jb20vcGFwZXJqcy9wYXBlci5qcy9ibG9iL2RldmVsb3Avc3JjL3N2Zy9TdmdJbXBvcnQuanMjTDMxNVxuICAgICAgICAgIGlmICgvbm9uZS9pLnRlc3QodmFsdWUpKSBicmVhaztcbiAgICAgICAgICBtID0gKG5vZGUuZ3JhZGllbnRUcmFuc2Zvcm0gJiYgbm9kZS5ncmFkaWVudFRyYW5zZm9ybS5iYXNlVmFsICYmIG5vZGUuZ3JhZGllbnRUcmFuc2Zvcm0uYmFzZVZhbC5sZW5ndGggPiAwKVxuICAgICAgICAgICAgPyBub2RlLmdyYWRpZW50VHJhbnNmb3JtLmJhc2VWYWxbMF0ubWF0cml4XG4gICAgICAgICAgICA6IChub2RlLmdldENUTSA/IG5vZGUuZ2V0Q1RNKCkgOiBudWxsKTtcblxuICAgICAgICAgIGlmIChtID09PSBudWxsKSBicmVhaztcblxuICAgICAgICAgIHRyYW5zZm9ybXMgPSBkZWNvbXBvc2VNYXRyaXgobSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGVsZW0uX3JlbmRlcmVyLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2xpbmVhci1ncmFkaWVudCc6XG4gICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3Jtc1RvVmVjdG9yKHRyYW5zZm9ybXMsIGVsZW0ubGVmdCk7XG4gICAgICAgICAgICAgIGFwcGx5VHJhbnNmb3Jtc1RvVmVjdG9yKHRyYW5zZm9ybXMsIGVsZW0ucmlnaHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JhZGlhbC1ncmFkaWVudCc6XG4gICAgICAgICAgICAgIGVsZW0uY2VudGVyLnggKz0gdHJhbnNmb3Jtcy50cmFuc2xhdGVYO1xuICAgICAgICAgICAgICBlbGVtLmNlbnRlci55ICs9IHRyYW5zZm9ybXMudHJhbnNsYXRlWTtcblxuICAgICAgICAgICAgICBlbGVtLmZvY2FsLnggKz0gdHJhbnNmb3Jtcy50cmFuc2xhdGVYO1xuICAgICAgICAgICAgICBlbGVtLmZvY2FsLnkgKz0gdHJhbnNmb3Jtcy50cmFuc2xhdGVZO1xuXG4gICAgICAgICAgICAgIGVsZW0ucmFkaXVzICo9IE1hdGgubWF4KHRyYW5zZm9ybXMuc2NhbGVYLCB0cmFuc2Zvcm1zLnNjYWxlWSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0cmFuc2Zvcm0nOlxuICAgICAgICAgIC8vIFRPRE86IENoZWNrIHRoaXMgb3V0IGh0dHBzOi8vZ2l0aHViLmNvbS9wYXBlcmpzL3BhcGVyLmpzL2Jsb2IvZGV2ZWxvcC9zcmMvc3ZnL1N2Z0ltcG9ydC5qcyNMMzE1XG4gICAgICAgICAgaWYgKC9ub25lL2kudGVzdCh2YWx1ZSkpIGJyZWFrO1xuICAgICAgICAgIG0gPSAobm9kZS50cmFuc2Zvcm0gJiYgbm9kZS50cmFuc2Zvcm0uYmFzZVZhbCAmJiBub2RlLnRyYW5zZm9ybS5iYXNlVmFsLmxlbmd0aCA+IDApXG4gICAgICAgICAgICA/IG5vZGUudHJhbnNmb3JtLmJhc2VWYWxbMF0ubWF0cml4XG4gICAgICAgICAgICA6IChub2RlLmdldENUTSA/IG5vZGUuZ2V0Q1RNKCkgOiBudWxsKTtcblxuICAgICAgICAgIC8vIE1pZ2h0IGhhcHBlbiB3aGVuIHRyYW5zZm9ybSBzdHJpbmcgaXMgZW1wdHkgb3Igbm90IHZhbGlkLlxuICAgICAgICAgIGlmIChtID09PSBudWxsKSBicmVhaztcblxuICAgICAgICAgIGlmIChDb25zdGFudHMuQXV0b0NhbGN1bGF0ZUltcG9ydGVkTWF0cmljZXMpIHtcblxuICAgICAgICAgICAgLy8gRGVjb21wb3NlIGFuZCBpbmZlciBUd28uanMgcmVsYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdHJhbnNmb3JtcyA9IGRlY29tcG9zZU1hdHJpeChtKTtcblxuICAgICAgICAgICAgZWxlbS50cmFuc2xhdGlvbi5zZXQodHJhbnNmb3Jtcy50cmFuc2xhdGVYLCB0cmFuc2Zvcm1zLnRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgZWxlbS5yb3RhdGlvbiA9IE1hdGguUEkgKiAodHJhbnNmb3Jtcy5yb3RhdGlvbiAvIDE4MCk7XG4gICAgICAgICAgICBlbGVtLnNjYWxlID0gbmV3IFZlY3Rvcih0cmFuc2Zvcm1zLnNjYWxlWCwgdHJhbnNmb3Jtcy5zY2FsZVkpO1xuXG4gICAgICAgICAgICB4ID0gcGFyc2VGbG9hdCgoc3R5bGVzLnggKyAnJykucmVwbGFjZSgncHgnKSk7XG4gICAgICAgICAgICB5ID0gcGFyc2VGbG9hdCgoc3R5bGVzLnkgKyAnJykucmVwbGFjZSgncHgnKSk7XG5cbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIGJhc2VkIG9uIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICBpZiAoeCkge1xuICAgICAgICAgICAgICBlbGVtLnRyYW5zbGF0aW9uLnggPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSkge1xuICAgICAgICAgICAgICBlbGVtLnRyYW5zbGF0aW9uLnkgPSB5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gRWRpdCB0aGUgdW5kZXJseWluZyBtYXRyaXggYW5kIGRvbid0IGZvcmNlIGFuIGF1dG8gY2FsYy5cbiAgICAgICAgICAgIG0gPSBub2RlLmdldENUTSgpO1xuICAgICAgICAgICAgZWxlbS5fbWF0cml4Lm1hbnVhbCA9IHRydWU7XG4gICAgICAgICAgICBlbGVtLl9tYXRyaXguc2V0KG0uYSwgbS5iLCBtLmMsIG0uZCwgbS5lLCBtLmYpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3ZpZXdCb3gnOlxuICAgICAgICAgIGFwcGx5U3ZnVmlld0JveC5jYWxsKHRoaXMsIGVsZW0sIHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndmlzaWJsZSc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgZWxlbS5fdmlzaWJsZSA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW0udmlzaWJsZSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzdHJva2UtbGluZWNhcCc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgICAgZWxlbS5fY2FwID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbS5jYXAgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Ryb2tlLWxpbmVqb2luJzpcbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICBlbGVtLl9qb2luID0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbS5qb2luID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N0cm9rZS1taXRlcmxpbWl0JzpcbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICBlbGVtLl9taXRlciA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW0ubWl0ZXIgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Ryb2tlLXdpZHRoJzpcbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICBlbGVtLl9saW5ld2lkdGggPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbGVtLmxpbmV3aWR0aCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvcGFjaXR5JzpcbiAgICAgICAgY2FzZSAnc3Ryb2tlLW9wYWNpdHknOlxuICAgICAgICBjYXNlICdmaWxsLW9wYWNpdHknOlxuICAgICAgICAgIC8vIE9ubHkgYXBwbHkgc3R5bGVzIHRvIHJlbmRlcmVkIHNoYXBlc1xuICAgICAgICAgIC8vIGluIHRoZSBzY2VuZS5cbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICBlbGVtLl9vcGFjaXR5ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbS5vcGFjaXR5ID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NsaXAtcGF0aCc6XG4gICAgICAgICAgaWYgKC91cmxcXCgjLipcXCkvaS50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWQgPSB2YWx1ZS5yZXBsYWNlKC91cmxcXCgjKC4qKVxcKS9pLCAnJDEnKTtcbiAgICAgICAgICAgIGlmIChyZWFkLmRlZnMuY3VycmVudCAmJiByZWFkLmRlZnMuY3VycmVudC5jb250YWlucyhpZCkpIHtcbiAgICAgICAgICAgICAgcmVmID0gcmVhZC5kZWZzLmN1cnJlbnQuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgaWYgKHJlZiAmJiByZWYuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVmID0gcmVmLmNoaWxkTm9kZXNbMF07XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGdldFRhZ05hbWUocmVmLm5vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICBlbGVtLm1hc2sgPSByZWFkW3RhZ05hbWVdLmNhbGwodGhpcywgcmVmLCB7fSk7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChlbGVtLl9yZW5kZXJlci50eXBlKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3BhdGgnOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbWF0cml4IGhlcmUgbmVlZHMgdG8gY2hhbmdlIHRvIGluc3VyZSB0aGF0IHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpcHBpbmcgaXMgaW4gdGhlIHNhbWUgY29vcmRpbmF0ZSBzcGFjZSBhcyB0aGUgYGVsZW1gLlxuICAgICAgICAgICAgICAgICAgICBlbGVtLnBvc2l0aW9uLmFkZChlbGVtLm1hc2sucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBlbGVtLm1hc2sucG9zaXRpb24uY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmaWxsJzpcbiAgICAgICAgY2FzZSAnc3Ryb2tlJzpcbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgICAgICBrZXkgPSAnXycgKyBrZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgvdXJsXFwoIy4qXFwpL2kudGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGlkID0gdmFsdWUucmVwbGFjZSgvdXJsXFwoIyguKilcXCkvaSwgJyQxJyk7XG4gICAgICAgICAgICBpZiAocmVhZC5kZWZzLmN1cnJlbnQgJiYgcmVhZC5kZWZzLmN1cnJlbnQuY29udGFpbnMoaWQpKSB7XG4gICAgICAgICAgICAgIHJlZiA9IHJlYWQuZGVmcy5jdXJyZW50LmdldChpZCk7XG4gICAgICAgICAgICAgIHRhZ05hbWUgPSBnZXRUYWdOYW1lKHJlZi5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgIHJlZiA9IHJlYWRbdGFnTmFtZV0uY2FsbCh0aGlzLCByZWYsIHt9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjZW5lID0gZ2V0U2NlbmUodGhpcyk7XG4gICAgICAgICAgICAgIHJlZiA9IHNjZW5lLmdldEJ5SWQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbVtrZXldID0gcmVmO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtW2tleV0gPSAoL25vbmUvaS50ZXN0KHZhbHVlKSkgPyAndHJhbnNwYXJlbnQnIDogdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpZCc6XG4gICAgICAgICAgZWxlbS5pZCA9IHZhbHVlO1xuICAgICAgICAgIC8vIE92ZXJ3cml0dGVuIGlkIGZvciBub24tY29uZmxpY3RzIG9uIHNhbWUgcGFnZSBTVkcgZG9jdW1lbnRzXG4gICAgICAgICAgLy8gVE9ETzogTWFrZSB0aGlzIG5vbi1kZXNjcnVjdGl2ZVxuICAgICAgICAgIG5vZGUuaWQgPSB2YWx1ZSArICctJyArIENvbnN0YW50cy5JZGVudGlmaWVyICsgJ2FwcGxpZWQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgIGNhc2UgJ2NsYXNzTmFtZSc6XG4gICAgICAgICAgZWxlbS5jbGFzc0xpc3QgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgdmFyIGNhID0gZWxlbSBpbnN0YW5jZW9mIEdyYWRpZW50O1xuICAgICAgICAgIHZhciBjYiA9IGVsZW0gaW5zdGFuY2VvZiBMaW5lYXJHcmFkaWVudDtcbiAgICAgICAgICB2YXIgY2MgPSBlbGVtIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnQ7XG4gICAgICAgICAgaWYgKGNhIHx8IGNiIHx8IGNjKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlLm1hdGNoKCdbYS16JV0kJykgJiYgIXZhbHVlLmVuZHNXaXRoKCdweCcpKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgVHdvRXJyb3IoXG4gICAgICAgICAgICAgICdvbmx5IHBpeGVsIHZhbHVlcyBhcmUgc3VwcG9ydGVkIHdpdGggdGhlICcgKyBrZXkgKyAnIGF0dHJpYnV0ZS4nKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihlcnJvci5uYW1lLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbS50cmFuc2xhdGlvbltrZXldID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZvbnQtZmFtaWx5JzpcbiAgICAgICAgICBpZiAoZWxlbSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgICAgIGVsZW0uZmFtaWx5ID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb250LXNpemUnOlxuICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgZWxlbS5zaXplID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmb250LXdlaWdodCc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICBlbGVtLndlaWdodCA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZm9udC1zdHlsZSc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICBlbGVtLnN0eWxlID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0ZXh0LWRlY29yYXRpb24nOlxuICAgICAgICAgIGlmIChlbGVtIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICAgICAgZWxlbS5kZWNvcmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lLWhlaWdodCc6XG4gICAgICAgICAgaWYgKGVsZW0gaW5zdGFuY2VvZiBUZXh0KSB7XG4gICAgICAgICAgICBlbGVtLmxlYWRpbmcgPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlcztcblxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMudXBkYXRlRGVmc0NhY2hlXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IG5vZGUgLSBUaGUgU1ZHIE5vZGUgd2l0aCB3aGljaCB0byB1cGRhdGUgdGhlIGRlZnMgY2FjaGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBPYmplY3QgLSBUaGUgZGVmcyBjYWNoZSB0byBiZSB1cGRhdGVkLlxuICAgKiBAZGVzY3JpcHRpb24gVXBkYXRlIHRoZSBjYWNoZSBvZiBjaGlsZHJlbiBvZiA8ZGVmcyAvPiB0YWdzLlxuICAgKi9cbiAgdmFyIHVwZGF0ZURlZnNDYWNoZSA9IGZ1bmN0aW9uKG5vZGUsIGRlZnNDYWNoZSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG4gPSBub2RlLmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoIW4uaWQpIGNvbnRpbnVlO1xuXG4gICAgICB2YXIgdGFnTmFtZSA9IGdldFRhZ05hbWUobm9kZS5ub2RlTmFtZSk7XG4gICAgICBpZiAodGFnTmFtZSA9PT0gJyN0ZXh0JykgY29udGludWU7XG5cbiAgICAgIGRlZnNDYWNoZS5hZGQobi5pZCwgbik7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uVXRpbHMuZ2V0U2NlbmVcbiAgICogQHBhcmFtIHtUd28uU2hhcGV9IG5vZGUgLSBUaGUgY3VycmVudGx5IGF2YWlsYWJsZSBvYmplY3QgaW4gdGhlIHNjZW5lZ3JhcGguXG4gICAqIEByZXR1cm5zIHtHcm91cH0gLSBUaGUgaGlnaGVzdCBvcmRlciB7QGxpbmsgVHdvLkdyb3VwfSBpbiB0aGUgc2NlbmVncmFwaC5cbiAgICogQHByb3BlcnR5IHtGdW5jdGlvbn1cbiAgICovXG4gIHZhciBnZXRTY2VuZSA9IGZ1bmN0aW9uKG5vZGUpIHtcblxuICAgIHdoaWxlIChub2RlLnBhcmVudCkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBub2RlLnNjZW5lO1xuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy5yZWFkXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSByZWFkIC0gQSBtYXAgb2YgZnVuY3Rpb25zIHRvIHJlYWQgYW55IG51bWJlciBvZiBTVkcgbm9kZSB0eXBlcyBhbmQgY3JlYXRlIFR3by5qcyBlcXVpdmFsZW50cyBvZiB0aGVtLiBQcmltYXJpbHkgdXNlZCBieSB0aGUge0BsaW5rIFR3byNpbnRlcnByZXR9IG1ldGhvZC5cbiAgICovXG4gIHZhciByZWFkID0ge1xuXG4gICAgc3ZnOiBmdW5jdGlvbihub2RlKSB7XG5cbiAgICAgIHZhciBkZWZzID0gcmVhZC5kZWZzLmN1cnJlbnQgPSBuZXcgUmVnaXN0cnkoKTtcbiAgICAgIHZhciBlbGVtZW50cyA9IG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RlZnMnKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB1cGRhdGVEZWZzQ2FjaGUoZWxlbWVudHNbaV0sIGRlZnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3ZnID0gcmVhZC5nLmNhbGwodGhpcywgbm9kZSk7XG4gICAgICAvLyB2YXIgdmlld0JveCA9IG5vZGUuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG5cbiAgICAgIHN2Zy5kZWZzID0gZGVmczsgIC8vIEV4cG9ydCBvdXQgdGhlIDxkZWZzIC8+IGZvciBsYXRlciB1c2VcbiAgICAgIC8vIFV0aWxzLmFwcGx5U3ZnVmlld0JveChzdmcsIHZpZXdCb3gpO1xuXG4gICAgICBkZWxldGUgcmVhZC5kZWZzLmN1cnJlbnQ7XG5cbiAgICAgIHJldHVybiBzdmc7XG5cbiAgICB9LFxuXG4gICAgZGVmczogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHVzZTogZnVuY3Rpb24obm9kZSwgc3R5bGVzKSB7XG5cbiAgICAgIHZhciBlcnJvcjtcbiAgICAgIHZhciBocmVmID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSB8fCBub2RlLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpO1xuICAgICAgaWYgKCFocmVmKSB7XG4gICAgICAgIGVycm9yID0gbmV3IFR3b0Vycm9yKCdlbmNvdW50ZXJlZCA8dXNlIC8+IHdpdGggbm8gaHJlZi4nKTtcbiAgICAgICAgY29uc29sZS53YXJuKGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gaHJlZi5zbGljZSgxKTtcbiAgICAgIGlmICghcmVhZC5kZWZzLmN1cnJlbnQuY29udGFpbnMoaWQpKSB7XG4gICAgICAgIGVycm9yID0gbmV3IFR3b0Vycm9yKFxuICAgICAgICAgICd1bmFibGUgdG8gZmluZCBlbGVtZW50IGZvciByZWZlcmVuY2UgJyArIGhyZWYgKyAnLicpO1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubmFtZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGVtcGxhdGUgPSByZWFkLmRlZnMuY3VycmVudC5nZXQoaWQpO1xuICAgICAgdmFyIGZ1bGxOb2RlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgdmFyIG92ZXJ3cml0ZUF0dHJzID0gWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ2hyZWYnLCAneGxpbms6aHJlZiddO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgdmFyIGNhID0gb3ZlcndyaXRlQXR0cnMuaW5jbHVkZXMoYXR0ci5ub2RlTmFtZSk7XG4gICAgICAgIHZhciBjYiA9ICFmdWxsTm9kZS5oYXNBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSk7XG4gICAgICAgIGlmIChjYSB8fCBjYikge1xuICAgICAgICAgIGZ1bGxOb2RlLnNldEF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lLCBhdHRyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGFnTmFtZSA9IGdldFRhZ05hbWUoZnVsbE5vZGUubm9kZU5hbWUpO1xuICAgICAgcmV0dXJuIHJlYWRbdGFnTmFtZV0uY2FsbCh0aGlzLCBmdWxsTm9kZSwgc3R5bGVzKTtcblxuICAgIH0sXG5cbiAgICBnOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgICAgdmFyIHN0eWxlcztcbiAgICAgIHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBncm91cCwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgdGhpcy5hZGQoZ3JvdXApO1xuXG4gICAgICAvLyBTd2l0Y2hlZCB1cCBvcmRlciB0byBpbmhlcml0IG1vcmUgc3BlY2lmaWMgc3R5bGVzXG4gICAgICBzdHlsZXMgPSBnZXRTdmdTdHlsZXMuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBuID0gbm9kZS5jaGlsZE5vZGVzW2ldO1xuICAgICAgICB2YXIgdGFnID0gbi5ub2RlTmFtZTtcbiAgICAgICAgaWYgKCF0YWcpIHJldHVybjtcblxuICAgICAgICB2YXIgdGFnTmFtZSA9IGdldFRhZ05hbWUodGFnKTtcblxuICAgICAgICBpZiAodGFnTmFtZSBpbiByZWFkKSB7XG4gICAgICAgICAgdmFyIG8gPSByZWFkW3RhZ05hbWVdLmNhbGwoZ3JvdXAsIG4sIHN0eWxlcyk7XG4gICAgICAgICAgaWYgKCEhbyAmJiAhby5wYXJlbnQpIHtcbiAgICAgICAgICAgIGdyb3VwLmFkZChvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdyb3VwO1xuXG4gICAgfSxcblxuICAgIHBvbHlnb246IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuXG4gICAgICB2YXIgcG9pbnRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpO1xuXG4gICAgICB2YXIgdmVydHMgPSBbXTtcbiAgICAgIHBvaW50cy5yZXBsYWNlKC8oLT9bXFxkLmVFLV0rKVssfFxcc10oLT9bXFxkLmVFLV0rKS9nLCBmdW5jdGlvbihtYXRjaCwgcDEsIHAyKSB7XG4gICAgICAgIHZlcnRzLnB1c2gobmV3IEFuY2hvcihwYXJzZUZsb2F0KHAxKSwgcGFyc2VGbG9hdChwMikpKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgcG9seSA9IG5ldyBQYXRoKHZlcnRzLCB0cnVlKS5ub1N0cm9rZSgpO1xuICAgICAgcG9seS5maWxsID0gJ2JsYWNrJztcblxuICAgICAgYXBwbHlTdmdBdHRyaWJ1dGVzLmNhbGwodGhpcywgbm9kZSwgcG9seSwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgcmV0dXJuIHBvbHk7XG5cbiAgICB9LFxuXG4gICAgcG9seWxpbmU6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuICAgICAgdmFyIHBvbHkgPSByZWFkLnBvbHlnb24uY2FsbCh0aGlzLCBub2RlLCBwYXJlbnRTdHlsZXMpO1xuICAgICAgcG9seS5jbG9zZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiBwb2x5O1xuICAgIH0sXG5cbiAgICBwYXRoOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgICAgdmFyIHBhdGggPSBub2RlLmdldEF0dHJpYnV0ZSgnZCcpO1xuICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgdmFyIGNsb3NlZCA9IGZhbHNlLCByZWxhdGl2ZSA9IGZhbHNlO1xuXG4gICAgICBpZiAocGF0aCkge1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIFR3by5QYXRoIGZyb20gdGhlIHBhdGhzLlxuXG4gICAgICAgIHZhciBjb29yZCA9IG5ldyBBbmNob3IoKTtcbiAgICAgICAgdmFyIGNvbnRyb2wsIGNvb3JkcztcbiAgICAgICAgdmFyIGNvbW1hbmRzID0gcGF0aC5tYXRjaCgvW2EtZGYtel1bXmEtZGYtel0qL2lnKTtcbiAgICAgICAgdmFyIGxhc3QgPSBjb21tYW5kcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIC8vIFNwbGl0IHVwIHBvbHliZXppZXJzXG5cbiAgICAgICAgXy5lYWNoKGNvbW1hbmRzLnNsaWNlKDApLCBmdW5jdGlvbihjb21tYW5kLCBpKSB7XG5cbiAgICAgICAgICB2YXIgaXRlbXMgPSBjb21tYW5kLnNsaWNlKDEpLnRyaW0oKS5tYXRjaChyZWdleC5wYXRoKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IGNvbW1hbmRbMF07XG4gICAgICAgICAgdmFyIGxvd2VyID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgIHZhciBiaW4sIGosIGwsIGN0LCB0aW1lcywgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgY29tbWFuZHMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzd2l0Y2ggKGxvd2VyKSB7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIGNhc2UgJ3YnOlxuICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGJpbiA9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgYmluID0gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAgICAgYmluID0gNDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgICBpZiAoaXRlbXMubGVuZ3RoID4gNikge1xuICAgICAgICAgICAgICAgIGJpbiA9IDY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgICAgICBiaW4gPSA3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRoaXMgbWVhbnMgd2UgaGF2ZSBhIHBvbHliZXppZXIuXG4gICAgICAgICAgaWYgKGJpbikge1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwLCBsID0gaXRlbXMubGVuZ3RoLCB0aW1lcyA9IDA7IGogPCBsOyBqKz1iaW4pIHtcblxuICAgICAgICAgICAgICBjdCA9IHR5cGU7XG4gICAgICAgICAgICAgIGlmICh0aW1lcyA+IDApIHtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgIGN0ID0gJ2wnO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgICAgICAgICAgICBjdCA9ICdMJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXN1bHQucHVzaChjdCArIGl0ZW1zLnNsaWNlKGosIGogKyBiaW4pLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICAgIHRpbWVzKys7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbWFuZHMgPSBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KGNvbW1hbmRzLCByZXN1bHQpO1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29tbWFuZHMucHVzaChjb21tYW5kKTtcblxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHZlcnRpY2VzIGZvciBvdXIgVHdvLlBhdGhcblxuICAgICAgICBfLmVhY2goY29tbWFuZHMsIGZ1bmN0aW9uKGNvbW1hbmQsIGkpIHtcblxuICAgICAgICAgIHZhciByZXN1bHQsIHgsIHk7XG4gICAgICAgICAgdmFyIHR5cGUgPSBjb21tYW5kWzBdO1xuICAgICAgICAgIHZhciBsb3dlciA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIGNvb3JkcyA9IGNvbW1hbmQuc2xpY2UoMSkudHJpbSgpLm1hdGNoKHJlZ2V4LnBhdGgpO1xuICAgICAgICAgIHJlbGF0aXZlID0gdHlwZSA9PT0gbG93ZXI7XG5cbiAgICAgICAgICB2YXIgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgeDQsIHk0LCByZWZsZWN0aW9uO1xuXG4gICAgICAgICAgc3dpdGNoIChsb3dlcikge1xuXG4gICAgICAgICAgICBjYXNlICd6JzpcbiAgICAgICAgICAgICAgaWYgKGkgPj0gbGFzdCkge1xuICAgICAgICAgICAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IGNvb3JkLng7XG4gICAgICAgICAgICAgICAgeSA9IGNvb3JkLnk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFuY2hvcihcbiAgICAgICAgICAgICAgICAgIHgsIHksXG4gICAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgQ29tbWFuZHMuY2xvc2VcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIE1ha2UgY29vcmQgYmUgdGhlIGxhc3QgYG1gIGNvbW1hbmRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBwb2ludHNbal07XG4gICAgICAgICAgICAgICAgICBpZiAoL20vaS50ZXN0KHBvaW50LmNvbW1hbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkID0gcG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICBjYXNlICdsJzpcblxuICAgICAgICAgICAgICBjb250cm9sID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHggPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XG4gICAgICAgICAgICAgIHkgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG5cbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFuY2hvcihcbiAgICAgICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIC9tL2kudGVzdChsb3dlcikgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMubGluZVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRTZWxmKGNvb3JkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHJlc3VsdC5jb250cm9scy5sZWZ0LmNvcHkocmVzdWx0KTtcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LmNvbnRyb2xzLnJpZ2h0LmNvcHkocmVzdWx0KTtcblxuICAgICAgICAgICAgICBjb29yZCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAgICAgY2FzZSAndic6XG5cbiAgICAgICAgICAgICAgdmFyIGEgPSAvaC9pLnRlc3QobG93ZXIpID8gJ3gnIDogJ3knO1xuICAgICAgICAgICAgICB2YXIgYiA9IC94L2kudGVzdChhKSA/ICd5JyA6ICd4JztcblxuICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQW5jaG9yKFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIENvbW1hbmRzLmxpbmVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmVzdWx0W2FdID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xuICAgICAgICAgICAgICByZXN1bHRbYl0gPSBjb29yZFtiXTtcblxuICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYV0gKz0gY29vcmRbYV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyByZXN1bHQuY29udHJvbHMubGVmdC5jb3B5KHJlc3VsdCk7XG4gICAgICAgICAgICAgIC8vIHJlc3VsdC5jb250cm9scy5yaWdodC5jb3B5KHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgY29vcmQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGNhc2UgJ3MnOlxuXG4gICAgICAgICAgICAgIHgxID0gY29vcmQueDtcbiAgICAgICAgICAgICAgeTEgPSBjb29yZC55O1xuXG4gICAgICAgICAgICAgIGlmICghY29udHJvbCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSBuZXcgVmVjdG9yKCk7Ly8uY29weShjb29yZCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoL2MvaS50ZXN0KGxvd2VyKSkge1xuXG4gICAgICAgICAgICAgICAgeDIgPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XG4gICAgICAgICAgICAgICAgeTIgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICAgICAgeDMgPSBwYXJzZUZsb2F0KGNvb3Jkc1syXSk7XG4gICAgICAgICAgICAgICAgeTMgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XG4gICAgICAgICAgICAgICAgeDQgPSBwYXJzZUZsb2F0KGNvb3Jkc1s0XSk7XG4gICAgICAgICAgICAgICAgeTQgPSBwYXJzZUZsb2F0KGNvb3Jkc1s1XSk7XG5cbiAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSByZWZsZWN0aW9uIGNvbnRyb2wgcG9pbnQgZm9yIHByb3BlciB4MiwgeTJcbiAgICAgICAgICAgICAgICAvLyBpbmNsdXNpb24uXG5cbiAgICAgICAgICAgICAgICByZWZsZWN0aW9uID0gZ2V0UmVmbGVjdGlvbihjb29yZCwgY29udHJvbCwgcmVsYXRpdmUpO1xuXG4gICAgICAgICAgICAgICAgeDIgPSByZWZsZWN0aW9uLng7XG4gICAgICAgICAgICAgICAgeTIgPSByZWZsZWN0aW9uLnk7XG4gICAgICAgICAgICAgICAgeDMgPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XG4gICAgICAgICAgICAgICAgeTMgPSBwYXJzZUZsb2F0KGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICAgICAgeDQgPSBwYXJzZUZsb2F0KGNvb3Jkc1syXSk7XG4gICAgICAgICAgICAgICAgeTQgPSBwYXJzZUZsb2F0KGNvb3Jkc1szXSk7XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChyZWxhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHgyICs9IHgxO1xuICAgICAgICAgICAgICAgIHkyICs9IHkxO1xuICAgICAgICAgICAgICAgIHgzICs9IHgxO1xuICAgICAgICAgICAgICAgIHkzICs9IHkxO1xuICAgICAgICAgICAgICAgIHg0ICs9IHgxO1xuICAgICAgICAgICAgICAgIHk0ICs9IHkxO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFfLmlzT2JqZWN0KGNvb3JkLmNvbnRyb2xzKSkge1xuICAgICAgICAgICAgICAgIEFuY2hvci5BcHBlbmRDdXJ2ZVByb3BlcnRpZXMoY29vcmQpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29vcmQuY29udHJvbHMucmlnaHQuc2V0KHgyIC0gY29vcmQueCwgeTIgLSBjb29yZC55KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEFuY2hvcihcbiAgICAgICAgICAgICAgICB4NCwgeTQsXG4gICAgICAgICAgICAgICAgeDMgLSB4NCwgeTMgLSB5NCxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBDb21tYW5kcy5jdXJ2ZVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgIGNvb3JkID0gcmVzdWx0O1xuICAgICAgICAgICAgICBjb250cm9sID0gcmVzdWx0LmNvbnRyb2xzLmxlZnQ7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgY2FzZSAncSc6XG5cbiAgICAgICAgICAgICAgeDEgPSBjb29yZC54O1xuICAgICAgICAgICAgICB5MSA9IGNvb3JkLnk7XG5cbiAgICAgICAgICAgICAgaWYgKCFjb250cm9sKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbCA9IG5ldyBWZWN0b3IoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICgvcS9pLnRlc3QobG93ZXIpKSB7XG5cbiAgICAgICAgICAgICAgICB4MiA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcbiAgICAgICAgICAgICAgICB5MiA9IHBhcnNlRmxvYXQoY29vcmRzWzFdKTtcbiAgICAgICAgICAgICAgICB4MyA9IHBhcnNlRmxvYXQoY29vcmRzWzBdKTtcbiAgICAgICAgICAgICAgICB5MyA9IHBhcnNlRmxvYXQoY29vcmRzWzFdKTtcbiAgICAgICAgICAgICAgICB4NCA9IHBhcnNlRmxvYXQoY29vcmRzWzJdKTtcbiAgICAgICAgICAgICAgICB5NCA9IHBhcnNlRmxvYXQoY29vcmRzWzNdKTtcblxuICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcmVmbGVjdGlvbiA9IGdldFJlZmxlY3Rpb24oY29vcmQsIGNvbnRyb2wsIHJlbGF0aXZlKTtcblxuICAgICAgICAgICAgICAgIHgyID0gcmVmbGVjdGlvbi54O1xuICAgICAgICAgICAgICAgIHkyID0gcmVmbGVjdGlvbi55O1xuICAgICAgICAgICAgICAgIHgzID0gcmVmbGVjdGlvbi54O1xuICAgICAgICAgICAgICAgIHkzID0gcmVmbGVjdGlvbi55O1xuICAgICAgICAgICAgICAgIHg0ID0gcGFyc2VGbG9hdChjb29yZHNbMF0pO1xuICAgICAgICAgICAgICAgIHk0ID0gcGFyc2VGbG9hdChjb29yZHNbMV0pO1xuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAocmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB4MiArPSB4MTtcbiAgICAgICAgICAgICAgICB5MiArPSB5MTtcbiAgICAgICAgICAgICAgICB4MyArPSB4MTtcbiAgICAgICAgICAgICAgICB5MyArPSB5MTtcbiAgICAgICAgICAgICAgICB4NCArPSB4MTtcbiAgICAgICAgICAgICAgICB5NCArPSB5MTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghXy5pc09iamVjdChjb29yZC5jb250cm9scykpIHtcbiAgICAgICAgICAgICAgICBBbmNob3IuQXBwZW5kQ3VydmVQcm9wZXJ0aWVzKGNvb3JkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvb3JkLmNvbnRyb2xzLnJpZ2h0LnNldChcbiAgICAgICAgICAgICAgICAoeDIgLSBjb29yZC54KSAqIDAuMzMsICh5MiAtIGNvb3JkLnkpICogMC4zMyk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBBbmNob3IoXG4gICAgICAgICAgICAgICAgeDQsIHk0LFxuICAgICAgICAgICAgICAgIHgzIC0geDQsIHkzIC0geTQsXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgQ29tbWFuZHMuY3VydmVcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICBjb29yZCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHJlc3VsdC5jb250cm9scy5sZWZ0O1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdhJzpcblxuICAgICAgICAgICAgICB4MSA9IGNvb3JkLng7XG4gICAgICAgICAgICAgIHkxID0gY29vcmQueTtcblxuICAgICAgICAgICAgICB2YXIgcnggPSBwYXJzZUZsb2F0KGNvb3Jkc1swXSk7XG4gICAgICAgICAgICAgIHZhciByeSA9IHBhcnNlRmxvYXQoY29vcmRzWzFdKTtcbiAgICAgICAgICAgICAgdmFyIHhBeGlzUm90YXRpb24gPSBwYXJzZUZsb2F0KGNvb3Jkc1syXSk7Ly8gKiBQSSAvIDE4MDtcbiAgICAgICAgICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IHBhcnNlRmxvYXQoY29vcmRzWzNdKTtcbiAgICAgICAgICAgICAgdmFyIHN3ZWVwRmxhZyA9IHBhcnNlRmxvYXQoY29vcmRzWzRdKTtcblxuICAgICAgICAgICAgICB4NCA9IHBhcnNlRmxvYXQoY29vcmRzWzVdKTtcbiAgICAgICAgICAgICAgeTQgPSBwYXJzZUZsb2F0KGNvb3Jkc1s2XSk7XG5cbiAgICAgICAgICAgICAgaWYgKHJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgeDQgKz0geDE7XG4gICAgICAgICAgICAgICAgeTQgKz0geTE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgYW5jaG9yID0gbmV3IEFuY2hvcih4NCwgeTQpO1xuICAgICAgICAgICAgICBhbmNob3IuY29tbWFuZCA9IENvbW1hbmRzLmFyYztcbiAgICAgICAgICAgICAgYW5jaG9yLnJ4ID0gcng7XG4gICAgICAgICAgICAgIGFuY2hvci5yeSA9IHJ5O1xuICAgICAgICAgICAgICBhbmNob3IueEF4aXNSb3RhdGlvbiA9IHhBeGlzUm90YXRpb247XG4gICAgICAgICAgICAgIGFuY2hvci5sYXJnZUFyY0ZsYWcgPSBsYXJnZUFyY0ZsYWc7XG4gICAgICAgICAgICAgIGFuY2hvci5zd2VlcEZsYWcgPSBzd2VlcEZsYWc7XG5cbiAgICAgICAgICAgICAgcmVzdWx0ID0gYW5jaG9yO1xuXG4gICAgICAgICAgICAgIGNvb3JkID0gYW5jaG9yO1xuICAgICAgICAgICAgICBjb250cm9sID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KHJlc3VsdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb2ludHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgfVxuXG4gICAgICBwYXRoID0gbmV3IFBhdGgocG9pbnRzLCBjbG9zZWQsIHVuZGVmaW5lZCwgdHJ1ZSkubm9TdHJva2UoKTtcbiAgICAgIHBhdGguZmlsbCA9ICdibGFjayc7XG5cbiAgICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QodHJ1ZSk7XG5cbiAgICAgIC8vIENlbnRlciBvYmplY3RzIHRvIHN0YXkgY29uc2lzdGVudFxuICAgICAgLy8gd2l0aCB0aGUgcmVzdCBvZiB0aGUgVHdvLmpzIEFQSS5cbiAgICAgIHJlY3QuY2VudHJvaWQgPSB7XG4gICAgICAgIHg6IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyLFxuICAgICAgICB5OiByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMlxuICAgICAgfTtcblxuICAgICAgXy5lYWNoKHBhdGgudmVydGljZXMsIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdi5zdWJTZWxmKHJlY3QuY2VudHJvaWQpO1xuICAgICAgfSk7XG5cbiAgICAgIGFwcGx5U3ZnQXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUsIHBhdGgsIHBhcmVudFN0eWxlcyk7XG5cbiAgICAgIHBhdGgudHJhbnNsYXRpb24uYWRkU2VsZihyZWN0LmNlbnRyb2lkKTtcblxuICAgICAgcmV0dXJuIHBhdGg7XG5cbiAgICB9LFxuXG4gICAgY2lyY2xlOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdjeCcpKTtcbiAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnY3knKSk7XG4gICAgICB2YXIgciA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3InKSk7XG5cbiAgICAgIHZhciBjaXJjbGUgPSBuZXcgQ2lyY2xlKDAsIDAsIHIpLm5vU3Ryb2tlKCk7XG4gICAgICBjaXJjbGUuZmlsbCA9ICdibGFjayc7XG5cbiAgICAgIGFwcGx5U3ZnQXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUsIGNpcmNsZSwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgY2lyY2xlLnRyYW5zbGF0aW9uLnggPSB4O1xuICAgICAgY2lyY2xlLnRyYW5zbGF0aW9uLnkgPSB5O1xuXG4gICAgICByZXR1cm4gY2lyY2xlO1xuXG4gICAgfSxcblxuICAgIGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUsIHBhcmVudFN0eWxlcykge1xuXG4gICAgICB2YXIgeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2N4JykpO1xuICAgICAgdmFyIHkgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdjeScpKTtcbiAgICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3J4JykpO1xuICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3J5JykpO1xuXG4gICAgICB2YXIgZWxsaXBzZSA9IG5ldyBFbGxpcHNlKDAsIDAsIHdpZHRoLCBoZWlnaHQpLm5vU3Ryb2tlKCk7XG4gICAgICBlbGxpcHNlLmZpbGwgPSAnYmxhY2snO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBlbGxpcHNlLCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICBlbGxpcHNlLnRyYW5zbGF0aW9uLnggPSB4O1xuICAgICAgZWxsaXBzZS50cmFuc2xhdGlvbi55ID0geTtcblxuICAgICAgcmV0dXJuIGVsbGlwc2U7XG5cbiAgICB9LFxuXG4gICAgcmVjdDogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciByeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3J4JykpO1xuICAgICAgdmFyIHJ5ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgncnknKSk7XG5cbiAgICAgIGlmICghXy5pc05hTihyeCkgfHwgIV8uaXNOYU4ocnkpKSB7XG4gICAgICAgIHJldHVybiByZWFkWydyb3VuZGVkLXJlY3QnXShub2RlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XG4gICAgICB2YXIgaGVpZ2h0ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuXG4gICAgICB2YXIgdzIgPSB3aWR0aCAvIDI7XG4gICAgICB2YXIgaDIgPSBoZWlnaHQgLyAyO1xuXG4gICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUoMCwgMCwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgLm5vU3Ryb2tlKCk7XG4gICAgICByZWN0LmZpbGwgPSAnYmxhY2snO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCByZWN0LCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICAvLyBGb3IgcmVjdGFuZ2xlcywgKHgsIHkpIGlzIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlIHJhdGhlciB0aGFuIHRoZSB0b3BcbiAgICAgIC8vIGxlZnQgY29ybmVyLlxuICAgICAgcmVjdC50cmFuc2xhdGlvbi54ICs9IHcyO1xuICAgICAgcmVjdC50cmFuc2xhdGlvbi55ICs9IGgyO1xuXG4gICAgICByZXR1cm4gcmVjdDtcblxuICAgIH0sXG5cbiAgICAncm91bmRlZC1yZWN0JzogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciByeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3J4JykpIHx8IDA7XG4gICAgICB2YXIgcnkgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdyeScpKSB8fCAwO1xuXG4gICAgICB2YXIgd2lkdGggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKTtcbiAgICAgIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSk7XG5cbiAgICAgIHZhciB3MiA9IHdpZHRoIC8gMjtcbiAgICAgIHZhciBoMiA9IGhlaWdodCAvIDI7XG4gICAgICB2YXIgcmFkaXVzID0gbmV3IFZlY3RvcihyeCwgcnkpO1xuXG4gICAgICB2YXIgcmVjdCA9IG5ldyBSb3VuZGVkUmVjdGFuZ2xlKDAsIDAsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cylcbiAgICAgICAgLm5vU3Ryb2tlKCk7XG4gICAgICByZWN0LmZpbGwgPSAnYmxhY2snO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCByZWN0LCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICAvLyBGb3IgcmVjdGFuZ2xlcywgKHgsIHkpIGlzIHRoZSBjZW50ZXIgb2YgdGhlIHNoYXBlIHJhdGhlciB0aGFuIHRoZSB0b3BcbiAgICAgIC8vIGxlZnQgY29ybmVyLlxuICAgICAgcmVjdC50cmFuc2xhdGlvbi54ICs9IHcyO1xuICAgICAgcmVjdC50cmFuc2xhdGlvbi55ICs9IGgyO1xuXG4gICAgICByZXR1cm4gcmVjdDtcblxuICAgIH0sXG5cbiAgICBsaW5lOiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgICAgdmFyIHgxID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneDEnKSk7XG4gICAgICB2YXIgeTEgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd5MScpKTtcbiAgICAgIHZhciB4MiA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3gyJykpO1xuICAgICAgdmFyIHkyID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneTInKSk7XG5cbiAgICAgIHZhciBsaW5lID0gbmV3IExpbmUoeDEsIHkxLCB4MiwgeTIpLm5vRmlsbCgpO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBsaW5lLCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICByZXR1cm4gbGluZTtcblxuICAgIH0sXG5cbiAgICBsaW5lYXJncmFkaWVudDogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciB4MSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3gxJykpO1xuICAgICAgdmFyIHkxID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgneTEnKSk7XG4gICAgICB2YXIgeDIgPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4MicpKTtcbiAgICAgIHZhciB5MiA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3kyJykpO1xuXG4gICAgICB2YXIgb3ggPSAoeDIgKyB4MSkgLyAyO1xuICAgICAgdmFyIG95ID0gKHkyICsgeTEpIC8gMjtcblxuICAgICAgdmFyIHN0b3BzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpO1xuICAgICAgICBpZiAoLyUvaWcudGVzdChvZmZzZXQpKSB7XG4gICAgICAgICAgb2Zmc2V0ID0gcGFyc2VGbG9hdChvZmZzZXQucmVwbGFjZSgvJS9pZywgJycpKSAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGNvbG9yID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJyk7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdzdG9wLW9wYWNpdHknKTtcbiAgICAgICAgdmFyIHN0eWxlID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuXG4gICAgICAgIHZhciBtYXRjaGVzO1xuICAgICAgICBpZiAoY29sb3IgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaGVzID0gc3R5bGUgPyBzdHlsZS5tYXRjaCgvc3RvcC1jb2xvcjpcXHM/KFsjYS1mQS1GMC05XSopLykgOiBmYWxzZTtcbiAgICAgICAgICBjb2xvciA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcGFjaXR5ID09PSBudWxsKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IHN0eWxlID8gc3R5bGUubWF0Y2goL3N0b3Atb3BhY2l0eTpcXHM/KFswLTkuLV0qKS8pIDogZmFsc2U7XG4gICAgICAgICAgb3BhY2l0eSA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxID8gcGFyc2VGbG9hdChtYXRjaGVzWzFdKSA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BhY2l0eSA9IHBhcnNlRmxvYXQob3BhY2l0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdG9wcy5wdXNoKG5ldyBTdG9wKG9mZnNldCwgY29sb3IsIG9wYWNpdHkpKTtcblxuICAgICAgfVxuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgTGluZWFyR3JhZGllbnQoeDEgLSBveCwgeTEgLSBveSwgeDIgLSBveCxcbiAgICAgICAgeTIgLSBveSwgc3RvcHMpO1xuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBncmFkaWVudCwgcGFyZW50U3R5bGVzKTtcblxuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuXG4gICAgfSxcblxuICAgIHJhZGlhbGdyYWRpZW50OiBmdW5jdGlvbihub2RlLCBwYXJlbnRTdHlsZXMpIHtcblxuICAgICAgdmFyIGN4ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnY3gnKSkgfHwgMDtcbiAgICAgIHZhciBjeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2N5JykpIHx8IDA7XG4gICAgICB2YXIgciA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3InKSk7XG5cbiAgICAgIHZhciBmeCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2Z4JykpO1xuICAgICAgdmFyIGZ5ID0gcGFyc2VGbG9hdChub2RlLmdldEF0dHJpYnV0ZSgnZnknKSk7XG5cbiAgICAgIGlmIChfLmlzTmFOKGZ4KSkge1xuICAgICAgICBmeCA9IGN4O1xuICAgICAgfVxuXG4gICAgICBpZiAoXy5pc05hTihmeSkpIHtcbiAgICAgICAgZnkgPSBjeTtcbiAgICAgIH1cblxuICAgICAgdmFyIG94ID0gTWF0aC5hYnMoY3ggKyBmeCkgLyAyO1xuICAgICAgdmFyIG95ID0gTWF0aC5hYnMoY3kgKyBmeSkgLyAyO1xuXG4gICAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnb2Zmc2V0Jyk7XG4gICAgICAgIGlmICgvJS9pZy50ZXN0KG9mZnNldCkpIHtcbiAgICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldC5yZXBsYWNlKC8lL2lnLCAnJykpIC8gMTAwO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCA9IHBhcnNlRmxvYXQob2Zmc2V0KTtcblxuICAgICAgICB2YXIgY29sb3IgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKTtcbiAgICAgICAgdmFyIG9wYWNpdHkgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScpO1xuICAgICAgICB2YXIgc3R5bGUgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG5cbiAgICAgICAgdmFyIG1hdGNoZXM7XG4gICAgICAgIGlmIChjb2xvciA9PT0gbnVsbCkge1xuICAgICAgICAgIG1hdGNoZXMgPSBzdHlsZSA/IHN0eWxlLm1hdGNoKC9zdG9wLWNvbG9yOlxccz8oWyNhLWZBLUYwLTldKikvKSA6IGZhbHNlO1xuICAgICAgICAgIGNvbG9yID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEgPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wYWNpdHkgPT09IG51bGwpIHtcbiAgICAgICAgICBtYXRjaGVzID0gc3R5bGUgPyBzdHlsZS5tYXRjaCgvc3RvcC1vcGFjaXR5Olxccz8oWzAtOS4tXSopLykgOiBmYWxzZTtcbiAgICAgICAgICBvcGFjaXR5ID0gbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDEgPyBwYXJzZUZsb2F0KG1hdGNoZXNbMV0pIDogMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcGFjaXR5ID0gcGFyc2VGbG9hdChvcGFjaXR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3BzLnB1c2gobmV3IFN0b3Aob2Zmc2V0LCBjb2xvciwgb3BhY2l0eSkpO1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBSYWRpYWxHcmFkaWVudChjeCAtIG94LCBjeSAtIG95LCByLFxuICAgICAgICBzdG9wcywgZnggLSBveCwgZnkgLSBveSk7XG5cbiAgICAgIGFwcGx5U3ZnQXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUsIGdyYWRpZW50LCBwYXJlbnRTdHlsZXMpO1xuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG5cbiAgICB9LFxuXG4gICAgdGV4dDogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciBhbGlnbm1lbnQgPSBnZXRBbGlnbm1lbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJykpIHx8ICdsZWZ0JztcbiAgICAgIHZhciBiYXNlbGluZSA9IGdldEJhc2VsaW5lKG5vZGUpIHx8ICdiYXNlbGluZSc7XG4gICAgICB2YXIgbWVzc2FnZSA9IG5vZGUudGV4dENvbnRlbnQ7XG5cbiAgICAgIHZhciB0ZXh0ID0gbmV3IFRleHQobWVzc2FnZSk7XG5cbiAgICAgIGFwcGx5U3ZnQXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUsIHRleHQsIHBhcmVudFN0eWxlcyk7XG5cbiAgICAgIHRleHQuYWxpZ25tZW50ID0gYWxpZ25tZW50O1xuICAgICAgdGV4dC5iYXNlbGluZSA9IGJhc2VsaW5lO1xuXG4gICAgICByZXR1cm4gdGV4dDtcblxuICAgIH0sXG5cbiAgICBjbGlwcGF0aDogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG4gICAgICBpZiAocmVhZC5kZWZzLmN1cnJlbnQgJiYgIXJlYWQuZGVmcy5jdXJyZW50LmNvbnRhaW5zKG5vZGUuaWQpKSB7XG4gICAgICAgIHJlYWQuZGVmcy5jdXJyZW50LmFkZChub2RlLmlkLCBub2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBpbWFnZTogZnVuY3Rpb24obm9kZSwgcGFyZW50U3R5bGVzKSB7XG5cbiAgICAgIHZhciBocmVmID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2hyZWYnKSB8fCBub2RlLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpO1xuICAgICAgaWYgKCFocmVmKSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBUd29FcnJvcignZW5jb3VudGVyZWQgPGltYWdlIC8+IHdpdGggbm8gaHJlZi4nKTtcbiAgICAgICAgY29uc29sZS53YXJuKGVycm9yLm5hbWUsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHggPSBwYXJzZUZsb2F0KG5vZGUuZ2V0QXR0cmlidXRlKCd4JykpIHx8IDA7XG4gICAgICB2YXIgeSA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3knKSkgfHwgMDtcbiAgICAgIHZhciB3aWR0aCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuICAgICAgdmFyIGhlaWdodCA9IHBhcnNlRmxvYXQobm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpKTtcblxuICAgICAgdmFyIHNwcml0ZSA9IG5ldyBTcHJpdGUoaHJlZiwgeCwgeSk7XG5cbiAgICAgIGlmICghXy5pc05hTih3aWR0aCkpIHtcbiAgICAgICAgc3ByaXRlLndpZHRoID0gd2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoIV8uaXNOYU4oaGVpZ2h0KSkge1xuICAgICAgICBzcHJpdGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBhcHBseVN2Z0F0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlLCBzcHJpdGUsIHBhcmVudFN0eWxlcyk7XG5cbiAgICAgIHJldHVybiBzcHJpdGU7XG4gICAgfVxuXG4gIH07XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5VdGlscy54aHJcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEByZXR1cm5zIHtYTUxIdHRwUmVxdWVzdH0gVGhlIGNvbnN0cnVjdGVkIGFuZCBjYWxsZWQgWEhSIHJlcXVlc3QuXG4gICAqIEBkZXNjcmlwdGlvbiBDYW5vbmljYWwgbWV0aG9kIHRvIGluaXRpYXRlIGBHRVRgIHJlcXVlc3RzIGluIHRoZSBicm93c2VyLiBNYWlubHkgdXNlZCBieSB7QGxpbmsgVHdvI2xvYWR9IG1ldGhvZC5cbiAgICovXG4gIGZ1bmN0aW9uIHhocihwYXRoLCBjYWxsYmFjaykge1xuXG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vcGVuKCdHRVQnLCBwYXRoKTtcblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiB4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY2FsbGJhY2soeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHhoci5zZW5kKCk7XG4gICAgcmV0dXJuIHhocjtcblxuICB9XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uUmVjdGFuZ2xlXG4gICAqIEBwYXJhbSB7U3RyaW5nfFN0cmluZ1tdfFR3by5UZXh0dXJlfFR3by5UZXh0dXJlW119IHBhdGhzIC0gQSBsaXN0IG9mIFVSTHMgb3Ige0BsaW5rIFR3by5UZXh0dXJlfXMuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3g9MF0gLSBUaGUgaW5pdGlhbCBgeGAgcG9zaXRpb24gb2YgdGhlIFR3by5JbWFnZVNlcXVlbmNlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW295PTBdIC0gVGhlIGluaXRpYWwgYHlgIHBvc2l0aW9uIG9mIHRoZSBUd28uSW1hZ2VTZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcmFtZVJhdGU9MzBdIC0gVGhlIGZyYW1lIHJhdGUgYXQgd2hpY2ggdGhlIGltYWdlcyBzaG91bGQgcGxheWJhY2sgYXQuXG4gICAqIEBkZXNjcmlwdGlvbiBBIGNvbnZlbmllbnQgcGFja2FnZSB0byBkaXNwbGF5IHN0aWxsIG9yIGFuaW1hdGVkIGltYWdlcyBvcmdhbml6ZWQgYXMgYSBzZXJpZXMgb2Ygc3RpbGwgaW1hZ2VzLlxuICAgKi9cbiAgZnVuY3Rpb24gSW1hZ2VTZXF1ZW5jZShwYXRocywgb3gsIG95LCBmcmFtZVJhdGUpIHtcblxuICAgIC8vIE5vdCB1c2luZyBkZWZhdWx0IGNvbnN0cnVjdG9yIG9mIFJlY3RhbmdsZSBkdWUgdG8gb2RkIGBiZWdpbm5pbmdgIC8gYGVuZGluZ2AgYmVoYXZpb3IuXG4gICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam9ub2JyMS90d28uanMvaXNzdWVzLzM4M1xuICAgIFBhdGguY2FsbCh0aGlzLCBbXG4gICAgICBuZXcgQW5jaG9yKCksXG4gICAgICBuZXcgQW5jaG9yKCksXG4gICAgICBuZXcgQW5jaG9yKCksXG4gICAgICBuZXcgQW5jaG9yKClcbiAgICBdLCB0cnVlKTtcblxuICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdUZXh0dXJlcyA9IEltYWdlU2VxdWVuY2UuRmxhZ1RleHR1cmVzLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuYmluZFRleHR1cmVzID0gSW1hZ2VTZXF1ZW5jZS5CaW5kVGV4dHVyZXMuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9yZW5kZXJlci51bmJpbmRUZXh0dXJlcyA9IEltYWdlU2VxdWVuY2UuVW5iaW5kVGV4dHVyZXMuYmluZCh0aGlzKTtcblxuICAgIHRoaXMubm9TdHJva2UoKTtcbiAgICB0aGlzLm5vRmlsbCgpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjdGV4dHVyZXNcbiAgICAgKiBAcHJvcGVydHkge1R3by5UZXh0dXJlW119IC0gQSBsaXN0IG9mIHRleHR1cmVzIHRvIGJlIHVzZWQgYXMgZnJhbWVzIGZvciBhbmltYXRpbmcgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXG4gICAgICovXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF0aHMpKSB7XG4gICAgICB0aGlzLnRleHR1cmVzID0gcGF0aHMubWFwKEltYWdlU2VxdWVuY2UuR2VuZXJhdGVUZXh0dXJlLmJpbmQodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBqdXN0IGEgc2luZ2xlIHBhdGggY29udmVydCBpbnRvIGEgc2luZ2xlIFR3by5UZXh0dXJlXG4gICAgICB0aGlzLnRleHR1cmVzID0gW0ltYWdlU2VxdWVuY2UuR2VuZXJhdGVUZXh0dXJlKHBhdGhzKV07XG4gICAgfVxuXG4gICAgdGhpcy5vcmlnaW4gPSBuZXcgVmVjdG9yKCk7XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uLnNldChveCB8fCAwLCBveSB8fCAwKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI2ZyYW1lUmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBudW1iZXIgb2YgZnJhbWVzIHRvIGFuaW1hdGUgYWdhaW5zdCBwZXIgc2Vjb25kLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZnJhbWVSYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5mcmFtZVJhdGUgPSBmcmFtZVJhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZnJhbWVSYXRlID0gSW1hZ2VTZXF1ZW5jZS5EZWZhdWx0RnJhbWVSYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI2luZGV4XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHRpbGUgb2YgdGhlIHNwcml0ZSB0byBkaXNwbGF5LiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5pbmRleCA9IDA7XG5cbiAgfVxuXG4gIF8uZXh0ZW5kKEltYWdlU2VxdWVuY2UsIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlLlByb3BlcnRpZXNcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ1tdfSAtIEEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIG9uIGV2ZXJ5IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXG4gICAgICovXG4gICAgUHJvcGVydGllczogW1xuICAgICAgJ2ZyYW1lUmF0ZScsXG4gICAgICAnaW5kZXgnXG4gICAgXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlLkRlZmF1bHRGcmFtZVJhdGVcbiAgICAgKiBAcHJvcGVydHkgVGhlIGRlZmF1bHQgZnJhbWUgcmF0ZSB0aGF0IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSNmcmFtZVJhdGV9IGlzIHNldCB0byB3aGVuIGluc3RhbnRpYXRlZC5cbiAgICAgKi9cbiAgICBEZWZhdWx0RnJhbWVSYXRlOiAzMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlLkZsYWdUZXh0dXJlc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCByZW5kZXJlcnMga25vdyB0ZXh0dXJlcyBoYXZlIGJlZW4gdXBkYXRlZCBvbiBhIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXG4gICAgICovXG4gICAgRmxhZ1RleHR1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX2ZsYWdUZXh0dXJlcyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlLkJpbmRUZXh0dXJlc1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZWQgbWV0aG9kIHRvIGxldCB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IGtub3cgdGV4dHVyZXMgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBCaW5kVGV4dHVyZXM6IGZ1bmN0aW9uKGl0ZW1zKSB7XG5cbiAgICAgIHZhciBpID0gaXRlbXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpdGVtc1tpXS5iaW5kKEV2ZW50cy5UeXBlcy5jaGFuZ2UsIHRoaXMuX3JlbmRlcmVyLmZsYWdUZXh0dXJlcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlbmRlcmVyLmZsYWdUZXh0dXJlcygpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlLlVuYmluZFZlcnRpY2VzXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIENhY2hlZCBtZXRob2QgdG8gbGV0IHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0ga25vdyB0ZXh0dXJlcyBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBVbmJpbmRUZXh0dXJlczogZnVuY3Rpb24oaXRlbXMpIHtcblxuICAgICAgdmFyIGkgPSBpdGVtcy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGl0ZW1zW2ldLnVuYmluZChFdmVudHMuVHlwZXMuY2hhbmdlLCB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlci5mbGFnVGV4dHVyZXMoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5NYWtlT2JzZXJ2YWJsZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgb2JqZWN0IHRvIG1ha2Ugb2JzZXJ2YWJsZS5cbiAgICAgKiBAZGVzY3JpcHRpb24gQ29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYXBwbHkgb2JzZXJ2YWJsZSBxdWFsaXRpZXMgb2YgYSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IHRvIGFueSBvYmplY3QuIEhhbmR5IGlmIHlvdSdkIGxpa2UgdG8gZXh0ZW5kIG9yIGluaGVyaXQgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgICBSZWN0YW5nbGUuTWFrZU9ic2VydmFibGUob2JqKTtcbiAgICAgIF8uZWFjaChJbWFnZVNlcXVlbmNlLlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqKTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgJ3RleHR1cmVzJywge1xuXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4dHVyZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0OiBmdW5jdGlvbih0ZXh0dXJlcykge1xuXG4gICAgICAgICAgdmFyIGJpbmRUZXh0dXJlcyA9IHRoaXMuX3JlbmRlcmVyLmJpbmRUZXh0dXJlcztcbiAgICAgICAgICB2YXIgdW5iaW5kVGV4dHVyZXMgPSB0aGlzLl9yZW5kZXJlci51bmJpbmRUZXh0dXJlcztcblxuICAgICAgICAgIC8vIFJlbW92ZSBwcmV2aW91cyBsaXN0ZW5lcnNcbiAgICAgICAgICBpZiAodGhpcy5fdGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3RleHR1cmVzXG4gICAgICAgICAgICAgIC51bmJpbmQoRXZlbnRzLlR5cGVzLmluc2VydCwgYmluZFRleHR1cmVzKVxuICAgICAgICAgICAgICAudW5iaW5kKEV2ZW50cy5UeXBlcy5yZW1vdmUsIHVuYmluZFRleHR1cmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDcmVhdGUgbmV3IENvbGxlY3Rpb24gd2l0aCBjb3B5IG9mIHZlcnRpY2VzXG4gICAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBuZXcgQ29sbGVjdGlvbigodGV4dHVyZXMgfHwgW10pLnNsaWNlKDApKTtcblxuICAgICAgICAgIC8vIExpc3RlbiBmb3IgQ29sbGVjdGlvbiBjaGFuZ2VzIGFuZCBiaW5kIC8gdW5iaW5kXG4gICAgICAgICAgdGhpcy5fdGV4dHVyZXNcbiAgICAgICAgICAgIC5iaW5kKEV2ZW50cy5UeXBlcy5pbnNlcnQsIGJpbmRUZXh0dXJlcylcbiAgICAgICAgICAgIC5iaW5kKEV2ZW50cy5UeXBlcy5yZW1vdmUsIHVuYmluZFRleHR1cmVzKTtcblxuICAgICAgICAgIC8vIEJpbmQgSW5pdGlhbCBUZXh0dXJlc1xuICAgICAgICAgIGJpbmRUZXh0dXJlcyh0aGlzLl90ZXh0dXJlcyk7XG5cbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZS5HZW5lcmF0ZVRleHR1cmVcbiAgICAgKiBAcHJvcGVydHkge0Z1bmN0aW9ufSAtIFNob3J0aGFuZCBmdW5jdGlvbiB0byBwcmVwYXJlIHNvdXJjZSBpbWFnZSBtYXRlcmlhbCBpbnRvIHJlYWRhYmxlIGZvcm1hdCBieSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFR3by5UZXh0dXJlfSB0ZXh0dXJlT3JTdHJpbmcgLSBUaGUgdGV4dHVyZSBvciBzdHJpbmcgdG8gY3JlYXRlIGEge0BsaW5rIFR3by5UZXh0dXJlfSBmcm9tLlxuICAgICAqIEBkZXNjcmlwdGlvbiBGdW5jdGlvbiB1c2VkIGludGVybmFsbHkgYnkge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSB0byBwYXJzZSBhcmd1bWVudHMgYW5kIHJldHVybiB7QGxpbmsgVHdvLlRleHR1cmV9cy5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlRleHR1cmV9XG4gICAgICovXG4gICAgR2VuZXJhdGVUZXh0dXJlOiBmdW5jdGlvbihvYmopIHtcbiAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBUZXh0dXJlKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dHVyZShvYmopO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChJbWFnZVNlcXVlbmNlLnByb3RvdHlwZSwgUmVjdGFuZ2xlLnByb3RvdHlwZSwge1xuXG4gICAgY29uc3RydWN0b3I6IEltYWdlU2VxdWVuY2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfZmxhZ1RleHR1cmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2UjdGV4dHVyZXN9IG5lZWQgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdUZXh0dXJlczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfZmxhZ0ZyYW1lUmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI2ZyYW1lUmF0ZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdGcmFtZVJhdGU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2ZsYWdJbmRleFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlI2luZGV4fSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ0luZGV4OiBmYWxzZSxcblxuICAgIC8vIFByaXZhdGUgdmFyaWFibGVzXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfYW1vdW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBOdW1iZXIgb2YgZnJhbWVzIGZvciBhIGdpdmVuIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXG4gICAgICovXG4gICAgX2Ftb3VudDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19kdXJhdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBhIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXG4gICAgICovXG4gICAgX2R1cmF0aW9uOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2luZGV4XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgY3VycmVudCBmcmFtZSB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBpcyBjdXJyZW50bHkgZGlzcGxheWluZy5cbiAgICAgKi9cbiAgICBfaW5kZXg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfc3RhcnRUaW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge01pbGxpc2Vjb25kc30gLSBFcG9jaCB0aW1lIGluIG1pbGxpc2Vjb25kcyBvZiB3aGVuIHRoZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2V9IHN0YXJ0ZWQuXG4gICAgICovXG4gICAgX3N0YXJ0VGltZTogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19wbGF5aW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGljdGF0ZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBpcyBhbmltYXRpbmcgb3Igbm90LlxuICAgICAqL1xuICAgIF9wbGF5aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI19maXJzdEZyYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgZnJhbWUgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gc2hvdWxkIHN0YXJ0IHdpdGguXG4gICAgICovXG4gICAgX2ZpcnN0RnJhbWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfbGFzdEZyYW1lXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgZnJhbWUgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gc2hvdWxkIGVuZCB3aXRoLlxuICAgICAqL1xuICAgIF9sYXN0RnJhbWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfcGxheWluZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERpY3RhdGVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gc2hvdWxkIGxvb3Agb3Igbm90LlxuICAgICAqL1xuICAgIF9sb29wOiB0cnVlLFxuXG4gICAgLy8gRXhwb3NlZCB0aHJvdWdoIGdldHRlci1zZXR0ZXJcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI190ZXh0dXJlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2UjdGV4dHVyZXN9XG4gICAgICovXG4gICAgX3RleHR1cmVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX2ZyYW1lUmF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkltYWdlU2VxdWVuY2UjZnJhbWVSYXRlfVxuICAgICAqL1xuICAgIF9mcmFtZVJhdGU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNfb3JpZ2luXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSNvcmlnaW59XG4gICAgICovXG4gICAgX29yaWdpbjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI3BsYXlcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2ZpcnN0RnJhbWU9MF0gLSBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIHRvIHN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2xhc3RGcmFtZV0gLSBUaGUgaW5kZXggb2YgdGhlIGZyYW1lIHRvIGVuZCB0aGUgYW5pbWF0aW9uIHdpdGguIERlZmF1bHRzIHRvIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZSN0ZXh0dXJlc30uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29uTGFzdEZyYW1lXSAtIE9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHRyaWdnZXJlZCBhZnRlciBwbGF5aW5nIHRoZSBsYXN0IGZyYW1lLiBUaGlzIGZpcmVzIG11bHRpcGxlIHRpbWVzIHdoZW4gdGhlIGltYWdlIHNlcXVlbmNlIGlzIGxvb3BlZC5cbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhdGUgYW5pbWF0aW9uIHBsYXliYWNrIG9mIGEge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfS5cbiAgICAgKi9cbiAgICBwbGF5OiBmdW5jdGlvbihmaXJzdEZyYW1lLCBsYXN0RnJhbWUsIG9uTGFzdEZyYW1lKSB7XG5cbiAgICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fZmlyc3RGcmFtZSA9IDA7XG4gICAgICB0aGlzLl9sYXN0RnJhbWUgPSB0aGlzLmFtb3VudCAtIDE7XG4gICAgICB0aGlzLl9zdGFydFRpbWUgPSBfLnBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICBpZiAodHlwZW9mIGZpcnN0RnJhbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX2ZpcnN0RnJhbWUgPSBmaXJzdEZyYW1lO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBsYXN0RnJhbWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZSA9IGxhc3RGcmFtZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb25MYXN0RnJhbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5fb25MYXN0RnJhbWUgPSBvbkxhc3RGcmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9vbkxhc3RGcmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2luZGV4ICE9PSB0aGlzLl9maXJzdEZyYW1lKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSAtPSAxMDAwICogTWF0aC5hYnModGhpcy5faW5kZXggLSB0aGlzLl9maXJzdEZyYW1lKVxuICAgICAgICAgIC8gdGhpcy5fZnJhbWVSYXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNwYXVzZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBIYWx0IGFuaW1hdGlvbiBwbGF5YmFjayBvZiBhIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0uXG4gICAgICovXG4gICAgcGF1c2U6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNzdG9wXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbHQgYW5pbWF0aW9uIHBsYXliYWNrIG9mIGEge0BsaW5rIFR3by5JbWFnZVNlcXVlbmNlfSBhbmQgc2V0IHRoZSBjdXJyZW50IGZyYW1lIGJhY2sgdG8gdGhlIGZpcnN0IGZyYW1lLlxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX2ZpcnN0RnJhbWU7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5JbWFnZVNlcXVlbmNlI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uSW1hZ2VTZXF1ZW5jZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uSW1hZ2VTZXF1ZW5jZX0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGltYWdlIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIGNsb25lID0gbmV3IEltYWdlU2VxdWVuY2UodGhpcy50ZXh0dXJlcywgdGhpcy50cmFuc2xhdGlvbi54LFxuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uLnksIHRoaXMuZnJhbWVSYXRlKTtcblxuICAgICAgY2xvbmUuX2xvb3AgPSB0aGlzLl9sb29wO1xuXG4gICAgICBpZiAodGhpcy5fcGxheWluZykge1xuICAgICAgICBjbG9uZS5wbGF5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmplY3QgPSBSZWN0YW5nbGUucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG4gICAgICBvYmplY3QudGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzLm1hcChmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlLnRvT2JqZWN0KCk7XG4gICAgICB9KTtcbiAgICAgIG9iamVjdC5mcmFtZVJhdGUgPSB0aGlzLmZyYW1lUmF0ZTtcbiAgICAgIG9iamVjdC5pbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICBvYmplY3QuX2ZpcnN0RnJhbWUgPSB0aGlzLl9maXJzdEZyYW1lO1xuICAgICAgb2JqZWN0Ll9sYXN0RnJhbWUgPSB0aGlzLl9sYXN0RnJhbWU7XG4gICAgICBvYmplY3QuX2xvb3AgPSB0aGlzLl9sb29wO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkltYWdlU2VxdWVuY2UjX3VwZGF0ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYnViYmxlcz1mYWxzZV0gLSBGb3JjZSB0aGUgcGFyZW50IHRvIGBfdXBkYXRlYCBhcyB3ZWxsLlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgcmVuZGVyaW5nIGhhcHBlbnMgYnkgdGhlIHJlbmRlcmVyLiBUaGlzIGFwcGxpZXMgYWxsIGNoYW5nZXMgbmVjZXNzYXJ5IHNvIHRoYXQgcmVuZGVyaW5nIGlzIHVwLXRvLWRhdGUgYnV0IG5vdCB1cGRhdGVkIG1vcmUgdGhhbiBpdCBuZWVkcyB0byBiZS5cbiAgICAgKiBAbm90YS1iZW5lIFRyeSBub3QgdG8gY2FsbCB0aGlzIG1ldGhvZCBtb3JlIHRoYW4gb25jZSBhIGZyYW1lLlxuICAgICAqL1xuICAgIF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgZWZmZWN0cyA9IHRoaXMuX3RleHR1cmVzO1xuICAgICAgdmFyIHdpZHRoLCBoZWlnaHQsIGVsYXBzZWQsIGFtb3VudCwgZHVyYXRpb24sIHRleHR1cmU7XG4gICAgICB2YXIgaW5kZXgsIGZyYW1lcztcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdUZXh0dXJlcykge1xuICAgICAgICB0aGlzLl9hbW91bnQgPSBlZmZlY3RzLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2ZsYWdGcmFtZVJhdGUpIHtcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSAxMDAwICogdGhpcy5fYW1vdW50IC8gdGhpcy5fZnJhbWVSYXRlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGxheWluZyAmJiB0aGlzLl9mcmFtZVJhdGUgPiAwKSB7XG5cbiAgICAgICAgYW1vdW50ID0gdGhpcy5fYW1vdW50O1xuXG4gICAgICAgIGlmIChfLmlzTmFOKHRoaXMuX2xhc3RGcmFtZSkpIHtcbiAgICAgICAgICB0aGlzLl9sYXN0RnJhbWUgPSBhbW91bnQgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogT2ZmbG9hZCBwZXJmIGxvZ2ljIHRvIGluc3RhbmNlIG9mIGBUd29gLlxuICAgICAgICBlbGFwc2VkID0gXy5wZXJmb3JtYW5jZS5ub3coKSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgZnJhbWVzID0gdGhpcy5fbGFzdEZyYW1lICsgMTtcbiAgICAgICAgZHVyYXRpb24gPSAxMDAwICogKGZyYW1lcyAtIHRoaXMuX2ZpcnN0RnJhbWUpIC8gdGhpcy5fZnJhbWVSYXRlO1xuXG4gICAgICAgIGlmICh0aGlzLl9sb29wKSB7XG4gICAgICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgJSBkdXJhdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGFwc2VkID0gTWF0aC5taW4oZWxhcHNlZCwgZHVyYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBsZXJwKHRoaXMuX2ZpcnN0RnJhbWUsIGZyYW1lcywgZWxhcHNlZCAvIGR1cmF0aW9uKTtcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKGluZGV4KTtcblxuICAgICAgICBpZiAoaW5kZXggIT09IHRoaXMuX2luZGV4KSB7XG5cbiAgICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4O1xuICAgICAgICAgIHRleHR1cmUgPSBlZmZlY3RzW3RoaXMuX2luZGV4XTtcblxuICAgICAgICAgIGlmICh0ZXh0dXJlLmxvYWRlZCkge1xuXG4gICAgICAgICAgICB3aWR0aCA9IHRleHR1cmUuaW1hZ2Uud2lkdGg7XG4gICAgICAgICAgICBoZWlnaHQgPSB0ZXh0dXJlLmltYWdlLmhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZpbGwgPSB0ZXh0dXJlO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5fbGFzdEZyYW1lIC0gMSAmJiB0aGlzLl9vbkxhc3RGcmFtZSkge1xuICAgICAgICAgICAgICB0aGlzLl9vbkxhc3RGcmFtZSgpOyAgLy8gU2hvcnRjdXQgZm9yIGNoYWluYWJsZSBzcHJpdGUgYW5pbWF0aW9uc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9mbGFnSW5kZXggfHwgISh0aGlzLmZpbGwgaW5zdGFuY2VvZiBUZXh0dXJlKSkge1xuXG4gICAgICAgIHRleHR1cmUgPSBlZmZlY3RzW3RoaXMuX2luZGV4XTtcblxuICAgICAgICBpZiAodGV4dHVyZS5sb2FkZWQpIHtcblxuICAgICAgICAgIHdpZHRoID0gdGV4dHVyZS5pbWFnZS53aWR0aDtcbiAgICAgICAgICBoZWlnaHQgPSB0ZXh0dXJlLmltYWdlLmhlaWdodDtcblxuICAgICAgICAgIGlmICh0aGlzLndpZHRoICE9PSB3aWR0aCkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgIT09IGhlaWdodCkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpbGwgPSB0ZXh0dXJlO1xuXG4gICAgICB9XG5cbiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uSW1hZ2VTZXF1ZW5jZSNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdUZXh0dXJlcyA9IHRoaXMuX2ZsYWdGcmFtZVJhdGUgPSBmYWxzZTtcbiAgICAgIFJlY3RhbmdsZS5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIEltYWdlU2VxdWVuY2UuTWFrZU9ic2VydmFibGUoSW1hZ2VTZXF1ZW5jZS5wcm90b3R5cGUpO1xuXG4gIHZhciBUV09fUEkkMiA9IE1hdGguUEkgKiAyLCBIQUxGX1BJID0gTWF0aC5QSSAvIDI7XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5BcmNTZWdtZW50XG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgYXJjIHNlZ21lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBhcmMgc2VnbWVudC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtpbm5lclJhZGl1cz0wXSAtIFRoZSBpbm5lciByYWRpdXMgdmFsdWUgb2YgdGhlIGFyYyBzZWdtZW50LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW291dGVyUmFkaXVzPTBdIC0gVGhlIG91dGVyIHJhZGl1cyB2YWx1ZSBvZiB0aGUgYXJjIHNlZ21lbnQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnRBbmdsZT0wXSAtIFRoZSBzdGFydCBhbmdsZSBvZiB0aGUgYXJjIHNlZ21lbnQgaW4gTnVtYmVyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZEFuZ2xlPTYuMjgzMV0gLSBUaGUgZW5kIGFuZ2xlIG9mIHRoZSBhcmMgc2VnbWVudCBpbiBOdW1iZXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmVzb2x1dGlvbj0yNF0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBhcmMgc2VnbWVudC5cbiAgICovXG4gIGZ1bmN0aW9uIEFyY1NlZ21lbnQob3gsIG95LCBpciwgb3IsIHNhLCBlYSwgcmVzKSB7XG5cbiAgICB2YXIgYW1vdW50ID0gcmVzIHx8IChDb25zdGFudHMuUmVzb2x1dGlvbiAqIDMpO1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG4gICAgICBwb2ludHMucHVzaChuZXcgQW5jaG9yKCkpO1xuICAgIH1cblxuICAgIFBhdGguY2FsbCh0aGlzLCBwb2ludHMsIHRydWUsIGZhbHNlLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I2lubmVyUmFkaXVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIGlubmVyIHJhZGl1cyBvZiB0aGUgYXJjIHNlZ21lbnQuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBpciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBpcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNvdXRlclJhZGl1c1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSBvdXRlciByYWRpdXMgb2YgdGhlIGFyYyBzZWdtZW50LlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygb3IgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm91dGVyUmFkaXVzID0gb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjc3RhcnRSYWRpdXNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgYW5nbGUgb2Ygb25lIHNpZGUgZm9yIHRoZSBhcmMgc2VnbWVudC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHNhID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5zdGFydEFuZ2xlID0gc2E7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjZW5kQW5nbGVcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgYW5nbGUgb2YgdGhlIG90aGVyIHNpZGUgZm9yIHRoZSBhcmMgc2VnbWVudC5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGVhID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5lbmRBbmdsZSA9IGVhO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBveCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueCA9IG94O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG95ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy50cmFuc2xhdGlvbi55ID0gb3k7XG4gICAgfVxuXG4gIH1cblxuICBfLmV4dGVuZChBcmNTZWdtZW50LCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudC5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLkFyY1NlZ21lbnR9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFsnc3RhcnRBbmdsZScsICdlbmRBbmdsZScsICdpbm5lclJhZGl1cycsICdvdXRlclJhZGl1cyddLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQuTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5BcmNTZWdtZW50fSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5BcmNTZWdtZW50fSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqKSB7XG5cbiAgICAgIFBhdGguTWFrZU9ic2VydmFibGUob2JqKTtcbiAgICAgIF8uZWFjaChBcmNTZWdtZW50LlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqKTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChBcmNTZWdtZW50LnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBBcmNTZWdtZW50LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX2ZsYWdTdGFydEFuZ2xlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjc3RhcnRBbmdsZX0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdTdGFydEFuZ2xlOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfZmxhZ0VuZEFuZ2xlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjZW5kQW5nbGV9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnRW5kQW5nbGU6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19mbGFnSW5uZXJSYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uQXJjU2VnbWVudCNpbm5lclJhZGl1c30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdJbm5lclJhZGl1czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLkFyY1NlZ21lbnQjX2ZsYWdPdXRlclJhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5BcmNTZWdtZW50I291dGVyUmFkaXVzfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ091dGVyUmFkaXVzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19zdGFydEFuZ2xlXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uQXJjU2VnbWVudCNzdGFydEFuZ2xlfVxuICAgICAqL1xuICAgIF9zdGFydEFuZ2xlOiAwLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I19lbmRBbmdsZVxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHNlZSB7QGxpbmsgVHdvLkFyY1NlZ21lbnQjZW5kQW5nbGV9XG4gICAgICovXG4gICAgX2VuZEFuZ2xlOiBUV09fUEkkMixcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfaW5uZXJSYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5BcmNTZWdtZW50I2lubmVyUmFkaXVzfVxuICAgICAqL1xuICAgIF9pbm5lclJhZGl1czogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNfb3V0ZXJSYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5BcmNTZWdtZW50I291dGVyUmFkaXVzfVxuICAgICAqL1xuICAgIF9vdXRlclJhZGl1czogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcyB8fCB0aGlzLl9mbGFnU3RhcnRBbmdsZSB8fCB0aGlzLl9mbGFnRW5kQW5nbGVcbiAgICAgICAgfHwgdGhpcy5fZmxhZ0lubmVyUmFkaXVzIHx8IHRoaXMuX2ZsYWdPdXRlclJhZGl1cykge1xuXG4gICAgICAgIHZhciBzYSA9IHRoaXMuX3N0YXJ0QW5nbGU7XG4gICAgICAgIHZhciBlYSA9IHRoaXMuX2VuZEFuZ2xlO1xuXG4gICAgICAgIHZhciBpciA9IHRoaXMuX2lubmVyUmFkaXVzO1xuICAgICAgICB2YXIgb3IgPSB0aGlzLl9vdXRlclJhZGl1cztcblxuICAgICAgICB2YXIgY29ubmVjdGVkID0gbW9kKHNhLCBUV09fUEkkMikgPT09IG1vZChlYSwgVFdPX1BJJDIpO1xuICAgICAgICB2YXIgcHVuY3R1cmVkID0gaXIgPiAwO1xuXG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgIHZhciBsZW5ndGggPSAocHVuY3R1cmVkID8gdmVydGljZXMubGVuZ3RoIC8gMiA6IHZlcnRpY2VzLmxlbmd0aCk7XG4gICAgICAgIHZhciBjb21tYW5kLCBpZCA9IDA7XG5cbiAgICAgICAgaWYgKGNvbm5lY3RlZCkge1xuICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICB9IGVsc2UgaWYgKCFwdW5jdHVyZWQpIHtcbiAgICAgICAgICBsZW5ndGggLT0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPdXRlciBDaXJjbGVcbiAgICAgICAgICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsYXN0ID0gbGVuZ3RoIC0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICB2YXIgcGN0ID0gaSAvIGxhc3Q7XG4gICAgICAgICAgdmFyIHYgPSB2ZXJ0aWNlc1tpZF07XG4gICAgICAgICAgdmFyIHRoZXRhID0gcGN0ICogKGVhIC0gc2EpICsgc2E7XG4gICAgICAgICAgdmFyIHN0ZXAgPSAoZWEgLSBzYSkgLyBsZW5ndGg7XG5cbiAgICAgICAgICB2YXIgeCA9IG9yICogTWF0aC5jb3ModGhldGEpO1xuICAgICAgICAgIHZhciB5ID0gb3IgKiBNYXRoLnNpbih0aGV0YSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY29tbWFuZCA9IENvbW1hbmRzLm1vdmU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29tbWFuZCA9IENvbW1hbmRzLmN1cnZlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHYuY29tbWFuZCA9IGNvbW1hbmQ7XG4gICAgICAgICAgdi54ID0geDtcbiAgICAgICAgICB2LnkgPSB5O1xuICAgICAgICAgIHYuY29udHJvbHMubGVmdC5jbGVhcigpO1xuICAgICAgICAgIHYuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcblxuICAgICAgICAgIGlmICh2LmNvbW1hbmQgPT09IENvbW1hbmRzLmN1cnZlKSB7XG4gICAgICAgICAgICB2YXIgYW1wID0gb3IgKiBzdGVwIC8gTWF0aC5QSTtcbiAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC54ID0gYW1wICogTWF0aC5jb3ModGhldGEgLSBIQUxGX1BJKTtcbiAgICAgICAgICAgIHYuY29udHJvbHMubGVmdC55ID0gYW1wICogTWF0aC5zaW4odGhldGEgLSBIQUxGX1BJKTtcbiAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQueCA9IGFtcCAqIE1hdGguY29zKHRoZXRhICsgSEFMRl9QSSk7XG4gICAgICAgICAgICB2LmNvbnRyb2xzLnJpZ2h0LnkgPSBhbXAgKiBNYXRoLnNpbih0aGV0YSArIEhBTEZfUEkpO1xuICAgICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0Lm11bHRpcGx5U2NhbGFyKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgdi5jb250cm9scy5yaWdodC5tdWx0aXBseVNjYWxhcigyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZCsrO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHVuY3R1cmVkKSB7XG5cbiAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICB2ZXJ0aWNlc1tpZF0uY29tbWFuZCA9IENvbW1hbmRzLmNsb3NlO1xuICAgICAgICAgICAgaWQrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBsYXN0ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBJbm5lciBDaXJjbGVcbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgcGN0ID0gaSAvIGxhc3Q7XG4gICAgICAgICAgICB2ID0gdmVydGljZXNbaWRdO1xuICAgICAgICAgICAgdGhldGEgPSAoMSAtIHBjdCkgKiAoZWEgLSBzYSkgKyBzYTtcbiAgICAgICAgICAgIHN0ZXAgPSAoZWEgLSBzYSkgLyBsZW5ndGg7XG5cbiAgICAgICAgICAgIHggPSBpciAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICAgIHkgPSBpciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBDb21tYW5kcy5jdXJ2ZTtcbiAgICAgICAgICAgIGlmIChpIDw9IDApIHtcbiAgICAgICAgICAgICAgY29tbWFuZCA9IGNvbm5lY3RlZCA/IENvbW1hbmRzLm1vdmUgOiBDb21tYW5kcy5saW5lO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2LmNvbW1hbmQgPSBjb21tYW5kO1xuICAgICAgICAgICAgdi54ID0geDtcbiAgICAgICAgICAgIHYueSA9IHk7XG4gICAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQuY2xlYXIoKTtcbiAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQuY2xlYXIoKTtcblxuICAgICAgICAgICAgaWYgKHYuY29tbWFuZCA9PT0gQ29tbWFuZHMuY3VydmUpIHtcbiAgICAgICAgICAgICAgYW1wID0gaXIgKiBzdGVwIC8gTWF0aC5QSTtcbiAgICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0LnggPSBhbXAgKiBNYXRoLmNvcyh0aGV0YSArIEhBTEZfUEkpO1xuICAgICAgICAgICAgICB2LmNvbnRyb2xzLmxlZnQueSA9IGFtcCAqIE1hdGguc2luKHRoZXRhICsgSEFMRl9QSSk7XG4gICAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQueCA9IGFtcCAqIE1hdGguY29zKHRoZXRhIC0gSEFMRl9QSSk7XG4gICAgICAgICAgICAgIHYuY29udHJvbHMucmlnaHQueSA9IGFtcCAqIE1hdGguc2luKHRoZXRhIC0gSEFMRl9QSSk7XG4gICAgICAgICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdi5jb250cm9scy5sZWZ0Lm11bHRpcGx5U2NhbGFyKDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChpID09PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgdi5jb250cm9scy5yaWdodC5tdWx0aXBseVNjYWxhcigyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZCsrO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRmluYWwgUG9pbnRcbiAgICAgICAgICB2ZXJ0aWNlc1tpZF0uY29weSh2ZXJ0aWNlc1swXSk7XG4gICAgICAgICAgdmVydGljZXNbaWRdLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIWNvbm5lY3RlZCkge1xuXG4gICAgICAgICAgdmVydGljZXNbaWRdLmNvbW1hbmQgPSBDb21tYW5kcy5saW5lO1xuICAgICAgICAgIHZlcnRpY2VzW2lkXS54ID0gMDtcbiAgICAgICAgICB2ZXJ0aWNlc1tpZF0ueSA9IDA7XG4gICAgICAgICAgaWQrKztcblxuICAgICAgICAgIC8vIEZpbmFsIFBvaW50XG4gICAgICAgICAgdmVydGljZXNbaWRdLmNvcHkodmVydGljZXNbMF0pO1xuICAgICAgICAgIHZlcnRpY2VzW2lkXS5jb21tYW5kID0gQ29tbWFuZHMubGluZTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIFBhdGgucHJvdG90eXBlLmZsYWdSZXNldC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLl9mbGFnU3RhcnRBbmdsZSA9IHRoaXMuX2ZsYWdFbmRBbmdsZVxuICAgICAgICA9IHRoaXMuX2ZsYWdJbm5lclJhZGl1cyA9IHRoaXMuX2ZsYWdPdXRlclJhZGl1cyA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uQXJjU2VnbWVudCNjbG9uZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkdyb3VwfSBbcGFyZW50XSAtIFRoZSBwYXJlbnQgZ3JvdXAgb3Igc2NlbmUgdG8gYWRkIHRoZSBjbG9uZSB0by5cbiAgICAgKiBAcmV0dXJucyB7VHdvLkFyY1NlZ21lbnR9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB7QGxpbmsgVHdvLkFyY1NlZ21lbnR9IHdpdGggdGhlIHNhbWUgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYXRoLlxuICAgICAqL1xuICAgIGNsb25lOiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgdmFyIGlyID0gdGhpcy5pbm5lclJhZGl1cztcbiAgICAgIHZhciBvciA9IHRoaXMub3V0ZXJSYWRpdXM7XG4gICAgICB2YXIgc2EgPSB0aGlzLnN0YXJ0QW5nbGU7XG4gICAgICB2YXIgZWEgPSB0aGlzLmVuZEFuZ2xlO1xuICAgICAgdmFyIHJlc29sdXRpb24gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgdmFyIGNsb25lID0gbmV3IEFyY1NlZ21lbnQoMCwgMCwgaXIsIG9yLCBzYSwgZWEsIHJlc29sdXRpb24pO1xuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgY2xvbmUuc2tld1kgPSB0aGlzLnNrZXdZO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgXy5lYWNoKFBhdGguUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5BcmNTZWdtZW50I3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gUGF0aC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcblxuICAgICAgXy5lYWNoKEFyY1NlZ21lbnQuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgQXJjU2VnbWVudC5NYWtlT2JzZXJ2YWJsZShBcmNTZWdtZW50LnByb3RvdHlwZSk7XG5cbiAgdmFyIFRXT19QSSQxID0gTWF0aC5QSSAqIDIsIGNvcyQxID0gTWF0aC5jb3MsIHNpbiQxID0gTWF0aC5zaW47XG5cbiAgLyoqXG4gICAqIEBuYW1lIFR3by5Qb2x5Z29uXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uUGF0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gW3g9MF0gLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt5PTBdIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHBvbHlnb24uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbcmFkaXVzPTBdIC0gVGhlIHJhZGl1cyB2YWx1ZSBvZiB0aGUgcG9seWdvbi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtzaWRlcz0xMl0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBwb2x5Z29uLlxuICAgKi9cbiAgZnVuY3Rpb24gUG9seWdvbihveCwgb3ksIHIsIHNpZGVzKSB7XG5cbiAgICBzaWRlcyA9IE1hdGgubWF4KHNpZGVzIHx8IDAsIDMpO1xuXG4gICAgUGF0aC5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5jbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuYXV0b21hdGljID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiN3aWR0aFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIFRoZSBzaXplIG9mIHRoZSB3aWR0aCBvZiB0aGUgcG9seWdvbi5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLndpZHRoID0gciAqIDI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jaGVpZ2h0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIHNpemUgb2YgdGhlIGhlaWdodCBvZiB0aGUgcG9seWdvbi5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmhlaWdodCA9IHIgKiAyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI3NpZGVzXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGFtb3VudCBvZiBzaWRlcyB0aGUgcG9seW9nbiBoYXMuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBzaWRlcyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuc2lkZXMgPSBzaWRlcztcbiAgICB9XG5cbiAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgIGlmICh0eXBlb2Ygb3ggPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0aW9uLnggPSBveDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBveSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueSA9IG95O1xuICAgIH1cblxuICB9XG5cbiAgXy5leHRlbmQoUG9seWdvbiwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24uUHJvcGVydGllc1xuICAgICAqIEBwcm9wZXJ0eSB7U3RyaW5nW119IC0gQSBsaXN0IG9mIHByb3BlcnRpZXMgdGhhdCBhcmUgb24gZXZlcnkge0BsaW5rIFR3by5Qb2x5Z29ufS5cbiAgICAgKi9cbiAgICBQcm9wZXJ0aWVzOiBbJ3dpZHRoJywgJ2hlaWdodCcsICdzaWRlcyddLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24uTWFrZU9ic2VydmFibGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYWtlIG9ic2VydmFibGUuXG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGFwcGx5IG9ic2VydmFibGUgcXVhbGl0aWVzIG9mIGEge0BsaW5rIFR3by5Qb2x5Z29ufSB0byBhbnkgb2JqZWN0LiBIYW5keSBpZiB5b3UnZCBsaWtlIHRvIGV4dGVuZCB0aGUge0BsaW5rIFR3by5Qb2x5Z29ufSBjbGFzcyBvbiBhIGN1c3RvbSBjbGFzcy5cbiAgICAgKi9cbiAgICBNYWtlT2JzZXJ2YWJsZTogZnVuY3Rpb24ob2JqKSB7XG5cbiAgICAgIFBhdGguTWFrZU9ic2VydmFibGUob2JqKTtcbiAgICAgIF8uZWFjaChQb2x5Z29uLlByb3BlcnRpZXMsIGRlZmluZUdldHRlclNldHRlciwgb2JqKTtcblxuICAgIH1cblxuICB9KTtcblxuICBfLmV4dGVuZChQb2x5Z29uLnByb3RvdHlwZSwgUGF0aC5wcm90b3R5cGUsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBQb2x5Z29uLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jX2ZsYWdXaWR0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Qb2x5Z29uI3dpZHRofSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ1dpZHRoOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfZmxhZ0hlaWdodFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5Qb2x5Z29uI2hlaWdodH0gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdIZWlnaHQ6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI19mbGFnU2lkZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uUG9seWdvbiNzaWRlc30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdTaWRlczogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfd2lkdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5Qb2x5Z29uI3dpZHRofVxuICAgICAqL1xuICAgIF93aWR0aDogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfaGVpZ2h0XG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uUG9seWdvbiNoZWlnaHR9XG4gICAgICovXG4gICAgX2hlaWdodDogMCxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiNfc2lkZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBzZWUge0BsaW5rIFR3by5Qb2x5Z29uI3NpZGVzfVxuICAgICAqL1xuICAgIF9zaWRlczogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5Qb2x5Z29uI191cGRhdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2J1YmJsZXM9ZmFsc2VdIC0gRm9yY2UgdGhlIHBhcmVudCB0byBgX3VwZGF0ZWAgYXMgd2VsbC5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBpcyBjYWxsZWQgYmVmb3JlIHJlbmRlcmluZyBoYXBwZW5zIGJ5IHRoZSByZW5kZXJlci4gVGhpcyBhcHBsaWVzIGFsbCBjaGFuZ2VzIG5lY2Vzc2FyeSBzbyB0aGF0IHJlbmRlcmluZyBpcyB1cC10by1kYXRlIGJ1dCBub3QgdXBkYXRlZCBtb3JlIHRoYW4gaXQgbmVlZHMgdG8gYmUuXG4gICAgICogQG5vdGEtYmVuZSBUcnkgbm90IHRvIGNhbGwgdGhpcyBtZXRob2QgbW9yZSB0aGFuIG9uY2UgYSBmcmFtZS5cbiAgICAgKi9cbiAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcblxuICAgICAgaWYgKHRoaXMuX2ZsYWdWZXJ0aWNlcyB8fCB0aGlzLl9mbGFnV2lkdGggfHwgdGhpcy5fZmxhZ0hlaWdodCB8fCB0aGlzLl9mbGFnU2lkZXMpIHtcblxuICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLl9zaWRlcztcbiAgICAgICAgdmFyIGFtb3VudCA9IHNpZGVzICsgMTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChsZW5ndGggPiBzaWRlcykge1xuICAgICAgICAgIHRoaXMudmVydGljZXMuc3BsaWNlKHNpZGVzIC0gMSwgbGVuZ3RoIC0gc2lkZXMpO1xuICAgICAgICAgIGxlbmd0aCA9IHNpZGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXG4gICAgICAgICAgdmFyIHBjdCA9IChpICsgMC41KSAvIHNpZGVzO1xuICAgICAgICAgIHZhciB0aGV0YSA9IFRXT19QSSQxICogcGN0ICsgTWF0aC5QSSAvIDI7XG4gICAgICAgICAgdmFyIHggPSB0aGlzLl93aWR0aCAqIGNvcyQxKHRoZXRhKSAvIDI7XG4gICAgICAgICAgdmFyIHkgPSB0aGlzLl9oZWlnaHQgKiBzaW4kMSh0aGV0YSkgLyAyO1xuXG4gICAgICAgICAgaWYgKGkgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IEFuY2hvcih4LCB5KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbaV0uc2V0KHgsIHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudmVydGljZXNbaV0uY29tbWFuZCA9IGkgPT09IDAgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMubGluZTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jZmxhZ1Jlc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZGVzY3JpcHRpb24gQ2FsbGVkIGludGVybmFsbHkgdG8gcmVzZXQgYWxsIGZsYWdzLiBFbnN1cmVzIHRoYXQgb25seSBwcm9wZXJ0aWVzIHRoYXQgY2hhbmdlIGFyZSB1cGRhdGVkIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSByZW5kZXJlci5cbiAgICAgKi9cbiAgICBmbGFnUmVzZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLl9mbGFnV2lkdGggPSB0aGlzLl9mbGFnSGVpZ2h0ID0gdGhpcy5fZmxhZ1NpZGVzID0gZmFsc2U7XG4gICAgICBQYXRoLnByb3RvdHlwZS5mbGFnUmVzZXQuY2FsbCh0aGlzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlBvbHlnb24jY2xvbmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1R3by5Hcm91cH0gW3BhcmVudF0gLSBUaGUgcGFyZW50IGdyb3VwIG9yIHNjZW5lIHRvIGFkZCB0aGUgY2xvbmUgdG8uXG4gICAgICogQHJldHVybnMge1R3by5Qb2x5Z29ufVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3by5Qb2x5Z29ufSB3aXRoIHRoZSBzYW1lIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgcGF0aC5cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBQb2x5Z29uKDAsIDAsIHRoaXMucmFkaXVzLCB0aGlzLnNpZGVzKTtcblxuICAgICAgY2xvbmUudHJhbnNsYXRpb24uY29weSh0aGlzLnRyYW5zbGF0aW9uKTtcbiAgICAgIGNsb25lLnJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcbiAgICAgIGNsb25lLnNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgIGNsb25lLnNrZXdYID0gdGhpcy5za2V3WDtcbiAgICAgIGNsb25lLnNrZXdZID0gdGhpcy5za2V3WTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4Lm1hbnVhbCkge1xuICAgICAgICBjbG9uZS5tYXRyaXguY29weSh0aGlzLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIF8uZWFjaChQYXRoLlByb3BlcnRpZXMsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY2xvbmVba10gPSB0aGlzW2tdO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmFkZChjbG9uZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9uZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uUG9seWdvbiN0b09iamVjdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIEpTT04gY29tcGF0aWJsZSBwbGFpbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBwYXRoLlxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIG9iamVjdCA9IFBhdGgucHJvdG90eXBlLnRvT2JqZWN0LmNhbGwodGhpcyk7XG5cbiAgICAgIF8uZWFjaChQb2x5Z29uLlByb3BlcnRpZXMsIGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0gPSB0aGlzW3Byb3BlcnR5XTtcbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuXG4gICAgfVxuXG4gIH0pO1xuXG4gIFBvbHlnb24uTWFrZU9ic2VydmFibGUoUG9seWdvbi5wcm90b3R5cGUpO1xuXG4gIHZhciBUV09fUEkgPSBNYXRoLlBJICogMiwgY29zID0gTWF0aC5jb3MsIHNpbiA9IE1hdGguc2luO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uU3RhclxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLlBhdGhcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFt4PTBdIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbeT0wXSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzdGFyLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2lubmVyUmFkaXVzPTBdIC0gVGhlIGlubmVyIHJhZGl1cyB2YWx1ZSBvZiB0aGUgc3Rhci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvdXRlclJhZGl1cz0wXSAtIFRoZSBvdXRlciByYWRpdXMgdmFsdWUgb2YgdGhlIHN0YXIuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc2lkZXM9NV0gLSBUaGUgbnVtYmVyIG9mIHNpZGVzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBzdGFyLlxuICAgKi9cbiAgZnVuY3Rpb24gU3RhcihveCwgb3ksIGlyLCBvciwgc2lkZXMpIHtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDMpIHtcbiAgICAgIG9yID0gaXI7XG4gICAgICBpciA9IG9yIC8gMjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNpZGVzICE9PSAnbnVtYmVyJyB8fCBzaWRlcyA8PSAwKSB7XG4gICAgICBzaWRlcyA9IDU7XG4gICAgfVxuXG4gICAgUGF0aC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9tYXRpYyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjaW5uZXJSYWRpdXNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgaW5uZXIgcmFkaXVzIG9mIHRoZSBzdGFyLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgaXIgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmlubmVyUmFkaXVzID0gaXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjb3V0ZXJSYWRpdXNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgc2l6ZSBvZiB0aGUgb3V0ZXIgcmFkaXVzIG9mIHRoZSBzdGFyLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2Ygb3IgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLm91dGVyUmFkaXVzID0gb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjc2lkZXNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgYW1vdW50IG9mIHNpZGVzIHRoZSBzdGFyIGhhcy5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIHNpZGVzID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5zaWRlcyA9IHNpZGVzO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBveCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRpb24ueCA9IG94O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG95ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy50cmFuc2xhdGlvbi55ID0gb3k7XG4gICAgfVxuXG4gIH1cblxuICBfLmV4dGVuZChTdGFyLCB7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3Rhci5Qcm9wZXJ0aWVzXG4gICAgICogQHByb3BlcnR5IHtTdHJpbmdbXX0gLSBBIGxpc3Qgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBvbiBldmVyeSB7QGxpbmsgVHdvLlN0YXJ9LlxuICAgICAqL1xuICAgIFByb3BlcnRpZXM6IFsnaW5uZXJSYWRpdXMnLCAnb3V0ZXJSYWRpdXMnLCAnc2lkZXMnXSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyLk1ha2VPYnNlcnZhYmxlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFrZSBvYnNlcnZhYmxlLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDb252ZW5pZW5jZSBmdW5jdGlvbiB0byBhcHBseSBvYnNlcnZhYmxlIHF1YWxpdGllcyBvZiBhIHtAbGluayBUd28uU3Rhcn0gdG8gYW55IG9iamVjdC4gSGFuZHkgaWYgeW91J2QgbGlrZSB0byBleHRlbmQgdGhlIHtAbGluayBUd28uU3Rhcn0gY2xhc3Mgb24gYSBjdXN0b20gY2xhc3MuXG4gICAgICovXG4gICAgTWFrZU9ic2VydmFibGU6IGZ1bmN0aW9uKG9iaikge1xuXG4gICAgICBQYXRoLk1ha2VPYnNlcnZhYmxlKG9iaik7XG4gICAgICBfLmVhY2goU3Rhci5Qcm9wZXJ0aWVzLCBkZWZpbmVHZXR0ZXJTZXR0ZXIsIG9iaik7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoU3Rhci5wcm90b3R5cGUsIFBhdGgucHJvdG90eXBlLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogU3RhcixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI19mbGFnSW5uZXJSYWRpdXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHtAbGluayBUd28uU3RhciNpbm5lclJhZGl1c30gbmVlZHMgdXBkYXRpbmcuXG4gICAgICovXG4gICAgX2ZsYWdJbm5lclJhZGl1czogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjX2ZsYWdPdXRlclJhZGl1c1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSAtIERldGVybWluZXMgd2hldGhlciB0aGUge0BsaW5rIFR3by5TdGFyI291dGVyUmFkaXVzfSBuZWVkcyB1cGRhdGluZy5cbiAgICAgKi9cbiAgICBfZmxhZ091dGVyUmFkaXVzOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RhciNfZmxhZ1NpZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSB7QGxpbmsgVHdvLlN0YXIjc2lkZXN9IG5lZWRzIHVwZGF0aW5nLlxuICAgICAqL1xuICAgIF9mbGFnU2lkZXM6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjX2lubmVyUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3RhciNpbm5lclJhZGl1c31cbiAgICAgKi9cbiAgICBfaW5uZXJSYWRpdXM6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjX291dGVyUmFkaXVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3RhciNvdXRlclJhZGl1c31cbiAgICAgKi9cbiAgICBfb3V0ZXJSYWRpdXM6IDAsXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlN0YXIjX3NpZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc2VlIHtAbGluayBUd28uU3RhciNzaWRlc31cbiAgICAgKi9cbiAgICBfc2lkZXM6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RhciNfdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtidWJibGVzPWZhbHNlXSAtIEZvcmNlIHRoZSBwYXJlbnQgdG8gYF91cGRhdGVgIGFzIHdlbGwuXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSByZW5kZXJpbmcgaGFwcGVucyBieSB0aGUgcmVuZGVyZXIuIFRoaXMgYXBwbGllcyBhbGwgY2hhbmdlcyBuZWNlc3Nhcnkgc28gdGhhdCByZW5kZXJpbmcgaXMgdXAtdG8tZGF0ZSBidXQgbm90IHVwZGF0ZWQgbW9yZSB0aGFuIGl0IG5lZWRzIHRvIGJlLlxuICAgICAqIEBub3RhLWJlbmUgVHJ5IG5vdCB0byBjYWxsIHRoaXMgbWV0aG9kIG1vcmUgdGhhbiBvbmNlIGEgZnJhbWUuXG4gICAgICovXG4gICAgX3VwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIGlmICh0aGlzLl9mbGFnVmVydGljZXMgfHwgdGhpcy5fZmxhZ0lubmVyUmFkaXVzIHx8IHRoaXMuX2ZsYWdPdXRlclJhZGl1cyB8fCB0aGlzLl9mbGFnU2lkZXMpIHtcblxuICAgICAgICB2YXIgc2lkZXMgPSB0aGlzLl9zaWRlcyAqIDI7XG4gICAgICAgIHZhciBhbW91bnQgPSBzaWRlcyArIDE7XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDtcblxuICAgICAgICBpZiAobGVuZ3RoID4gc2lkZXMpIHtcbiAgICAgICAgICB0aGlzLnZlcnRpY2VzLnNwbGljZShzaWRlcyAtIDEsIGxlbmd0aCAtIHNpZGVzKTtcbiAgICAgICAgICBsZW5ndGggPSBzaWRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblxuICAgICAgICAgIHZhciBwY3QgPSAoaSArIDAuNSkgLyBzaWRlcztcbiAgICAgICAgICB2YXIgdGhldGEgPSBUV09fUEkgKiBwY3Q7XG4gICAgICAgICAgdmFyIHIgPSAoIShpICUgMikgPyB0aGlzLl9pbm5lclJhZGl1cyA6IHRoaXMuX291dGVyUmFkaXVzKSAvIDI7XG4gICAgICAgICAgdmFyIHggPSByICogY29zKHRoZXRhKTtcbiAgICAgICAgICB2YXIgeSA9IHIgKiBzaW4odGhldGEpO1xuXG4gICAgICAgICAgaWYgKGkgPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2gobmV3IEFuY2hvcih4LCB5KSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXNbaV0uc2V0KHgsIHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudmVydGljZXNbaV0uY29tbWFuZCA9IGkgPT09IDAgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMubGluZTtcblxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgUGF0aC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU3RhciNmbGFnUmVzZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsZWQgaW50ZXJuYWxseSB0byByZXNldCBhbGwgZmxhZ3MuIEVuc3VyZXMgdGhhdCBvbmx5IHByb3BlcnRpZXMgdGhhdCBjaGFuZ2UgYXJlIHVwZGF0ZWQgYmVmb3JlIGJlaW5nIHNlbnQgdG8gdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIGZsYWdSZXNldDogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHRoaXMuX2ZsYWdJbm5lclJhZGl1cyA9IHRoaXMuX2ZsYWdPdXRlclJhZGl1cyA9IHRoaXMuX2ZsYWdTaWRlcyA9IGZhbHNlO1xuICAgICAgUGF0aC5wcm90b3R5cGUuZmxhZ1Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI2Nsb25lXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtUd28uR3JvdXB9IFtwYXJlbnRdIC0gVGhlIHBhcmVudCBncm91cCBvciBzY2VuZSB0byBhZGQgdGhlIGNsb25lIHRvLlxuICAgICAqIEByZXR1cm5zIHtUd28uU3Rhcn1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd28uU3Rhcn0gd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhdGguXG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICB2YXIgaXIgPSB0aGlzLmlubmVyUmFkaXVzO1xuICAgICAgdmFyIG9yID0gdGhpcy5vdXRlclJhZGl1cztcbiAgICAgIHZhciBzaWRlcyA9IHRoaXMuc2lkZXM7XG5cbiAgICAgIHZhciBjbG9uZSA9IG5ldyBTdGFyKDAsIDAsIGlyLCBvciwgc2lkZXMpO1xuXG4gICAgICBjbG9uZS50cmFuc2xhdGlvbi5jb3B5KHRoaXMudHJhbnNsYXRpb24pO1xuICAgICAgY2xvbmUucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xuICAgICAgY2xvbmUuc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgY2xvbmUuc2tld1ggPSB0aGlzLnNrZXdYO1xuICAgICAgY2xvbmUuc2tld1kgPSB0aGlzLnNrZXdZO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgubWFudWFsKSB7XG4gICAgICAgIGNsb25lLm1hdHJpeC5jb3B5KHRoaXMubWF0cml4KTtcbiAgICAgIH1cblxuICAgICAgXy5lYWNoKFBhdGguUHJvcGVydGllcywgZnVuY3Rpb24oaykge1xuICAgICAgICBjbG9uZVtrXSA9IHRoaXNba107XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICBwYXJlbnQuYWRkKGNsb25lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNsb25lO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TdGFyI3RvT2JqZWN0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgSlNPTiBjb21wYXRpYmxlIHBsYWluIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHBhdGguXG4gICAgICovXG4gICAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgb2JqZWN0ID0gUGF0aC5wcm90b3R5cGUudG9PYmplY3QuY2FsbCh0aGlzKTtcblxuICAgICAgXy5lYWNoKFN0YXIuUHJvcGVydGllcywgZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICAgICAgb2JqZWN0W3Byb3BlcnR5XSA9IHRoaXNbcHJvcGVydHldO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiBvYmplY3Q7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgU3Rhci5NYWtlT2JzZXJ2YWJsZShTdGFyLnByb3RvdHlwZSk7XG5cbiAgdmFyIHN2ZyA9IHtcblxuICAgIHZlcnNpb246IDEuMSxcblxuICAgIG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuICAgIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cbiAgICBhbGlnbm1lbnRzOiB7XG4gICAgICBsZWZ0OiAnc3RhcnQnLFxuICAgICAgY2VudGVyOiAnbWlkZGxlJyxcbiAgICAgIHJpZ2h0OiAnZW5kJ1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYW4gc3ZnIG5hbWVzcGFjZWQgZWxlbWVudC5cbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jdGlvbihuYW1lLCBhdHRycykge1xuICAgICAgdmFyIHRhZyA9IG5hbWU7XG4gICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmcubnMsIHRhZyk7XG4gICAgICBpZiAodGFnID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IF8uZGVmYXVsdHMoYXR0cnMgfHwge30sIHtcbiAgICAgICAgICB2ZXJzaW9uOiBzdmcudmVyc2lvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChhdHRycyAmJiBPYmplY3Qua2V5cyhhdHRycykubGVuZ3RoID4gMCkge1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyhlbGVtLCBhdHRycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbTtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGF0dHJpYnV0ZXMgZnJvbSBhbiBzdmcgZWxlbWVudC5cbiAgICBzZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtLCBhdHRycykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhdHRycyk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKC9ocmVmLy50ZXN0KGtleXNbaV0pKSB7XG4gICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGVOUyhzdmcueGxpbmssIGtleXNbaV0sIGF0dHJzW2tleXNbaV1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZShrZXlzW2ldLCBhdHRyc1trZXlzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW1vdmUgYXR0cmlidXRlcyBmcm9tIGFuIHN2ZyBlbGVtZW50LlxuICAgIHJlbW92ZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGVsZW0sIGF0dHJzKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUdXJuIGEgc2V0IG9mIHZlcnRpY2VzIGludG8gYSBzdHJpbmcgZm9yIHRoZSBkIHByb3BlcnR5IG9mIGEgcGF0aFxuICAgIC8vIGVsZW1lbnQuIEl0IGlzIGltcGVyYXRpdmUgdGhhdCB0aGUgc3RyaW5nIGNvbGxhdGlvbiBpcyBhcyBmYXN0IGFzXG4gICAgLy8gcG9zc2libGUsIGJlY2F1c2UgdGhpcyBjYWxsIHdpbGwgYmUgaGFwcGVuaW5nIG11bHRpcGxlIHRpbWVzIGFcbiAgICAvLyBzZWNvbmQuXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKHBvaW50cywgY2xvc2VkKSB7XG5cbiAgICAgIHZhciBsID0gcG9pbnRzLmxlbmd0aCxcbiAgICAgICAgbGFzdCA9IGwgLSAxLFxuICAgICAgICBkLCAvLyBUaGUgZWx1c2l2ZSBsYXN0IENvbW1hbmRzLm1vdmUgcG9pbnRcbiAgICAgICAgc3RyaW5nID0gJyc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBiID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgY29tbWFuZDtcbiAgICAgICAgdmFyIHByZXYgPSBjbG9zZWQgPyBtb2QoaSAtIDEsIGwpIDogTWF0aC5tYXgoaSAtIDEsIDApO1xuICAgICAgICB2YXIgbmV4dCA9IGNsb3NlZCA/IG1vZChpICsgMSwgbCkgOiBNYXRoLm1pbihpICsgMSwgbGFzdCk7XG5cbiAgICAgICAgdmFyIGEgPSBwb2ludHNbcHJldl07XG4gICAgICAgIHZhciBjID0gcG9pbnRzW25leHRdO1xuXG4gICAgICAgIHZhciB2eCwgdnksIHV4LCB1eSwgYXIsIGJsLCBiciwgY2w7XG4gICAgICAgIHZhciByeCwgcnksIHhBeGlzUm90YXRpb24sIGxhcmdlQXJjRmxhZywgc3dlZXBGbGFnO1xuXG4gICAgICAgIC8vIEFjY2VzcyB4IGFuZCB5IGRpcmVjdGx5LFxuICAgICAgICAvLyBieXBhc3NpbmcgdGhlIGdldHRlclxuICAgICAgICB2YXIgeCA9IHRvRml4ZWQoYi54KTtcbiAgICAgICAgdmFyIHkgPSB0b0ZpeGVkKGIueSk7XG5cbiAgICAgICAgc3dpdGNoIChiLmNvbW1hbmQpIHtcblxuICAgICAgICAgIGNhc2UgQ29tbWFuZHMuY2xvc2U6XG4gICAgICAgICAgICBjb21tYW5kID0gQ29tbWFuZHMuY2xvc2U7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQ29tbWFuZHMuYXJjOlxuXG4gICAgICAgICAgICByeCA9IGIucng7XG4gICAgICAgICAgICByeSA9IGIucnk7XG4gICAgICAgICAgICB4QXhpc1JvdGF0aW9uID0gYi54QXhpc1JvdGF0aW9uO1xuICAgICAgICAgICAgbGFyZ2VBcmNGbGFnID0gYi5sYXJnZUFyY0ZsYWc7XG4gICAgICAgICAgICBzd2VlcEZsYWcgPSBiLnN3ZWVwRmxhZztcblxuICAgICAgICAgICAgY29tbWFuZCA9IENvbW1hbmRzLmFyYyArICcgJyArIHJ4ICsgJyAnICsgcnkgKyAnICdcbiAgICAgICAgICAgICAgKyB4QXhpc1JvdGF0aW9uICsgJyAnICsgbGFyZ2VBcmNGbGFnICsgJyAnICsgc3dlZXBGbGFnICsgJyAnXG4gICAgICAgICAgICAgICsgeCArICcgJyArIHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQ29tbWFuZHMuY3VydmU6XG5cbiAgICAgICAgICAgIGFyID0gKGEuY29udHJvbHMgJiYgYS5jb250cm9scy5yaWdodCkgfHwgVmVjdG9yLnplcm87XG4gICAgICAgICAgICBibCA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMubGVmdCkgfHwgVmVjdG9yLnplcm87XG5cbiAgICAgICAgICAgIGlmIChhLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgIHZ4ID0gdG9GaXhlZCgoYXIueCArIGEueCkpO1xuICAgICAgICAgICAgICB2eSA9IHRvRml4ZWQoKGFyLnkgKyBhLnkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZ4ID0gdG9GaXhlZChhci54KTtcbiAgICAgICAgICAgICAgdnkgPSB0b0ZpeGVkKGFyLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYi5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoKGJsLnggKyBiLngpKTtcbiAgICAgICAgICAgICAgdXkgPSB0b0ZpeGVkKChibC55ICsgYi55KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoYmwueCk7XG4gICAgICAgICAgICAgIHV5ID0gdG9GaXhlZChibC55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29tbWFuZCA9ICgoaSA9PT0gMCkgPyBDb21tYW5kcy5tb3ZlIDogQ29tbWFuZHMuY3VydmUpICtcbiAgICAgICAgICAgICAgJyAnICsgdnggKyAnICcgKyB2eSArICcgJyArIHV4ICsgJyAnICsgdXkgKyAnICcgKyB4ICsgJyAnICsgeTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBDb21tYW5kcy5tb3ZlOlxuICAgICAgICAgICAgZCA9IGI7XG4gICAgICAgICAgICBjb21tYW5kID0gQ29tbWFuZHMubW92ZSArICcgJyArIHggKyAnICcgKyB5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29tbWFuZCA9IGIuY29tbWFuZCArICcgJyArIHggKyAnICcgKyB5O1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgYSBmaW5hbCBwb2ludCBhbmQgY2xvc2UgaXQgb2ZmXG5cbiAgICAgICAgaWYgKGkgPj0gbGFzdCAmJiBjbG9zZWQpIHtcblxuICAgICAgICAgIGlmIChiLmNvbW1hbmQgPT09IENvbW1hbmRzLmN1cnZlKSB7XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBjbG9zZSB0byB0aGUgbW9zdCBwcmV2aW91cyBDb21tYW5kcy5tb3ZlXG4gICAgICAgICAgICBjID0gZDtcblxuICAgICAgICAgICAgYnIgPSAoYi5jb250cm9scyAmJiBiLmNvbnRyb2xzLnJpZ2h0KSB8fCBiO1xuICAgICAgICAgICAgY2wgPSAoYy5jb250cm9scyAmJiBjLmNvbnRyb2xzLmxlZnQpIHx8IGM7XG5cbiAgICAgICAgICAgIGlmIChiLnJlbGF0aXZlKSB7XG4gICAgICAgICAgICAgIHZ4ID0gdG9GaXhlZCgoYnIueCArIGIueCkpO1xuICAgICAgICAgICAgICB2eSA9IHRvRml4ZWQoKGJyLnkgKyBiLnkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZ4ID0gdG9GaXhlZChici54KTtcbiAgICAgICAgICAgICAgdnkgPSB0b0ZpeGVkKGJyLnkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYy5yZWxhdGl2ZSkge1xuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoKGNsLnggKyBjLngpKTtcbiAgICAgICAgICAgICAgdXkgPSB0b0ZpeGVkKChjbC55ICsgYy55KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1eCA9IHRvRml4ZWQoY2wueCk7XG4gICAgICAgICAgICAgIHV5ID0gdG9GaXhlZChjbC55KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCA9IHRvRml4ZWQoYy54KTtcbiAgICAgICAgICAgIHkgPSB0b0ZpeGVkKGMueSk7XG5cbiAgICAgICAgICAgIGNvbW1hbmQgKz1cbiAgICAgICAgICAgICAgJyBDICcgKyB2eCArICcgJyArIHZ5ICsgJyAnICsgdXggKyAnICcgKyB1eSArICcgJyArIHggKyAnICcgKyB5O1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGIuY29tbWFuZCAhPT0gQ29tbWFuZHMuY2xvc2UpIHtcbiAgICAgICAgICAgIGNvbW1hbmQgKz0gJyBaJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmluZyArPSBjb21tYW5kICsgJyAnO1xuXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJpbmc7XG5cbiAgICB9LFxuXG4gICAgZ2V0Q2xpcDogZnVuY3Rpb24oc2hhcGUsIGRvbUVsZW1lbnQpIHtcblxuICAgICAgdmFyIGNsaXAgPSBzaGFwZS5fcmVuZGVyZXIuY2xpcDtcblxuICAgICAgaWYgKCFjbGlwKSB7XG5cbiAgICAgICAgY2xpcCA9IHNoYXBlLl9yZW5kZXJlci5jbGlwID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ2NsaXBQYXRoJywge1xuICAgICAgICAgICdjbGlwLXJ1bGUnOiAnbm9uemVybydcbiAgICAgICAgfSk7XG4gICAgICAgIGRvbUVsZW1lbnQuZGVmcy5hcHBlbmRDaGlsZChjbGlwKTtcblxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xpcDtcblxuICAgIH0sXG5cbiAgICBncm91cDoge1xuXG4gICAgICAvLyBUT0RPOiBDYW4gc3BlZWQgdXAuXG4gICAgICAvLyBUT0RPOiBIb3cgZG9lcyB0aGlzIGVmZmVjdCBhIGZcbiAgICAgIGFwcGVuZENoaWxkOiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgICB2YXIgZWxlbSA9IG9iamVjdC5fcmVuZGVyZXIuZWxlbTtcblxuICAgICAgICBpZiAoIWVsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFnID0gZWxlbS5ub2RlTmFtZTtcblxuICAgICAgICBpZiAoIXRhZyB8fCAvKHJhZGlhbHxsaW5lYXIpZ3JhZGllbnQvaS50ZXN0KHRhZykgfHwgb2JqZWN0Ll9jbGlwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtLmFwcGVuZENoaWxkKGVsZW0pO1xuXG4gICAgICB9LFxuXG4gICAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24ob2JqZWN0KSB7XG5cbiAgICAgICAgdmFyIGVsZW0gPSBvYmplY3QuX3JlbmRlcmVyLmVsZW07XG5cbiAgICAgICAgaWYgKCFlbGVtIHx8IGVsZW0ucGFyZW50Tm9kZSAhPSB0aGlzLmVsZW0pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGFnID0gZWxlbS5ub2RlTmFtZTtcblxuICAgICAgICBpZiAoIXRhZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmVyIHN1YnRyYWN0aW9ucyB3aGlsZSBjbGlwcGluZy5cbiAgICAgICAgaWYgKG9iamVjdC5fY2xpcCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbS5yZW1vdmVDaGlsZChlbGVtKTtcblxuICAgICAgfSxcblxuICAgICAgb3JkZXJDaGlsZDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZWxlbS5hcHBlbmRDaGlsZChvYmplY3QuX3JlbmRlcmVyLmVsZW0pO1xuICAgICAgfSxcblxuICAgICAgcmVuZGVyQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHN2Z1tjaGlsZC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoY2hpbGQsIHRoaXMpO1xuICAgICAgfSxcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihkb21FbGVtZW50KSB7XG5cbiAgICAgICAgLy8gU2hvcnRjdXQgZm9yIGhpZGRlbiBvYmplY3RzLlxuICAgICAgICAvLyBEb2Vzbid0IHJlc2V0IHRoZSBmbGFncywgc28gY2hhbmdlcyBhcmUgc3RvcmVkIGFuZFxuICAgICAgICAvLyBhcHBsaWVkIG9uY2UgdGhlIG9iamVjdCBpcyB2aXNpYmxlIGFnYWluXG4gICAgICAgIGlmICgoIXRoaXMuX3Zpc2libGUgJiYgIXRoaXMuX2ZsYWdWaXNpYmxlKVxuICAgICAgICAgIHx8ICh0aGlzLl9vcGFjaXR5ID09PSAwICYmICF0aGlzLl9mbGFnT3BhY2l0eSkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWxlbSkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgnZycsIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZG9tRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIF9VcGRhdGUgc3R5bGVzIGZvciB0aGUgPGc+XG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xuICAgICAgICB2YXIgY29udGV4dCA9IHtcbiAgICAgICAgICBkb21FbGVtZW50OiBkb21FbGVtZW50LFxuICAgICAgICAgIGVsZW06IHRoaXMuX3JlbmRlcmVyLmVsZW1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZmxhZ01hdHJpeCkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAnbWF0cml4KCcgKyB0aGlzLl9tYXRyaXgudG9TdHJpbmcoKSArICcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgICAgIHN2Z1tjaGlsZC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoY2hpbGQsIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdJZCkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnT3BhY2l0eSkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgdGhpcy5fb3BhY2l0eSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1Zpc2libGUpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsIHRoaXMuX3Zpc2libGUgPyAnaW5saW5lJyA6ICdub25lJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NsYXNzTmFtZSkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuY2xhc3NMaXN0LmpvaW4oJyAnKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0FkZGl0aW9ucykge1xuICAgICAgICAgIHRoaXMuYWRkaXRpb25zLmZvckVhY2goc3ZnLmdyb3VwLmFwcGVuZENoaWxkLCBjb250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3VidHJhY3Rpb25zKSB7XG4gICAgICAgICAgdGhpcy5zdWJ0cmFjdGlvbnMuZm9yRWFjaChzdmcuZ3JvdXAucmVtb3ZlQ2hpbGQsIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPcmRlcikge1xuICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChzdmcuZ3JvdXAub3JkZXJDaGlsZCwgY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21tZW50ZWQgdHdvLXdheSBmdW5jdGlvbmFsaXR5IG9mIGNsaXBzIC8gbWFza3Mgd2l0aCBncm91cHMgYW5kXG4gICAgICAgIC8vIHBvbHlnb25zLiBVbmNvbW1lbnQgd2hlbiB0aGlzIGJ1ZyBpcyBmaXhlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MVxuXG4gICAgICAgIC8vIGlmICh0aGlzLl9mbGFnQ2xpcCkge1xuXG4gICAgICAgIC8vICAgY2xpcCA9IHN2Zy5nZXRDbGlwKHRoaXMsIGRvbUVsZW1lbnQpO1xuICAgICAgICAvLyAgIGVsZW0gPSB0aGlzLl9yZW5kZXJlci5lbGVtO1xuXG4gICAgICAgIC8vICAgaWYgKHRoaXMuX2NsaXApIHtcbiAgICAgICAgLy8gICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAvLyAgICAgY2xpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5pZCk7XG4gICAgICAgIC8vICAgICBjbGlwLmFwcGVuZENoaWxkKGVsZW0pO1xuICAgICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBjbGlwLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgLy8gICAgIGVsZW0uc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xuICAgICAgICAvLyAgICAgdGhpcy5wYXJlbnQuX3JlbmRlcmVyLmVsZW0uYXBwZW5kQ2hpbGQoZWxlbSk7IC8vIFRPRE86IHNob3VsZCBiZSBpbnNlcnRCZWZvcmVcbiAgICAgICAgLy8gICB9XG5cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTWFzaykge1xuICAgICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgICAgICBzdmdbdGhpcy5fbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fbWFzaywgZG9tRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ3VybCgjJyArIHRoaXMuX21hc2suaWQgKyAnKScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xpcC1wYXRoJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwYXRoOiB7XG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZG9tRWxlbWVudCkge1xuXG4gICAgICAgIC8vIFNob3J0Y3V0IGZvciBoaWRkZW4gb2JqZWN0cy5cbiAgICAgICAgLy8gRG9lc24ndCByZXNldCB0aGUgZmxhZ3MsIHNvIGNoYW5nZXMgYXJlIHN0b3JlZCBhbmRcbiAgICAgICAgLy8gYXBwbGllZCBvbmNlIHRoZSBvYmplY3QgaXMgdmlzaWJsZSBhZ2FpblxuICAgICAgICBpZiAodGhpcy5fb3BhY2l0eSA9PT0gMCAmJiAhdGhpcy5fZmxhZ09wYWNpdHkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIC8vIENvbGxlY3QgYW55IGF0dHJpYnV0ZSB0aGF0IG5lZWRzIHRvIGJlIGNoYW5nZWQgaGVyZVxuICAgICAgICB2YXIgY2hhbmdlZCA9IHt9O1xuXG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xuXG4gICAgICAgIGlmIChmbGFnTWF0cml4KSB7XG4gICAgICAgICAgY2hhbmdlZC50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyB0aGlzLl9tYXRyaXgudG9TdHJpbmcoKSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnSWQpIHtcbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5faWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1ZlcnRpY2VzKSB7XG4gICAgICAgICAgdmFyIHZlcnRpY2VzID0gc3ZnLnRvU3RyaW5nKHRoaXMuX3JlbmRlcmVyLnZlcnRpY2VzLCB0aGlzLl9jbG9zZWQpO1xuICAgICAgICAgIGNoYW5nZWQuZCA9IHZlcnRpY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZpbGwgJiYgdGhpcy5fZmlsbC5fcmVuZGVyZXIpIHtcbiAgICAgICAgICB0aGlzLl9maWxsLl91cGRhdGUoKTtcbiAgICAgICAgICBzdmdbdGhpcy5fZmlsbC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fZmlsbCwgZG9tRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0ZpbGwpIHtcbiAgICAgICAgICBjaGFuZ2VkLmZpbGwgPSB0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuaWRcbiAgICAgICAgICAgID8gJ3VybCgjJyArIHRoaXMuX2ZpbGwuaWQgKyAnKScgOiB0aGlzLl9maWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3N0cm9rZSAmJiB0aGlzLl9zdHJva2UuX3JlbmRlcmVyKSB7XG4gICAgICAgICAgdGhpcy5fc3Ryb2tlLl91cGRhdGUoKTtcbiAgICAgICAgICBzdmdbdGhpcy5fc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbCh0aGlzLl9zdHJva2UsIGRvbUVsZW1lbnQsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdHJva2UpIHtcbiAgICAgICAgICBjaGFuZ2VkLnN0cm9rZSA9IHRoaXMuX3N0cm9rZSAmJiB0aGlzLl9zdHJva2UuaWRcbiAgICAgICAgICAgID8gJ3VybCgjJyArIHRoaXMuX3N0cm9rZS5pZCArICcpJyA6IHRoaXMuX3N0cm9rZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTGluZXdpZHRoKSB7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLXdpZHRoJ10gPSB0aGlzLl9saW5ld2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ09wYWNpdHkpIHtcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2Utb3BhY2l0eSddID0gdGhpcy5fb3BhY2l0eTtcbiAgICAgICAgICBjaGFuZ2VkWydmaWxsLW9wYWNpdHknXSA9IHRoaXMuX29wYWNpdHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NsYXNzTmFtZSkge1xuICAgICAgICAgIGNoYW5nZWRbJ2NsYXNzJ10gPSB0aGlzLmNsYXNzTGlzdC5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1Zpc2libGUpIHtcbiAgICAgICAgICBjaGFuZ2VkLnZpc2liaWxpdHkgPSB0aGlzLl92aXNpYmxlID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NhcCkge1xuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS1saW5lY2FwJ10gPSB0aGlzLl9jYXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0pvaW4pIHtcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2UtbGluZWpvaW4nXSA9IHRoaXMuX2pvaW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ01pdGVyKSB7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLW1pdGVybGltaXQnXSA9IHRoaXMuX21pdGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGFzaGVzICYmIHRoaXMuZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaGFuZ2VkWydzdHJva2UtZGFzaGFycmF5J10gPSB0aGlzLmRhc2hlcy5qb2luKCcgJyk7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWRhc2hvZmZzZXQnXSA9IHRoaXMuZGFzaGVzLm9mZnNldCB8fCAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYXR0YWNoZWQgRE9NIGVsZW1lbnQgeWV0LFxuICAgICAgICAvLyBjcmVhdGUgaXQgd2l0aCBhbGwgbmVjZXNzYXJ5IGF0dHJpYnV0ZXMuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWxlbSkge1xuXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgncGF0aCcsIGNoYW5nZWQpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuZWxlbSk7XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGFwcGx5IGFsbCBwZW5kaW5nIGF0dHJpYnV0ZXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyh0aGlzLl9yZW5kZXJlci5lbGVtLCBjaGFuZ2VkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnQ2xpcCkge1xuXG4gICAgICAgICAgdmFyIGNsaXAgPSBzdmcuZ2V0Q2xpcCh0aGlzLCBkb21FbGVtZW50KTtcbiAgICAgICAgICB2YXIgZWxlbSA9IHRoaXMuX3JlbmRlcmVyLmVsZW07XG5cbiAgICAgICAgICBpZiAodGhpcy5fY2xpcCkge1xuICAgICAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICBjbGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIGNsaXAuYXBwZW5kQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsaXAucmVtb3ZlQXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5pZCk7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5fcmVuZGVyZXIuZWxlbS5hcHBlbmRDaGlsZChlbGVtKTsgLy8gVE9ETzogc2hvdWxkIGJlIGluc2VydEJlZm9yZVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tbWVudGVkIHR3by13YXkgZnVuY3Rpb25hbGl0eSBvZiBjbGlwcyAvIG1hc2tzIHdpdGggZ3JvdXBzIGFuZFxuICAgICAgICAvLyBwb2x5Z29ucy4gVW5jb21tZW50IHdoZW4gdGhpcyBidWcgaXMgZml4ZWQ6XG4gICAgICAgIC8vIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNzA5NTFcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ01hc2spIHtcbiAgICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgICAgc3ZnW3RoaXMuX21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX21hc2ssIGRvbUVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoIycgKyB0aGlzLl9tYXNrLmlkICsgJyknKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGV4dDoge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbUVsZW1lbnQpIHtcblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICB2YXIgY2hhbmdlZCA9IHt9O1xuXG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xuXG4gICAgICAgIGlmIChmbGFnTWF0cml4KSB7XG4gICAgICAgICAgY2hhbmdlZC50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyB0aGlzLl9tYXRyaXgudG9TdHJpbmcoKSArICcpJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnSWQpIHtcbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5faWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0ZhbWlseSkge1xuICAgICAgICAgIGNoYW5nZWRbJ2ZvbnQtZmFtaWx5J10gPSB0aGlzLl9mYW1pbHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTaXplKSB7XG4gICAgICAgICAgY2hhbmdlZFsnZm9udC1zaXplJ10gPSB0aGlzLl9zaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnTGVhZGluZykge1xuICAgICAgICAgIGNoYW5nZWRbJ2xpbmUtaGVpZ2h0J10gPSB0aGlzLl9sZWFkaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnQWxpZ25tZW50KSB7XG4gICAgICAgICAgY2hhbmdlZFsndGV4dC1hbmNob3InXSA9IHN2Zy5hbGlnbm1lbnRzW3RoaXMuX2FsaWdubWVudF0gfHwgdGhpcy5fYWxpZ25tZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnQmFzZWxpbmUpIHtcbiAgICAgICAgICBjaGFuZ2VkWydhbGlnbm1lbnQtYmFzZWxpbmUnXSA9IGNoYW5nZWRbJ2RvbWluYW50LWJhc2VsaW5lJ10gPSB0aGlzLl9iYXNlbGluZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ1N0eWxlKSB7XG4gICAgICAgICAgY2hhbmdlZFsnZm9udC1zdHlsZSddID0gdGhpcy5fc3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdXZWlnaHQpIHtcbiAgICAgICAgICBjaGFuZ2VkWydmb250LXdlaWdodCddID0gdGhpcy5fd2VpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnRGVjb3JhdGlvbikge1xuICAgICAgICAgIGNoYW5nZWRbJ3RleHQtZGVjb3JhdGlvbiddID0gdGhpcy5fZGVjb3JhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmlsbCAmJiB0aGlzLl9maWxsLl9yZW5kZXJlcikge1xuICAgICAgICAgIHRoaXMuX2ZpbGwuX3VwZGF0ZSgpO1xuICAgICAgICAgIHN2Z1t0aGlzLl9maWxsLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbCh0aGlzLl9maWxsLCBkb21FbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0ZpbGwpIHtcbiAgICAgICAgICBjaGFuZ2VkLmZpbGwgPSB0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuaWRcbiAgICAgICAgICAgID8gJ3VybCgjJyArIHRoaXMuX2ZpbGwuaWQgKyAnKScgOiB0aGlzLl9maWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdHJva2UgJiYgdGhpcy5fc3Ryb2tlLl9yZW5kZXJlcikge1xuICAgICAgICAgIHRoaXMuX3N0cm9rZS5fdXBkYXRlKCk7XG4gICAgICAgICAgc3ZnW3RoaXMuX3N0cm9rZS5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fc3Ryb2tlLCBkb21FbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ1N0cm9rZSkge1xuICAgICAgICAgIGNoYW5nZWQuc3Ryb2tlID0gdGhpcy5fc3Ryb2tlICYmIHRoaXMuX3N0cm9rZS5pZFxuICAgICAgICAgICAgPyAndXJsKCMnICsgdGhpcy5fc3Ryb2tlLmlkICsgJyknIDogdGhpcy5fc3Ryb2tlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9mbGFnTGluZXdpZHRoKSB7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLXdpZHRoJ10gPSB0aGlzLl9saW5ld2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPcGFjaXR5KSB7XG4gICAgICAgICAgY2hhbmdlZC5vcGFjaXR5ID0gdGhpcy5fb3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0NsYXNzTmFtZSkge1xuICAgICAgICAgIGNoYW5nZWRbJ2NsYXNzJ10gPSB0aGlzLmNsYXNzTGlzdC5qb2luKCcgJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdWaXNpYmxlKSB7XG4gICAgICAgICAgY2hhbmdlZC52aXNpYmlsaXR5ID0gdGhpcy5fdmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRhc2hlcyAmJiB0aGlzLmRhc2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY2hhbmdlZFsnc3Ryb2tlLWRhc2hhcnJheSddID0gdGhpcy5kYXNoZXMuam9pbignICcpO1xuICAgICAgICAgIGNoYW5nZWRbJ3N0cm9rZS1kYXNob2Zmc2V0J10gPSB0aGlzLmRhc2hlcy5vZmZzZXQgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWxlbSkge1xuXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuXG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbSA9IHN2Zy5jcmVhdGVFbGVtZW50KCd0ZXh0JywgY2hhbmdlZCk7XG4gICAgICAgICAgZG9tRWxlbWVudC5kZWZzLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0pO1xuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyh0aGlzLl9yZW5kZXJlci5lbGVtLCBjaGFuZ2VkKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdDbGlwKSB7XG5cbiAgICAgICAgICB2YXIgY2xpcCA9IHN2Zy5nZXRDbGlwKHRoaXMsIGRvbUVsZW1lbnQpO1xuICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5fcmVuZGVyZXIuZWxlbTtcblxuICAgICAgICAgIGlmICh0aGlzLl9jbGlwKSB7XG4gICAgICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnaWQnKTtcbiAgICAgICAgICAgIGNsaXAuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuaWQpO1xuICAgICAgICAgICAgY2xpcC5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xpcC5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50Ll9yZW5kZXJlci5lbGVtLmFwcGVuZENoaWxkKGVsZW0pOyAvLyBUT0RPOiBzaG91bGQgYmUgaW5zZXJ0QmVmb3JlXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21tZW50ZWQgdHdvLXdheSBmdW5jdGlvbmFsaXR5IG9mIGNsaXBzIC8gbWFza3Mgd2l0aCBncm91cHMgYW5kXG4gICAgICAgIC8vIHBvbHlnb25zLiBVbmNvbW1lbnQgd2hlbiB0aGlzIGJ1ZyBpcyBmaXhlZDpcbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3MDk1MVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTWFzaykge1xuICAgICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgICAgICBzdmdbdGhpcy5fbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fbWFzaywgZG9tRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ3VybCgjJyArIHRoaXMuX21hc2suaWQgKyAnKScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnJlbW92ZUF0dHJpYnV0ZSgnY2xpcC1wYXRoJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdWYWx1ZSkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0udGV4dENvbnRlbnQgPSB0aGlzLl92YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgJ2xpbmVhci1ncmFkaWVudCc6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihkb21FbGVtZW50LCBzaWxlbnQpIHtcblxuICAgICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYW5nZWQgPSB7fTtcblxuICAgICAgICBpZiAodGhpcy5fZmxhZ0lkKSB7XG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdFbmRQb2ludHMpIHtcbiAgICAgICAgICBjaGFuZ2VkLngxID0gdGhpcy5sZWZ0Ll94O1xuICAgICAgICAgIGNoYW5nZWQueTEgPSB0aGlzLmxlZnQuX3k7XG4gICAgICAgICAgY2hhbmdlZC54MiA9IHRoaXMucmlnaHQuX3g7XG4gICAgICAgICAgY2hhbmdlZC55MiA9IHRoaXMucmlnaHQuX3k7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NwcmVhZCkge1xuICAgICAgICAgIGNoYW5nZWQuc3ByZWFkTWV0aG9kID0gdGhpcy5fc3ByZWFkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gYXR0YWNoZWQgRE9NIGVsZW1lbnQgeWV0LFxuICAgICAgICAvLyBjcmVhdGUgaXQgd2l0aCBhbGwgbmVjZXNzYXJ5IGF0dHJpYnV0ZXMuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWxlbSkge1xuXG4gICAgICAgICAgY2hhbmdlZC5pZCA9IHRoaXMuX2lkO1xuICAgICAgICAgIGNoYW5nZWQuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbSA9IHN2Zy5jcmVhdGVFbGVtZW50KCdsaW5lYXJHcmFkaWVudCcsIGNoYW5nZWQpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtKTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgYXBwbHkgYWxsIHBlbmRpbmcgYXR0cmlidXRlc1xuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3RvcHMpIHtcblxuICAgICAgICAgIHZhciBsZW5ndGhDaGFuZ2VkID0gdGhpcy5fcmVuZGVyZXIuZWxlbS5jaGlsZE5vZGVzLmxlbmd0aFxuICAgICAgICAgICAgIT09IHRoaXMuc3RvcHMubGVuZ3RoO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aENoYW5nZWQpIHtcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLl9yZW5kZXJlci5lbGVtLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtLnJlbW92ZUNoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0ubGFzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RvcHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgdmFyIHN0b3AgPSB0aGlzLnN0b3BzW2ldO1xuICAgICAgICAgICAgdmFyIGF0dHJzID0ge307XG5cbiAgICAgICAgICAgIGlmIChzdG9wLl9mbGFnT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGF0dHJzLm9mZnNldCA9IDEwMCAqIHN0b3AuX29mZnNldCArICclJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdG9wLl9mbGFnQ29sb3IpIHtcbiAgICAgICAgICAgICAgYXR0cnNbJ3N0b3AtY29sb3InXSA9IHN0b3AuX2NvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3AuX2ZsYWdPcGFjaXR5KSB7XG4gICAgICAgICAgICAgIGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IHN0b3AuX29wYWNpdHk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3RvcC5fcmVuZGVyZXIuZWxlbSkge1xuICAgICAgICAgICAgICBzdG9wLl9yZW5kZXJlci5lbGVtID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ3N0b3AnLCBhdHRycyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyhzdG9wLl9yZW5kZXJlci5lbGVtLCBhdHRycyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGhDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uYXBwZW5kQ2hpbGQoc3RvcC5fcmVuZGVyZXIuZWxlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9wLmZsYWdSZXNldCgpO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgICdyYWRpYWwtZ3JhZGllbnQnOiB7XG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oZG9tRWxlbWVudCwgc2lsZW50KSB7XG5cbiAgICAgICAgaWYgKCFzaWxlbnQpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFuZ2VkID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdJZCkge1xuICAgICAgICAgIGNoYW5nZWQuaWQgPSB0aGlzLl9pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnQ2VudGVyKSB7XG4gICAgICAgICAgY2hhbmdlZC5jeCA9IHRoaXMuY2VudGVyLl94O1xuICAgICAgICAgIGNoYW5nZWQuY3kgPSB0aGlzLmNlbnRlci5feTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZmxhZ0ZvY2FsKSB7XG4gICAgICAgICAgY2hhbmdlZC5meCA9IHRoaXMuZm9jYWwuX3g7XG4gICAgICAgICAgY2hhbmdlZC5meSA9IHRoaXMuZm9jYWwuX3k7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1JhZGl1cykge1xuICAgICAgICAgIGNoYW5nZWQuciA9IHRoaXMuX3JhZGl1cztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3ByZWFkKSB7XG4gICAgICAgICAgY2hhbmdlZC5zcHJlYWRNZXRob2QgPSB0aGlzLl9zcHJlYWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBhdHRhY2hlZCBET00gZWxlbWVudCB5ZXQsXG4gICAgICAgIC8vIGNyZWF0ZSBpdCB3aXRoIGFsbCBuZWNlc3NhcnkgYXR0cmlidXRlcy5cbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lbGVtKSB7XG5cbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5faWQ7XG4gICAgICAgICAgY2hhbmdlZC5ncmFkaWVudFVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJztcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lbGVtID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ3JhZGlhbEdyYWRpZW50JywgY2hhbmdlZCk7XG4gICAgICAgICAgZG9tRWxlbWVudC5kZWZzLmFwcGVuZENoaWxkKHRoaXMuX3JlbmRlcmVyLmVsZW0pO1xuXG4gICAgICAgIC8vIE90aGVyd2lzZSBhcHBseSBhbGwgcGVuZGluZyBhdHRyaWJ1dGVzXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlcyh0aGlzLl9yZW5kZXJlci5lbGVtLCBjaGFuZ2VkKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdTdG9wcykge1xuXG4gICAgICAgICAgdmFyIGxlbmd0aENoYW5nZWQgPSB0aGlzLl9yZW5kZXJlci5lbGVtLmNoaWxkTm9kZXMubGVuZ3RoXG4gICAgICAgICAgICAhPT0gdGhpcy5zdG9wcy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoQ2hhbmdlZCkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuX3JlbmRlcmVyLmVsZW0ubGFzdENoaWxkKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0ucmVtb3ZlQ2hpbGQodGhpcy5fcmVuZGVyZXIuZWxlbS5sYXN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdG9wcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuc3RvcHNbaV07XG4gICAgICAgICAgICB2YXIgYXR0cnMgPSB7fTtcblxuICAgICAgICAgICAgaWYgKHN0b3AuX2ZsYWdPZmZzZXQpIHtcbiAgICAgICAgICAgICAgYXR0cnMub2Zmc2V0ID0gMTAwICogc3RvcC5fb2Zmc2V0ICsgJyUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0b3AuX2ZsYWdDb2xvcikge1xuICAgICAgICAgICAgICBhdHRyc1snc3RvcC1jb2xvciddID0gc3RvcC5fY29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RvcC5fZmxhZ09wYWNpdHkpIHtcbiAgICAgICAgICAgICAgYXR0cnNbJ3N0b3Atb3BhY2l0eSddID0gc3RvcC5fb3BhY2l0eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFzdG9wLl9yZW5kZXJlci5lbGVtKSB7XG4gICAgICAgICAgICAgIHN0b3AuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgnc3RvcCcsIGF0dHJzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVzKHN0b3AuX3JlbmRlcmVyLmVsZW0sIGF0dHJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxlbmd0aENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuZWxlbS5hcHBlbmRDaGlsZChzdG9wLl9yZW5kZXJlci5lbGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0b3AuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGV4dHVyZToge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGRvbUVsZW1lbnQsIHNpbGVudCkge1xuXG4gICAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2hhbmdlZCA9IHt9O1xuICAgICAgICB2YXIgc3R5bGVzID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaW1hZ2U7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdJZCkge1xuICAgICAgICAgIGNoYW5nZWQuaWQgPSB0aGlzLl9pZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnTG9hZGVkICYmIHRoaXMubG9hZGVkKSB7XG5cbiAgICAgICAgICBzd2l0Y2ggKGltYWdlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcblxuICAgICAgICAgICAgY2FzZSAnY2FudmFzJzpcbiAgICAgICAgICAgICAgc3R5bGVzLmhyZWYgPSBzdHlsZXNbJ3hsaW5rOmhyZWYnXSA9IGltYWdlLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgICAgICAgICAgc3R5bGVzLmhyZWYgPSBzdHlsZXNbJ3hsaW5rOmhyZWYnXSA9IHRoaXMuc3JjO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZsYWdPZmZzZXQgfHwgdGhpcy5fZmxhZ0xvYWRlZCB8fCB0aGlzLl9mbGFnU2NhbGUpIHtcblxuICAgICAgICAgIGNoYW5nZWQueCA9IHRoaXMuX29mZnNldC54O1xuICAgICAgICAgIGNoYW5nZWQueSA9IHRoaXMuX29mZnNldC55O1xuXG4gICAgICAgICAgaWYgKGltYWdlKSB7XG5cbiAgICAgICAgICAgIGNoYW5nZWQueCAtPSBpbWFnZS53aWR0aCAvIDI7XG4gICAgICAgICAgICBjaGFuZ2VkLnkgLT0gaW1hZ2UuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICAgIGNoYW5nZWQueCAqPSB0aGlzLl9zY2FsZS54O1xuICAgICAgICAgICAgICBjaGFuZ2VkLnkgKj0gdGhpcy5fc2NhbGUueTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYW5nZWQueCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgICAgY2hhbmdlZC55ICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGFuZ2VkLnggPiAwKSB7XG4gICAgICAgICAgICBjaGFuZ2VkLnggKj0gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2hhbmdlZC55ID4gMCkge1xuICAgICAgICAgICAgY2hhbmdlZC55ICo9IC0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU2NhbGUgfHwgdGhpcy5fZmxhZ0xvYWRlZCB8fCB0aGlzLl9mbGFnUmVwZWF0KSB7XG5cbiAgICAgICAgICBjaGFuZ2VkLndpZHRoID0gMDtcbiAgICAgICAgICBjaGFuZ2VkLmhlaWdodCA9IDA7XG5cbiAgICAgICAgICBpZiAoaW1hZ2UpIHtcblxuICAgICAgICAgICAgc3R5bGVzLndpZHRoID0gY2hhbmdlZC53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgICAgICAgc3R5bGVzLmhlaWdodCA9IGNoYW5nZWQuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuXG4gICAgICAgICAgICAvLyBUT0RPOiBIYWNrIC8gQmFuZC1haWRcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcmVwZWF0KSB7XG4gICAgICAgICAgICAgIGNhc2UgJ25vLXJlcGVhdCc6XG4gICAgICAgICAgICAgICAgY2hhbmdlZC53aWR0aCArPSAxO1xuICAgICAgICAgICAgICAgIGNoYW5nZWQuaGVpZ2h0ICs9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgICBjaGFuZ2VkLndpZHRoICo9IHRoaXMuX3NjYWxlLng7XG4gICAgICAgICAgICAgIGNoYW5nZWQuaGVpZ2h0ICo9IHRoaXMuX3NjYWxlLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjaGFuZ2VkLndpZHRoICo9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgICBjaGFuZ2VkLmhlaWdodCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9mbGFnU2NhbGUgfHwgdGhpcy5fZmxhZ0xvYWRlZCkge1xuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuaW1hZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmltYWdlID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ2ltYWdlJywgc3R5bGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuaW1hZ2UsIHN0eWxlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lbGVtKSB7XG5cbiAgICAgICAgICBjaGFuZ2VkLmlkID0gdGhpcy5faWQ7XG4gICAgICAgICAgY2hhbmdlZC5wYXR0ZXJuVW5pdHMgPSAndXNlclNwYWNlT25Vc2UnO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0gPSBzdmcuY3JlYXRlRWxlbWVudCgncGF0dGVybicsIGNoYW5nZWQpO1xuICAgICAgICAgIGRvbUVsZW1lbnQuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLl9yZW5kZXJlci5lbGVtKTtcblxuICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5rZXlzKGNoYW5nZWQpLmxlbmd0aCAhPT0gMCkge1xuXG4gICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZXModGhpcy5fcmVuZGVyZXIuZWxlbSwgY2hhbmdlZCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJlci5lbGVtICYmIHRoaXMuX3JlbmRlcmVyLmltYWdlICYmICF0aGlzLl9yZW5kZXJlci5hcHBlbmRlZCkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmVsZW0uYXBwZW5kQ2hpbGQodGhpcy5fcmVuZGVyZXIuaW1hZ2UpO1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLmFwcGVuZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfTtcblxuICAvKipcbiAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyXG4gICAqIEBjbGFzc1xuICAgKiBAZXh0ZW5kcyBUd28uRXZlbnRzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1ldGVyc10gLSBUaGlzIG9iamVjdCBpcyBpbmhlcml0ZWQgd2hlbiBjb25zdHJ1Y3RpbmcgYSBuZXcgaW5zdGFuY2Ugb2Yge0BsaW5rIFR3b30uXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW3BhcmFtZXRlcnMuZG9tRWxlbWVudF0gLSBUaGUgYDxzdmcgLz5gIHRvIGRyYXcgdG8uIElmIG5vbmUgZ2l2ZW4gYSBuZXcgb25lIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBkZXNjcmlwdGlvbiBUaGlzIGNsYXNzIGlzIHVzZWQgYnkge0BsaW5rIFR3b30gd2hlbiBjb25zdHJ1Y3Rpbmcgd2l0aCBgdHlwZWAgb2YgYFR3by5UeXBlcy5zdmdgICh0aGUgZGVmYXVsdCB0eXBlKS4gSXQgdGFrZXMgVHdvLmpzJyBzY2VuZWdyYXBoIGFuZCByZW5kZXJzIGl0IHRvIGEgYDxzdmcgLz5gLlxuICAgKi9cbiAgZnVuY3Rpb24gUmVuZGVyZXIkMShwYXJhbXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TVkdSZW5kZXJlciNkb21FbGVtZW50XG4gICAgICogQHByb3BlcnR5IHtFbGVtZW50fSAtIFRoZSBgPHN2ZyAvPmAgYXNzb2NpYXRlZCB3aXRoIHRoZSBUd28uanMgc2NlbmUuXG4gICAgICovXG4gICAgdGhpcy5kb21FbGVtZW50ID0gcGFyYW1zLmRvbUVsZW1lbnQgfHwgc3ZnLmNyZWF0ZUVsZW1lbnQoJ3N2ZycpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyI3NjZW5lXG4gICAgICogQHByb3BlcnR5IHtUd28uR3JvdXB9IC0gVGhlIHJvb3QgZ3JvdXAgb2YgdGhlIHNjZW5lZ3JhcGguXG4gICAgICovXG4gICAgdGhpcy5zY2VuZSA9IG5ldyBHcm91cCgpO1xuICAgIHRoaXMuc2NlbmUucGFyZW50ID0gdGhpcztcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5TVkdSZW5kZXJlciNkZWZzXG4gICAgICogQHByb3BlcnR5IHtTdmdEZWZpbnRpb25zRWxlbWVudH0gLSBUaGUgYDxkZWZzIC8+YCB0byBhcHBseSBncmFkaWVudHMsIHBhdHRlcm5zLCBhbmQgYml0bWFwIGltYWdlcnkuXG4gICAgICovXG4gICAgdGhpcy5kZWZzID0gc3ZnLmNyZWF0ZUVsZW1lbnQoJ2RlZnMnKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5kZWZzKTtcbiAgICB0aGlzLmRvbUVsZW1lbnQuZGVmcyA9IHRoaXMuZGVmcztcbiAgICB0aGlzLmRvbUVsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcblxuICB9XG5cbiAgXy5leHRlbmQoUmVuZGVyZXIkMSwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyLlV0aWxzXG4gICAgICogQHByb3BlcnR5IHtPYmplY3R9IC0gQSBtYXNzaXZlIG9iamVjdCBmaWxsZWQgd2l0aCB1dGlsaXR5IGZ1bmN0aW9ucyBhbmQgcHJvcGVydGllcyB0byByZW5kZXIgVHdvLmpzIG9iamVjdHMgdG8gYSBgPHN2ZyAvPmAuXG4gICAgICovXG4gICAgVXRpbHM6IHN2Z1xuXG4gIH0pO1xuXG4gIF8uZXh0ZW5kKFJlbmRlcmVyJDEucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBSZW5kZXJlciQxLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLlNWR1JlbmRlcmVyI3NldFNpemVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gd2lkdGggLSBUaGUgbmV3IHdpZHRoIG9mIHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBoZWlnaHQgb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGFuZ2UgdGhlIHNpemUgb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqIEBub3RhLWJlbmUgVHJpZ2dlcnMgYSBgVHdvLkV2ZW50cy5yZXNpemVgLlxuICAgICAqL1xuICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGVzKHRoaXMuZG9tRWxlbWVudCwge1xuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMucmVzaXplLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uU1ZHUmVuZGVyZXIjcmVuZGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbmRlciB0aGUgY3VycmVudCBzY2VuZSB0byB0aGUgYDxzdmcgLz5gLlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHN2Zy5ncm91cC5yZW5kZXIuY2FsbCh0aGlzLnNjZW5lLCB0aGlzLmRvbUVsZW1lbnQpO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICAvLyBDb25zdGFudHNcblxuICB2YXIgbXVsdGlwbHlNYXRyaXggPSBNYXRyaXguTXVsdGlwbHksXG4gICAgaWRlbnRpdHkgPSBbMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMV0sXG4gICAgdHJhbnNmb3JtYXRpb24gPSBuZXcgTnVtQXJyYXkoOSksXG4gICAgQ2FudmFzVXRpbHMgPSBSZW5kZXJlciQyLlV0aWxzO1xuXG4gIHZhciB3ZWJnbCA9IHtcblxuICAgIGlzSGlkZGVuOiAvKHVuZGVmaW5lZHxub25lfHRyYW5zcGFyZW50KS9pLFxuXG4gICAgY2FudmFzOiAocm9vdCQxLmRvY3VtZW50ID8gcm9vdCQxLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpIDogeyBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHt9IH0pLFxuXG4gICAgYWxpZ25tZW50czoge1xuICAgICAgbGVmdDogJ3N0YXJ0JyxcbiAgICAgIG1pZGRsZTogJ2NlbnRlcicsXG4gICAgICByaWdodDogJ2VuZCdcbiAgICB9LFxuXG4gICAgbWF0cml4OiBuZXcgTWF0cml4KCksXG5cbiAgICBncm91cDoge1xuXG4gICAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24oY2hpbGQsIGdsKSB7XG4gICAgICAgIGlmIChjaGlsZC5jaGlsZHJlbikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHdlYmdsLmdyb3VwLnJlbW92ZUNoaWxkKGNoaWxkLmNoaWxkcmVuW2ldLCBnbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWFsbG9jYXRlIHRleHR1cmUgdG8gZnJlZSB1cCBnbCBtZW1vcnkuXG4gICAgICAgIGdsLmRlbGV0ZVRleHR1cmUoY2hpbGQuX3JlbmRlcmVyLnRleHR1cmUpO1xuICAgICAgICBkZWxldGUgY2hpbGQuX3JlbmRlcmVyLnRleHR1cmU7XG4gICAgICB9LFxuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aXNpYmxlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgZmxhZ1BhcmVudE1hdHJpeCA9IChwYXJlbnQuX21hdHJpeCAmJiBwYXJlbnQuX21hdHJpeC5tYW51YWwpIHx8IHBhcmVudC5fZmxhZ01hdHJpeDtcbiAgICAgICAgdmFyIGZsYWdNYXRyaXggPSB0aGlzLl9tYXRyaXgubWFudWFsIHx8IHRoaXMuX2ZsYWdNYXRyaXg7XG5cbiAgICAgICAgaWYgKGZsYWdQYXJlbnRNYXRyaXggfHwgZmxhZ01hdHJpeCkge1xuXG4gICAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5tYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm1hdHJpeCA9IG5ldyBOdW1BcnJheSg5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBSZWR1Y2UgYW1vdW50IG9mIG9iamVjdCAvIGFycmF5IGNyZWF0aW9uIC8gZGVsZXRpb25cbiAgICAgICAgICB0aGlzLl9tYXRyaXgudG9UcmFuc2Zvcm1BcnJheSh0cnVlLCB0cmFuc2Zvcm1hdGlvbik7XG5cbiAgICAgICAgICBtdWx0aXBseU1hdHJpeCh0cmFuc2Zvcm1hdGlvbiwgcGFyZW50Ll9yZW5kZXJlci5tYXRyaXgsIHRoaXMuX3JlbmRlcmVyLm1hdHJpeCk7XG5cbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5zY2FsZSBpbnN0YW5jZW9mIFZlY3RvcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlID0gbmV3IFZlY3RvcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLl9zY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueCA9IHRoaXMuX3NjYWxlLng7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS55ID0gdGhpcy5fc2NhbGUueTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueCA9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSA9IHRoaXMuX3NjYWxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghKC9yZW5kZXJlci9pLnRlc3QocGFyZW50Ll9yZW5kZXJlci50eXBlKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggKj0gcGFyZW50Ll9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSAqPSBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZsYWdQYXJlbnRNYXRyaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsYWdNYXRyaXggPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX21hc2spIHtcblxuICAgICAgICAgIC8vIFN0ZW5jaWwgYXdheSBldmVyeXRoaW5nIHRoYXQgaXNuJ3QgcmVuZGVyZWQgYnkgdGhlIG1hc2tcbiAgICAgICAgICBnbC5jbGVhcihnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgICAgIGdsLmVuYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuXG4gICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuQUxXQVlTLCAxLCAwKTtcbiAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuUkVQTEFDRSk7XG4gICAgICAgICAgLy8gRG9uJ3QgZHJhdyB0aGUgZWxlbWVudCBvbnRvIHRoZSBjYW52YXMsIG9ubHkgb250byB0aGUgc3RlbmNpbCBidWZmZXJcbiAgICAgICAgICBnbC5jb2xvck1hc2soZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpO1xuXG4gICAgICAgICAgd2ViZ2xbdGhpcy5fbWFzay5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwodGhpcy5fbWFzaywgZ2wsIHByb2dyYW0sIHRoaXMpO1xuXG4gICAgICAgICAgZ2wuc3RlbmNpbEZ1bmMoZ2wuRVFVQUwsIDEsIDB4ZmYpO1xuICAgICAgICAgIGdsLnN0ZW5jaWxPcChnbC5LRUVQLCBnbC5LRUVQLCBnbC5LRUVQKTtcbiAgICAgICAgICBnbC5jb2xvck1hc2sodHJ1ZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZsYWdPcGFjaXR5ID0gcGFyZW50Ll9mbGFnT3BhY2l0eSB8fCB0aGlzLl9mbGFnT3BhY2l0eTtcblxuICAgICAgICB0aGlzLl9yZW5kZXJlci5vcGFjaXR5ID0gdGhpcy5fb3BhY2l0eVxuICAgICAgICAgICogKHBhcmVudCAmJiBwYXJlbnQuX3JlbmRlcmVyID8gcGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5IDogMSk7XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICh0aGlzLl9mbGFnU3VidHJhY3Rpb25zKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuc3VidHJhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB3ZWJnbC5ncm91cC5yZW1vdmVDaGlsZCh0aGlzLnN1YnRyYWN0aW9uc1tpXSwgZ2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICB3ZWJnbFtjaGlsZC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoY2hpbGQsIGdsLCBwcm9ncmFtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG4gICAgICAgICAgZ2wuZGlzYWJsZShnbC5TVEVOQ0lMX1RFU1QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICBwYXRoOiB7XG5cbiAgICAgIHVwZGF0ZUNhbnZhczogZnVuY3Rpb24oZWxlbSkge1xuXG4gICAgICAgIHZhciBuZXh0LCBwcmV2LCBhLCBjLCB1eCwgdXksIHZ4LCB2eSwgYXIsIGJsLCBiciwgY2wsIHgsIHk7XG4gICAgICAgIHZhciBpc09mZnNldDtcblxuICAgICAgICB2YXIgY29tbWFuZHMgPSBlbGVtLl9yZW5kZXJlci52ZXJ0aWNlcztcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICAgICAgLy8gU3R5bGVzXG4gICAgICAgIHZhciBzY2FsZSA9IGVsZW0uX3JlbmRlcmVyLnNjYWxlO1xuICAgICAgICB2YXIgc3Ryb2tlID0gZWxlbS5fc3Ryb2tlO1xuICAgICAgICB2YXIgbGluZXdpZHRoID0gZWxlbS5fbGluZXdpZHRoO1xuICAgICAgICB2YXIgZmlsbCA9IGVsZW0uX2ZpbGw7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gZWxlbS5fcmVuZGVyZXIub3BhY2l0eSB8fCBlbGVtLl9vcGFjaXR5O1xuICAgICAgICB2YXIgY2FwID0gZWxlbS5fY2FwO1xuICAgICAgICB2YXIgam9pbiA9IGVsZW0uX2pvaW47XG4gICAgICAgIHZhciBtaXRlciA9IGVsZW0uX21pdGVyO1xuICAgICAgICB2YXIgY2xvc2VkID0gZWxlbS5fY2xvc2VkO1xuICAgICAgICB2YXIgZGFzaGVzID0gZWxlbS5kYXNoZXM7XG4gICAgICAgIHZhciBsZW5ndGggPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgICAgIHZhciBsYXN0ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoZWxlbS5fcmVuZGVyZXIucmVjdC53aWR0aCAqIHNjYWxlLngpLCAxKTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChlbGVtLl9yZW5kZXJlci5yZWN0LmhlaWdodCAqIHNjYWxlLnkpLCAxKTtcblxuICAgICAgICB2YXIgY2VudHJvaWQgPSBlbGVtLl9yZW5kZXJlci5yZWN0LmNlbnRyb2lkO1xuICAgICAgICB2YXIgY3ggPSBjZW50cm9pZC54O1xuICAgICAgICB2YXIgY3kgPSBjZW50cm9pZC55O1xuXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZmlsbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWJnbFtmaWxsLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChmaWxsLCBjdHgsIGVsZW0pO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwuX3JlbmRlcmVyLmVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3Ryb2tlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3ZWJnbFtzdHJva2UuX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHN0cm9rZSwgY3R4LCBlbGVtKTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS5fcmVuZGVyZXIuZWZmZWN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGluZXdpZHRoKSB7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gbGluZXdpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWl0ZXIpIHtcbiAgICAgICAgICAgIGN0eC5taXRlckxpbWl0ID0gbWl0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChqb2luKSB7XG4gICAgICAgICAgICBjdHgubGluZUpvaW4gPSBqb2luO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNsb3NlZCAmJiBjYXApIHtcbiAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gY2FwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wYWNpdHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXNoZXMgJiYgZGFzaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoZXMub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZDtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlLngsIHNjYWxlLnkpO1xuXG4gICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcblxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgIHZhciBiID0gY29tbWFuZHNbaV07XG5cbiAgICAgICAgICB4ID0gYi54O1xuICAgICAgICAgIHkgPSBiLnk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGIuY29tbWFuZCkge1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLmNsb3NlOlxuICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLmFyYzpcblxuICAgICAgICAgICAgICB2YXIgcnggPSBiLnJ4O1xuICAgICAgICAgICAgICB2YXIgcnkgPSBiLnJ5O1xuICAgICAgICAgICAgICB2YXIgeEF4aXNSb3RhdGlvbiA9IGIueEF4aXNSb3RhdGlvbjtcbiAgICAgICAgICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IGIubGFyZ2VBcmNGbGFnO1xuICAgICAgICAgICAgICB2YXIgc3dlZXBGbGFnID0gYi5zd2VlcEZsYWc7XG5cbiAgICAgICAgICAgICAgcHJldiA9IGNsb3NlZCA/IG1vZChpIC0gMSwgbGVuZ3RoKSA6IE1hdGgubWF4KGkgLSAxLCAwKTtcbiAgICAgICAgICAgICAgYSA9IGNvbW1hbmRzW3ByZXZdO1xuXG4gICAgICAgICAgICAgIHZhciBheCA9IGEueDtcbiAgICAgICAgICAgICAgdmFyIGF5ID0gYS55O1xuXG4gICAgICAgICAgICAgIENhbnZhc1V0aWxzLnJlbmRlclN2Z0FyY0NvbW1hbmQoY3R4LCBheCwgYXksIHJ4LCByeSwgbGFyZ2VBcmNGbGFnLCBzd2VlcEZsYWcsIHhBeGlzUm90YXRpb24sIHgsIHkpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5jdXJ2ZTpcblxuICAgICAgICAgICAgICBwcmV2ID0gY2xvc2VkID8gbW9kKGkgLSAxLCBsZW5ndGgpIDogTWF0aC5tYXgoaSAtIDEsIDApO1xuICAgICAgICAgICAgICBuZXh0ID0gY2xvc2VkID8gbW9kKGkgKyAxLCBsZW5ndGgpIDogTWF0aC5taW4oaSArIDEsIGxhc3QpO1xuXG4gICAgICAgICAgICAgIGEgPSBjb21tYW5kc1twcmV2XTtcbiAgICAgICAgICAgICAgYyA9IGNvbW1hbmRzW25leHRdO1xuICAgICAgICAgICAgICBhciA9IChhLmNvbnRyb2xzICYmIGEuY29udHJvbHMucmlnaHQpIHx8IFZlY3Rvci56ZXJvO1xuICAgICAgICAgICAgICBibCA9IChiLmNvbnRyb2xzICYmIGIuY29udHJvbHMubGVmdCkgfHwgVmVjdG9yLnplcm87XG5cbiAgICAgICAgICAgICAgaWYgKGEuX3JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgdnggPSBhci54ICsgYS54O1xuICAgICAgICAgICAgICAgIHZ5ID0gYXIueSArIGEueTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2eCA9IGFyLng7XG4gICAgICAgICAgICAgICAgdnkgPSBhci55O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGIuX3JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgdXggPSBibC54ICsgYi54O1xuICAgICAgICAgICAgICAgIHV5ID0gYmwueSArIGIueTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1eCA9IGJsLng7XG4gICAgICAgICAgICAgICAgdXkgPSBibC55O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8odngsIHZ5LCB1eCwgdXksIHgsIHkpO1xuXG4gICAgICAgICAgICAgIGlmIChpID49IGxhc3QgJiYgY2xvc2VkKSB7XG5cbiAgICAgICAgICAgICAgICBjID0gZDtcblxuICAgICAgICAgICAgICAgIGJyID0gKGIuY29udHJvbHMgJiYgYi5jb250cm9scy5yaWdodCkgfHwgVmVjdG9yLnplcm87XG4gICAgICAgICAgICAgICAgY2wgPSAoYy5jb250cm9scyAmJiBjLmNvbnRyb2xzLmxlZnQpIHx8IFZlY3Rvci56ZXJvO1xuXG4gICAgICAgICAgICAgICAgaWYgKGIuX3JlbGF0aXZlKSB7XG4gICAgICAgICAgICAgICAgICB2eCA9IGJyLnggKyBiLng7XG4gICAgICAgICAgICAgICAgICB2eSA9IGJyLnkgKyBiLnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZ4ID0gYnIueDtcbiAgICAgICAgICAgICAgICAgIHZ5ID0gYnIueTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYy5fcmVsYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgIHV4ID0gY2wueCArIGMueDtcbiAgICAgICAgICAgICAgICAgIHV5ID0gY2wueSArIGMueTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdXggPSBjbC54O1xuICAgICAgICAgICAgICAgICAgdXkgPSBjbC55O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHggPSBjLng7XG4gICAgICAgICAgICAgICAgeSA9IGMueTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHZ4LCB2eSwgdXgsIHV5LCB4LCB5KTtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMubGluZTpcbiAgICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMubW92ZTpcbiAgICAgICAgICAgICAgZCA9IGI7XG4gICAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29zZSBlbmRzXG5cbiAgICAgICAgaWYgKGNsb3NlZCkge1xuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghd2ViZ2wuaXNIaWRkZW4udGVzdChmaWxsKSkge1xuICAgICAgICAgIGlzT2Zmc2V0ID0gZmlsbC5fcmVuZGVyZXIgJiYgZmlsbC5fcmVuZGVyZXIub2Zmc2V0O1xuICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoXG4gICAgICAgICAgICAgIC0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LngsIC0gZmlsbC5fcmVuZGVyZXIub2Zmc2V0LnkpO1xuICAgICAgICAgICAgY3R4LnNjYWxlKGZpbGwuX3JlbmRlcmVyLnNjYWxlLngsIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXdlYmdsLmlzSGlkZGVuLnRlc3Qoc3Ryb2tlKSkge1xuICAgICAgICAgIGlzT2Zmc2V0ID0gc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldDtcbiAgICAgICAgICBpZiAoaXNPZmZzZXQpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKFxuICAgICAgICAgICAgICAtIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LngsIC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueSk7XG4gICAgICAgICAgICBjdHguc2NhbGUoc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54LCBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aCAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGlmIChpc09mZnNldCkge1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB9LFxuXG4gICAgICAvLyBSZXR1cm5zIHRoZSByZWN0IG9mIGEgc2V0IG9mIHZlcnRzLiBUeXBpY2FsbHkgdGFrZXMgdmVydGljZXMgdGhhdCBhcmVcbiAgICAgIC8vIFwiY2VudGVyZWRcIiBhcm91bmQgMCBhbmQgcmV0dXJucyB0aGVtIHRvIGJlIGFuY2hvcmVkIHVwcGVyLWxlZnQuXG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uKHZlcnRpY2VzLCBib3JkZXIsIHJlY3QpIHtcblxuICAgICAgICB2YXIgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eSxcbiAgICAgICAgICAgIHRvcCA9IEluZmluaXR5LCBib3R0b20gPSAtSW5maW5pdHksXG4gICAgICAgICAgICB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICAgIHZlcnRpY2VzLmZvckVhY2goZnVuY3Rpb24odikge1xuXG4gICAgICAgICAgdmFyIHggPSB2LngsIHkgPSB2LnksIGNvbnRyb2xzID0gdi5jb250cm9scztcbiAgICAgICAgICB2YXIgYSwgYiwgYywgZCwgY2wsIGNyO1xuXG4gICAgICAgICAgdG9wID0gTWF0aC5taW4oeSwgdG9wKTtcbiAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4oeCwgbGVmdCk7XG4gICAgICAgICAgcmlnaHQgPSBNYXRoLm1heCh4LCByaWdodCk7XG4gICAgICAgICAgYm90dG9tID0gTWF0aC5tYXgoeSwgYm90dG9tKTtcblxuICAgICAgICAgIGlmICghdi5jb250cm9scykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsID0gY29udHJvbHMubGVmdDtcbiAgICAgICAgICBjciA9IGNvbnRyb2xzLnJpZ2h0O1xuXG4gICAgICAgICAgaWYgKCFjbCB8fCAhY3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhID0gdi5fcmVsYXRpdmUgPyBjbC54ICsgeCA6IGNsLng7XG4gICAgICAgICAgYiA9IHYuX3JlbGF0aXZlID8gY2wueSArIHkgOiBjbC55O1xuICAgICAgICAgIGMgPSB2Ll9yZWxhdGl2ZSA/IGNyLnggKyB4IDogY3IueDtcbiAgICAgICAgICBkID0gdi5fcmVsYXRpdmUgPyBjci55ICsgeSA6IGNyLnk7XG5cbiAgICAgICAgICBpZiAoIWEgfHwgIWIgfHwgIWMgfHwgIWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0b3AgPSBNYXRoLm1pbihiLCBkLCB0b3ApO1xuICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihhLCBjLCBsZWZ0KTtcbiAgICAgICAgICByaWdodCA9IE1hdGgubWF4KGEsIGMsIHJpZ2h0KTtcbiAgICAgICAgICBib3R0b20gPSBNYXRoLm1heChiLCBkLCBib3R0b20pO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEV4cGFuZCBib3JkZXJzXG5cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXIgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdG9wIC09IGJvcmRlcjtcbiAgICAgICAgICBsZWZ0IC09IGJvcmRlcjtcbiAgICAgICAgICByaWdodCArPSBib3JkZXI7XG4gICAgICAgICAgYm90dG9tICs9IGJvcmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG5cbiAgICAgICAgcmVjdC50b3AgPSB0b3A7XG4gICAgICAgIHJlY3QubGVmdCA9IGxlZnQ7XG4gICAgICAgIHJlY3QucmlnaHQgPSByaWdodDtcbiAgICAgICAgcmVjdC5ib3R0b20gPSBib3R0b207XG4gICAgICAgIHJlY3Qud2lkdGggPSB3aWR0aDtcbiAgICAgICAgcmVjdC5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgaWYgKCFyZWN0LmNlbnRyb2lkKSB7XG4gICAgICAgICAgcmVjdC5jZW50cm9pZCA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdC5jZW50cm9pZC54ID0gLSBsZWZ0O1xuICAgICAgICByZWN0LmNlbnRyb2lkLnkgPSAtIHRvcDtcblxuICAgICAgfSxcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihnbCwgcHJvZ3JhbSwgZm9yY2VkUGFyZW50KSB7XG5cbiAgICAgICAgaWYgKCF0aGlzLl92aXNpYmxlIHx8ICF0aGlzLl9vcGFjaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgd2hhdCBjaGFuZ2VkXG5cbiAgICAgICAgdmFyIHBhcmVudCA9IGZvcmNlZFBhcmVudCB8fCB0aGlzLnBhcmVudDtcbiAgICAgICAgdmFyIGZsYWdQYXJlbnRNYXRyaXggPSBwYXJlbnQuX21hdHJpeC5tYW51YWwgfHwgcGFyZW50Ll9mbGFnTWF0cml4O1xuICAgICAgICB2YXIgZmxhZ01hdHJpeCA9IHRoaXMuX21hdHJpeC5tYW51YWwgfHwgdGhpcy5fZmxhZ01hdHJpeDtcbiAgICAgICAgdmFyIHBhcmVudENoYW5nZWQgPSB0aGlzLl9yZW5kZXJlci5wYXJlbnQgIT09IHBhcmVudDtcbiAgICAgICAgdmFyIGZsYWdUZXh0dXJlID0gdGhpcy5fZmxhZ1ZlcnRpY2VzIHx8IHRoaXMuX2ZsYWdGaWxsXG4gICAgICAgICAgfHwgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBMaW5lYXJHcmFkaWVudCAmJiAodGhpcy5fZmlsbC5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9maWxsLl9mbGFnU3RvcHMgfHwgdGhpcy5fZmlsbC5fZmxhZ0VuZFBvaW50cykpXG4gICAgICAgICAgfHwgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudCAmJiAodGhpcy5fZmlsbC5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9maWxsLl9mbGFnU3RvcHMgfHwgdGhpcy5fZmlsbC5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9maWxsLl9mbGFnQ2VudGVyIHx8IHRoaXMuX2ZpbGwuX2ZsYWdGb2NhbCkpXG4gICAgICAgICAgfHwgKHRoaXMuX2ZpbGwgaW5zdGFuY2VvZiBUZXh0dXJlICYmICh0aGlzLl9maWxsLl9mbGFnTG9hZGVkICYmIHRoaXMuX2ZpbGwubG9hZGVkIHx8IHRoaXMuX2ZpbGwuX2ZsYWdJbWFnZSB8fCB0aGlzLl9maWxsLl9mbGFnVmlkZW8gfHwgdGhpcy5fZmlsbC5fZmxhZ1JlcGVhdCB8fCB0aGlzLl9maWxsLl9mbGFnT2Zmc2V0IHx8IHRoaXMuX2ZpbGwuX2ZsYWdTY2FsZSkpXG4gICAgICAgICAgfHwgKHRoaXMuX3N0cm9rZSBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50ICYmICh0aGlzLl9zdHJva2UuX2ZsYWdTcHJlYWQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnU3RvcHMgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnRW5kUG9pbnRzKSlcbiAgICAgICAgICB8fCAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgUmFkaWFsR3JhZGllbnQgJiYgKHRoaXMuX3N0cm9rZS5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdTdG9wcyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdSYWRpdXMgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnQ2VudGVyIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ0ZvY2FsKSlcbiAgICAgICAgICB8fCAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgVGV4dHVyZSAmJiAodGhpcy5fc3Ryb2tlLl9mbGFnTG9hZGVkICYmIHRoaXMuX3N0cm9rZS5sb2FkZWQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnSW1hZ2UgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnVmlkZW8gfHwgdGhpcy5fc3Ryb2tlLl9mbGFnUmVwZWF0IHx8IHRoaXMuX3N0cm9rZS5fZmxhZ09mZnNldCB8fCB0aGlzLl9maWxsLl9mbGFnU2NhbGUpKVxuICAgICAgICAgIHx8IHRoaXMuX2ZsYWdTdHJva2UgfHwgdGhpcy5fZmxhZ0xpbmV3aWR0aCB8fCB0aGlzLl9mbGFnT3BhY2l0eVxuICAgICAgICAgIHx8IHBhcmVudC5fZmxhZ09wYWNpdHkgfHwgdGhpcy5fZmxhZ1Zpc2libGUgfHwgdGhpcy5fZmxhZ0NhcFxuICAgICAgICAgIHx8IHRoaXMuX2ZsYWdKb2luIHx8IHRoaXMuX2ZsYWdNaXRlciB8fCB0aGlzLl9mbGFnU2NhbGVcbiAgICAgICAgICB8fCAodGhpcy5kYXNoZXMgJiYgdGhpcy5kYXNoZXMubGVuZ3RoID4gMClcbiAgICAgICAgICB8fCAhdGhpcy5fcmVuZGVyZXIudGV4dHVyZTtcblxuICAgICAgICBpZiAoZmxhZ1BhcmVudE1hdHJpeCB8fCBmbGFnTWF0cml4IHx8IHBhcmVudENoYW5nZWQpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIubWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5tYXRyaXggPSBuZXcgTnVtQXJyYXkoOSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVkdWNlIGFtb3VudCBvZiBvYmplY3QgLyBhcnJheSBjcmVhdGlvbiAvIGRlbGV0aW9uXG5cbiAgICAgICAgICB0aGlzLl9tYXRyaXgudG9UcmFuc2Zvcm1BcnJheSh0cnVlLCB0cmFuc2Zvcm1hdGlvbik7XG5cbiAgICAgICAgICBtdWx0aXBseU1hdHJpeCh0cmFuc2Zvcm1hdGlvbiwgcGFyZW50Ll9yZW5kZXJlci5tYXRyaXgsIHRoaXMuX3JlbmRlcmVyLm1hdHJpeCk7XG5cbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5zY2FsZSBpbnN0YW5jZW9mIFZlY3RvcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlID0gbmV3IFZlY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZS54ICogcGFyZW50Ll9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSA9IHRoaXMuX3NjYWxlLnkgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZSAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgPSB0aGlzLl9zY2FsZSAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyZW50Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG5cbiAgICAgICAgICAvLyBTdGVuY2lsIGF3YXkgZXZlcnl0aGluZyB0aGF0IGlzbid0IHJlbmRlcmVkIGJ5IHRoZSBtYXNrXG4gICAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbiAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywgMSwgMCk7XG4gICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLlJFUExBQ0UpO1xuICAgICAgICAgIC8vIERvbid0IGRyYXcgdGhlIGVsZW1lbnQgb250byB0aGUgY2FudmFzLCBvbmx5IG9udG8gdGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgIHdlYmdsW3RoaXMuX21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX21hc2ssIGdsLCBwcm9ncmFtLCB0aGlzKTtcblxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAxLCAweGZmKTtcbiAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ1RleHR1cmUpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIucmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVjdCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5ICogcGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5O1xuXG4gICAgICAgICAgd2ViZ2wucGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy5fcmVuZGVyZXIudmVydGljZXMsIHRoaXMuX2xpbmV3aWR0aCwgdGhpcy5fcmVuZGVyZXIucmVjdCk7XG5cbiAgICAgICAgICB3ZWJnbC51cGRhdGVUZXh0dXJlLmNhbGwod2ViZ2wsIGdsLCB0aGlzKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgY2hpbGQgVHdvIGVsZW1lbnRzIG9uIHRoZSBmaWxsIGFuZFxuICAgICAgICAgIC8vIHN0cm9rZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGlmICh0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuX3VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbC5fdXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgJiYgdGhpcy5fc3Ryb2tlLl91cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZS5fdXBkYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY2xpcCAmJiAhZm9yY2VkUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyBUZXh0dXJlXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3JlbmRlcmVyLnRleHR1cmUpO1xuXG4gICAgICAgIC8vIERyYXcgUmVjdFxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX3JlbmRlcmVyLnJlY3Q7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYocHJvZ3JhbS5tYXRyaXgsIGZhbHNlLCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGYocHJvZ3JhbS5yZWN0LCByZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcblxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgdGV4dDoge1xuXG4gICAgICB1cGRhdGVDYW52YXM6IGZ1bmN0aW9uKGVsZW0pIHtcblxuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5jYW52YXM7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgICAvLyBTdHlsZXNcbiAgICAgICAgdmFyIHNjYWxlID0gZWxlbS5fcmVuZGVyZXIuc2NhbGU7XG4gICAgICAgIHZhciBzdHJva2UgPSBlbGVtLl9zdHJva2U7XG4gICAgICAgIHZhciBsaW5ld2lkdGggPSBlbGVtLl9saW5ld2lkdGggKiBzY2FsZTtcbiAgICAgICAgdmFyIGZpbGwgPSBlbGVtLl9maWxsO1xuICAgICAgICB2YXIgb3BhY2l0eSA9IGVsZW0uX3JlbmRlcmVyLm9wYWNpdHkgfHwgZWxlbS5fb3BhY2l0eTtcbiAgICAgICAgdmFyIGRhc2hlcyA9IGVsZW0uZGFzaGVzO1xuICAgICAgICB2YXIgZGVjb3JhdGlvbiA9IGVsZW0uX2RlY29yYXRpb247XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKGVsZW0uX3JlbmRlcmVyLnJlY3Qud2lkdGggKiBzY2FsZS54KSwgMSk7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoZWxlbS5fcmVuZGVyZXIucmVjdC5oZWlnaHQgKiBzY2FsZS55KSwgMSk7XG5cbiAgICAgICAgdmFyIGNlbnRyb2lkID0gZWxlbS5fcmVuZGVyZXIucmVjdC5jZW50cm9pZDtcbiAgICAgICAgdmFyIGN4ID0gY2VudHJvaWQueDtcbiAgICAgICAgdmFyIGN5ID0gY2VudHJvaWQueTtcblxuICAgICAgICB2YXIgYSwgYiwgYywgZCwgZSwgc3gsIHN5LCB4MSwgeTEsIHgyLCB5MjtcbiAgICAgICAgdmFyIGlzT2Zmc2V0ID0gZmlsbC5fcmVuZGVyZXIgJiYgZmlsbC5fcmVuZGVyZXIub2Zmc2V0XG4gICAgICAgICAgJiYgc3Ryb2tlLl9yZW5kZXJlciAmJiBzdHJva2UuX3JlbmRlcmVyLm9mZnNldDtcblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgaWYgKCFpc09mZnNldCkge1xuICAgICAgICAgIGN0eC5mb250ID0gW2VsZW0uX3N0eWxlLCBlbGVtLl93ZWlnaHQsIGVsZW0uX3NpemUgKyAncHgvJyArXG4gICAgICAgICAgICBlbGVtLl9sZWFkaW5nICsgJ3B4JywgZWxlbS5fZmFtaWx5XS5qb2luKCcgJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcblxuICAgICAgICAvLyBTdHlsZXNcbiAgICAgICAgaWYgKGZpbGwpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbGwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xbZmlsbC5fcmVuZGVyZXIudHlwZV0ucmVuZGVyLmNhbGwoZmlsbCwgY3R4LCBlbGVtKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLl9yZW5kZXJlci5lZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJva2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0cm9rZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2ViZ2xbc3Ryb2tlLl9yZW5kZXJlci50eXBlXS5yZW5kZXIuY2FsbChzdHJva2UsIGN0eCwgZWxlbSk7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UuX3JlbmRlcmVyLmVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpbmV3aWR0aCkge1xuICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGxpbmV3aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcGFjaXR5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhc2hlcyAmJiBkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hlcy5vZmZzZXQgfHwgMDtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZS54LCBzY2FsZS55KTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShjeCwgY3kpO1xuXG4gICAgICAgIGlmICghd2ViZ2wuaXNIaWRkZW4udGVzdChmaWxsKSkge1xuXG4gICAgICAgICAgaWYgKGZpbGwuX3JlbmRlcmVyICYmIGZpbGwuX3JlbmRlcmVyLm9mZnNldCkge1xuXG4gICAgICAgICAgICBzeCA9IGZpbGwuX3JlbmRlcmVyLnNjYWxlLng7XG4gICAgICAgICAgICBzeSA9IGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XG5cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKCAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC54LFxuICAgICAgICAgICAgICAtIGZpbGwuX3JlbmRlcmVyLm9mZnNldC55KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuXG4gICAgICAgICAgICBhID0gZWxlbS5fc2l6ZSAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgICBiID0gZWxlbS5fbGVhZGluZyAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgICBjdHguZm9udCA9IFtlbGVtLl9zdHlsZSwgZWxlbS5fd2VpZ2h0LCBhICsgJ3B4LycsXG4gICAgICAgICAgICAgIGIgKyAncHgnLCBlbGVtLl9mYW1pbHldLmpvaW4oJyAnKTtcblxuICAgICAgICAgICAgYyA9IGZpbGwuX3JlbmRlcmVyLm9mZnNldC54IC8gZmlsbC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIGQgPSBmaWxsLl9yZW5kZXJlci5vZmZzZXQueSAvIGZpbGwuX3JlbmRlcmVyLnNjYWxlLnk7XG5cbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChlbGVtLnZhbHVlLCBjLCBkKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KGVsZW0udmFsdWUsIDAsIDApO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF3ZWJnbC5pc0hpZGRlbi50ZXN0KHN0cm9rZSkpIHtcblxuICAgICAgICAgIGlmIChzdHJva2UuX3JlbmRlcmVyICYmIHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0KSB7XG5cbiAgICAgICAgICAgIHN4ID0gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgc3kgPSBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XG5cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC0gc3Ryb2tlLl9yZW5kZXJlci5vZmZzZXQueCxcbiAgICAgICAgICAgICAgLSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC55KTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzeCwgc3kpO1xuXG4gICAgICAgICAgICBhID0gZWxlbS5fc2l6ZSAvIHN0cm9rZS5fcmVuZGVyZXIuc2NhbGUueTtcbiAgICAgICAgICAgIGIgPSBlbGVtLl9sZWFkaW5nIC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS55O1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBbZWxlbS5fc3R5bGUsIGVsZW0uX3dlaWdodCwgYSArICdweC8nLFxuICAgICAgICAgICAgICBiICsgJ3B4JywgZWxlbS5fZmFtaWx5XS5qb2luKCcgJyk7XG5cbiAgICAgICAgICAgIGMgPSBzdHJva2UuX3JlbmRlcmVyLm9mZnNldC54IC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgZCA9IHN0cm9rZS5fcmVuZGVyZXIub2Zmc2V0LnkgLyBzdHJva2UuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgICBlID0gbGluZXdpZHRoIC8gc3Ryb2tlLl9yZW5kZXJlci5zY2FsZS54O1xuXG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gZTtcbiAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGVsZW0udmFsdWUsIGMsIGQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dChlbGVtLnZhbHVlLCAwLCAwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSB0ZXh0LWRlY29yYXRpb25cbiAgICAgICAgaWYgKC8odW5kZXJsaW5lfHN0cmlrZXRocm91Z2gpL2kudGVzdChkZWNvcmF0aW9uKSkge1xuXG4gICAgICAgICAgdmFyIG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoZWxlbS52YWx1ZSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGRlY29yYXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3VuZGVybGluZSc6XG4gICAgICAgICAgICAgIHkxID0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgICAgICAgICAgeTIgPSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3N0cmlrZXRocm91Z2gnOlxuICAgICAgICAgICAgICB5MSA9IDA7XG4gICAgICAgICAgICAgIHkyID0gMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEgPSAtIG1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgICAgIHgyID0gbWV0cmljcy53aWR0aCAvIDI7XG5cbiAgICAgICAgICBjdHgubGluZVdpZHRoID0gTWF0aC5tYXgoTWF0aC5mbG9vcihlbGVtLl9zaXplIC8gMTUpLCAxKTtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICB9LFxuXG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGZ1bmN0aW9uKGVsZW0sIHJlY3QpIHtcblxuICAgICAgICB2YXIgY3R4ID0gd2ViZ2wuY3R4O1xuXG4gICAgICAgIGN0eC5mb250ID0gW2VsZW0uX3N0eWxlLCBlbGVtLl93ZWlnaHQsIGVsZW0uX3NpemUgKyAncHgvJyArXG4gICAgICAgICAgZWxlbS5fbGVhZGluZyArICdweCcsIGVsZW0uX2ZhbWlseV0uam9pbignICcpO1xuXG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IGVsZW0uX2Jhc2VsaW5lO1xuXG4gICAgICAgIC8vIFRPRE86IEVzdGltYXRlIHRoaXMgYmV0dGVyXG4gICAgICAgIHZhciB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChlbGVtLl92YWx1ZSkud2lkdGggKiAxLjI1O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoZWxlbS5fc2l6ZSwgZWxlbS5fbGVhZGluZykgKiAxLjI1O1xuXG4gICAgICAgIGlmICh0aGlzLl9saW5ld2lkdGggJiYgIXdlYmdsLmlzSGlkZGVuLnRlc3QodGhpcy5fc3Ryb2tlKSkge1xuICAgICAgICAgIHdpZHRoICs9IHRoaXMuX2xpbmV3aWR0aCAqIDI7XG4gICAgICAgICAgaGVpZ2h0ICs9IHRoaXMuX2xpbmV3aWR0aCAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdyA9IHdpZHRoIC8gMjtcbiAgICAgICAgdmFyIGggPSBoZWlnaHQgLyAyO1xuXG4gICAgICAgIHN3aXRjaCAod2ViZ2wuYWxpZ25tZW50c1tlbGVtLl9hbGlnbm1lbnRdIHx8IGVsZW0uX2FsaWdubWVudCkge1xuXG4gICAgICAgICAgY2FzZSB3ZWJnbC5hbGlnbm1lbnRzLmxlZnQ6XG4gICAgICAgICAgICByZWN0LmxlZnQgPSAwO1xuICAgICAgICAgICAgcmVjdC5yaWdodCA9IHdpZHRoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSB3ZWJnbC5hbGlnbm1lbnRzLnJpZ2h0OlxuICAgICAgICAgICAgcmVjdC5sZWZ0ID0gLSB3aWR0aDtcbiAgICAgICAgICAgIHJlY3QucmlnaHQgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlY3QubGVmdCA9IC0gdztcbiAgICAgICAgICAgIHJlY3QucmlnaHQgPSB3O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogR3JhZGllbnRzIGFyZW4ndCBpbmhlcml0ZWQuLi5cbiAgICAgICAgc3dpdGNoIChlbGVtLl9iYXNlbGluZSkge1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICByZWN0LnRvcCA9IC0gaGVpZ2h0O1xuICAgICAgICAgICAgcmVjdC5ib3R0b20gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHJlY3QudG9wID0gMDtcbiAgICAgICAgICAgIHJlY3QuYm90dG9tID0gaGVpZ2h0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlY3QudG9wID0gLSBoO1xuICAgICAgICAgICAgcmVjdC5ib3R0b20gPSBoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdC53aWR0aCA9IHdpZHRoO1xuICAgICAgICByZWN0LmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICBpZiAoIXJlY3QuY2VudHJvaWQpIHtcbiAgICAgICAgICByZWN0LmNlbnRyb2lkID0ge307XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOlxuICAgICAgICByZWN0LmNlbnRyb2lkLnggPSB3O1xuICAgICAgICByZWN0LmNlbnRyb2lkLnkgPSBoO1xuXG4gICAgICB9LFxuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGdsLCBwcm9ncmFtLCBmb3JjZWRQYXJlbnQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX3Zpc2libGUgfHwgIXRoaXMuX29wYWNpdHkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB3aGF0IGNoYW5nZWRcblxuICAgICAgICB2YXIgcGFyZW50ID0gZm9yY2VkUGFyZW50IHx8IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgZmxhZ1BhcmVudE1hdHJpeCA9IHBhcmVudC5fbWF0cml4Lm1hbnVhbCB8fCBwYXJlbnQuX2ZsYWdNYXRyaXg7XG4gICAgICAgIHZhciBmbGFnTWF0cml4ID0gdGhpcy5fbWF0cml4Lm1hbnVhbCB8fCB0aGlzLl9mbGFnTWF0cml4O1xuICAgICAgICB2YXIgcGFyZW50Q2hhbmdlZCA9IHRoaXMuX3JlbmRlcmVyLnBhcmVudCAhPT0gcGFyZW50O1xuICAgICAgICB2YXIgZmxhZ1RleHR1cmUgPSB0aGlzLl9mbGFnVmVydGljZXMgfHwgdGhpcy5fZmxhZ0ZpbGxcbiAgICAgICAgICB8fCAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIExpbmVhckdyYWRpZW50ICYmICh0aGlzLl9maWxsLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZpbGwuX2ZsYWdTdG9wcyB8fCB0aGlzLl9maWxsLl9mbGFnRW5kUG9pbnRzKSlcbiAgICAgICAgICB8fCAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIFJhZGlhbEdyYWRpZW50ICYmICh0aGlzLl9maWxsLl9mbGFnU3ByZWFkIHx8IHRoaXMuX2ZpbGwuX2ZsYWdTdG9wcyB8fCB0aGlzLl9maWxsLl9mbGFnUmFkaXVzIHx8IHRoaXMuX2ZpbGwuX2ZsYWdDZW50ZXIgfHwgdGhpcy5fZmlsbC5fZmxhZ0ZvY2FsKSlcbiAgICAgICAgICB8fCAodGhpcy5fZmlsbCBpbnN0YW5jZW9mIFRleHR1cmUgJiYgKHRoaXMuX2ZpbGwuX2ZsYWdMb2FkZWQgJiYgdGhpcy5fZmlsbC5sb2FkZWQgfHwgdGhpcy5fZmlsbC5fZmxhZ0ltYWdlIHx8IHRoaXMuX2ZpbGwuX2ZsYWdWaWRlbyB8fCB0aGlzLl9maWxsLl9mbGFnUmVwZWF0IHx8IHRoaXMuX2ZpbGwuX2ZsYWdPZmZzZXQgfHwgdGhpcy5fZmlsbC5fZmxhZ1NjYWxlKSlcbiAgICAgICAgICB8fCAodGhpcy5fc3Ryb2tlIGluc3RhbmNlb2YgTGluZWFyR3JhZGllbnQgJiYgKHRoaXMuX3N0cm9rZS5fZmxhZ1NwcmVhZCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdTdG9wcyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdFbmRQb2ludHMpKVxuICAgICAgICAgIHx8ICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBSYWRpYWxHcmFkaWVudCAmJiAodGhpcy5fc3Ryb2tlLl9mbGFnU3ByZWFkIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ1N0b3BzIHx8IHRoaXMuX3N0cm9rZS5fZmxhZ1JhZGl1cyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdDZW50ZXIgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnRm9jYWwpKVxuICAgICAgICAgIHx8ICh0aGlzLl9zdHJva2UgaW5zdGFuY2VvZiBUZXh0dXJlICYmICh0aGlzLl9zdHJva2UuX2ZsYWdMb2FkZWQgJiYgdGhpcy5fc3Ryb2tlLmxvYWRlZCB8fCB0aGlzLl9zdHJva2UuX2ZsYWdJbWFnZSB8fCB0aGlzLl9zdHJva2UuX2ZsYWdWaWRlbyB8fCB0aGlzLl9zdHJva2UuX2ZsYWdSZXBlYXQgfHwgdGhpcy5fc3Ryb2tlLl9mbGFnT2Zmc2V0IHx8IHRoaXMuX2ZpbGwuX2ZsYWdTY2FsZSkpXG4gICAgICAgICAgfHwgdGhpcy5fZmxhZ1N0cm9rZSB8fCB0aGlzLl9mbGFnTGluZXdpZHRoIHx8IHRoaXMuX2ZsYWdPcGFjaXR5XG4gICAgICAgICAgfHwgcGFyZW50Ll9mbGFnT3BhY2l0eSB8fCB0aGlzLl9mbGFnVmlzaWJsZSB8fCB0aGlzLl9mbGFnU2NhbGVcbiAgICAgICAgICB8fCB0aGlzLl9mbGFnVmFsdWUgfHwgdGhpcy5fZmxhZ0ZhbWlseSB8fCB0aGlzLl9mbGFnU2l6ZVxuICAgICAgICAgIHx8IHRoaXMuX2ZsYWdMZWFkaW5nIHx8IHRoaXMuX2ZsYWdBbGlnbm1lbnQgfHwgdGhpcy5fZmxhZ0Jhc2VsaW5lXG4gICAgICAgICAgfHwgdGhpcy5fZmxhZ1N0eWxlIHx8IHRoaXMuX2ZsYWdXZWlnaHQgfHwgdGhpcy5fZmxhZ0RlY29yYXRpb25cbiAgICAgICAgICB8fCAodGhpcy5kYXNoZXMgJiYgdGhpcy5kYXNoZXMubGVuZ3RoID4gMClcbiAgICAgICAgICB8fCAhdGhpcy5fcmVuZGVyZXIudGV4dHVyZTtcblxuICAgICAgICBpZiAoZmxhZ1BhcmVudE1hdHJpeCB8fCBmbGFnTWF0cml4IHx8IHBhcmVudENoYW5nZWQpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIubWF0cml4KSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5tYXRyaXggPSBuZXcgTnVtQXJyYXkoOSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVkdWNlIGFtb3VudCBvZiBvYmplY3QgLyBhcnJheSBjcmVhdGlvbiAvIGRlbGV0aW9uXG5cbiAgICAgICAgICB0aGlzLl9tYXRyaXgudG9UcmFuc2Zvcm1BcnJheSh0cnVlLCB0cmFuc2Zvcm1hdGlvbik7XG5cbiAgICAgICAgICBtdWx0aXBseU1hdHJpeCh0cmFuc2Zvcm1hdGlvbiwgcGFyZW50Ll9yZW5kZXJlci5tYXRyaXgsIHRoaXMuX3JlbmRlcmVyLm1hdHJpeCk7XG5cbiAgICAgICAgICBpZiAoISh0aGlzLl9yZW5kZXJlci5zY2FsZSBpbnN0YW5jZW9mIFZlY3RvcikpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlID0gbmV3IFZlY3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fc2NhbGUgaW5zdGFuY2VvZiBWZWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZS54ICogcGFyZW50Ll9yZW5kZXJlci5zY2FsZS54O1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUueSA9IHRoaXMuX3NjYWxlLnkgKiBwYXJlbnQuX3JlbmRlcmVyLnNjYWxlLnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnggPSB0aGlzLl9zY2FsZSAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueDtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNjYWxlLnkgPSB0aGlzLl9zY2FsZSAqIHBhcmVudC5fcmVuZGVyZXIuc2NhbGUueTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyZW50Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXNrKSB7XG5cbiAgICAgICAgICAvLyBTdGVuY2lsIGF3YXkgZXZlcnl0aGluZyB0aGF0IGlzbid0IHJlbmRlcmVkIGJ5IHRoZSBtYXNrXG4gICAgICAgICAgZ2wuY2xlYXIoZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbiAgICAgICAgICBnbC5lbmFibGUoZ2wuU1RFTkNJTF9URVNUKTtcblxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkFMV0FZUywgMSwgMCk7XG4gICAgICAgICAgZ2wuc3RlbmNpbE9wKGdsLktFRVAsIGdsLktFRVAsIGdsLlJFUExBQ0UpO1xuICAgICAgICAgIC8vIERvbid0IGRyYXcgdGhlIGVsZW1lbnQgb250byB0aGUgY2FudmFzLCBvbmx5IG9udG8gdGhlIHN0ZW5jaWwgYnVmZmVyXG4gICAgICAgICAgZ2wuY29sb3JNYXNrKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcblxuICAgICAgICAgIHdlYmdsW3RoaXMuX21hc2suX3JlbmRlcmVyLnR5cGVdLnJlbmRlci5jYWxsKHRoaXMuX21hc2ssIGdsLCBwcm9ncmFtLCB0aGlzKTtcblxuICAgICAgICAgIGdsLnN0ZW5jaWxGdW5jKGdsLkVRVUFMLCAxLCAweGZmKTtcbiAgICAgICAgICBnbC5zdGVuY2lsT3AoZ2wuS0VFUCwgZ2wuS0VFUCwgZ2wuS0VFUCk7XG4gICAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ1RleHR1cmUpIHtcblxuICAgICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIucmVjdCkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIucmVjdCA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9wYWNpdHkgPSB0aGlzLl9vcGFjaXR5ICogcGFyZW50Ll9yZW5kZXJlci5vcGFjaXR5O1xuXG4gICAgICAgICAgd2ViZ2wudGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QodGhpcywgdGhpcy5fcmVuZGVyZXIucmVjdCk7XG5cbiAgICAgICAgICB3ZWJnbC51cGRhdGVUZXh0dXJlLmNhbGwod2ViZ2wsIGdsLCB0aGlzKTtcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy8gV2Ugc3RpbGwgbmVlZCB0byB1cGRhdGUgY2hpbGQgVHdvIGVsZW1lbnRzIG9uIHRoZSBmaWxsIGFuZFxuICAgICAgICAgIC8vIHN0cm9rZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGlmICh0aGlzLl9maWxsICYmIHRoaXMuX2ZpbGwuX3VwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fZmlsbC5fdXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLl9zdHJva2UgJiYgdGhpcy5fc3Ryb2tlLl91cGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0cm9rZS5fdXBkYXRlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fY2xpcCAmJiAhZm9yY2VkUGFyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyBUZXh0dXJlXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3JlbmRlcmVyLnRleHR1cmUpO1xuXG4gICAgICAgIC8vIERyYXcgUmVjdFxuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuX3JlbmRlcmVyLnJlY3Q7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYocHJvZ3JhbS5tYXRyaXgsIGZhbHNlLCB0aGlzLl9yZW5kZXJlci5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtNGYocHJvZ3JhbS5yZWN0LCByZWN0LmxlZnQsIHJlY3QudG9wLCByZWN0LnJpZ2h0LCByZWN0LmJvdHRvbSk7XG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcblxuICAgICAgICBpZiAodGhpcy5fbWFzaykge1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuU1RFTkNJTF9URVNUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdSZXNldCgpO1xuXG4gICAgICB9XG5cbiAgICB9LFxuXG4gICAgJ2xpbmVhci1ncmFkaWVudCc6IHtcblxuICAgICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIGVsZW0pIHtcblxuICAgICAgICBpZiAoIWN0eC5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgICAgIGlmICghdGhpcy5fcmVuZGVyZXIuZWZmZWN0IHx8IHRoaXMuX2ZsYWdFbmRQb2ludHMgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XG5cbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoXG4gICAgICAgICAgICB0aGlzLmxlZnQuX3gsIHRoaXMubGVmdC5feSxcbiAgICAgICAgICAgIHRoaXMucmlnaHQuX3gsIHRoaXMucmlnaHQuX3lcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuc3RvcHNbaV07XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QuYWRkQ29sb3JTdG9wKHN0b3AuX29mZnNldCwgc3RvcC5fY29sb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICAncmFkaWFsLWdyYWRpZW50Jzoge1xuXG4gICAgICByZW5kZXI6IGZ1bmN0aW9uKGN0eCwgZWxlbSkge1xuXG4gICAgICAgIGlmICghY3R4LmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZW5kZXJlci5lZmZlY3QgfHwgdGhpcy5fZmxhZ0NlbnRlciB8fCB0aGlzLl9mbGFnRm9jYWxcbiAgICAgICAgICAgIHx8IHRoaXMuX2ZsYWdSYWRpdXMgfHwgdGhpcy5fZmxhZ1N0b3BzKSB7XG5cbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoXG4gICAgICAgICAgICB0aGlzLmNlbnRlci5feCwgdGhpcy5jZW50ZXIuX3ksIDAsXG4gICAgICAgICAgICB0aGlzLmZvY2FsLl94LCB0aGlzLmZvY2FsLl95LCB0aGlzLl9yYWRpdXNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN0b3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuc3RvcHNbaV07XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QuYWRkQ29sb3JTdG9wKHN0b3AuX29mZnNldCwgc3RvcC5fY29sb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG5cbiAgICAgIH1cblxuICAgIH0sXG5cbiAgICB0ZXh0dXJlOiB7XG5cbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oY3R4LCBlbGVtKSB7XG5cbiAgICAgICAgaWYgKCFjdHguY2FudmFzLmdldENvbnRleHQoJzJkJykpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICB2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xuXG4gICAgICAgIGlmICgoKHRoaXMuX2ZsYWdMb2FkZWQgfHwgdGhpcy5fZmxhZ0ltYWdlIHx8IHRoaXMuX2ZsYWdWaWRlbyB8fCB0aGlzLl9mbGFnUmVwZWF0KSAmJiB0aGlzLmxvYWRlZCkpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5lZmZlY3QgPSBjdHguY3JlYXRlUGF0dGVybihpbWFnZSwgdGhpcy5fcmVwZWF0KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fcmVuZGVyZXIuZWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ1Jlc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ09mZnNldCB8fCB0aGlzLl9mbGFnTG9hZGVkIHx8IHRoaXMuX2ZsYWdTY2FsZSkge1xuXG4gICAgICAgICAgaWYgKCEodGhpcy5fcmVuZGVyZXIub2Zmc2V0IGluc3RhbmNlb2YgVmVjdG9yKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0ID0gbmV3IFZlY3RvcigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ID0gLSB0aGlzLl9vZmZzZXQueDtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueSA9IC0gdGhpcy5fb2Zmc2V0Lnk7XG5cbiAgICAgICAgICBpZiAoaW1hZ2UpIHtcblxuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnggKz0gaW1hZ2Uud2lkdGggLyAyO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKz0gaW1hZ2UuaGVpZ2h0IC8gMjtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC54ICo9IHRoaXMuX3NjYWxlLng7XG4gICAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLm9mZnNldC55ICo9IHRoaXMuX3NjYWxlLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5vZmZzZXQueCAqPSB0aGlzLl9zY2FsZTtcbiAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIub2Zmc2V0LnkgKj0gdGhpcy5fc2NhbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fZmxhZ1NjYWxlIHx8IHRoaXMuX2ZsYWdMb2FkZWQpIHtcblxuICAgICAgICAgIGlmICghKHRoaXMuX3JlbmRlcmVyLnNjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUgPSBuZXcgVmVjdG9yKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuX3NjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5zY2FsZS5jb3B5KHRoaXMuX3NjYWxlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyZXIuc2NhbGUuc2V0KHRoaXMuX3NjYWxlLCB0aGlzLl9zY2FsZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5mbGFnUmVzZXQoKTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwZGF0ZVRleHR1cmU6IGZ1bmN0aW9uKGdsLCBlbGVtKSB7XG5cbiAgICAgIHRoaXNbZWxlbS5fcmVuZGVyZXIudHlwZV0udXBkYXRlQ2FudmFzLmNhbGwod2ViZ2wsIGVsZW0pO1xuXG4gICAgICBpZiAoIWVsZW0uX3JlbmRlcmVyLnRleHR1cmUpIHtcbiAgICAgICAgZWxlbS5fcmVuZGVyZXIudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIH1cblxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgZWxlbS5fcmVuZGVyZXIudGV4dHVyZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgcGFyYW1ldGVycyBzbyB3ZSBjYW4gcmVuZGVyIGFueSBzaXplIGltYWdlLlxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgLy8gZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICAvLyBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAvLyBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG5cbiAgICAgIGlmICh0aGlzLmNhbnZhcy53aWR0aCA8PSAwIHx8IHRoaXMuY2FudmFzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVXBsb2FkIHRoZSBpbWFnZSBpbnRvIHRoZSB0ZXh0dXJlLlxuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLmNhbnZhcyk7XG5cbiAgICB9LFxuXG4gICAgcHJvZ3JhbToge1xuXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uKGdsLCBzaGFkZXJzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtLCBsaW5rZWQsIGVycm9yO1xuICAgICAgICBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICBfLmVhY2goc2hhZGVycywgZnVuY3Rpb24ocykge1xuICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xuICAgICAgICBpZiAoIWxpbmtlZCkge1xuICAgICAgICAgIGVycm9yID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSk7XG4gICAgICAgICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICB0aHJvdyBuZXcgVHdvRXJyb3IoJ3VuYWJsZSB0byBsaW5rIHByb2dyYW06ICcgKyBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcblxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHNoYWRlcnM6IHtcblxuICAgICAgY3JlYXRlOiBmdW5jdGlvbihnbCwgc291cmNlLCB0eXBlKSB7XG4gICAgICAgIHZhciBzaGFkZXIsIGNvbXBpbGVkLCBlcnJvcjtcbiAgICAgICAgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsW3R5cGVdKTtcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAgIGNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuICAgICAgICBpZiAoIWNvbXBpbGVkKSB7XG4gICAgICAgICAgZXJyb3IgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgICAgdGhyb3cgbmV3IFR3b0Vycm9yKCd1bmFibGUgdG8gY29tcGlsZSBzaGFkZXIgJyArIHNoYWRlciArICc6ICcgKyBlcnJvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2hhZGVyO1xuXG4gICAgICB9LFxuXG4gICAgICB0eXBlczoge1xuICAgICAgICB2ZXJ0ZXg6ICdWRVJURVhfU0hBREVSJyxcbiAgICAgICAgZnJhZ21lbnQ6ICdGUkFHTUVOVF9TSEFERVInXG4gICAgICB9LFxuXG4gICAgICB2ZXJ0ZXg6IFtcbiAgICAgICAgJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycsXG4gICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOycsXG4gICAgICAgICcnLFxuICAgICAgICAndW5pZm9ybSBtYXQzIHVfbWF0cml4OycsXG4gICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycsXG4gICAgICAgICd1bmlmb3JtIHZlYzQgdV9yZWN0OycsXG4gICAgICAgICcnLFxuICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4dHVyZUNvb3JkczsnLFxuICAgICAgICAnJyxcbiAgICAgICAgJ3ZvaWQgbWFpbigpIHsnLFxuICAgICAgICAnICAgdmVjMiByZWN0Q29vcmRzID0gKGFfcG9zaXRpb24gKiAodV9yZWN0Lnp3IC0gdV9yZWN0Lnh5KSkgKyB1X3JlY3QueHk7JyxcbiAgICAgICAgJyAgIHZlYzIgcHJvamVjdGVkID0gKHVfbWF0cml4ICogdmVjMyhyZWN0Q29vcmRzLCAxLjApKS54eTsnLFxuICAgICAgICAnICAgdmVjMiBub3JtYWwgPSBwcm9qZWN0ZWQgLyB1X3Jlc29sdXRpb247JyxcbiAgICAgICAgJyAgIHZlYzIgY2xpcHNwYWNlID0gKG5vcm1hbCAqIDIuMCkgLSAxLjA7JyxcbiAgICAgICAgJycsXG4gICAgICAgICcgICBnbF9Qb3NpdGlvbiA9IHZlYzQoY2xpcHNwYWNlICogdmVjMigxLjAsIC0xLjApLCAwLjAsIDEuMCk7JyxcbiAgICAgICAgJyAgIHZfdGV4dHVyZUNvb3JkcyA9IGFfcG9zaXRpb247JyxcbiAgICAgICAgJ30nXG4gICAgICBdLmpvaW4oJ1xcbicpLFxuXG4gICAgICBmcmFnbWVudDogW1xuICAgICAgICAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyxcbiAgICAgICAgJycsXG4gICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlOycsXG4gICAgICAgICd2YXJ5aW5nIHZlYzIgdl90ZXh0dXJlQ29vcmRzOycsXG4gICAgICAgICcnLFxuICAgICAgICAndm9pZCBtYWluKCkgeycsXG4gICAgICAgICcgIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXh0dXJlQ29vcmRzKTsnLFxuICAgICAgICAnICBpZiAodGV4ZWwuYSA9PSAwLjApIHsnLFxuICAgICAgICAnICAgIGRpc2NhcmQ7JyxcbiAgICAgICAgJyAgfScsXG4gICAgICAgICcgIGdsX0ZyYWdDb2xvciA9IHRleGVsOycsXG4gICAgICAgICd9J1xuICAgICAgXS5qb2luKCdcXG4nKVxuXG4gICAgfSxcblxuICAgIFRleHR1cmVSZWdpc3RyeTogbmV3IFJlZ2lzdHJ5KClcblxuICB9O1xuXG4gIHdlYmdsLmN0eCA9IHdlYmdsLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd28uV2ViR0xSZW5kZXJlclxuICAgKiBAY2xhc3NcbiAgICogQGV4dGVuZHMgVHdvLkV2ZW50c1xuICAgKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtZXRlcnNdIC0gVGhpcyBvYmplY3QgaXMgaW5oZXJpdGVkIHdoZW4gY29uc3RydWN0aW5nIGEgbmV3IGluc3RhbmNlIG9mIHtAbGluayBUd299LlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IFtwYXJhbWV0ZXJzLmRvbUVsZW1lbnRdIC0gVGhlIGA8Y2FudmFzIC8+YCB0byBkcmF3IHRvLiBJZiBub25lIGdpdmVuIGEgbmV3IG9uZSB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0ge0hUTUxDYW52YXNFbGVtZW50fSBbcGFyYW1ldGVycy5vZmZzY3JlZW5FbGVtZW50XSAtIFRoZSBvZmZzY3JlZW4gdHdvIGRpbWVuc2lvbmFsIGA8Y2FudmFzIC8+YCB0byByZW5kZXIgZWFjaCBlbGVtZW50IG9uIFdlYkdMIHRleHR1cmUgdXBkYXRlcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbcGFyYW1ldGVycy5hbnRpYWxpYXNdIC0gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBjYW52YXMgc2hvdWxkIGNsZWFyIHJlbmRlciB3aXRoIGFudGlhbGlhcyBvbi5cbiAgICogQGRlc2NyaXB0aW9uIFRoaXMgY2xhc3MgaXMgdXNlZCBieSB7QGxpbmsgVHdvfSB3aGVuIGNvbnN0cnVjdGluZyB3aXRoIGB0eXBlYCBvZiBgVHdvLlR5cGVzLndlYmdsYC4gSXQgdGFrZXMgVHdvLmpzJyBzY2VuZWdyYXBoIGFuZCByZW5kZXJzIGl0IHRvIGEgYDxjYW52YXMgLz5gIHRocm91Z2ggdGhlIFdlYkdMIGFwaS5cbiAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cua2hyb25vcy5vcmcvcmVnaXN0cnkvd2ViZ2wvc3BlY3MvbGF0ZXN0LzEuMC99XG4gICAqL1xuICBmdW5jdGlvbiBSZW5kZXJlcihwYXJhbXMpIHtcblxuICAgIHZhciBnbCwgdnMsIGZzO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjZG9tRWxlbWVudFxuICAgICAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gLSBUaGUgYDxjYW52YXMgLz5gIGFzc29jaWF0ZWQgd2l0aCB0aGUgVHdvLmpzIHNjZW5lLlxuICAgICAqL1xuICAgIHRoaXMuZG9tRWxlbWVudCA9IHBhcmFtcy5kb21FbGVtZW50IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMub2Zmc2NyZWVuRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdlYmdsLmNhbnZhcyA9IHBhcmFtcy5vZmZzY3JlZW5FbGVtZW50O1xuICAgICAgd2ViZ2wuY3R4ID0gd2ViZ2wuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjc2NlbmVcbiAgICAgKiBAcHJvcGVydHkge1R3by5Hcm91cH0gLSBUaGUgcm9vdCBncm91cCBvZiB0aGUgc2NlbmVncmFwaC5cbiAgICAgKi9cbiAgICB0aGlzLnNjZW5lID0gbmV3IEdyb3VwKCk7XG4gICAgdGhpcy5zY2VuZS5wYXJlbnQgPSB0aGlzO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIgPSB7XG4gICAgICB0eXBlOiAncmVuZGVyZXInLFxuICAgICAgbWF0cml4OiBuZXcgTnVtQXJyYXkoaWRlbnRpdHkpLFxuICAgICAgc2NhbGU6IDEsXG4gICAgICBvcGFjaXR5OiAxXG4gICAgfTtcbiAgICB0aGlzLl9mbGFnTWF0cml4ID0gdHJ1ZTtcblxuICAgIC8vIGh0dHA6Ly9nYW1lcy5ncmVnZ21hbi5jb20vZ2FtZS93ZWJnbC1hbmQtYWxwaGEvXG4gICAgLy8gaHR0cDovL3d3dy5raHJvbm9zLm9yZy9yZWdpc3RyeS93ZWJnbC9zcGVjcy9sYXRlc3QvIzUuMlxuICAgIHBhcmFtcyA9IF8uZGVmYXVsdHMocGFyYW1zIHx8IHt9LCB7XG4gICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgYWxwaGE6IHRydWUsXG4gICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IHRydWUsXG4gICAgICBzdGVuY2lsOiB0cnVlLFxuICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlLFxuICAgICAgb3ZlcmRyYXc6IGZhbHNlXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uV2ViR0xSZW5kZXJlciNvdmVyZHJhd1xuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNhbnZhcyBjbGVhcnMgdGhlIGJhY2tncm91bmQgZWFjaCBkcmF3IGNhbGwuXG4gICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAqL1xuICAgIHRoaXMub3ZlcmRyYXcgPSBwYXJhbXMub3ZlcmRyYXc7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uV2ViR0xSZW5kZXJlciNjdHhcbiAgICAgKiBAcHJvcGVydHkge1dlYkdMQ29udGV4dH0gLSBBc3NvY2lhdGVkIHR3byBkaW1lbnNpb25hbCBjb250ZXh0IHRvIHJlbmRlciBvbiB0aGUgYDxjYW52YXMgLz5gLlxuICAgICAqL1xuICAgIGdsID0gdGhpcy5jdHggPSB0aGlzLmRvbUVsZW1lbnQuZ2V0Q29udGV4dCgnd2ViZ2wnLCBwYXJhbXMpIHx8XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgcGFyYW1zKTtcblxuICAgIGlmICghdGhpcy5jdHgpIHtcbiAgICAgIHRocm93IG5ldyBUd29FcnJvcihcbiAgICAgICAgJ3VuYWJsZSB0byBjcmVhdGUgYSB3ZWJnbCBjb250ZXh0LiBUcnkgdXNpbmcgYW5vdGhlciByZW5kZXJlci4nKTtcbiAgICB9XG5cbiAgICAvLyBDb21waWxlIEJhc2UgU2hhZGVycyB0byBkcmF3IGluIHBpeGVsIHNwYWNlLlxuICAgIHZzID0gd2ViZ2wuc2hhZGVycy5jcmVhdGUoXG4gICAgICBnbCwgd2ViZ2wuc2hhZGVycy52ZXJ0ZXgsIHdlYmdsLnNoYWRlcnMudHlwZXMudmVydGV4KTtcbiAgICBmcyA9IHdlYmdsLnNoYWRlcnMuY3JlYXRlKFxuICAgICAgZ2wsIHdlYmdsLnNoYWRlcnMuZnJhZ21lbnQsIHdlYmdsLnNoYWRlcnMudHlwZXMuZnJhZ21lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjcHJvZ3JhbVxuICAgICAqIEBwcm9wZXJ0eSB7V2ViR0xQcm9ncmFtfSAtIEFzc29jaWF0ZWQgV2ViR0wgcHJvZ3JhbSB0byByZW5kZXIgYWxsIGVsZW1lbnRzIGZyb20gdGhlIHNjZW5lZ3JhcGguXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtID0gd2ViZ2wucHJvZ3JhbS5jcmVhdGUoZ2wsIFt2cywgZnNdKTtcbiAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XG5cbiAgICAvLyBDcmVhdGUgYW5kIGJpbmQgdGhlIGRyYXdpbmcgYnVmZmVyXG5cbiAgICAvLyBsb29rIHVwIHdoZXJlIHRoZSB2ZXJ0ZXggZGF0YSBuZWVkcyB0byBnby5cbiAgICB0aGlzLnByb2dyYW0ucG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sICdhX3Bvc2l0aW9uJyk7XG4gICAgdGhpcy5wcm9ncmFtLm1hdHJpeCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sICd1X21hdHJpeCcpO1xuICAgIHRoaXMucHJvZ3JhbS5yZWN0ID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgJ3VfcmVjdCcpO1xuXG4gICAgLy8gQmluZCB0aGUgdmVydGV4IGJ1ZmZlclxuICAgIHZhciBwb3NpdGlvbkJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLnByb2dyYW0ucG9zaXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5wcm9ncmFtLnBvc2l0aW9uKTtcbiAgICBnbC5idWZmZXJEYXRhKFxuICAgICAgZ2wuQVJSQVlfQlVGRkVSLFxuICAgICAgbmV3IE51bUFycmF5KFtcbiAgICAgICAgMCwgMCxcbiAgICAgICAgMSwgMCxcbiAgICAgICAgMCwgMSxcbiAgICAgICAgMCwgMSxcbiAgICAgICAgMSwgMCxcbiAgICAgICAgMSwgMVxuICAgICAgXSksXG4gICAgICBnbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyBTZXR1cCBzb21lIGluaXRpYWwgc3RhdGVtZW50cyBvZiB0aGUgZ2wgY29udGV4dFxuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG5cbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuXG4gICAgZ2wuYmxlbmRFcXVhdGlvbihnbC5GVU5DX0FERCk7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gIH1cblxuICBfLmV4dGVuZChSZW5kZXJlciwge1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIuVXRpbHNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBBIG1hc3NpdmUgb2JqZWN0IGZpbGxlZCB3aXRoIHV0aWxpdHkgZnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzIHRvIHJlbmRlciBUd28uanMgb2JqZWN0cyB0byBhIGA8Y2FudmFzIC8+YCB0aHJvdWdoIHRoZSBXZWJHTCBBUEkuXG4gICAgICovXG4gICAgVXRpbHM6IHdlYmdsXG5cbiAgfSk7XG5cbiAgXy5leHRlbmQoUmVuZGVyZXIucHJvdG90eXBlLCBFdmVudHMsIHtcblxuICAgIGNvbnN0cnVjdG9yOiBSZW5kZXJlcixcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3by5XZWJHTFJlbmRlcmVyI3NldFNpemVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgcmVzaXplXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoIC0gVGhlIG5ldyB3aWR0aCBvZiB0aGUgcmVuZGVyZXIuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgaGVpZ2h0IG9mIHRoZSByZW5kZXJlci5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3JhdGlvXSAtIFRoZSBuZXcgcGl4ZWwgcmF0aW8gKHBpeGVsIGRlbnNpdHkpIG9mIHRoZSByZW5kZXJlci4gRGVmYXVsdHMgdG8gY2FsY3VsYXRlIHRoZSBwaXhlbCBkZW5zaXR5IG9mIHRoZSB1c2VyJ3Mgc2NyZWVuLlxuICAgICAqIEBkZXNjcmlwdGlvbiBDaGFuZ2UgdGhlIHNpemUgb2YgdGhlIHJlbmRlcmVyLlxuICAgICAqL1xuICAgIHNldFNpemU6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHJhdGlvKSB7XG5cbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICB0aGlzLnJhdGlvID0gdHlwZW9mIHJhdGlvID09PSAndW5kZWZpbmVkJyA/IGdldFJhdGlvKHRoaXMuY3R4KSA6IHJhdGlvO1xuXG4gICAgICB0aGlzLmRvbUVsZW1lbnQud2lkdGggPSB3aWR0aCAqIHRoaXMucmF0aW87XG4gICAgICB0aGlzLmRvbUVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0ICogdGhpcy5yYXRpbztcblxuICAgICAgaWYgKF8uaXNPYmplY3QodGhpcy5kb21FbGVtZW50LnN0eWxlKSkge1xuICAgICAgICBfLmV4dGVuZCh0aGlzLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGggKyAncHgnLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICsgJ3B4J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGZvciB0aGlzLnN0YWdlIHBhcmVudCBzY2FsaW5nIHRvIGFjY291bnQgZm9yIEhEUElcbiAgICAgIHRoaXMuX3JlbmRlcmVyLm1hdHJpeFswXSA9IHRoaXMuX3JlbmRlcmVyLm1hdHJpeFs0XSA9IHRoaXMuX3JlbmRlcmVyLnNjYWxlID0gdGhpcy5yYXRpbztcblxuICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IHRydWU7XG5cbiAgICAgIHRoaXMuY3R4LnZpZXdwb3J0KDAsIDAsIHdpZHRoICogdGhpcy5yYXRpbywgaGVpZ2h0ICogdGhpcy5yYXRpbyk7XG5cbiAgICAgIHZhciByZXNvbHV0aW9uTG9jYXRpb24gPSB0aGlzLmN0eC5nZXRVbmlmb3JtTG9jYXRpb24oXG4gICAgICAgIHRoaXMucHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpO1xuICAgICAgdGhpcy5jdHgudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgd2lkdGggKiB0aGlzLnJhdGlvLCBoZWlnaHQgKiB0aGlzLnJhdGlvKTtcblxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMucmVzaXplLCB3aWR0aCwgaGVpZ2h0LCByYXRpbyk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvLldlYkdMUmVuZGVyZXIjcmVuZGVyXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbmRlciB0aGUgY3VycmVudCBzY2VuZSB0byB0aGUgYDxjYW52YXMgLz5gLlxuICAgICAqL1xuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBnbCA9IHRoaXMuY3R4O1xuXG4gICAgICBpZiAoIXRoaXMub3ZlcmRyYXcpIHtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICB9XG5cbiAgICAgIHdlYmdsLmdyb3VwLnJlbmRlci5jYWxsKHRoaXMuc2NlbmUsIGdsLCB0aGlzLnByb2dyYW0pO1xuICAgICAgdGhpcy5fZmxhZ01hdHJpeCA9IGZhbHNlO1xuXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIH1cblxuICB9KTtcblxuICAvLyBVdGlsc1xuXG4gIC8qKlxuICAgKiBAbmFtZSBUd29cbiAgICogQGNsYXNzXG4gICAqIEBnbG9iYWxcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZ1bGxzY3JlZW49ZmFsc2VdIC0gU2V0IHRvIGB0cnVlYCB0byBhdXRvbWF0aWNhbGx5IG1ha2UgdGhlIHN0YWdlIGFkYXB0IHRvIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgZG9jdW1lbnQuIFRoaXMgcGFyYW1ldGVyIG92ZXJyaWRlcyBgd2lkdGhgIGFuZCBgaGVpZ2h0YCBwYXJhbWV0ZXJzIGlmIHNldCB0byBgdHJ1ZWAuIFRoaXMgb3ZlcnJpZGVzIGBvcHRpb25zLmZpdHRlZGAgYXMgd2VsbC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maXR0ZWQ9ZmFsc2VdID0gU2V0IHRvIGB0cnVlYCB0byBhdXRvbWF0aWNhbGx5IG1ha2UgdGhlIHN0YWdlIGFkYXB0IHRvIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBwYXJlbnQgZWxlbWVudC4gVGhpcyBwYXJhbWV0ZXIgb3ZlcnJpZGVzIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHBhcmFtZXRlcnMgaWYgc2V0IHRvIGB0cnVlYC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLndpZHRoPTY0MF0gLSBUaGUgd2lkdGggb2YgdGhlIHN0YWdlIG9uIGNvbnN0cnVjdGlvbi4gVGhpcyBjYW4gYmUgc2V0IGF0IGEgbGF0ZXIgdGltZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhlaWdodD00ODBdIC0gVGhlIGhlaWdodCBvZiB0aGUgc3RhZ2Ugb24gY29uc3RydWN0aW9uLiBUaGlzIGNhbiBiZSBzZXQgYXQgYSBsYXRlciB0aW1lLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudHlwZT1Ud28uVHlwZXMuc3ZnXSAtIFRoZSB0eXBlIG9mIHJlbmRlcmVyIHRvIHNldHVwIGRyYXdpbmcgd2l0aC4gU2VlIHtAbGluayBUd28uVHlwZXN9IGZvciBhdmFpbGFibGUgb3B0aW9ucy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvc3RhcnQ9ZmFsc2VdIC0gU2V0IHRvIGB0cnVlYCB0byBhZGQgdGhlIGluc3RhbmNlIHRvIGRyYXcgb24gYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuIFRoaXMgaXMgYSBjb252ZW5pZW50IHN1YnN0aXR1dGUgZm9yIHtAbGluayBUd28jcGxheX0uXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gW29wdGlvbnMuZG9tRWxlbWVudF0gLSBUaGUgY2FudmFzIG9yIFNWRyBlbGVtZW50IHRvIGRyYXcgaW50by4gVGhpcyBvdmVycmlkZXMgdGhlIGBvcHRpb25zLnR5cGVgIGFyZ3VtZW50LlxuICAgKiBAZGVzY3JpcHRpb24gVGhlIGVudHJ5cG9pbnQgZm9yIFR3by5qcy4gSW5zdGFudGlhdGUgYSBgbmV3IFR3b2AgaW4gb3JkZXIgdG8gc2V0dXAgYSBzY2VuZSB0byByZW5kZXIgdG8uIGBUd29gIGlzIGFsc28gdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgbmFtZXNwYWNlIHRoYXQgYWxsIG90aGVyIHN1Yi1jbGFzc2VzLCBmdW5jdGlvbnMsIGFuZCB1dGlsaXRpZXMgYXR0YWNoIHRvLlxuICAgKi9cbiAgZnVuY3Rpb24gVHdvKG9wdGlvbnMpIHtcblxuICAgIC8vIERldGVybWluZSB3aGF0IFJlbmRlcmVyIHRvIHVzZSBhbmQgc2V0dXAgYSBzY2VuZS5cblxuICAgIHZhciBwYXJhbXMgPSBfLmRlZmF1bHRzKG9wdGlvbnMgfHwge30sIHtcbiAgICAgIGZ1bGxzY3JlZW46IGZhbHNlLFxuICAgICAgZml0dGVkOiBmYWxzZSxcbiAgICAgIHdpZHRoOiA2NDAsXG4gICAgICBoZWlnaHQ6IDQ4MCxcbiAgICAgIHR5cGU6IFR3by5UeXBlcy5zdmcsXG4gICAgICBhdXRvc3RhcnQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBfLmVhY2gocGFyYW1zLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICBpZiAoL2Z1bGxzY3JlZW4vaS50ZXN0KGspIHx8IC9hdXRvc3RhcnQvaS50ZXN0KGspKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXNba10gPSB2O1xuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gU3BlY2lmaWVkIGRvbUVsZW1lbnQgb3ZlcnJpZGVzIHR5cGUgZGVjbGFyYXRpb24gb25seSBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBzdXBwb3J0IGRlY2xhcmVkIHJlbmRlcmVyIHR5cGUuXG4gICAgaWYgKF8uaXNFbGVtZW50KHBhcmFtcy5kb21FbGVtZW50KSkge1xuICAgICAgdmFyIHRhZ05hbWUgPSBwYXJhbXMuZG9tRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAvLyBUT0RPOiBSZWNvbnNpZGVyIHRoaXMgaWYgc3RhdGVtZW50J3MgbG9naWMuXG4gICAgICBpZiAoIS9eKENhbnZhc1JlbmRlcmVyLWNhbnZhc3xXZWJHTFJlbmRlcmVyLWNhbnZhc3xTVkdSZW5kZXJlci1zdmcpJC8udGVzdCh0aGlzLnR5cGUrJy0nK3RhZ05hbWUpKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IFR3by5UeXBlc1t0YWdOYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFR3b1t0aGlzLnR5cGVdKHRoaXMpO1xuICAgIHRoaXMuc2V0UGxheWluZyhwYXJhbXMuYXV0b3N0YXJ0KTtcbiAgICB0aGlzLmZyYW1lQ291bnQgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI2ZpdFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBJZiBgb3B0aW9ucy5mdWxsc2NyZWVuYCBvciBgb3B0aW9ucy5maXR0ZWRgIGluIGNvbnN0cnVjdGlvbiBjcmVhdGUgdGhpcyBmdW5jdGlvbi4gSXQgc2V0cyB0aGUgYHdpZHRoYCBhbmQgYGhlaWdodGAgb2YgdGhlIGluc3RhbmNlIHRvIGl0cyByZXNwZWN0aXZlIHBhcmVudCBgd2luZG93YCBvciBgZWxlbWVudGAgZGVwZW5kaW5nIG9uIHRoZSBgb3B0aW9uc2AgcGFzc2VkLlxuICAgICAqL1xuICAgIGlmIChwYXJhbXMuZnVsbHNjcmVlbikge1xuXG4gICAgICB0aGlzLmZpdCA9IGZpdFRvV2luZG93LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmZpdC5kb21FbGVtZW50ID0gd2luZG93O1xuICAgICAgdGhpcy5maXQuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgXy5leHRlbmQoZG9jdW1lbnQuYm9keS5zdHlsZSwge1xuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgIG1hcmdpbjogMCxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJ1xuICAgICAgfSk7XG4gICAgICBfLmV4dGVuZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJ1xuICAgICAgfSk7XG4gICAgICBkb20uYmluZCh0aGlzLmZpdC5kb21FbGVtZW50LCAncmVzaXplJywgdGhpcy5maXQpO1xuICAgICAgdGhpcy5maXQoKTtcblxuICAgIH0gZWxzZSBpZiAocGFyYW1zLmZpdHRlZCkge1xuXG4gICAgICB0aGlzLmZpdCA9IGZpdFRvUGFyZW50LmJpbmQodGhpcyk7XG4gICAgICBfLmV4dGVuZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQuc3R5bGUsIHtcbiAgICAgICAgZGlzcGxheTogJ2Jsb2NrJ1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKCFfLmlzRWxlbWVudChwYXJhbXMuZG9tRWxlbWVudCkpIHtcblxuICAgICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHBhcmFtcy53aWR0aCwgcGFyYW1zLmhlaWdodCwgdGhpcy5yYXRpbyk7XG4gICAgICB0aGlzLndpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuXG4gICAgfVxuXG4gICAgdGhpcy5yZW5kZXJlci5iaW5kKEV2ZW50cy5UeXBlcy5yZXNpemUsIHVwZGF0ZURpbWVuc2lvbnMuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5zY2VuZSA9IHRoaXMucmVuZGVyZXIuc2NlbmU7XG5cbiAgICBUd28uSW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgaWYgKHBhcmFtcy5hdXRvc3RhcnQpIHtcbiAgICAgIHJhZi5pbml0KCk7XG4gICAgfVxuXG4gIH1cblxuICBfLmV4dGVuZChUd28sIENvbnN0YW50cyk7XG5cbiAgXy5leHRlbmQoVHdvLnByb3RvdHlwZSwgRXZlbnRzLCB7XG5cbiAgICBjb25zdHJ1Y3RvcjogVHdvLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI3R5cGVcbiAgICAgKiBAcHJvcGVydHkge1N0cmluZ30gLSBBIHN0cmluZyByZXByZXNlbnRpbmcgd2hpY2ggdHlwZSBvZiByZW5kZXJlciB0aGUgaW5zdGFuY2UgaGFzIGluc3RhbnRpYXRlZC5cbiAgICAgKi9cbiAgICB0eXBlOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNyZW5kZXJlclxuICAgICAqIEBwcm9wZXJ0eSB7KFR3by5TVkdSZW5kZXJlcnxUd28uQ2FudmFzUmVuZGVyZXJ8VHdvLldlYkdMUmVuZGVyZXIpfSAtIFRoZSBpbnN0YW50aWF0ZWQgcmVuZGVyaW5nIGNsYXNzIGZvciB0aGUgaW5zdGFuY2UuIEZvciBhIGxpc3Qgb2YgcG9zc2libGUgcmVuZGVyaW5nIHR5cGVzIGNoZWNrIG91dCBUd28uVHlwZXMuXG4gICAgICovXG4gICAgcmVuZGVyZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jc2NlbmVcbiAgICAgKiBAcHJvcGVydHkge1R3by5Hcm91cH0gLSBUaGUgYmFzZSBsZXZlbCB7QGxpbmsgVHdvLkdyb3VwfSB3aGljaCBob3VzZXMgYWxsIG9iamVjdHMgZm9yIHRoZSBpbnN0YW5jZS4gQmVjYXVzZSBpdCBpcyBhIHtAbGluayBUd28uR3JvdXB9IHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgYXBwbGllZCB0byBpdCB0aGF0IHdpbGwgYWZmZWN0IGFsbCBvYmplY3RzIGluIHRoZSBpbnN0YW5jZS4gVGhpcyBpcyBoYW5keSBhcyBhIG1ha2VzaGlmdCBpbnZlcnRlZCBjYW1lcmEuXG4gICAgICovXG4gICAgc2NlbmU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jd2lkdGhcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBUaGUgd2lkdGggb2YgdGhlIGluc3RhbmNlJ3MgZG9tIGVsZW1lbnQuXG4gICAgICovXG4gICAgd2lkdGg6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jaGVpZ2h0XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IC0gVGhlIGhlaWdodCBvZiB0aGUgaW5zdGFuY2UncyBkb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBoZWlnaHQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jZnJhbWVDb3VudFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSAtIEFuIGludGVnZXIgcmVwcmVzZW50aW5nIGhvdyBtYW55IGZyYW1lcyBoYXZlIGVsYXBzZWQuXG4gICAgICovXG4gICAgZnJhbWVDb3VudDogMCxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byN0aW1lRGVsdGFcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gLSBBIG51bWJlciByZXByZXNlbnRpbmcgaG93IG11Y2ggdGltZSBoYXMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBmcmFtZSBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgdGltZURlbHRhOiAwLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI3BsYXlpbmdcbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IC0gQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGV0aGVyIG9yIG5vdCB0aGUgaW5zdGFuY2UgaXMgYmVpbmcgdXBkYXRlZCB0aHJvdWdoIHRoZSBhdXRvbWF0aWMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gICAgICovXG4gICAgcGxheWluZzogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jYXBwZW5kVG9cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW0gLSBUaGUgRE9NIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSBUd28uanMgc3RhZ2UgdG8uXG4gICAgICogQGRlc2NyaXB0aW9uIFNob3J0aGFuZCBtZXRob2QgdG8gYXBwZW5kIHlvdXIgaW5zdGFuY2Ugb2YgVHdvLmpzIHRvIHRoZSBgZG9jdW1lbnRgLlxuICAgICAqL1xuICAgIGFwcGVuZFRvOiBmdW5jdGlvbihlbGVtKSB7XG5cbiAgICAgIGVsZW0uYXBwZW5kQ2hpbGQodGhpcy5yZW5kZXJlci5kb21FbGVtZW50KTtcblxuICAgICAgaWYgKHRoaXMuZml0KSB7XG4gICAgICAgIGlmICh0aGlzLmZpdC5kb21FbGVtZW50ICE9PSB3aW5kb3cpIHtcbiAgICAgICAgICB0aGlzLmZpdC5kb21FbGVtZW50ID0gZWxlbTtcbiAgICAgICAgICB0aGlzLmZpdC5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNwbGF5XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIFR3by5FdmVudHMuVHlwZXMucGxheSBldmVudFxuICAgICAqIEBkZXNjcmlwdGlvbiBDYWxsIHRvIHN0YXJ0IGFuIGludGVybmFsIGFuaW1hdGlvbiBsb29wLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBmdW5jdGlvbiBpbml0aWF0ZXMgYSBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBsb29wLlxuICAgICAqL1xuICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLnBsYXlpbmcgPSB0cnVlO1xuICAgICAgcmFmLmluaXQoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnBsYXkpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNwYXVzZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBmaXJlcyBUd28uRXZlbnRzLlR5cGVzLnBhdXNlIGV2ZW50XG4gICAgICogQGRlc2NyaXB0aW9uIENhbGwgdG8gc3RvcCB0aGUgaW50ZXJuYWwgYW5pbWF0aW9uIGxvb3AgZm9yIGEgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgVHdvLmpzLlxuICAgICAqL1xuICAgIHBhdXNlOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKEV2ZW50cy5UeXBlcy5wYXVzZSk7XG5cbiAgICB9LFxuXG4gICAgc2V0UGxheWluZzogZnVuY3Rpb24ocCkge1xuICAgICAgdGhpcy5wbGF5aW5nID0gcDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI3JlbGVhc2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIG9iamVjdCBwYXNzZWQgZm9yIGV2ZW50IGRlYWxsb2NhdGlvbi5cbiAgICAgKiBAZGVzY3JpcHRpb24gUmVsZWFzZSBhbiBhcmJpdHJhcnkgY2xhc3MnIGV2ZW50cyBmcm9tIHRoZSBUd28uanMgY29ycHVzIGFuZCByZWN1cnNlIHRocm91Z2ggaXRzIGNoaWxkcmVuIGFuZCBvciB2ZXJ0aWNlcy5cbiAgICAgKi9cbiAgICByZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblxuICAgICAgdmFyIGksIHYsIGNoaWxkO1xuXG4gICAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb2JqLnVuYmluZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvYmoudW5iaW5kKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmoudmVydGljZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoudmVydGljZXMudW5iaW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb2JqLnZlcnRpY2VzLnVuYmluZCgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvYmoudmVydGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2ID0gb2JqLnZlcnRpY2VzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2Ygdi51bmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHYudW5iaW5kKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvYmouY2hpbGRyZW4pIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNoaWxkID0gb2JqLmNoaWxkcmVuW2ldO1xuICAgICAgICAgIHRoaXMucmVsZWFzZShjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iajtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jdXBkYXRlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGZpcmVzIFR3by5FdmVudHMuVHlwZXMudXBkYXRlIGV2ZW50XG4gICAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZSBwb3NpdGlvbnMgYW5kIGNhbGN1bGF0aW9ucyBpbiBvbmUgcGFzcyBiZWZvcmUgcmVuZGVyaW5nLiBUaGVuIHJlbmRlciB0byB0aGUgY2FudmFzLlxuICAgICAqIEBub3RhLWJlbmUgVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBpZiB1c2luZyB7QGxpbmsgVHdvI3BsYXl9IG9yIHRoZSBgYXV0b3N0YXJ0YCBwYXJhbWV0ZXIgaW4gY29uc3RydWN0aW9uLlxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBhbmltYXRlZCA9ICEhdGhpcy5fbGFzdEZyYW1lO1xuICAgICAgdmFyIG5vdyA9IF8ucGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICAgIGlmIChhbmltYXRlZCkge1xuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IHBhcnNlRmxvYXQoKG5vdyAtIHRoaXMuX2xhc3RGcmFtZSkudG9GaXhlZCgzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0RnJhbWUgPSBub3c7XG5cbiAgICAgIGlmICh0aGlzLmZpdCAmJiB0aGlzLmZpdC5kb21FbGVtZW50ICYmICF0aGlzLmZpdC5hdHRhY2hlZCkge1xuICAgICAgICAgIGRvbS5iaW5kKHRoaXMuZml0LmRvbUVsZW1lbnQsICdyZXNpemUnLCB0aGlzLmZpdCk7XG4gICAgICAgICAgdGhpcy5maXQuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuZml0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyO1xuXG4gICAgICAvLyBVcGRhdGUgd2lkdGggLyBoZWlnaHQgZm9yIHRoZSByZW5kZXJlclxuICAgICAgaWYgKHdpZHRoICE9PSByZW5kZXJlci53aWR0aCB8fCBoZWlnaHQgIT09IHJlbmRlcmVyLmhlaWdodCkge1xuICAgICAgICByZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIHRoaXMucmF0aW8pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnVwZGF0ZSwgdGhpcy5mcmFtZUNvdW50LCB0aGlzLnRpbWVEZWx0YSk7XG5cbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcigpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNyZW5kZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAZmlyZXMgcmVuZGVyXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbmRlciBhbGwgZHJhd2FibGUgYW5kIHZpc2libGUgb2JqZWN0cyBvZiB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcblxuICAgICAgdGhpcy5yZW5kZXJlci5yZW5kZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoRXZlbnRzLlR5cGVzLnJlbmRlciwgdGhpcy5mcmFtZUNvdW50KyspO1xuXG4gICAgfSxcblxuICAgIC8vIENvbnZlbmllbmNlIE1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNhZGRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhUd28uU2hhcGVbXXwuLi5Ud28uU2hhcGUpfSBbb2JqZWN0c10gLSBBbiBhcnJheSBvZiBUd28uanMgb2JqZWN0cy4gQWx0ZXJuYXRpdmVseSBjYW4gYWRkIG9iamVjdHMgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuXG4gICAgICogQGRlc2NyaXB0aW9uIEEgc2hvcnRoYW5kIG1ldGhvZCB0byBhZGQgc3BlY2lmaWMgVHdvLmpzIG9iamVjdHMgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obykge1xuXG4gICAgICB2YXIgb2JqZWN0cyA9IG87XG4gICAgICBpZiAoIShvYmplY3RzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIG9iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZChvYmplY3RzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNyZW1vdmVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhUd28uU2hhcGVbXXwuLi5Ud28uU2hhcGUpfSBbb2JqZWN0c10gLSBBbiBhcnJheSBvZiBUd28uanMgb2JqZWN0cy5cbiAgICAgKiBAZGVzY3JpcHRpb24gQSBzaG9ydGhhbmQgbWV0aG9kIHRvIHJlbW92ZSBzcGVjaWZpYyBUd28uanMgb2JqZWN0cyBmcm9tIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG8pIHtcblxuICAgICAgdmFyIG9iamVjdHMgPSBvO1xuICAgICAgaWYgKCEob2JqZWN0cyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBvYmplY3RzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY2VuZS5yZW1vdmUob2JqZWN0cyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNjbGVhclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGFsbCBvYmplY3RzIGZyb20gdGhlIGluc3RhbmNlJ3Mgc2NlbmUuIElmIHlvdSBpbnRlbmQgdG8gaGF2ZSB0aGUgYnJvd3NlciBnYXJiYWdlIGNvbGxlY3QgdGhpcywgZG9uJ3QgZm9yZ2V0IHRvIGRlbGV0ZSB0aGUgcmVmZXJlbmNlcyBpbiB5b3VyIGFwcGxpY2F0aW9uIGFzIHdlbGwuXG4gICAgICovXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuXG4gICAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLnNjZW5lLmNoaWxkcmVuKTtcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlTGluZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgICAqIEByZXR1cm5zIHtUd28uTGluZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBsaW5lIGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBtYWtlTGluZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcblxuICAgICAgdmFyIGxpbmUgPSBuZXcgTGluZSh4MSwgeTEsIHgyLCB5Mik7XG4gICAgICB0aGlzLnNjZW5lLmFkZChsaW5lKTtcblxuICAgICAgcmV0dXJuIGxpbmU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VBcnJvd1xuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MlxuICAgICAqIEByZXR1cm5zIHtUd28uUGF0aH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBhcnJvdyBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgbWFrZUFycm93OiBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Miwgc2l6ZSkge1xuXG4gICAgICB2YXIgaGVhZGxlbiA9IHR5cGVvZiBzaXplID09PSAnbnVtYmVyJyA/IHNpemUgOiAxMDtcblxuICAgICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMih5MiAtIHkxLCB4MiAtIHgxKTtcblxuICAgICAgdmFyIHZlcnRpY2VzID0gW1xuXG4gICAgICAgIG5ldyBBbmNob3IoeDEsIHkxLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIENvbW1hbmRzLm1vdmUpLFxuICAgICAgICBuZXcgQW5jaG9yKHgyLCB5MiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBDb21tYW5kcy5saW5lKSxcbiAgICAgICAgbmV3IEFuY2hvcihcbiAgICAgICAgICB4MiAtIGhlYWRsZW4gKiBNYXRoLmNvcyhhbmdsZSAtIE1hdGguUEkgLyA0KSxcbiAgICAgICAgICB5MiAtIGhlYWRsZW4gKiBNYXRoLnNpbihhbmdsZSAtIE1hdGguUEkgLyA0KSxcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIENvbW1hbmRzLmxpbmVcbiAgICAgICAgKSxcblxuICAgICAgICBuZXcgQW5jaG9yKHgyLCB5MiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBDb21tYW5kcy5tb3ZlKSxcbiAgICAgICAgbmV3IEFuY2hvcihcbiAgICAgICAgICB4MiAtIGhlYWRsZW4gKiBNYXRoLmNvcyhhbmdsZSArIE1hdGguUEkgLyA0KSxcbiAgICAgICAgICB5MiAtIGhlYWRsZW4gKiBNYXRoLnNpbihhbmdsZSArIE1hdGguUEkgLyA0KSxcbiAgICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIENvbW1hbmRzLmxpbmVcbiAgICAgICAgKVxuXG4gICAgICBdO1xuXG4gICAgICB2YXIgcGF0aCA9IG5ldyBQYXRoKHZlcnRpY2VzLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgcGF0aC5ub0ZpbGwoKTtcbiAgICAgIHBhdGguY2FwID0gJ3JvdW5kJztcbiAgICAgIHBhdGguam9pbiA9ICdyb3VuZCc7XG5cbiAgICAgIHRoaXMuc2NlbmUuYWRkKHBhdGgpO1xuXG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VSZWN0YW5nbGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICAgICAqIEByZXR1cm5zIHtUd28uUmVjdGFuZ2xlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIHJlY3RhbmdsZSBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgbWFrZVJlY3RhbmdsZTogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuXG4gICAgICB2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChyZWN0KTtcblxuICAgICAgcmV0dXJuIHJlY3Q7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VSb3VuZGVkUmVjdGFuZ2xlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2lkZXNcbiAgICAgKiBAcmV0dXJucyB7VHdvLlJlY3RhbmdsZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyByb3VuZGVkIHJlY3RhbmdsZSBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgbWFrZVJvdW5kZWRSZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIHNpZGVzKSB7XG5cbiAgICAgIHZhciByZWN0ID0gbmV3IFJvdW5kZWRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCwgc2lkZXMpO1xuICAgICAgdGhpcy5zY2VuZS5hZGQocmVjdCk7XG5cbiAgICAgIHJldHVybiByZWN0O1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlQ2lyY2xlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3Jlc29sdXRpb249NF1cbiAgICAgKiBAcmV0dXJucyB7VHdvLkNpcmNsZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBjaXJjbGUgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VDaXJjbGU6IGZ1bmN0aW9uKHgsIHksIHJhZGl1cywgcmVzb2x1dGlvbikge1xuXG4gICAgICB2YXIgY2lyY2xlID0gbmV3IENpcmNsZSh4LCB5LCByYWRpdXMsIHJlc29sdXRpb24pO1xuICAgICAgdGhpcy5zY2VuZS5hZGQoY2lyY2xlKTtcblxuICAgICAgcmV0dXJuIGNpcmNsZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZUVsbGlwc2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJ4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJ5XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNvbHV0aW9uPTRdXG4gICAgICogQHJldHVybnMge1R3by5FbGxpcHNlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIGVsbGlwc2UgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VFbGxpcHNlOiBmdW5jdGlvbih4LCB5LCByeCwgcnksIHJlc29sdXRpb24pIHtcblxuICAgICAgdmFyIGVsbGlwc2UgPSBuZXcgRWxsaXBzZSh4LCB5LCByeCwgcnksIHJlc29sdXRpb24pO1xuICAgICAgdGhpcy5zY2VuZS5hZGQoZWxsaXBzZSk7XG5cbiAgICAgIHJldHVybiBlbGxpcHNlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlU3RhclxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gb3V0ZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5uZXJSYWRpdXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc2lkZXNcbiAgICAgKiBAcmV0dXJucyB7VHdvLlN0YXJ9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgc3RhciBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXG4gICAgICovXG4gICAgbWFrZVN0YXI6IGZ1bmN0aW9uKG94LCBveSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBzaWRlcykge1xuXG4gICAgICB2YXIgc3RhciA9IG5ldyBTdGFyKG94LCBveSwgb3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzLCBzaWRlcyk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChzdGFyKTtcblxuICAgICAgcmV0dXJuIHN0YXI7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VDdXJ2ZVxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkFuY2hvcltdfSBbcG9pbnRzXSAtIEFuIGFycmF5IG9mIHtAbGluayBUd28uQW5jaG9yfSBwb2ludHMuXG4gICAgICogQHBhcmFtIHsuLi5OdW1iZXJ9IC0gQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHBhc3MgYWx0ZXJuYXRpbmcgYHhgIC8gYHlgIGNvb3JkaW5hdGUgdmFsdWVzIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLiBUaGVzZSB3aWxsIGJlIGNvbWJpbmVkIGludG8ge0BsaW5rIFR3by5BbmNob3J9cyBmb3IgdXNlIGluIHRoZSBwYXRoLlxuICAgICAqIEByZXR1cm5zIHtUd28uUGF0aH0gLSBXaGVyZSBgcGF0aC5jdXJ2ZWRgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgcGF0aCB0aGF0IGlzIGN1cnZlZCBhbmQgYWRkcyBpdCB0byB0aGUgc2NlbmUuXG4gICAgICogQG5vdGEtYmVuZSBJbiBlaXRoZXIgY2FzZSBvZiBwYXNzaW5nIGFuIGFycmF5IG9yIHBhc3NpbmcgbnVtYmVyZWQgYXJndW1lbnRzIHRoZSBsYXN0IGFyZ3VtZW50IGlzIGFuIG9wdGlvbmFsIGBCb29sZWFuYCB0aGF0IGRlZmluZXMgd2hldGhlciB0aGUgcGF0aCBzaG91bGQgYmUgb3BlbiBvciBjbG9zZWQuXG4gICAgICovXG4gICAgbWFrZUN1cnZlOiBmdW5jdGlvbihwKSB7XG5cbiAgICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aCwgcG9pbnRzID0gcDtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgICBwb2ludHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKz0yKSB7XG4gICAgICAgICAgdmFyIHggPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB5ID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgICAgICBwb2ludHMucHVzaChuZXcgQW5jaG9yKHgsIHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdCA9IGFyZ3VtZW50c1tsIC0gMV07XG4gICAgICB2YXIgY3VydmUgPSBuZXcgUGF0aChwb2ludHMsICEodHlwZW9mIGxhc3QgPT09ICdib29sZWFuJyA/IGxhc3QgOiB1bmRlZmluZWQpLCB0cnVlKTtcbiAgICAgIHZhciByZWN0ID0gY3VydmUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjdXJ2ZS5jZW50ZXIoKS50cmFuc2xhdGlvblxuICAgICAgICAuc2V0KHJlY3QubGVmdCArIHJlY3Qud2lkdGggLyAyLCByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMik7XG5cbiAgICAgIHRoaXMuc2NlbmUuYWRkKGN1cnZlKTtcblxuICAgICAgcmV0dXJuIGN1cnZlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlUG9seWdvblxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHNpZGVzXG4gICAgICogQHJldHVybnMge1R3by5Qb2x5Z29ufVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIHBvbHlnb24gYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VQb2x5Z29uOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHNpZGVzKSB7XG5cbiAgICAgIHZhciBwb2x5ID0gbmV3IFBvbHlnb24oeCwgeSwgcmFkaXVzLCBzaWRlcyk7XG4gICAgICB0aGlzLnNjZW5lLmFkZChwb2x5KTtcblxuICAgICAgcmV0dXJuIHBvbHk7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VBcmNTZWdtZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbm5lclJhZGl1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvdXRlclJhZGl1c1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydEFuZ2xlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGVuZEFuZ2xlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNvbHV0aW9uPVR3by5SZXNvbHV0aW9uXSAtIFRoZSBudW1iZXIgb2YgdmVydGljZXMgdGhhdCBzaG91bGQgY29tcHJpc2UgdGhlIGFyYyBzZWdtZW50LlxuICAgICAqL1xuICAgIG1ha2VBcmNTZWdtZW50OiBmdW5jdGlvbihveCwgb3ksIGlyLCBvciwgc2EsIGVhLCByZXMpIHtcbiAgICAgIHZhciBhcmNTZWdtZW50ID0gbmV3IEFyY1NlZ21lbnQob3gsIG95LCBpciwgb3IsIHNhLCBlYSwgcmVzKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGFyY1NlZ21lbnQpO1xuICAgICAgcmV0dXJuIGFyY1NlZ21lbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlUGF0aFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7VHdvLkFuY2hvcltdfSBbcG9pbnRzXSAtIEFuIGFycmF5IG9mIHtAbGluayBUd28uQW5jaG9yfSBwb2ludHMuXG4gICAgICogQHBhcmFtIHsuLi5OdW1iZXJ9IC0gQWx0ZXJuYXRpdmVseSB5b3UgY2FuIHBhc3MgYWx0ZXJuYXRpbmcgYHhgIC8gYHlgIGNvb3JkaW5hdGUgdmFsdWVzIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzLiBUaGVzZSB3aWxsIGJlIGNvbWJpbmVkIGludG8ge0BsaW5rIFR3by5BbmNob3J9cyBmb3IgdXNlIGluIHRoZSBwYXRoLlxuICAgICAqIEByZXR1cm5zIHtUd28uUGF0aH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBwYXRoIGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS5cbiAgICAgKiBAbm90YS1iZW5lIEluIGVpdGhlciBjYXNlIG9mIHBhc3NpbmcgYW4gYXJyYXkgb3IgcGFzc2luZyBudW1iZXJlZCBhcmd1bWVudHMgdGhlIGxhc3QgYXJndW1lbnQgaXMgYW4gb3B0aW9uYWwgYEJvb2xlYW5gIHRoYXQgZGVmaW5lcyB3aGV0aGVyIHRoZSBwYXRoIHNob3VsZCBiZSBvcGVuIG9yIGNsb3NlZC5cbiAgICAgKi9cbiAgICBtYWtlUGF0aDogZnVuY3Rpb24ocCkge1xuXG4gICAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGgsIHBvaW50cyA9IHA7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocCkpIHtcbiAgICAgICAgcG9pbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSs9Mikge1xuICAgICAgICAgIHZhciB4ID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGlmICh0eXBlb2YgeCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgeSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICAgICAgcG9pbnRzLnB1c2gobmV3IEFuY2hvcih4LCB5KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGxhc3QgPSBhcmd1bWVudHNbbCAtIDFdO1xuICAgICAgdmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMsICEodHlwZW9mIGxhc3QgPT09ICdib29sZWFuJyA/IGxhc3QgOiB1bmRlZmluZWQpKTtcbiAgICAgIHZhciByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGlmICh0eXBlb2YgcmVjdC50b3AgPT09ICdudW1iZXInICAgJiYgdHlwZW9mIHJlY3QubGVmdCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICB0eXBlb2YgcmVjdC5yaWdodCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHJlY3QuYm90dG9tID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXRoLmNlbnRlcigpLnRyYW5zbGF0aW9uXG4gICAgICAgICAgLnNldChyZWN0LmxlZnQgKyByZWN0LndpZHRoIC8gMiwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAvIDIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNjZW5lLmFkZChwYXRoKTtcblxuICAgICAgcmV0dXJuIHBhdGg7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VUZXh0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZXNdIC0gQW4gb2JqZWN0IHRvIGRlc2NyaWJlIGFueSBvZiB0aGUge0BsaW5rIFR3by5UZXh0LlByb3BlcnRpZXN9IGluY2x1ZGluZyBgZmlsbGAsIGBzdHJva2VgLCBgbGluZXdpZHRoYCwgYGZhbWlseWAsIGBhbGlnbm1lbnRgLCBgbGVhZGluZ2AsIGBvcGFjaXR5YCwgZXRjLi5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlRleHR9XG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBUd28uanMgdGV4dCBvYmplY3QgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VUZXh0OiBmdW5jdGlvbihtZXNzYWdlLCB4LCB5LCBzdHlsZXMpIHtcbiAgICAgIHZhciB0ZXh0ID0gbmV3IFRleHQobWVzc2FnZSwgeCwgeSwgc3R5bGVzKTtcbiAgICAgIHRoaXMuYWRkKHRleHQpO1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlTGluZWFyR3JhZGllbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTFcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geDJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geTJcbiAgICAgKiBAcGFyYW0gey4uLlR3by5TdG9wfSBzdG9wcyAtIEFueSBudW1iZXIgb2YgY29sb3Igc3RvcHMgc29tZXRpbWVzIHJlZmZlcmVkIHRvIGFzIHJhbXAgc3RvcHMuIElmIG5vbmUgYXJlIHN1cHBsaWVkIHRoZW4gdGhlIGRlZmF1bHQgYmxhY2stdG8td2hpdGUgdHdvIHN0b3AgZ3JhZGllbnQgaXMgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7VHdvLkxpbmVhckdyYWRpZW50fVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIGxpbmVhciBncmFkaWVudCBhbmQgYWRzIGl0IHRvIHRoZSBzY2VuZS4gSW4gdGhlIGNhc2Ugb2YgYW4gZWZmZWN0IGl0J3MgYWRkZWQgdG8gYW4gaW52aXNpYmxlIFwiZGVmaW5pdGlvbnNcIiBncm91cC5cbiAgICAgKi9cbiAgICBtYWtlTGluZWFyR3JhZGllbnQ6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyIC8qIHN0b3BzICovKSB7XG5cbiAgICAgIHZhciBzdG9wcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgNCk7XG4gICAgICB2YXIgZ3JhZGllbnQgPSBuZXcgTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIsIHN0b3BzKTtcblxuICAgICAgdGhpcy5hZGQoZ3JhZGllbnQpO1xuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VSYWRpYWxHcmFkaWVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5MVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKiBAcGFyYW0gey4uLlR3by5TdG9wfSBzdG9wcyAtIEFueSBudW1iZXIgb2YgY29sb3Igc3RvcHMgc29tZXRpbWVzIHJlZmZlcmVkIHRvIGFzIHJhbXAgc3RvcHMuIElmIG5vbmUgYXJlIHN1cHBsaWVkIHRoZW4gdGhlIGRlZmF1bHQgYmxhY2stdG8td2hpdGUgdHdvIHN0b3AgZ3JhZGllbnQgaXMgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7VHdvLlJhZGlhbEdyYWRpZW50fVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIGxpbmVhci1ncmFkaWVudCBvYmplY3QgYW5kIGFkcyBpdCB0byB0aGUgc2NlbmUuIEluIHRoZSBjYXNlIG9mIGFuIGVmZmVjdCBpdCdzIGFkZGVkIHRvIGFuIGludmlzaWJsZSBcImRlZmluaXRpb25zXCIgZ3JvdXAuXG4gICAgICovXG4gICAgbWFrZVJhZGlhbEdyYWRpZW50OiBmdW5jdGlvbih4MSwgeTEsIHIgLyogc3RvcHMgKi8pIHtcblxuICAgICAgdmFyIHN0b3BzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIHZhciBncmFkaWVudCA9IG5ldyBSYWRpYWxHcmFkaWVudCh4MSwgeTEsIHIsIHN0b3BzKTtcblxuICAgICAgdGhpcy5hZGQoZ3JhZGllbnQpO1xuXG4gICAgICByZXR1cm4gZ3JhZGllbnQ7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VTcHJpdGVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8VHdvLlRleHR1cmUpfSBwYXRoT3JUZXh0dXJlIC0gVGhlIFVSTCBwYXRoIHRvIGFuIGltYWdlIG9yIGFuIGFscmVhZHkgY3JlYXRlZCB7QGxpbmsgVHdvLlRleHR1cmV9LlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbHVtbnM9MV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW3Jvd3M9MV1cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW2ZyYW1lUmF0ZT0wXVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2F1dG9zdGFydD1mYWxzZV1cbiAgICAgKiBAcmV0dXJucyB7VHdvLlNwcml0ZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBzcHJpdGUgb2JqZWN0IGFuZCBhZGRzIGl0IHRvIHRoZSBzY2VuZS4gU3ByaXRlcyBjYW4gYmUgdXNlZCBmb3Igc3RpbGwgaW1hZ2VzIGFzIHdlbGwgYXMgYW5pbWF0aW9ucy5cbiAgICAgKi9cbiAgICBtYWtlU3ByaXRlOiBmdW5jdGlvbihwYXRoLCB4LCB5LCBjb2xzLCByb3dzLCBmcmFtZVJhdGUsIGF1dG9zdGFydCkge1xuXG4gICAgICB2YXIgc3ByaXRlID0gbmV3IFNwcml0ZShwYXRoLCB4LCB5LCBjb2xzLCByb3dzLCBmcmFtZVJhdGUpO1xuICAgICAgaWYgKGF1dG9zdGFydCkge1xuICAgICAgICBzcHJpdGUucGxheSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGQoc3ByaXRlKTtcblxuICAgICAgcmV0dXJuIHNwcml0ZTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28jbWFrZUltYWdlU2VxdWVuY2VcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhTdHJpbmdbXXxUd28uVGV4dHVyZVtdKX0gcGF0aHNPclRleHR1cmVzIC0gQW4gYXJyYXkgb2YgcGF0aHMgb3Igb2Yge0BsaW5rIFR3by5UZXh0dXJlc30uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJhbWVSYXRlPTBdXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbYXV0b3N0YXJ0PWZhbHNlXVxuICAgICAqIEByZXR1cm5zIHtUd28uSW1hZ2VTZXF1ZW5jZX1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBpbWFnZSBzZXF1ZW5jZSBvYmplY3QgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VJbWFnZVNlcXVlbmNlOiBmdW5jdGlvbihwYXRocywgeCwgeSwgZnJhbWVSYXRlLCBhdXRvc3RhcnQpIHtcblxuICAgICAgdmFyIGltYWdlU2VxdWVuY2UgPSBuZXcgSW1hZ2VTZXF1ZW5jZShwYXRocywgeCwgeSwgZnJhbWVSYXRlKTtcbiAgICAgIGlmIChhdXRvc3RhcnQpIHtcbiAgICAgICAgaW1hZ2VTZXF1ZW5jZS5wbGF5KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZChpbWFnZVNlcXVlbmNlKTtcblxuICAgICAgcmV0dXJuIGltYWdlU2VxdWVuY2U7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI21ha2VUZXh0dXJlXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsoU3RyaW5nfEhUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8SFRNTFZpZGVvRWxlbWVudCl9IFtwYXRoT3JTb3VyY2VdIC0gVGhlIFVSTCBwYXRoIHRvIGFuIGltYWdlIG9yIGEgRE9NIGltYWdlLWxpa2UgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gRnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIHRoZSBpbWFnZSBpcyBsb2FkZWQuXG4gICAgICogQHJldHVybnMge1R3by5UZXh0dXJlfVxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgVHdvLmpzIHRleHR1cmUgb2JqZWN0LlxuICAgICAqL1xuICAgIG1ha2VUZXh0dXJlOiBmdW5jdGlvbihwYXRoLCBjYWxsYmFjaykge1xuXG4gICAgICB2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKHBhdGgsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB0ZXh0dXJlO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNtYWtlR3JvdXBcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyhUd28uU2hhcGVbXXwuLi5Ud28uU2hhcGUpfSBbb2JqZWN0c10gLSBUd28uanMgb2JqZWN0cyB0byBiZSBhZGRlZCB0byB0aGUgZ3JvdXAgaW4gdGhlIGZvcm0gb2YgYW4gYXJyYXkgb3IgYXMgaW5kaXZpZHVhbCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge1R3by5Hcm91cH1cbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIFR3by5qcyBncm91cCBvYmplY3QgYW5kIGFkZHMgaXQgdG8gdGhlIHNjZW5lLlxuICAgICAqL1xuICAgIG1ha2VHcm91cDogZnVuY3Rpb24obykge1xuXG4gICAgICB2YXIgb2JqZWN0cyA9IG87XG4gICAgICBpZiAoIShvYmplY3RzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIG9iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXAgPSBuZXcgR3JvdXAoKTtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGdyb3VwKTtcbiAgICAgIGdyb3VwLmFkZChvYmplY3RzKTtcblxuICAgICAgcmV0dXJuIGdyb3VwO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFR3byNpbnRlcnByZXRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IFNWR0VsZW1lbnQgLSBUaGUgU1ZHIG5vZGUgdG8gYmUgcGFyc2VkLlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvdyAtIERvbid0IGNyZWF0ZSBhIHRvcC1tb3N0IGdyb3VwIGJ1dCBhcHBlbmQgYWxsIGNvbnRlbnQgZGlyZWN0bHkuXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBhZGQg4oCTIEF1dG9tYXRpY2FsbHkgYWRkIHRoZSByZWNvbnN0cnVjdGVkIFNWRyBub2RlIHRvIHNjZW5lLlxuICAgICAqIEByZXR1cm5zIHtUd28uR3JvdXB9XG4gICAgICogQGRlc2NyaXB0aW9uIEludGVycHJldCBhbiBTVkcgTm9kZSBhbmQgYWRkIGl0IHRvIHRoaXMgaW5zdGFuY2UncyBzY2VuZS4gVGhlIGRpc3RpbmN0aW9uIHNob3VsZCBiZSBtYWRlIHRoYXQgdGhpcyBkb2Vzbid0IGBpbXBvcnRgIHN2ZydzLCBpdCBzb2xlbHkgaW50ZXJwcmV0cyB0aGVtIGludG8gc29tZXRoaW5nIGNvbXBhdGlibGUgZm9yIFR3by5qcyAtIHRoaXMgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gYSBkaXJlY3QgdHJhbnNjcmlwdGlvbi5cbiAgICAgKi9cbiAgICBpbnRlcnByZXQ6IGZ1bmN0aW9uKFNWR0VsZW1lbnQsIHNoYWxsb3csIGFkZCkge1xuXG4gICAgICB2YXIgdGFnID0gU1ZHRWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIGFkZCA9ICh0eXBlb2YgYWRkICE9PSAndW5kZWZpbmVkJykgPyBhZGQgOiB0cnVlO1xuXG4gICAgICBpZiAoISh0YWcgaW4gcmVhZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gcmVhZFt0YWddLmNhbGwodGhpcywgU1ZHRWxlbWVudCk7XG5cbiAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgdGhpcy5hZGQoc2hhbGxvdyAmJiBub2RlIGluc3RhbmNlb2YgR3JvdXAgPyBub2RlLmNoaWxkcmVuIDogbm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIC8vIFJlbW92ZSBgZ2AgdGFncyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byBzY2VuZWdyYXBoIC8gRE9NXG4gICAgICAgIC8vIGluIG9yZGVyIHRvIGJlIGNvbXBhdGlibGUgd2l0aCBgZ2V0QnlJZGAgbWV0aG9kcy5cbiAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVHdvI2xvYWRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xTVkdFbGVtZW50fSBwYXRoT3JTVkdDb250ZW50IC0gVGhlIFVSTCBwYXRoIG9mIGFuIFNWRyBmaWxlIG9yIGFuIFNWRyBkb2N1bWVudCBhcyB0ZXh0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbCBvbmNlIGxvYWRpbmcgaGFzIGNvbXBsZXRlZC5cbiAgICAgKiBAcmV0dXJucyB7VHdvLkdyb3VwfVxuICAgICAqIEBkZXNjcmlwdGlvbiBMb2FkIGFuIFNWRyBmaWxlIG9yIFNWRyB0ZXh0IGFuZCBpbnRlcnByZXQgaXQgaW50byBUd28uanMgbGVnaWJsZSBvYmplY3RzLlxuICAgICAqL1xuICAgIGxvYWQ6IGZ1bmN0aW9uKHRleHQsIGNhbGxiYWNrKSB7XG5cbiAgICAgIHZhciBncm91cCA9IG5ldyBHcm91cCgpO1xuICAgICAgdmFyIGVsZW0sIGksIGosIGNoaWxkO1xuXG4gICAgICB2YXIgYXR0YWNoID0gKGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgICAgICBkb20udGVtcC5pbm5lckhUTUwgPSBkYXRhO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkb20udGVtcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsZW0gPSBkb20udGVtcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICBpZiAoL3N2Zy9pLnRlc3QoZWxlbS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIGNoaWxkID0gdGhpcy5pbnRlcnByZXQoZWxlbSk7XG4gICAgICAgICAgICAvLyBUd28uVXRpbHMuYXBwbHlTdmdWaWV3Qm94LmNhbGwodGhpcywgZ3JvdXAsIGVsZW0uZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykpO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgIGdyb3VwLmFkZChjaGlsZC5jaGlsZHJlbltqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyb3VwLmFkZCh0aGlzLmludGVycHJldChlbGVtKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBzdmcgPSBkb20udGVtcC5jaGlsZHJlbi5sZW5ndGggPD0gMVxuICAgICAgICAgICAgPyBkb20udGVtcC5jaGlsZHJlblswXSA6IGRvbS50ZW1wLmNoaWxkcmVuO1xuICAgICAgICAgIGNhbGxiYWNrKGdyb3VwLCBzdmcpO1xuICAgICAgICB9XG5cbiAgICAgIH0pLmJpbmQodGhpcyk7XG5cbiAgICAgIGlmICgvLipcXC5zdmcvaWcudGVzdCh0ZXh0KSkge1xuXG4gICAgICAgIHhocih0ZXh0LCBhdHRhY2gpO1xuXG4gICAgICAgIHJldHVybiBncm91cDtcblxuICAgICAgfVxuXG4gICAgICBhdHRhY2godGV4dCk7XG5cbiAgICAgIHJldHVybiBncm91cDtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBmaXRUb1dpbmRvdygpIHtcblxuICAgIHZhciB3ciA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoID0gd3Iud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuaGVpZ2h0ID0gd3IuaGVpZ2h0O1xuXG4gICAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHdpZHRoLCBoZWlnaHQsIHRoaXMucmF0aW8pO1xuXG4gIH1cblxuICBmdW5jdGlvbiBmaXRUb1BhcmVudCgpIHtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdUd28uanM6IEF0dGVtcHRpbmcgdG8gZml0IHRvIHBhcmVudCwgYnV0IG5vIHBhcmVudCBmb3VuZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdyID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgdmFyIHdpZHRoID0gdGhpcy53aWR0aCA9IHdyLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmhlaWdodCA9IHdyLmhlaWdodDtcblxuICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0LCB0aGlzLnJhdGlvKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRGltZW5zaW9ucyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMudHJpZ2dlcihFdmVudHMuVHlwZXMucmVzaXplLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuXG4gIC8vIFJlcXVlc3QgQW5pbWF0aW9uIEZyYW1lXG5cbiAgdmFyIHJhZiA9IGRvbS5nZXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKTtcblxuICBmdW5jdGlvbiBsb29wKCkge1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBUd28uSW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdCA9IFR3by5JbnN0YW5jZXNbaV07XG4gICAgICBpZiAodC5wbGF5aW5nKSB7XG4gICAgICAgIHQudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgVHdvLm5leHRGcmFtZUlEID0gcmFmKGxvb3ApO1xuXG4gIH1cblxuICByYWYuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGxvb3AoKTtcbiAgICByYWYuaW5pdCA9IGZ1bmN0aW9uKCkge307XG4gIH07XG5cbiAgXy5leHRlbmQoVHdvLCB7XG4gICAgQW5jaG9yOiBBbmNob3IsXG4gICAgQ29sbGVjdGlvbjogQ29sbGVjdGlvbixcbiAgICBFdmVudHM6IEV2ZW50cyxcbiAgICBHcm91cDogR3JvdXAsXG4gICAgTWF0cml4OiBNYXRyaXgsXG4gICAgUGF0aDogUGF0aCxcbiAgICBSZWdpc3RyeTogUmVnaXN0cnksXG4gICAgU2hhcGU6IFNoYXBlLFxuICAgIFRleHQ6IFRleHQsXG4gICAgVmVjdG9yOiBWZWN0b3IsXG5cbiAgICBHcmFkaWVudDogR3JhZGllbnQsXG4gICAgSW1hZ2VTZXF1ZW5jZTogSW1hZ2VTZXF1ZW5jZSxcbiAgICBMaW5lYXJHcmFkaWVudDogTGluZWFyR3JhZGllbnQsXG4gICAgUmFkaWFsR3JhZGllbnQ6IFJhZGlhbEdyYWRpZW50LFxuICAgIFNwcml0ZTogU3ByaXRlLFxuICAgIFN0b3A6IFN0b3AsXG4gICAgVGV4dHVyZTogVGV4dHVyZSxcblxuICAgIEFyY1NlZ21lbnQ6IEFyY1NlZ21lbnQsXG4gICAgQ2lyY2xlOiBDaXJjbGUsXG4gICAgRWxsaXBzZTogRWxsaXBzZSxcbiAgICBMaW5lOiBMaW5lLFxuICAgIFBvbHlnb246IFBvbHlnb24sXG4gICAgUmVjdGFuZ2xlOiBSZWN0YW5nbGUsXG4gICAgUm91bmRlZFJlY3RhbmdsZTogUm91bmRlZFJlY3RhbmdsZSxcbiAgICBTdGFyOiBTdGFyLFxuXG4gICAgQ2FudmFzUmVuZGVyZXI6IFJlbmRlcmVyJDIsXG4gICAgU1ZHUmVuZGVyZXI6IFJlbmRlcmVyJDEsXG4gICAgV2ViR0xSZW5kZXJlcjogUmVuZGVyZXIsXG5cbiAgICBDb21tYW5kczogQ29tbWFuZHMsXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUd28uVXRpbHNcbiAgICAgKiBAcHJvcGVydHkge09iamVjdH0gLSBBIG1hc3NpdmUgb2JqZWN0IGZpbGxlZCB3aXRoIHV0aWxpdHkgZnVuY3Rpb25zIGFuZCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIFV0aWxzOiBfLmV4dGVuZCh7XG5cbiAgICAgIEVycm9yOiBUd29FcnJvcixcbiAgICAgIGdldFJhdGlvOiBnZXRSYXRpbyxcbiAgICAgIGRlZmluZUdldHRlclNldHRlcjogZGVmaW5lR2V0dGVyU2V0dGVyLFxuICAgICAgcmVhZDogcmVhZCxcbiAgICAgIHhocjogeGhyXG5cbiAgICB9LCBfLCBDYW52YXNTaGltLCBDdXJ2ZXMsIG1hdGgpXG5cbiAgfSk7XG5cbiAgcmV0dXJuIFR3bztcblxufSkpKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoXCJpcy1mdW5jdGlvblwiKVxudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoXCJwYXJzZS1oZWFkZXJzXCIpXG52YXIgeHRlbmQgPSByZXF1aXJlKFwieHRlbmRcIilcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVYSFJcbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVhIUjtcbmNyZWF0ZVhIUi5YTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG5jcmVhdGVYSFIuWERvbWFpblJlcXVlc3QgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0KCkpID8gY3JlYXRlWEhSLlhNTEh0dHBSZXF1ZXN0IDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbmZvckVhY2hBcnJheShbXCJnZXRcIiwgXCJwdXRcIiwgXCJwb3N0XCIsIFwicGF0Y2hcIiwgXCJoZWFkXCIsIFwiZGVsZXRlXCJdLCBmdW5jdGlvbihtZXRob2QpIHtcbiAgICBjcmVhdGVYSFJbbWV0aG9kID09PSBcImRlbGV0ZVwiID8gXCJkZWxcIiA6IG1ldGhvZF0gPSBmdW5jdGlvbih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIG9wdGlvbnMgPSBpbml0UGFyYW1zKHVyaSwgb3B0aW9ucywgY2FsbGJhY2spXG4gICAgICAgIG9wdGlvbnMubWV0aG9kID0gbWV0aG9kLnRvVXBwZXJDYXNlKClcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVYSFIob3B0aW9ucylcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRvcihhcnJheVtpXSlcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHkob2JqKXtcbiAgICBmb3IodmFyIGkgaW4gb2JqKXtcbiAgICAgICAgaWYob2JqLmhhc093blByb3BlcnR5KGkpKSByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaW5pdFBhcmFtcyh1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcmFtcyA9IHVyaVxuXG4gICAgaWYgKGlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zXG4gICAgICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7dXJpOnVyaX1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmFtcyA9IHh0ZW5kKG9wdGlvbnMsIHt1cmk6IHVyaX0pXG4gICAgfVxuXG4gICAgcGFyYW1zLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICByZXR1cm4gcGFyYW1zXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUih1cmksIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IGluaXRQYXJhbXModXJpLCBvcHRpb25zLCBjYWxsYmFjaylcbiAgICByZXR1cm4gX2NyZWF0ZVhIUihvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlWEhSKG9wdGlvbnMpIHtcbiAgICBpZih0eXBlb2Ygb3B0aW9ucy5jYWxsYmFjayA9PT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbGxiYWNrIGFyZ3VtZW50IG1pc3NpbmdcIilcbiAgICB9XG5cbiAgICB2YXIgY2FsbGVkID0gZmFsc2VcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYk9uY2UoZXJyLCByZXNwb25zZSwgYm9keSl7XG4gICAgICAgIGlmKCFjYWxsZWQpe1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZVxuICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZSgpIHtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGxvYWRGdW5jLCAwKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgICAgICB2YXIgYm9keSA9IHVuZGVmaW5lZFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IGdldFhtbCh4aHIpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNKc29uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvZHlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvckZ1bmMoZXZ0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0VGltZXIpXG4gICAgICAgIGlmKCEoZXZ0IGluc3RhbmNlb2YgRXJyb3IpKXtcbiAgICAgICAgICAgIGV2dCA9IG5ldyBFcnJvcihcIlwiICsgKGV2dCB8fCBcIlVua25vd24gWE1MSHR0cFJlcXVlc3QgRXJyb3JcIikgKVxuICAgICAgICB9XG4gICAgICAgIGV2dC5zdGF0dXNDb2RlID0gMFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXZ0LCBmYWlsdXJlUmVzcG9uc2UpXG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRGdW5jKCkge1xuICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgIHZhciBzdGF0dXNcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRUaW1lcilcbiAgICAgICAgaWYob3B0aW9ucy51c2VYRFIgJiYgeGhyLnN0YXR1cz09PXVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy9JRTggQ09SUyBHRVQgc3VjY2Vzc2Z1bCByZXNwb25zZSBkb2Vzbid0IGhhdmUgYSBzdGF0dXMgZmllbGQsIGJ1dCBib2R5IGlzIGZpbmVcbiAgICAgICAgICAgIHN0YXR1cyA9IDIwMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhdHVzID0gKHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzKVxuICAgICAgICB9XG4gICAgICAgIHZhciByZXNwb25zZSA9IGZhaWx1cmVSZXNwb25zZVxuICAgICAgICB2YXIgZXJyID0gbnVsbFxuXG4gICAgICAgIGlmIChzdGF0dXMgIT09IDApe1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgICAgIHN0YXR1c0NvZGU6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7fSxcbiAgICAgICAgICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgICAgICAgICByYXdSZXF1ZXN0OiB4aHJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMpeyAvL3JlbWVtYmVyIHhociBjYW4gaW4gZmFjdCBiZSBYRFIgZm9yIENPUlMgaW4gSUVcbiAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHJlc3BvbnNlLmJvZHkpXG4gICAgfVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWERvbWFpblJlcXVlc3QoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBjcmVhdGVYSFIuWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleVxuICAgIHZhciBhYm9ydGVkXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybFxuICAgIHZhciBtZXRob2QgPSB4aHIubWV0aG9kID0gb3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIlxuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5IHx8IG9wdGlvbnMuZGF0YVxuICAgIHZhciBoZWFkZXJzID0geGhyLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge31cbiAgICB2YXIgc3luYyA9ICEhb3B0aW9ucy5zeW5jXG4gICAgdmFyIGlzSnNvbiA9IGZhbHNlXG4gICAgdmFyIHRpbWVvdXRUaW1lclxuICAgIHZhciBmYWlsdXJlUmVzcG9uc2UgPSB7XG4gICAgICAgIGJvZHk6IHVuZGVmaW5lZCxcbiAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgIHN0YXR1c0NvZGU6IDAsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICB1cmw6IHVyaSxcbiAgICAgICAgcmF3UmVxdWVzdDogeGhyXG4gICAgfVxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICE9PSBmYWxzZSkge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJhY2NlcHRcIl0gfHwgaGVhZGVyc1tcIkFjY2VwdFwiXSB8fCAoaGVhZGVyc1tcIkFjY2VwdFwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gfHwgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSB8fCAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiKSAvL0Rvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFjY2VwdCBoZWFkZXIgZGVjbGFyZWQgYnkgdXNlclxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbiA9PT0gdHJ1ZSA/IGJvZHkgOiBvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkRnVuY1xuICAgIHhoci5vbmVycm9yID0gZXJyb3JGdW5jXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbigpe1xuICAgICAgICBhYm9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgeGhyLm9udGltZW91dCA9IGVycm9yRnVuY1xuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYywgb3B0aW9ucy51c2VybmFtZSwgb3B0aW9ucy5wYXNzd29yZClcbiAgICAvL2hhcyB0byBiZSBhZnRlciBvcGVuXG4gICAgaWYoIXN5bmMpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhb3B0aW9ucy53aXRoQ3JlZGVudGlhbHNcbiAgICB9XG4gICAgLy8gQ2Fubm90IHNldCB0aW1lb3V0IHdpdGggc3luYyByZXF1ZXN0XG4gICAgLy8gbm90IHNldHRpbmcgdGltZW91dCBvbiB0aGUgeGhyIG9iamVjdCwgYmVjYXVzZSBvZiBvbGQgd2Via2l0cyBldGMuIG5vdCBoYW5kbGluZyB0aGF0IGNvcnJlY3RseVxuICAgIC8vIGJvdGggbnBtJ3MgcmVxdWVzdCBhbmQganF1ZXJ5IDEueCB1c2UgdGhpcyBraW5kIG9mIHRpbWVvdXQsIHNvIHRoaXMgaXMgYmVpbmcgY29uc2lzdGVudFxuICAgIGlmICghc3luYyAmJiBvcHRpb25zLnRpbWVvdXQgPiAwICkge1xuICAgICAgICB0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAoYWJvcnRlZCkgcmV0dXJuXG4gICAgICAgICAgICBhYm9ydGVkID0gdHJ1ZS8vSUU5IG1heSBzdGlsbCBjYWxsIHJlYWR5c3RhdGVjaGFuZ2VcbiAgICAgICAgICAgIHhoci5hYm9ydChcInRpbWVvdXRcIilcbiAgICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKFwiWE1MSHR0cFJlcXVlc3QgdGltZW91dFwiKVxuICAgICAgICAgICAgZS5jb2RlID0gXCJFVElNRURPVVRcIlxuICAgICAgICAgICAgZXJyb3JGdW5jKGUpXG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCApXG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMgJiYgIWlzRW1wdHkob3B0aW9ucy5oZWFkZXJzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJIZWFkZXJzIGNhbm5vdCBiZSBzZXQgb24gYW4gWERvbWFpblJlcXVlc3Qgb2JqZWN0XCIpXG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG5cbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5iZWZvcmVTZW5kID09PSBcImZ1bmN0aW9uXCJcbiAgICApIHtcbiAgICAgICAgb3B0aW9ucy5iZWZvcmVTZW5kKHhocilcbiAgICB9XG5cbiAgICAvLyBNaWNyb3NvZnQgRWRnZSBicm93c2VyIHNlbmRzIFwidW5kZWZpbmVkXCIgd2hlbiBzZW5kIGlzIGNhbGxlZCB3aXRoIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAvLyBYTUxIdHRwUmVxdWVzdCBzcGVjIHNheXMgdG8gcGFzcyBudWxsIGFzIGJvZHkgdG8gaW5kaWNhdGUgbm8gYm9keVxuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbmF1Z3R1ci94aHIvaXNzdWVzLzEwMC5cbiAgICB4aHIuc2VuZChib2R5IHx8IG51bGwpXG5cbiAgICByZXR1cm4geGhyXG5cblxufVxuXG5mdW5jdGlvbiBnZXRYbWwoeGhyKSB7XG4gICAgLy8geGhyLnJlc3BvbnNlWE1MIHdpbGwgdGhyb3cgRXhjZXB0aW9uIFwiSW52YWxpZFN0YXRlRXJyb3JcIiBvciBcIkRPTUV4Y2VwdGlvblwiXG4gICAgLy8gU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdC9yZXNwb25zZVhNTC5cbiAgICB0cnkge1xuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlWE1MXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcmVmb3hCdWdUYWtlbkVmZmVjdCA9IHhoci5yZXNwb25zZVhNTCAmJiB4aHIucmVzcG9uc2VYTUwuZG9jdW1lbnRFbGVtZW50Lm5vZGVOYW1lID09PSBcInBhcnNlcmVycm9yXCJcbiAgICAgICAgaWYgKHhoci5yZXNwb25zZVR5cGUgPT09IFwiXCIgJiYgIWZpcmVmb3hCdWdUYWtlbkVmZmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cblxuICAgIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiIsIlxuZ2xvYmFsLkNBTlZBU19TS0VUQ0hfREVGQVVMVF9TVE9SQUdFX0tFWSA9IFwiRDpcXFxcTWFudWVsXFxcXGNhbnZhcy1za2V0Y2hcXFxcZXhhbXBsZXNcXFxcYW5pbWF0ZWQtdHdvLWJpdG1hcC5qc1wiO1xuIl19
